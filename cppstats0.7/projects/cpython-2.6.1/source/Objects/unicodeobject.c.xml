<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/unicodeobject.c"><comment type="block">/*

Unicode implementation based on original code by Fredrik Lundh,
modified by Marc-Andre Lemburg &lt;mal@lemburg.com&gt; according to the
Unicode Integration Proposal (see file Misc/unicode.txt).

Major speed upgrades to the method implementations at the Reykjavik
NeedForSpeed sprint, by Fredrik Lundh and Andrew Dalke.

Copyright (c) Corporation for National Research Initiatives.

--------------------------------------------------------------------
The original string type implementation is:

    Copyright (c) 1999 by Secret Labs AB
    Copyright (c) 1999 by Fredrik Lundh

By obtaining, using, and/or copying this software and/or its
associated documentation, you agree that you have read, understood,
and will comply with the following terms and conditions:

Permission to use, copy, modify, and distribute this software and its
associated documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appears in all
copies, and that both that copyright notice and this permission notice
appear in supporting documentation, and that the name of Secret Labs
AB or the author not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.

SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
--------------------------------------------------------------------

*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unicodeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ucnhash.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Limit for the Unicode object free list */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_MAXFREELIST</name></cpp:macro>       <cpp:value>1024</cpp:value></cpp:define>

<comment type="block">/* Limit for the Unicode object free list stay alive optimization.

   The implementation will keep allocated Unicode memory intact for
   all objects on the free list having a size less than this
   limit. This reduces malloc() overhead for small Unicode objects.

   At worst this will result in PyUnicode_MAXFREELIST *
   (sizeof(PyUnicodeObject) + KEEPALIVE_SIZE_LIMIT +
   malloc()-overhead) bytes of unused garbage.

   Setting the limit to 0 effectively turns the feature off.

   Note: This is an experimental feature ! If you get core dumps when
   using Unicode objects, turn this feature off.

*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEEPALIVE_SIZE_LIMIT</name></cpp:macro>       <cpp:value>9</cpp:value></cpp:define>

<comment type="block">/* Endianness switches; defaults to little endian */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>BYTEORDER_IS_BIG_ENDIAN</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>BYTEORDER_IS_LITTLE_ENDIAN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* --- Globals ------------------------------------------------------------

   The globals are initialized by the _PyUnicode_Init() API and should
   not be used before calling that API.

*/</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Free list for Unicode objects */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyUnicodeObject</name> *</type><name>free_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>numfree</name></decl>;</decl_stmt>

<comment type="block">/* The empty Unicode object is shared to improve performance. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyUnicodeObject</name> *</type><name>unicode_empty</name></decl>;</decl_stmt>

<comment type="block">/* Single character Unicode strings in the Latin-1 range are being
   shared as well. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyUnicodeObject</name> *</type><name><name>unicode_latin1</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* Default encoding to use and assume when NULL is passed as encoding
   parameter; it is initialized by _PyUnicode_Init().

   Always use the PyUnicode_SetDefaultEncoding() and
   PyUnicode_GetDefaultEncoding() APIs to access this global.

*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>unicode_default_encoding</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* Fast detection of the most frequent whitespace characters */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>_Py_ascii_whitespace</name><index>[]</index></name> <init>= <expr><block>{
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<comment type="block">/*     case 0x0009: * HORIZONTAL TABULATION */</comment>
<comment type="block">/*     case 0x000A: * LINE FEED */</comment>
<comment type="block">/*     case 0x000B: * VERTICAL TABULATION */</comment>
<comment type="block">/*     case 0x000C: * FORM FEED */</comment>
<comment type="block">/*     case 0x000D: * CARRIAGE RETURN */</comment>
	<expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<comment type="block">/*     case 0x001C: * FILE SEPARATOR */</comment>
<comment type="block">/*     case 0x001D: * GROUP SEPARATOR */</comment>
<comment type="block">/*     case 0x001E: * RECORD SEPARATOR */</comment>
<comment type="block">/*     case 0x001F: * UNIT SEPARATOR */</comment>
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<comment type="block">/*     case 0x0020: * SPACE */</comment>
	<expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,

	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Same for linebreaks */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>ascii_linebreak</name><index>[]</index></name> <init>= <expr><block>{
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<comment type="block">/*         0x000A, * LINE FEED */</comment>
<comment type="block">/*         0x000D, * CARRIAGE RETURN */</comment>
	<expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<comment type="block">/*         0x001C, * FILE SEPARATOR */</comment>
<comment type="block">/*         0x001D, * GROUP SEPARATOR */</comment>
<comment type="block">/*         0x001E, * RECORD SEPARATOR */</comment>
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,

	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
	<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><name>Py_UNICODE</name></type>
<name>PyUnicode_GetMax</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
	<return>return <expr>0x10FFFF</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* This is actually an illegal character, so it should
	   not be passed to unichr. */</comment>
	<return>return <expr>0xFFFF</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* --- Bloom Filters ----------------------------------------------------- */</comment>

<comment type="block">/* stuff to implement simple "bloom filters" for Unicode characters.
   to keep things simple, we use a single bitmask, using the least 5
   bits from each unicode characters as the bit index. */</comment>

<comment type="block">/* the linebreak mask is set up by Unicode_Init below */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOOM_MASK</name></cpp:macro> <cpp:value>unsigned long</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>BLOOM_MASK</name></type> <name>bloom_linebreak</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOOM</name><parameter_list>(<param><type><name>mask</name></type></param>, <param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((mask &amp; (1 &lt;&lt; ((ch) &amp; 0x1F))))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOOM_LINEBREAK</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((ch) &lt; 128U ? ascii_linebreak[(ch)] : \
    (BLOOM(bloom_linebreak, (ch)) &amp;&amp; Py_UNICODE_ISLINEBREAK(ch)))</cpp:value></cpp:define>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>BLOOM_MASK</argument>)</argument_list></macro> <macro><name>make_bloom_mask</name><argument_list>(<argument>Py_UNICODE* ptr</argument>, <argument>Py_ssize_t len</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* calculate simple bloom-style bitmask for a given unicode string */</comment>

    <decl_stmt><decl><type><name>long</name></type> <name>mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>mask</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name>mask</name> |= (1 &lt;&lt; (<name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0x1F))</expr>;</expr_stmt></for>

    <return>return <expr><name>mask</name></expr>;</return>
}</block>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>unicode_member</name><argument_list>(<argument>Py_UNICODE chr</argument>, <argument>Py_UNICODE* set</argument>, <argument>Py_ssize_t setlen</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>setlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <if>if <condition>(<expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name> == <name>chr</name></expr>)</condition><then>
            <return>return <expr>1</expr>;</return></then></if></for>

    <return>return <expr>0</expr>;</return>
}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOOM_MEMBER</name><parameter_list>(<param><type><name>mask</name></type></param>, <param><type><name>chr</name></type></param>, <param><type><name>set</name></type></param>, <param><type><name>setlen</name></type></param>)</parameter_list></cpp:macro>\
    <cpp:value>BLOOM(mask, chr) &amp;&amp; unicode_member(chr, set, setlen)</cpp:value></cpp:define>

<comment type="block">/* --- Unicode Object ----------------------------------------------------- */</comment>

<function><type><specifier>static</specifier>
<name>int</name></type> <name>unicode_resize</name><parameter_list>(<param><decl><type><name>register</name> <name>PyUnicodeObject</name> *</type><name>unicode</name></decl></param>,
                      <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>oldstr</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut if there's nothing much to do. */</comment>
    <if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>length</name></name> == <name>length</name></expr>)</condition><then>
	<goto>goto <name>reset</name>;</goto></then></if>

    <comment type="block">/* Resizing shared object (unicode_empty or single character
       objects) in-place is not allowed. Use PyUnicode_Resize()
       instead ! */</comment>

    <if>if <condition>(<expr><name>unicode</name> == <name>unicode_empty</name> || 
	(<name><name>unicode</name>-&gt;<name>length</name></name> == 1 &amp;&amp; 
	 <name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> &lt; 256U &amp;&amp;
	 <name><name>unicode_latin1</name><index>[<expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr>]</index></name> == <name>unicode</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
                        <argument><expr>"can't resize shared unicode objects"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* We allocate one more byte to make sure the string is Ux0000 terminated.
       The overallocation is also used by fastsearch, which assumes that it's
       safe to look at str[length] (without making any assumptions about what
       it contains). */</comment>

    <expr_stmt><expr><name>oldstr</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = <call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>,
				    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * (<name>length</name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>unicode</name>-&gt;<name>str</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = (<name>Py_UNICODE</name> *)<name>oldstr</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr><name>length</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>length</name></name> = <name>length</name></expr>;</expr_stmt>

 <label><name>reset</name>:</label>
    <comment type="block">/* Reset the object caches */</comment>
    <if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>unicode</name>-&gt;<name>defenc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>hash</name></name> = -1</expr>;</expr_stmt>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* We allocate one more byte to make sure the string is
   Ux0000 terminated -- XXX is this needed ?

   XXX This allocator could further be enhanced by assuring that the
       free list never reduces its size below 1.

*/</comment>

<function><type><specifier>static</specifier>
<name>PyUnicodeObject</name> *</type><name>_PyUnicode_New</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>

    <comment type="block">/* Optimization for empty strings */</comment>
    <if>if <condition>(<expr><name>length</name> == 0 &amp;&amp; <name>unicode_empty</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>unicode_empty</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Ensure we won't overflow the size. */</comment>
    <if>if <condition>(<expr><name>length</name> &gt; ((<name>PY_SSIZE_T_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof>) - 1)</expr>)</condition><then> <block>{
        <return>return <expr>(<name>PyUnicodeObject</name> *)<call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Unicode freelist &amp; memory allocation */</comment>
    <if>if <condition>(<expr><name>free_list</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>unicode</name> = <name>free_list</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>free_list</name> = *(<name>PyUnicodeObject</name> **)<name>unicode</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numfree</name>--</expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>str</name></name></expr>)</condition><then> <block>{
	    <comment type="block">/* Keep-Alive optimization: we only upsize the buffer,
	       never downsize it. */</comment>
	    <if>if <condition>(<expr>(<name><name>unicode</name>-&gt;<name>length</name></name> &lt; <name>length</name>) &amp;&amp;
                <call><name>unicode_resize</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyObject_DEL</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = <name>NULL</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then>
        <else>else <block>{
	    <decl_stmt><decl><type><name>size_t</name></type> <name>new_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * ((<name>size_t</name>)<name>length</name> + 1)</expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = (<name>Py_UNICODE</name>*) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>new_size</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>unicode</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>PyUnicodeObject</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>new_size</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * ((<name>size_t</name>)<name>length</name> + 1)</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = (<name>Py_UNICODE</name>*) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr>!<name><name>unicode</name>-&gt;<name>str</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>onError</name>;</goto>
    }</block></then></if>
    <comment type="block">/* Initialize the first element to guard against cases where
     * the caller fails before initializing str -- unicode_resize()
     * reads str[0], and the Keep-Alive optimization can keep memory
     * allocated for str alive across a call to unicode_dealloc(unicode).
     * We don't want unicode_resize to read uninitialized memory in
     * that case.
     */</comment>
    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr><name>length</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>length</name></name> = <name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>hash</name></name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>defenc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>unicode</name></expr>;</return>

 <label><name>onError</name>:</label>
    <comment type="block">/* XXX UNREF/NEWREF interface should be more symmetrical */</comment>
    <expr_stmt><expr><name>_Py_DEC_REFTOTAL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_Py_ForgetReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>void</name></type> <name>unicode_dealloc</name><parameter_list>(<param><decl><type><name>register</name> <name>PyUnicodeObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call> &amp;&amp;
	<name>numfree</name> &lt; <name>PyUnicode_MAXFREELIST</name></expr>)</condition><then> <block>{
        <comment type="block">/* Keep-Alive optimization */</comment>
	<if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>length</name></name> &gt;= <name>KEEPALIVE_SIZE_LIMIT</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyObject_DEL</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = <name>NULL</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>length</name></name> = 0</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>unicode</name>-&gt;<name>defenc</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* Add to free list */</comment>
        <expr_stmt><expr>*(<name>PyUnicodeObject</name> **)<name>unicode</name> = <name>free_list</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>free_list</name> = <name>unicode</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numfree</name>++</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
	<expr_stmt><expr><call><name>PyObject_DEL</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name>int</name></type> <name>PyUnicode_Resize</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <comment type="block">/* Argument checks */</comment>
    <if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>v</name> = (<name>PyUnicodeObject</name> *)*<name>unicode</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 1 || <name>length</name> &lt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Resizing unicode_empty and single character objects is not
       possible since these are being shared. We simply return a fresh
       copy with the same Unicode content. */</comment>
    <if>if <condition>(<expr><name><name>v</name>-&gt;<name>length</name></name> != <name>length</name> &amp;&amp;
	(<name>v</name> == <name>unicode_empty</name> || <name><name>v</name>-&gt;<name>length</name></name> == 1)</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>w</name> <init>= <expr><call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>str</name></name></expr></argument>,
			<argument><expr><name>length</name> &lt; <name><name>v</name>-&gt;<name>length</name></name> ? <name>length</name> : <name><name>v</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>unicode</name> = (<name>PyObject</name> *)<name>w</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Note that we don't have to modify *unicode for unshared Unicode
       objects, since we can modify them in-place. */</comment>
    <return>return <expr><call><name>unicode_resize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Internal API for use in unicodeobject.c only ! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_Resize</name><parameter_list>(<param><type><name>unicodevar</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>PyUnicode_Resize(((PyObject **)(unicodevar)), length)</cpp:value></cpp:define>

<function><type><name>PyObject</name> *</type><name>PyUnicode_FromUnicode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>u</name></decl></param>,
				<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>

    <comment type="block">/* If the Unicode data is known at construction time, we can apply
       some optimizations which share commonly used objects. */</comment>
    <if>if <condition>(<expr><name>u</name> != <name>NULL</name></expr>)</condition><then> <block>{

	<comment type="block">/* Optimization for empty strings */</comment>
	<if>if <condition>(<expr><name>size</name> == 0 &amp;&amp; <name>unicode_empty</name> != <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>(<name>PyObject</name> *)<name>unicode_empty</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Single character Unicode objects in the Latin-1 range are
	   shared when using this constructor */</comment>
	<if>if <condition>(<expr><name>size</name> == 1 &amp;&amp; *<name>u</name> &lt; 256</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>unicode</name> = <name><name>unicode_latin1</name><index>[<expr>*<name>u</name></expr>]</index></name></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
		    <return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> = *<name>u</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unicode_latin1</name><index>[<expr>*<name>u</name></expr>]</index></name> = <name>unicode</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
	}</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Copy the Unicode data into the new object */</comment>
    <if>if <condition>(<expr><name>u</name> != <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_FromStringAndSize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>u</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
		    <argument><expr>"Negative size passed to PyUnicode_FromStringAndSize"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

    <comment type="block">/* If the Unicode data is known at construction time, we can apply
       some optimizations which share commonly used objects.
       Also, this means the input must be UTF-8, so fall back to the
       UTF-8 decoder at the end. */</comment>
    <if>if <condition>(<expr><name>u</name> != <name>NULL</name></expr>)</condition><then> <block>{

	<comment type="block">/* Optimization for empty strings */</comment>
	<if>if <condition>(<expr><name>size</name> == 0 &amp;&amp; <name>unicode_empty</name> != <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>(<name>PyObject</name> *)<name>unicode_empty</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Single characters are shared when using this constructor.
           Restrict to ASCII, since the input must be UTF-8. */</comment>
	<if>if <condition>(<expr><name>size</name> == 1 &amp;&amp; <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>u</name></expr></argument>)</argument_list></call> &lt; 128</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>unicode</name> = <name><name>unicode_latin1</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>u</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
		    <return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unicode_latin1</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>u</name></expr></argument>)</argument_list></call></expr>]</index></name> = <name>unicode</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
	}</block></then></if>

        <return>return <expr><call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_FromString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>u</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"input too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>PyUnicode_FromStringAndSize</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCHAR_H</name></cpp:ifdef>

<function><type><name>PyObject</name> *</type><name>PyUnicode_FromWideChar</name><parameter_list>(<param><decl><type><name>register</name> <specifier>const</specifier> <name>wchar_t</name> *</type><name>w</name></decl></param>,
				 <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Copy the wchar_t data into the new object */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_USABLE_WCHAR_T</name></cpp:ifdef>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>size</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
	    <expr_stmt><expr>*<name>u</name>++ = *<name>w</name>++</expr>;</expr_stmt></for>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>makefmt</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type><name>int</name></type> <name>longflag</name></decl></param>, <param><decl><type><name>int</name></type> <name>size_tflag</name></decl></param>, <param><decl><type><name>int</name></type> <name>zeropad</name></decl></param>, <param><decl><type><name>int</name></type> <name>width</name></decl></param>, <param><decl><type><name>int</name></type> <name>precision</name></decl></param>, <param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr>*<name>fmt</name>++ = '%'</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>width</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>zeropad</name></expr>)</condition><then>
			<expr_stmt><expr>*<name>fmt</name>++ = '0'</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>fmt</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>precision</name></expr>)</condition><then>
		<expr_stmt><expr><name>fmt</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr>".%d"</expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>longflag</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>fmt</name>++ = 'l'</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>size_tflag</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>f</name> <init>= <expr><name>PY_FORMAT_SIZE_T</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr>*<name>f</name></expr>)</condition>
			<expr_stmt><expr>*<name>fmt</name>++ = *<name>f</name>++</expr>;</expr_stmt></while>
	}</block></then></if></else></if>
	<expr_stmt><expr>*<name>fmt</name>++ = <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>fmt</name> = '\0'</expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>appendstring</name><parameter_list>(<param><type><name>string</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{for (copy = string;*copy;) *s++ = *copy++;}</cpp:value></cpp:define>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_FromFormatV</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>vargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>callcount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>callresults</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>callresult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>precision</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>zeropad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>string</name></decl>;</decl_stmt>
	<comment type="block">/* used by sprintf */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>21</expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* use abuffer instead of buffer, if we need more space
	 * (which can happen if there's a format specifier with width). */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>abuffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>realbuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>abuffersize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>fmt</name><index>[<expr>60</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* should be enough for %0width.precisionld */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VA_LIST_IS_ARRAY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>va_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>  <name>__va_copy</name></cpp:ifdef>
	<expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>count</name> = <name>vargs</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* step 1: count the number of %S/%R format specifications
	 * (we call PyObject_Str()/PyObject_Repr() for these objects
	 * once during step 3 and put the result in an array) */</comment>
	<for>for (<init><expr><name>f</name> = <name>format</name></expr>;</init> <condition><expr>*<name>f</name></expr>;</condition> <incr><expr><name>f</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>f</name> == '%' &amp;&amp; (*(<name>f</name>+1)=='S' || *(<name>f</name>+1)=='R')</expr>)</condition><then>
			<expr_stmt><expr>++<name>callcount</name></expr>;</expr_stmt></then></if>
	}</block></for>
	<comment type="block">/* step 2: allocate memory for the results of
	 * PyObject_Str()/PyObject_Repr() calls */</comment>
	<if>if <condition>(<expr><name>callcount</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>callresults</name> = <call><name>PyObject_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof>*<name>callcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>callresults</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>callresult</name> = <name>callresults</name></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* step 3: figure out how large a buffer we need */</comment>
	<for>for (<init><expr><name>f</name> = <name>format</name></expr>;</init> <condition><expr>*<name>f</name></expr>;</condition> <incr><expr><name>f</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>f</name> == '%'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>p</name> <init>= <expr><name>f</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>width</name> = 0</expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr>(<name>unsigned</name>)*<name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
				<expr_stmt><expr><name>width</name> = (<name>width</name>*10) + *<name>f</name>++ - '0'</expr>;</expr_stmt></while>
			<while>while <condition>(<expr>*++<name>f</name> &amp;&amp; *<name>f</name> != '%' &amp;&amp; !<call><name>isalpha</name><argument_list>(<argument><expr>(<name>unsigned</name>)*<name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
				<empty_stmt>;</empty_stmt></while>

			<comment type="block">/* skip the 'l' or 'z' in {%ld, %zd, %lu, %zu} since
			 * they don't affect the amount of space we reserve.
			 */</comment>
			<if>if <condition>(<expr>(*<name>f</name> == 'l' || *<name>f</name> == 'z') &amp;&amp;
					(<name><name>f</name><index>[<expr>1</expr>]</index></name> == 'd' || <name><name>f</name><index>[<expr>1</expr>]</index></name> == 'u')</expr>)</condition><then>
                                <expr_stmt><expr>++<name>f</name></expr>;</expr_stmt></then></if>

			<switch>switch <condition>(<expr>*<name>f</name></expr>)</condition> <block>{
			<case>case <expr>'c'</expr>:
				<expr_stmt><expr>(<name>void</name>)<call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* fall through... */</comment>
			</case><case>case <expr>'%'</expr>:
				<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'d'</expr>: </case><case>case <expr>'u'</expr>: </case><case>case <expr>'i'</expr>: </case><case>case <expr>'x'</expr>:
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* 20 bytes is enough to hold a 64-bit
				   integer.  Decimal takes the most space.
				   This isn't enough for octal.
				   If a width is specified we need more
				   (which we allocate later). */</comment>
				<if>if <condition>(<expr><name>width</name> &lt; 20</expr>)</condition><then>
					<expr_stmt><expr><name>width</name> = 20</expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>n</name> += <name>width</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>abuffersize</name> &lt; <name>width</name></expr>)</condition><then>
					<expr_stmt><expr><name>abuffersize</name> = <name>width</name></expr>;</expr_stmt></then></if>
				<break>break;</break>
			</case><case>case <expr>'s'</expr>:
			<block>{
				<comment type="block">/* UTF-8 */</comment>
				<decl_stmt><decl><type><name>unsigned</name> <name>char</name>*</type><name>s</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>s</name> = <macro><name>va_arg</name><argument_list>(<argument>count</argument>, <argument>unsigned char*</argument>)</argument_list></macro></expr>;</expr_stmt>
				<while>while <condition>(<expr>*<name>s</name></expr>)</condition> <block>{
					<if>if <condition>(<expr>*<name>s</name> &lt; 128</expr>)</condition><then> <block>{
						<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt> <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
					}</block></then> <else>else <if>if <condition>(<expr>*<name>s</name> &lt; 0xc0</expr>)</condition><then> <block>{
						<comment type="block">/* invalid UTF-8 */</comment>
						<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt> <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
					}</block></then> <else>else <if>if <condition>(<expr>*<name>s</name> &lt; 0xc0</expr>)</condition><then> <block>{
						<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
						<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt> <if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
						<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
					}</block></then> <else>else <if>if <condition>(<expr>*<name>s</name> &lt; 0xe0</expr>)</condition><then> <block>{
						<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
						<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt> <if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
						<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt> <if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
						<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
					}</block></then> <else>else <block>{
						<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
						<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
						<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
						<expr_stmt><expr><name>n</name>+=2</expr>;</expr_stmt>
						<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt> <if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
						<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt> <if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
						<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt> <if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
						<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
					}</block></else></if></else></if></else></if></else></if>
				}</block></while>
				<break>break;</break>
			}</block>
			</case><case>case <expr>'U'</expr>:
			<block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name> &amp;&amp; <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block>
			</case><case>case <expr>'V'</expr>:
			<block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name> || <name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>obj</name> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>obj</name></expr>)</condition><then>
					<expr_stmt><expr><name>n</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>n</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
				<break>break;</break>
			}</block>
			</case><case>case <expr>'S'</expr>:
			<block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
					<goto>goto <name>fail</name>;</goto></then></if>
				<expr_stmt><expr><name>n</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Remember the str and switch to the next slot */</comment>
				<expr_stmt><expr>*<name>callresult</name>++ = <name>str</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block>
			</case><case>case <expr>'R'</expr>:
			<block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>repr</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>repr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!<name>repr</name></expr>)</condition><then>
					<goto>goto <name>fail</name>;</goto></then></if>
				<expr_stmt><expr><name>n</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Remember the repr and switch to the next slot */</comment>
				<expr_stmt><expr>*<name>callresult</name>++ = <name>repr</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block>
			</case><case>case <expr>'p'</expr>:
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* maximum 64-bit pointer representation:
				 * 0xffffffffffffffff
				 * so 19 characters is enough.
				 * XXX I count 18 -- what's the extra for?
				 */</comment>
				<expr_stmt><expr><name>n</name> += 19</expr>;</expr_stmt>
				<break>break;</break>
			</case><default>default:
				<comment type="block">/* if we stumble upon an unknown
				   formatting code, copy the rest of
				   the format string to the output
				   string. (we cannot just skip the
				   code, since there's no way to know
				   what's in the argument list) */</comment>
				<expr_stmt><expr><name>n</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>expand</name>;</goto>
			</default>}</block></switch>
		}</block></then> <else>else
			<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></else></if>
	}</block></for>
 <label><name>expand</name>:</label>
	<if>if <condition>(<expr><name>abuffersize</name> &gt; 20</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>abuffer</name> = <call><name>PyObject_Malloc</name><argument_list>(<argument><expr><name>abuffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>abuffer</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>realbuffer</name> = <name>abuffer</name></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>realbuffer</name> = <name>buffer</name></expr>;</expr_stmt></else></if>
	<comment type="block">/* step 4: fill the buffer */</comment>
	<comment type="block">/* Since we've analyzed how much space we need for the worst case,
	   we don't have to resize the string.
	   There can be no errors beyond this point. */</comment>
	<expr_stmt><expr><name>string</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>string</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>

	<expr_stmt><expr><name>s</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>callresult</name> = <name>callresults</name></expr>;</expr_stmt>

	<for>for (<init><expr><name>f</name> = <name>format</name></expr>;</init> <condition><expr>*<name>f</name></expr>;</condition> <incr><expr><name>f</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>f</name> == '%'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>p</name> <init>= <expr><name>f</name>++</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>longflag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>size_tflag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>zeropad</name> = (*<name>f</name> == '0')</expr>;</expr_stmt>
			<comment type="block">/* parse the width.precision part */</comment>
			<expr_stmt><expr><name>width</name> = 0</expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr>(<name>unsigned</name>)*<name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
				<expr_stmt><expr><name>width</name> = (<name>width</name>*10) + *<name>f</name>++ - '0'</expr>;</expr_stmt></while>
			<expr_stmt><expr><name>precision</name> = 0</expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>f</name> == '.'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>f</name>++</expr>;</expr_stmt>
				<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr>(<name>unsigned</name>)*<name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
					<expr_stmt><expr><name>precision</name> = (<name>precision</name>*10) + *<name>f</name>++ - '0'</expr>;</expr_stmt></while>
			}</block></then></if>
			<comment type="block">/* handle the long flag, but only for %ld and %lu.
			   others can be added when necessary. */</comment>
			<if>if <condition>(<expr>*<name>f</name> == 'l' &amp;&amp; (<name><name>f</name><index>[<expr>1</expr>]</index></name> == 'd' || <name><name>f</name><index>[<expr>1</expr>]</index></name> == 'u')</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>longflag</name> = 1</expr>;</expr_stmt>
				<expr_stmt><expr>++<name>f</name></expr>;</expr_stmt>
			}</block></then></if>
			<comment type="block">/* handle the size_t flag. */</comment>
			<if>if <condition>(<expr>*<name>f</name> == 'z' &amp;&amp; (<name><name>f</name><index>[<expr>1</expr>]</index></name> == 'd' || <name><name>f</name><index>[<expr>1</expr>]</index></name> == 'u')</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>size_tflag</name> = 1</expr>;</expr_stmt>
				<expr_stmt><expr>++<name>f</name></expr>;</expr_stmt>
			}</block></then></if>

			<switch>switch <condition>(<expr>*<name>f</name></expr>)</condition> <block>{
			<case>case <expr>'c'</expr>:
				<expr_stmt><expr>*<name>s</name>++ = <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'d'</expr>:
				<expr_stmt><expr><call><name>makefmt</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>longflag</name></expr></argument>, <argument><expr><name>size_tflag</name></expr></argument>, <argument><expr><name>zeropad</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr>'d'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>longflag</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name>size_tflag</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
				<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'u'</expr>:
				<expr_stmt><expr><call><name>makefmt</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>longflag</name></expr></argument>, <argument><expr><name>size_tflag</name></expr></argument>, <argument><expr><name>zeropad</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr>'u'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>longflag</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><macro><name>va_arg</name><argument_list>(<argument>vargs</argument>, <argument>unsigned long</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name>size_tflag</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><macro><name>va_arg</name><argument_list>(<argument>vargs</argument>, <argument>unsigned int</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
				<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'i'</expr>:
				<expr_stmt><expr><call><name>makefmt</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zeropad</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr>'i'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'x'</expr>:
				<expr_stmt><expr><call><name>makefmt</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zeropad</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr>'x'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'s'</expr>:
			<block>{
				<comment type="block">/* Parameter must be UTF-8 encoded.
				   In case of encoding errors, use
				   the replacement character. */</comment>
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>p</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>char</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, 
							 <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
					<goto>goto <name>fail</name>;</goto></then></if>
				<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block>
			</case><case>case <expr>'U'</expr>:
			<block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> += <name>size</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block>
			</case><case>case <expr>'V'</expr>:
			<block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>obj</name></expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>s</name> += <name>size</name></expr>;</expr_stmt>
				}</block></then> <else>else <block>{
					<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></else></if>
				<break>break;</break>
			}</block>
			</case><case>case <expr>'S'</expr>:
			</case><case>case <expr>'R'</expr>:
			<block>{
				<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>ucopy</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>usize</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>upos</name></decl>;</decl_stmt>
				<comment type="block">/* unused, since we already have the result */</comment>
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ucopy</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>callresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>usize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>callresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for (<init><expr><name>upos</name> = 0</expr>;</init> <condition><expr><name>upos</name>&lt;<name>usize</name></expr>;</condition><incr/>)
					<expr_stmt><expr>*<name>s</name>++ = <name><name>ucopy</name><index>[<expr><name>upos</name>++</expr>]</index></name></expr>;</expr_stmt></for>
				<comment type="block">/* We're done with the unicode()/repr() =&gt; forget it */</comment>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>callresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* switch to next unicode()/repr() result */</comment>
				<expr_stmt><expr>++<name>callresult</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block>
			</case><case>case <expr>'p'</expr>:
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"%p"</expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>void</name>*</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* %p is ill-defined:  ensure leading 0x. */</comment>
				<if>if <condition>(<expr><name><name>buffer</name><index>[<expr>1</expr>]</index></name> == 'X'</expr>)</condition><then>
					<expr_stmt><expr><name><name>buffer</name><index>[<expr>1</expr>]</index></name> = 'x'</expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name><name>buffer</name><index>[<expr>1</expr>]</index></name> != 'x'</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buffer</name>+2</expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>buffer</name><index>[<expr>0</expr>]</index></name> = '0'</expr>;</expr_stmt>
					<expr_stmt><expr><name><name>buffer</name><index>[<expr>1</expr>]</index></name> = 'x'</expr>;</expr_stmt>
				}</block></then></if></else></if>
				<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr>'%'</expr>:
				<expr_stmt><expr>*<name>s</name>++ = '%'</expr>;</expr_stmt>
				<break>break;</break>
			</case><default>default:
				<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>end</name>;</goto>
			</default>}</block></switch>
		}</block></then> <else>else
			<expr_stmt><expr>*<name>s</name>++ = *<name>f</name></expr>;</expr_stmt></else></if>
	}</block></for>

 <label><name>end</name>:</label>
	<if>if <condition>(<expr><name>callresults</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>callresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>abuffer</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>abuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>string</name></expr></argument>, <argument><expr><name>s</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>string</name></expr>;</return>
 <label><name>fail</name>:</label>
	<if>if <condition>(<expr><name>callresults</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>callresult2</name> <init>= <expr><name>callresults</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>callresult2</name> &lt; <name>callresult</name></expr>)</condition> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>callresult2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr>++<name>callresult2</name></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>callresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>abuffer</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>abuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>appendstring</name></cpp:undef>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_FromFormat</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STDARG_PROTOTYPES</name></cpp:ifdef>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>ret</name> = <call><name>PyUnicode_FromFormatV</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_AsWideChar</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl></param>,
				<param><decl><type><name>wchar_t</name> *</type><name>w</name></decl></param>,
				<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* If possible, try to copy the 0-termination as well */</comment>
    <if>if <condition>(<expr><name>size</name> &gt; <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>size</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_USABLE_WCHAR_T</name></cpp:ifdef>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>size</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
	    <expr_stmt><expr>*<name>w</name>++ = *<name>u</name>++</expr>;</expr_stmt></for>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>size</name> &gt; <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else
    <return>return <expr><name>size</name></expr>;</return></else></if>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PyObject</name> *</type><name>PyUnicode_FromOrdinal</name><parameter_list>(<param><decl><type><name>int</name></type> <name>ordinal</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>s</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
    <if>if <condition>(<expr><name>ordinal</name> &lt; 0 || <name>ordinal</name> &gt; 0x10ffff</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			<argument><expr>"unichr() arg not in range(0x110000) "
			"(wide Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr><name>ordinal</name> &lt; 0 || <name>ordinal</name> &gt; 0xffff</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			<argument><expr>"unichr() arg not in range(0x10000) "
			"(narrow Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>s</name><index>[<expr>0</expr>]</index></name> = (<name>Py_UNICODE</name>)<name>ordinal</name></expr>;</expr_stmt>
    <return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_FromObject</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* XXX Perhaps we should make this API an alias of
           PyObject_Unicode() instead ?! */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>obj</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/* For a Unicode subtype that's not a Unicode object,
	   return a true Unicode object with the same data. */</comment>
	<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_FromEncodedObject</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>obj</name></decl></param>,
				      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
				      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
    <comment type="block">/* For b/w compatibility we also accept Unicode objects provided
       that no encodings is given and then redirect to
       PyObject_Unicode() which then applies the additional logic for
       Unicode subclasses.

       NOTE: This API should really only be used for object which
             represent *encoded* Unicode !

    */</comment>
	if (PyUnicode_Check(obj)) {
	    if (encoding) {
		PyErr_SetString(PyExc_TypeError,
				"decoding Unicode is not supported");
	    return NULL;
	    }
	return PyObject_Unicode(obj);
	    }
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"decoding Unicode is not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Coerce object */</comment>
    <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Python 2.x specific */</comment>
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"decoding bytearray is not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/* Overwrite the error message with something more useful in
	   case of a TypeError. */</comment>
	<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			 <argument><expr>"coercing to Unicode: need string or buffer, "
			 "%.80s found"</expr></argument>,
		     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<goto>goto <name>onError</name>;</goto>
    }</block></then></if></else></if></else></if>

    <comment type="block">/* Convert to Unicode */</comment>
    <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> = (<name>PyObject</name> *)<name>unicode_empty</name></expr>;</expr_stmt>
    }</block></then>
    <else>else
	<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_Decode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
			   <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
			   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init>, *<name>unicode</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Shortcuts for common default encodings */</comment>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"utf-8"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"latin-1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><call><name>PyUnicode_DecodeLatin1</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"mbcs"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><call><name>PyUnicode_DecodeMBCS</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"ascii"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><call><name>PyUnicode_DecodeASCII</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if></else></if></else></if>

    <comment type="block">/* Decode via the codec registry */</comment>
    <expr_stmt><expr><name>buffer</name> = <call><name>PyBuffer_FromMemory</name><argument_list>(<argument><expr>(<name>void</name> *)<name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><name>unicode</name> = <call><name>PyCodec_Decode</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"decoder did not return an unicode object (type=%.400s)"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>unicode</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsDecodedObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Decode via the codec registry */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>PyCodec_Decode</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_Encode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
			   <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
			   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>unicode</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsEncodedObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Encode via the codec registry */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>PyCodec_Encode</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsEncodedString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Shortcuts for common default encodings */</comment>
    <if>if <condition>(<expr><name>errors</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"utf-8"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	    <return>return <expr><call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"latin-1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	    <return>return <expr><call><name>PyUnicode_AsLatin1String</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"mbcs"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	    <return>return <expr><call><name>PyUnicode_AsMBCSString</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"ascii"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	    <return>return <expr><call><name>PyUnicode_AsASCIIString</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if></else></if></else></if>
    }</block></then></if>

    <comment type="block">/* Encode via the codec registry */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>PyCodec_Encode</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"encoder did not return a string object (type=%.400s)"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>
    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>_PyUnicode_AsDefaultEncodedString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
					    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr>((<name>PyUnicodeObject</name> *)<name>unicode</name>)-&gt;<name>defenc</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>v</name></expr>)</condition><then>
        <return>return <expr><name>v</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> &amp;&amp; <name>errors</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr>((<name>PyUnicodeObject</name> *)<name>unicode</name>)-&gt;<name>defenc</name> = <name>v</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><name>Py_UNICODE</name> *</type><name>PyUnicode_AsUnicode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_GetSize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>onError</name>;</goto>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type><name>PyUnicode_GetDefaultEncoding</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>unicode_default_encoding</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>PyUnicode_SetDefaultEncoding</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <comment type="block">/* Make sure the encoding is valid. As side effect, this also
       loads the encoding into the codec registry cache. */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>_PyCodec_Lookup</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>unicode_default_encoding</name></expr></argument>,
	    <argument><expr><name>encoding</name></expr></argument>,
	    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unicode_default_encoding</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* error handling callback helper:
   build arguments, call the callback and check the arguments,
   if no exception occurred, copy the replacement to the output
   and adjust various state variables.
   return 0 on success, -1 on error
*/</comment>

<function><type><specifier>static</specifier>
<name>int</name></type> <name>unicode_decode_call_errorhandler</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>errorHandler</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>insize</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>startinpos</name></decl></param>,
                 <param><decl><type><name>Py_ssize_t</name> *</type><name>endinpos</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>inptr</name></decl></param>,
                 <param><decl><type><name>PyObject</name> **</type><name>output</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>outpos</name></decl></param>, <param><decl><type><name>Py_UNICODE</name> **</type><name>outptr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>argparse</name> <init>= <expr>"O!n;decoding error handler must return (unicode, int) tuple"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PyObject</name> *</type><name>restuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outsize</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>output</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>repptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>errorHandler</name> = <call><name>PyCodec_LookupError</name><argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then>
	   <goto>goto <name>onError</name>;</goto></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then> <block>{
    	<expr_stmt><expr>*<name>exceptionObject</name> = <call><name>PyUnicodeDecodeError_Create</name><argument_list>(
	    <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>insize</name></expr></argument>, <argument><expr>*<name>startinpos</name></expr></argument>, <argument><expr>*<name>endinpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then>
	   <goto>goto <name>onError</name>;</goto></then></if>
    }</block></then>
    <else>else <block>{
	<if>if <condition>(<expr><call><name>PyUnicodeDecodeError_SetStart</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr>*<name>startinpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>PyUnicodeDecodeError_SetEnd</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr>*<name>endinpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>PyUnicodeDecodeError_SetReason</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
    }</block></else></if>

    <expr_stmt><expr><name>restuple</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr>*<name>errorHandler</name></expr></argument>, <argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>restuple</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>&amp;<name><name>argparse</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>onError</name>;</goto>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>, <argument><expr><name>argparse</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>repunicode</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>newpos</name>&lt;0</expr>)</condition><then>
	<expr_stmt><expr><name>newpos</name> = <name>insize</name>+<name>newpos</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>newpos</name>&lt;0 || <name>newpos</name>&gt;<name>insize</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"position %zd from error handler out of bounds"</expr></argument>, <argument><expr><name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>onError</name>;</goto>
    }</block></then></if>

    <comment type="block">/* need more space? (at least enough for what we
       have+the replacement+the rest of the string (starting
       at the new input position), so we won't have to check space
       when there are no errors in the rest of the string) */</comment>
    <expr_stmt><expr><name>repptr</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>requiredsize</name> = *<name>outpos</name> + <name>repsize</name> + <name>insize</name>-<name>newpos</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>requiredsize</name> &gt; <name>outsize</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>requiredsize</name>&lt;2*<name>outsize</name></expr>)</condition><then>
	    <expr_stmt><expr><name>requiredsize</name> = 2*<name>outsize</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>PyUnicode_Resize</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<expr_stmt><expr>*<name>outptr</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>output</name></expr></argument>)</argument_list></call> + *<name>outpos</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>endinpos</name> = <name>newpos</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>inptr</name> = <name>input</name> + <name>newpos</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr>*<name>outptr</name></expr></argument>, <argument><expr><name>repptr</name></expr></argument>, <argument><expr><name>repsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>outptr</name> += <name>repsize</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>outpos</name> += <name>repsize</name></expr>;</expr_stmt>
    <comment type="block">/* we made it! */</comment>
    <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>

    <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* --- UTF-7 Codec -------------------------------------------------------- */</comment>

<comment type="block">/* see RFC2152 for details */</comment>

<decl_stmt><decl><type><specifier>static</specifier>
<name>char</name></type> <name><name>utf7_special</name><index>[<expr>128</expr>]</index></name> <init>= <expr><block>{
    <comment type="block">/* indicate whether a UTF-7 character is special i.e. cannot be directly
       encoded:
	   0 - not special
	   1 - special
	   2 - whitespace (optional)
	   3 - RFC2152 Set O (optional) */</comment>
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>2</expr>, <expr>2</expr>, <expr>1</expr>, <expr>1</expr>, <expr>2</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>2</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>3</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>0</expr>,
    <expr>3</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>3</expr>, <expr>1</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>,
    <expr>3</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>1</expr>, <expr>1</expr>,

}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Note: The comparison (c) &lt;= 0 is a trick to work-around gcc
   warnings about the comparison always being false; since
   utf7_special[0] is 1, we can safely make that one comparison
   true  */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPECIAL</name><parameter_list>(<param><type><name>c</name></type></param>, <param><type><name>encodeO</name></type></param>, <param><type><name>encodeWS</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((c) &gt; 127 || (c) &lt;= 0 || utf7_special[(c)] == 1 || \
     (encodeWS &amp;&amp; (utf7_special[(c)] == 2)) || \
     (encodeO &amp;&amp; (utf7_special[(c)] == 3)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B64</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>  \
    <cpp:value>("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(n) &amp; 0x3f])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B64CHAR</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>(isalnum(c) || (c) == '+' || (c) == '/')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UB64</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((c) == '+' ? 62 : (c) == '/' ? 63 : (c) &gt;= 'a' ?                   \
     (c) - 71 : (c) &gt;= 'A' ? (c) - 65 : (c) + 4 )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODE</name><parameter_list>(<param><type><name>out</name></type></param>, <param><type><name>ch</name></type></param>, <param><type><name>bits</name></type></param>)</parameter_list></cpp:macro>                   \
    <cpp:value>while (bits &gt;= 6) {                         \
        *out++ = B64(ch &gt;&gt; (bits-6));           \
        bits -= 6;                              \
    }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECODE</name><parameter_list>(<param><type><name>out</name></type></param>, <param><type><name>ch</name></type></param>, <param><type><name>bits</name></type></param>, <param><type><name>surrogate</name></type></param>)</parameter_list></cpp:macro>                                \
    <cpp:value>while (bits &gt;= 16) {                                                \
        Py_UNICODE outCh = (Py_UNICODE) ((ch &gt;&gt; (bits-16)) &amp; 0xffff);   \
        bits -= 16;                                                     \
        if (surrogate) {                                                \
            <comment type="block">/* We have already generated an error for the high surrogate \
               so let's not bother seeing if the low surrogate is correct or not */</comment> \
            surrogate = 0;                                              \
        } else if (0xDC00 &lt;= outCh &amp;&amp; outCh &lt;= 0xDFFF) {                \
            <comment type="block">/* This is a surrogate pair. Unfortunately we can't represent \
               it in a 16-bit character */</comment>                              \
            surrogate = 1;                                              \
            errmsg = "code pairs are not supported";                    \
            goto utf7Error;                                             \
        } else {                                                        \
            *out++ = outCh;                                             \
        }                                                               \
    }</cpp:value></cpp:define>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUTF7</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
			       <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_DecodeUTF7Stateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUTF7Stateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
			       <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
			       <param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>inShift</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bitsleft</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>charsleft</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>surrogate</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>consumed</name> = 0</expr>;</expr_stmt></then></if>
        <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>p</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name></decl>;</decl_stmt>
        <label><name>restart</name>:</label>
        <expr_stmt><expr><name>ch</name> = (<name>unsigned</name> <name>char</name>) *<name>s</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>inShift</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>(<name>ch</name> == '-') || !<call><name>B64CHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>

                <comment type="block">/* p, charsleft, bitsleft, surrogate = */</comment> <expr_stmt><expr><call><name>DECODE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>charsleft</name></expr></argument>, <argument><expr><name>bitsleft</name></expr></argument>, <argument><expr><name>surrogate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>bitsleft</name> &gt;= 6</expr>)</condition><then> <block>{
                    <comment type="block">/* The shift sequence has a partial character in it. If
                       bitsleft &lt; 6 then we could just classify it as padding
                       but that is not the case here */</comment>

                    <expr_stmt><expr><name>errmsg</name> = "partial character in shift sequence"</expr>;</expr_stmt>
                    <goto>goto <name>utf7Error</name>;</goto>
                }</block></then></if>
                <comment type="block">/* According to RFC2152 the remaining bits should be zero. We
                   choose to signal an error/insert a replacement character
                   here so indicate the potential of a misencoded character. */</comment>

                <comment type="block">/* On x86, a &lt;&lt; b == a &lt;&lt; (b%32) so make sure that bitsleft != 0 */</comment>
                <if>if <condition>(<expr><name>bitsleft</name> &amp;&amp; <name>charsleft</name> &lt;&lt; (<sizeof>sizeof<argument_list>(<argument><expr><name>charsleft</name></expr></argument>)</argument_list></sizeof> * 8 - <name>bitsleft</name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>errmsg</name> = "non-zero padding bits in shift sequence"</expr>;</expr_stmt>
                    <goto>goto <name>utf7Error</name>;</goto>
                }</block></then></if>

                <if>if <condition>(<expr><name>ch</name> == '-'</expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>(<name>s</name> &lt; <name>e</name>) &amp;&amp; (*(<name>s</name>) == '-')</expr>)</condition><then> <block>{
                        <expr_stmt><expr>*<name>p</name>++ = '-'</expr>;</expr_stmt>
                        <expr_stmt><expr><name>inShift</name> = 1</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <else>else <if>if <condition>(<expr><call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>errmsg</name> = "unexpected special character"</expr>;</expr_stmt>
	                <goto>goto <name>utf7Error</name>;</goto>
                }</block></then> <else>else  <block>{
                    <expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt>
                }</block></else></if></else></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>charsleft</name> = (<name>charsleft</name> &lt;&lt; 6) | <call><name>UB64</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bitsleft</name> += 6</expr>;</expr_stmt>
                <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
                <comment type="block">/* p, charsleft, bitsleft, surrogate = */</comment> <expr_stmt><expr><call><name>DECODE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>charsleft</name></expr></argument>, <argument><expr><name>bitsleft</name></expr></argument>, <argument><expr><name>surrogate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>( <expr><name>ch</name> == '+'</expr> )</condition><then> <block>{
            <expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>s</name> &lt; <name>e</name> &amp;&amp; *<name>s</name> == '-'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name>++ = '+'</expr>;</expr_stmt>
            }</block></then> <else>else
            <block>{
                <expr_stmt><expr><name>inShift</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>bitsleft</name> = 0</expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>errmsg</name> = "unexpected special character"</expr>;</expr_stmt>
            <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
	        <goto>goto <name>utf7Error</name>;</goto>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>
        <continue>continue;</continue>
    <label><name>utf7Error</name>:</label>
        <expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
             <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
             <argument><expr>"utf7"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>,
             <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
             <argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    }</block></while>

    <if>if <condition>(<expr><name>inShift</name> &amp;&amp; !<name>consumed</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>endinpos</name> = <name>size</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
             <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
             <argument><expr>"utf7"</expr></argument>, <argument><expr>"unterminated shift sequence"</expr></argument>,
             <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
             <argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>onError</name>;</goto></then></if>
        <if>if <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition><then>
           <goto>goto <name>restart</name>;</goto></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then> <block>{
        <if>if<condition>(<expr><name>inShift</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>consumed</name> = <name>startinpos</name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr>*<name>consumed</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt></else></if>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>unicode</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>

<label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeUTF7</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
                   <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
                   <param><decl><type><name>int</name></type> <name>encodeSetO</name></decl></param>,
                   <param><decl><type><name>int</name></type> <name>encodeWhiteSpace</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <comment type="block">/* It might be possible to tighten this worst case */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cbAllocated</name> <init>= <expr>5 * <name>size</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>inShift</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bitsleft</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>charsleft</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type> <name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type> <name>start</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>cbAllocated</name> / 5 != <name>size</name></expr>)</condition><then>
        <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>

    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cbAllocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>start</name> = <name>out</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init><condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<name>inShift</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>ch</name> == '+'</expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>out</name>++ = '+'</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>encodeSetO</name></expr></argument>, <argument><expr><name>encodeWhiteSpace</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>charsleft</name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>bitsleft</name> = 16</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>out</name>++ = '+'</expr>;</expr_stmt>
                <comment type="block">/* out, charsleft, bitsleft = */</comment> <expr_stmt><expr><call><name>ENCODE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>charsleft</name></expr></argument>, <argument><expr><name>bitsleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>inShift</name> = <name>bitsleft</name> &gt; 0</expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr>*<name>out</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>encodeSetO</name></expr></argument>, <argument><expr><name>encodeWhiteSpace</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>out</name>++ = <call><name>B64</name><argument_list>(<argument><expr><name>charsleft</name> &lt;&lt; (6-<name>bitsleft</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>charsleft</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>bitsleft</name> = 0</expr>;</expr_stmt>
                <comment type="block">/* Characters not in the BASE64 set implicitly unshift the sequence
                   so no '-' is required, except if the character is itself a '-' */</comment>
                <if>if <condition>(<expr><call><name>B64CHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> || <name>ch</name> == '-'</expr>)</condition><then> <block>{
                    <expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>out</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>bitsleft</name> += 16</expr>;</expr_stmt>
                <expr_stmt><expr><name>charsleft</name> = (<name>charsleft</name> &lt;&lt; 16) | <name>ch</name></expr>;</expr_stmt>
                <comment type="block">/* out, charsleft, bitsleft = */</comment> <expr_stmt><expr><call><name>ENCODE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>charsleft</name></expr></argument>, <argument><expr><name>bitsleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* If the next character is special then we dont' need to terminate
                   the shift sequence. If the next character is not a BASE64 character
                   or '-' then the shift sequence will be terminated implicitly and we
                   don't have to insert a '-'. */</comment>

                <if>if <condition>(<expr><name>bitsleft</name> == 0</expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>i</name> + 1 &lt; <name>size</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></init></decl>;</decl_stmt>

                        <if>if <condition>(<expr><call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch2</name></expr></argument>, <argument><expr><name>encodeSetO</name></expr></argument>, <argument><expr><name>encodeWhiteSpace</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

                        }</block></then> <else>else <if>if <condition>(<expr><call><name>B64CHAR</name><argument_list>(<argument><expr><name>ch2</name></expr></argument>)</argument_list></call> || <name>ch2</name> == '-'</expr>)</condition><then> <block>{
                            <expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
                            <expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
                        }</block></else></if></else></if>

                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
                        <expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then></if>
            }</block></else></if>
        }</block></else></if>
    }</block></for>
    <if>if <condition>(<expr><name>bitsleft</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>out</name>++= <call><name>B64</name><argument_list>(<argument><expr><name>charsleft</name> &lt;&lt; (6-<name>bitsleft</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>out</name> - <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SPECIAL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>B64</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>B64CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UB64</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ENCODE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DECODE</name></cpp:undef>

<comment type="block">/* --- UTF-8 Codec -------------------------------------------------------- */</comment>

<decl_stmt><decl><type><specifier>static</specifier>
<name>char</name></type> <name><name>utf8_code_length</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
    <comment type="block">/* Map UTF-8 encoded prefix byte to sequence length.  zero means
       illegal prefix.  see RFC 2279 for details */</comment>
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>,
    <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>,
    <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>,
    <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>6</expr>, <expr>6</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUTF8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
			       <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_DecodeUTF8Stateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUTF8Stateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
			                <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
			                <param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Note: size will always be longer than the resulting Unicode
       character count */</comment>
    <expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>consumed</name> = 0</expr>;</expr_stmt></then></if>
        <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Unpack UTF-8 encoded data */</comment>
    <expr_stmt><expr><name>p</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch</name> <init>= <expr>(<name>unsigned</name> <name>char</name>)*<name>s</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ch</name> &lt; 0x80</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>ch</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <expr_stmt><expr><name>n</name> = <name><name>utf8_code_length</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>s</name> + <name>n</name> &gt; <name>e</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
		<break>break;</break></then>
	    <else>else <block>{
		<expr_stmt><expr><name>errmsg</name> = "unexpected end of data"</expr>;</expr_stmt>
		<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>size</name></expr>;</expr_stmt>
		<goto>goto <name>utf8Error</name>;</goto>
	    }</block></else></if>
	}</block></then></if>

        <switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{

        <case>case <expr>0</expr>:
            <expr_stmt><expr><name>errmsg</name> = "unexpected code byte"</expr>;</expr_stmt>
	    <expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+1</expr>;</expr_stmt>
	    <goto>goto <name>utf8Error</name>;</goto>

        </case><case>case <expr>1</expr>:
            <expr_stmt><expr><name>errmsg</name> = "internal error"</expr>;</expr_stmt>
	    <expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+1</expr>;</expr_stmt>
	    <goto>goto <name>utf8Error</name>;</goto>

        </case><case>case <expr>2</expr>:
            <if>if <condition>(<expr>(<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0xc0) != 0x80</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>errmsg</name> = "invalid data"</expr>;</expr_stmt>
		<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+2</expr>;</expr_stmt>
		<goto>goto <name>utf8Error</name>;</goto>
	    }</block></then></if>
            <expr_stmt><expr><name>ch</name> = ((<name><name>s</name><index>[<expr>0</expr>]</index></name> &amp; 0x1f) &lt;&lt; 6) + (<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0x3f)</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ch</name> &lt; 0x80</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+2</expr>;</expr_stmt>
                <expr_stmt><expr><name>errmsg</name> = "illegal encoding"</expr>;</expr_stmt>
		<goto>goto <name>utf8Error</name>;</goto>
	    }</block></then>
	    <else>else
		<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>ch</name></expr>;</expr_stmt></else></if>
            <break>break;</break>

        </case><case>case <expr>3</expr>:
            <if>if <condition>(<expr>(<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0xc0) != 0x80 ||
                (<name><name>s</name><index>[<expr>2</expr>]</index></name> &amp; 0xc0) != 0x80</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>errmsg</name> = "invalid data"</expr>;</expr_stmt>
		<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+3</expr>;</expr_stmt>
		<goto>goto <name>utf8Error</name>;</goto>
	    }</block></then></if>
            <expr_stmt><expr><name>ch</name> = ((<name><name>s</name><index>[<expr>0</expr>]</index></name> &amp; 0x0f) &lt;&lt; 12) + ((<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0x3f) &lt;&lt; 6) + (<name><name>s</name><index>[<expr>2</expr>]</index></name> &amp; 0x3f)</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ch</name> &lt; 0x0800</expr>)</condition><then> <block>{
		<comment type="block">/* Note: UTF-8 encodings of surrogates are considered
		   legal UTF-8 sequences;

		   XXX For wide builds (UCS-4) we should probably try
		       to recombine the surrogates into a single code
		       unit.
		*/</comment>
                <expr_stmt><expr><name>errmsg</name> = "illegal encoding"</expr>;</expr_stmt>
		<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+3</expr>;</expr_stmt>
		<goto>goto <name>utf8Error</name>;</goto>
	    }</block></then>
	    <else>else
		<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>ch</name></expr>;</expr_stmt></else></if>
            <break>break;</break>

        </case><case>case <expr>4</expr>:
            <if>if <condition>(<expr>(<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0xc0) != 0x80 ||
                (<name><name>s</name><index>[<expr>2</expr>]</index></name> &amp; 0xc0) != 0x80 ||
                (<name><name>s</name><index>[<expr>3</expr>]</index></name> &amp; 0xc0) != 0x80</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>errmsg</name> = "invalid data"</expr>;</expr_stmt>
		<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+4</expr>;</expr_stmt>
		<goto>goto <name>utf8Error</name>;</goto>
	    }</block></then></if>
            <expr_stmt><expr><name>ch</name> = ((<name><name>s</name><index>[<expr>0</expr>]</index></name> &amp; 0x7) &lt;&lt; 18) + ((<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0x3f) &lt;&lt; 12) +
                 ((<name><name>s</name><index>[<expr>2</expr>]</index></name> &amp; 0x3f) &lt;&lt; 6) + (<name><name>s</name><index>[<expr>3</expr>]</index></name> &amp; 0x3f)</expr>;</expr_stmt>
            <comment type="block">/* validate and convert to UTF-16 */</comment>
            <if>if <condition>(<expr>(<name>ch</name> &lt; 0x10000)        <comment type="block">/* minimum value allowed for 4
					 byte encoding */</comment>
                || (<name>ch</name> &gt; 0x10ffff)</expr>)</condition><then>   <comment type="block">/* maximum value allowed for
					 UTF-16 */</comment>
	    <block>{
                <expr_stmt><expr><name>errmsg</name> = "illegal encoding"</expr>;</expr_stmt>
		<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+4</expr>;</expr_stmt>
		<goto>goto <name>utf8Error</name>;</goto>
	    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
	    <expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>ch</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="block">/*  compute and append the two surrogates: */</comment>

            <comment type="block">/*  translate from 10000..10FFFF to 0..FFFF */</comment>
            <expr_stmt><expr><name>ch</name> -= 0x10000</expr>;</expr_stmt>

            <comment type="block">/*  high surrogate = top 10 bits added to D800 */</comment>
            <expr_stmt><expr>*<name>p</name>++ = <call>(<name>Py_UNICODE</name>)<argument_list>(<argument><expr>0xD800 + (<name>ch</name> &gt;&gt; 10)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*  low surrogate = bottom 10 bits added to DC00 */</comment>
            <expr_stmt><expr>*<name>p</name>++ = <call>(<name>Py_UNICODE</name>)<argument_list>(<argument><expr>0xDC00 + (<name>ch</name> &amp; 0x03FF)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        </case><default>default:
            <comment type="block">/* Other sizes are only needed for UCS-4 */</comment>
            <expr_stmt><expr><name>errmsg</name> = "unsupported Unicode code range"</expr>;</expr_stmt>
	    <expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+<name>n</name></expr>;</expr_stmt>
	    <goto>goto <name>utf8Error</name>;</goto>
        </default>}</block></switch>
        <expr_stmt><expr><name>s</name> += <name>n</name></expr>;</expr_stmt>
	<continue>continue;</continue>

    <label><name>utf8Error</name>:</label>
    <expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
	     <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
	     <argument><expr>"utf8"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>,
	     <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
	     <argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    }</block></while>
    <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
	<expr_stmt><expr>*<name>consumed</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* Adjust length */</comment>
    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>unicode</name></expr></argument>, <argument><expr><name>p</name> - <name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>

<label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Allocation strategy:  if the string is short, convert into a stack buffer
   and allocate exactly as much space needed at the end.  Else allocate the
   maximum possible needed (4 result bytes per Unicode character), and return
   the excess memory at the end.
*/</comment>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_EncodeUTF8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
		     <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
		     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SHORT_UNICHARS</name></cpp:macro> <cpp:value>300</cpp:value></cpp:define>  <comment type="block">/* largest size we'll do on the stack */</comment>

    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>           <comment type="block">/* index into s of next input byte */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>        <comment type="block">/* result string object */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>            <comment type="block">/* next free byte in output buffer */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nallocated</name></decl>;</decl_stmt>  <comment type="block">/* number of result bytes allocated */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nneeded</name></decl>;</decl_stmt>        <comment type="block">/* number of result bytes needed */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>stackbuf</name><index>[<expr><name>MAX_SHORT_UNICHARS</name> * 4</expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>size</name> &lt;= <name>MAX_SHORT_UNICHARS</name></expr>)</condition><then> <block>{
        <comment type="block">/* Write into the stack buffer; nallocated can't overflow.
         * At the end, we'll allocate exactly as much heap space as it
         * turns out we need.
         */</comment>
        <expr_stmt><expr><name>nallocated</name> = <call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stackbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>   <comment type="block">/* will allocate after we're done */</comment>
        <expr_stmt><expr><name>p</name> = <name>stackbuf</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* Overallocate on the heap, and give the excess back at the end. */</comment>
        <expr_stmt><expr><name>nallocated</name> = <name>size</name> * 4</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nallocated</name> / 4 != <name>size</name></expr>)</condition><then>  <comment type="block">/* overflow! */</comment>
            <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
        <expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nallocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition><incr/>) <block>{
        <decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ch</name> &lt; 0x80</expr>)</condition><then>
            <comment type="block">/* Encode ASCII */</comment>
            <expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt></then>

        <else>else <if>if <condition>(<expr><name>ch</name> &lt; 0x0800</expr>)</condition><then> <block>{
            <comment type="block">/* Encode Latin-1 */</comment>
            <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0xc0 | (<name>ch</name> &gt;&gt; 6)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | (<name>ch</name> &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* Encode UCS2 Unicode ordinals */</comment>
            <if>if <condition>(<expr><name>ch</name> &lt; 0x10000</expr>)</condition><then> <block>{
                <comment type="block">/* Special case: check for high surrogate */</comment>
                <if>if <condition>(<expr>0xD800 &lt;= <name>ch</name> &amp;&amp; <name>ch</name> &lt;= 0xDBFF &amp;&amp; <name>i</name> != <name>size</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch2</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <comment type="block">/* Check for low surrogate and combine the two to
                       form a UCS4 value */</comment>
                    <if>if <condition>(<expr>0xDC00 &lt;= <name>ch2</name> &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>ch</name> = ((<name>ch</name> - 0xD800) &lt;&lt; 10 | (<name>ch2</name> - 0xDC00)) + 0x10000</expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
                        <goto>goto <name>encodeUCS4</name>;</goto>
                    }</block></then></if>
                    <comment type="block">/* Fall through: handles isolated high surrogates */</comment>
                }</block></then></if>
                <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0xe0 | (<name>ch</name> &gt;&gt; 12)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | ((<name>ch</name> &gt;&gt; 6) &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | (<name>ch</name> &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
    	    }</block></then></if>
<label><name>encodeUCS4</name>:</label>
            <comment type="block">/* Encode UCS4 Unicode ordinals */</comment>
            <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0xf0 | (<name>ch</name> &gt;&gt; 18)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | ((<name>ch</name> &gt;&gt; 12) &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | ((<name>ch</name> &gt;&gt; 6) &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | (<name>ch</name> &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></for>

    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* This was stack allocated. */</comment>
        <expr_stmt><expr><name>nneeded</name> = <name>p</name> - <name>stackbuf</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nneeded</name> &lt;= <name>nallocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>stackbuf</name></expr></argument>, <argument><expr><name>nneeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
    	<comment type="block">/* Cut back to size actually needed. */</comment>
        <expr_stmt><expr><name>nneeded</name> = <name>p</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nneeded</name> &lt;= <name>nallocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>nneeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>v</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX_SHORT_UNICHARS</name></cpp:undef>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsUTF8String</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_EncodeUTF8</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- UTF-32 Codec ------------------------------------------------------- */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_DecodeUTF32</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
		      <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
		      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
		      <param><decl><type><name>int</name> *</type><name>byteorder</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_DecodeUTF32Stateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>byteorder</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_DecodeUTF32Stateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
			      <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
			      <param><decl><type><name>int</name> *</type><name>byteorder</name></decl></param>,
			      <param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifndef>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pairs</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pairs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>q</name></decl>, *<decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* assume native ordering by default */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
    <comment type="block">/* Offsets from q for retrieving bytes in the right order. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BYTEORDER_IS_LITTLE_ENDIAN</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name><name>iorder</name><index>[]</index></name> <init>= <expr><block>{<expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name><name>iorder</name><index>[]</index></name> <init>= <expr><block>{<expr>3</expr>, <expr>2</expr>, <expr>1</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* On narrow builds we split characters outside the BMP into two
       codepoints =&gt; count how much extra space we need. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifndef>
    <for>for (<init><expr><name>i</name> = <name>pairs</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name>/4</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<if>if <condition>(<expr>((<name>Py_UCS4</name> *)<name>s</name>)<index>[<expr><name>i</name></expr>]</index> &gt;= 0x10000</expr>)</condition><then>
	    <expr_stmt><expr><name>pairs</name>++</expr>;</expr_stmt></then></if></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* This might be one to much, because of a BOM */</comment>
    <expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>(<name>size</name>+3)/4+<name>pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
        <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return></then></if>

    <comment type="block">/* Unpack UTF-32 encoded data */</comment>
    <expr_stmt><expr><name>p</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>q</name> = (<name>unsigned</name> <name>char</name> *)<name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> = <name>q</name> + <name>size</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>byteorder</name></expr>)</condition><then>
        <expr_stmt><expr><name>bo</name> = *<name>byteorder</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* Check for BOM marks (U+FEFF) in the input and adjust current
       byte order setting accordingly. In native mode, the leading BOM
       mark is skipped, in all other modes, it is copied to the output
       stream as-is (giving a ZWNBSP character). */</comment>
    <if>if <condition>(<expr><name>bo</name> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>size</name> &gt;= 4</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UCS4</name></type> <name>bom</name> <init>= <expr>(<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name></expr>]</index></name> &lt;&lt; 24) | (<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name></expr>]</index></name> &lt;&lt; 16) |
                                (<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BYTEORDER_IS_LITTLE_ENDIAN</name></cpp:ifdef>
	    <if>if <condition>(<expr><name>bom</name> == 0x0000FEFF</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
		<expr_stmt><expr><name>bo</name> = -1</expr>;</expr_stmt>
	    }</block></then>
	    <else>else <if>if <condition>(<expr><name>bom</name> == 0xFFFE0000</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
		<expr_stmt><expr><name>bo</name> = 1</expr>;</expr_stmt>
	    }</block></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <if>if <condition>(<expr><name>bom</name> == 0x0000FEFF</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
		<expr_stmt><expr><name>bo</name> = 1</expr>;</expr_stmt>
	    }</block></then>
	    <else>else <if>if <condition>(<expr><name>bom</name> == 0xFFFE0000</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
		<expr_stmt><expr><name>bo</name> = -1</expr>;</expr_stmt>
	    }</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>bo</name> == -1</expr>)</condition><then> <block>{
        <comment type="block">/* force LE */</comment>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name> = 2</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name> = 3</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>bo</name> == 1</expr>)</condition><then> <block>{
        <comment type="block">/* force BE */</comment>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name> = 3</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name> = 2</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <while>while <condition>(<expr><name>q</name> &lt; <name>e</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch</name></decl>;</decl_stmt>
	<comment type="block">/* remaining bytes at the end? (size should be divisible by 4) */</comment>
	<if>if <condition>(<expr><name>e</name>-<name>q</name>&lt;4</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr><name>errmsg</name> = "truncated data"</expr>;</expr_stmt>
	    <expr_stmt><expr><name>startinpos</name> = ((const <name>char</name> *)<name>q</name>)-<name>starts</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>endinpos</name> = ((const <name>char</name> *)<name>e</name>)-<name>starts</name></expr>;</expr_stmt>
	    <goto>goto <name>utf32Error</name>;</goto>
	    <comment type="block">/* The remaining input chars are ignored if the callback
	       chooses to skip the input */</comment>
	}</block></then></if>
	<expr_stmt><expr><name>ch</name> = (<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name></expr>]</index></name> &lt;&lt; 24) | (<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name></expr>]</index></name> &lt;&lt; 16) |
	     (<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>ch</name> &gt;= 0x110000</expr>)</condition><then>
	<block>{
	    <expr_stmt><expr><name>errmsg</name> = "codepoint not in range(0x110000)"</expr>;</expr_stmt>
	    <expr_stmt><expr><name>startinpos</name> = ((const <name>char</name> *)<name>q</name>)-<name>starts</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+4</expr>;</expr_stmt>
	    <goto>goto <name>utf32Error</name>;</goto>
	}</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifndef>
	<if>if <condition>(<expr><name>ch</name> &gt;= 0x10000</expr>)</condition><then>
	<block>{
	    <expr_stmt><expr>*<name>p</name>++ = 0xD800 | ((<name>ch</name>-0x10000) &gt;&gt; 10)</expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>p</name>++ = 0xDC00 | ((<name>ch</name>-0x10000) &amp; 0x3FF)</expr>;</expr_stmt>
	}</block></then>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
	<continue>continue;</continue>
    <label><name>utf32Error</name>:</label>
	<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
         <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
         <argument><expr>"utf32"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>,
         <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
         <argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
    }</block></while>

    <if>if <condition>(<expr><name>byteorder</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>byteorder</name> = <name>bo</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
	<expr_stmt><expr>*<name>consumed</name> = (const <name>char</name> *)<name>q</name>-<name>starts</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* Adjust length */</comment>
    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>unicode</name></expr></argument>, <argument><expr><name>p</name> - <name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>

<label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_EncodeUTF32</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
		      <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
		      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
		      <param><decl><type><name>int</name></type> <name>byteorder</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nsize</name></decl>, <decl><type ref="prev"/><name>bytesize</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifndef>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pairs</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pairs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Offsets from p for storing byte pairs in the right order. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BYTEORDER_IS_LITTLE_ENDIAN</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name><name>iorder</name><index>[]</index></name> <init>= <expr><block>{<expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name><name>iorder</name><index>[]</index></name> <init>= <expr><block>{<expr>3</expr>, <expr>2</expr>, <expr>1</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORECHAR</name><parameter_list>(<param><type><name>CH</name></type></param>)</parameter_list></cpp:macro>                       \
    <cpp:value>do {                                    \
        p[iorder[3]] = ((CH) &gt;&gt; 24) &amp; 0xff; \
        p[iorder[2]] = ((CH) &gt;&gt; 16) &amp; 0xff; \
        p[iorder[1]] = ((CH) &gt;&gt; 8) &amp; 0xff;  \
        p[iorder[0]] = (CH) &amp; 0xff;         \
        p += 4;                             \
    } while(0)</cpp:value></cpp:define>

    <comment type="block">/* In narrow builds we can output surrogate pairs as one codepoint,
       so we need less space. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifndef>
    <for>for (<init><expr><name>i</name> = <name>pairs</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name>-1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<if>if <condition>(<expr>0xD800 &lt;= <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &lt;= 0xDBFF &amp;&amp;
	    0xDC00 &lt;= <name><name>s</name><index>[<expr><name>i</name>+1</expr>]</index></name> &amp;&amp; <name><name>s</name><index>[<expr><name>i</name>+1</expr>]</index></name> &lt;= 0xDFFF</expr>)</condition><then>
	    <expr_stmt><expr><name>pairs</name>++</expr>;</expr_stmt></then></if></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>nsize</name> = (<name>size</name> - <name>pairs</name> + (<name>byteorder</name> == 0))</expr>;</expr_stmt>
    <expr_stmt><expr><name>bytesize</name> = <name>nsize</name> * 4</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>bytesize</name> / 4 != <name>nsize</name></expr>)</condition><then>
	<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bytesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>byteorder</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr>0xFEFF</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
        <return>return <expr><name>v</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>byteorder</name> == -1</expr>)</condition><then> <block>{
        <comment type="block">/* force LE */</comment>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name> = 2</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name> = 3</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>byteorder</name> == 1</expr>)</condition><then> <block>{
        <comment type="block">/* force BE */</comment>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name> = 3</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name> = 2</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
	<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch</name> <init>= <expr>*<name>s</name>++</expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifndef>
	<if>if <condition>(<expr>0xD800 &lt;= <name>ch</name> &amp;&amp; <name>ch</name> &lt;= 0xDBFF &amp;&amp; <name>size</name> &gt; 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch2</name> <init>= <expr>*<name>s</name></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr>0xDC00 &lt;= <name>ch2</name> &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ch</name> = (((<name>ch</name> &amp; 0x3FF)&lt;&lt;10) | (<name>ch2</name> &amp; 0x3FF)) + 0x10000</expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>v</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STORECHAR</name></cpp:undef>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsUTF32String</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_EncodeUTF32</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- UTF-16 Codec ------------------------------------------------------- */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_DecodeUTF16</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
		      <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
		      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
		      <param><decl><type><name>int</name> *</type><name>byteorder</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_DecodeUTF16Stateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>byteorder</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_DecodeUTF16Stateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
			      <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
			      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
			      <param><decl><type><name>int</name> *</type><name>byteorder</name></decl></param>,
			      <param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>q</name></decl>, *<decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* assume native ordering by default */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
    <comment type="block">/* Offsets from q for retrieving byte pairs in the right order. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BYTEORDER_IS_LITTLE_ENDIAN</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>ihi</name> <init>= <expr>1</expr></init>, <name>ilo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>ihi</name> <init>= <expr>0</expr></init>, <name>ilo</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Note: size will always be longer than the resulting Unicode
       character count */</comment>
    <expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
        <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return></then></if>

    <comment type="block">/* Unpack UTF-16 encoded data */</comment>
    <expr_stmt><expr><name>p</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>q</name> = (<name>unsigned</name> <name>char</name> *)<name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> = <name>q</name> + <name>size</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>byteorder</name></expr>)</condition><then>
        <expr_stmt><expr><name>bo</name> = *<name>byteorder</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* Check for BOM marks (U+FEFF) in the input and adjust current
       byte order setting accordingly. In native mode, the leading BOM
       mark is skipped, in all other modes, it is copied to the output
       stream as-is (giving a ZWNBSP character). */</comment>
    <if>if <condition>(<expr><name>bo</name> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>size</name> &gt;= 2</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name></type> <name>bom</name> <init>= <expr>(<name><name>q</name><index>[<expr><name>ihi</name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name>ilo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BYTEORDER_IS_LITTLE_ENDIAN</name></cpp:ifdef>
	    <if>if <condition>(<expr><name>bom</name> == 0xFEFF</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>bo</name> = -1</expr>;</expr_stmt>
	    }</block></then>
	    <else>else <if>if <condition>(<expr><name>bom</name> == 0xFFFE</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>bo</name> = 1</expr>;</expr_stmt>
	    }</block></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <if>if <condition>(<expr><name>bom</name> == 0xFEFF</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>bo</name> = 1</expr>;</expr_stmt>
	    }</block></then>
	    <else>else <if>if <condition>(<expr><name>bom</name> == 0xFFFE</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>bo</name> = -1</expr>;</expr_stmt>
	    }</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>bo</name> == -1</expr>)</condition><then> <block>{
        <comment type="block">/* force LE */</comment>
        <expr_stmt><expr><name>ihi</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>ilo</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>bo</name> == 1</expr>)</condition><then> <block>{
        <comment type="block">/* force BE */</comment>
        <expr_stmt><expr><name>ihi</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>ilo</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <while>while <condition>(<expr><name>q</name> &lt; <name>e</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name></decl>;</decl_stmt>
	<comment type="block">/* remaining bytes at the end? (size should be even) */</comment>
	<if>if <condition>(<expr><name>e</name>-<name>q</name>&lt;2</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr><name>errmsg</name> = "truncated data"</expr>;</expr_stmt>
	    <expr_stmt><expr><name>startinpos</name> = ((const <name>char</name> *)<name>q</name>)-<name>starts</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>endinpos</name> = ((const <name>char</name> *)<name>e</name>)-<name>starts</name></expr>;</expr_stmt>
	    <goto>goto <name>utf16Error</name>;</goto>
	    <comment type="block">/* The remaining input chars are ignored if the callback
	       chooses to skip the input */</comment>
	}</block></then></if>
	<expr_stmt><expr><name>ch</name> = (<name><name>q</name><index>[<expr><name>ihi</name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name>ilo</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>

	<if>if <condition>(<expr><name>ch</name> &lt; 0xD800 || <name>ch</name> &gt; 0xDFFF</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if>

	<comment type="block">/* UTF-16 code pair: */</comment>
	<if>if <condition>(<expr><name>q</name> &gt;= <name>e</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>errmsg</name> = "unexpected end of data"</expr>;</expr_stmt>
	    <expr_stmt><expr><name>startinpos</name> = (((const <name>char</name> *)<name>q</name>)-2)-<name>starts</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>endinpos</name> = ((const <name>char</name> *)<name>e</name>)-<name>starts</name></expr>;</expr_stmt>
	    <goto>goto <name>utf16Error</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr>0xD800 &lt;= <name>ch</name> &amp;&amp; <name>ch</name> &lt;= 0xDBFF</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name> <init>= <expr>(<name><name>q</name><index>[<expr><name>ihi</name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name>ilo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
	    <if>if <condition>(<expr>0xDC00 &lt;= <name>ch2</name> &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifndef>
		<expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name>ch2</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr>*<name>p</name>++ = (((<name>ch</name> &amp; 0x3FF)&lt;&lt;10) | (<name>ch2</name> &amp; 0x3FF)) + 0x10000</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<continue>continue;</continue>
	    }</block></then>
	    <else>else <block>{
                <expr_stmt><expr><name>errmsg</name> = "illegal UTF-16 surrogate"</expr>;</expr_stmt>
		<expr_stmt><expr><name>startinpos</name> = (((const <name>char</name> *)<name>q</name>)-4)-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+2</expr>;</expr_stmt>
		<goto>goto <name>utf16Error</name>;</goto>
	    }</block></else></if>

	}</block></then></if>
	<expr_stmt><expr><name>errmsg</name> = "illegal encoding"</expr>;</expr_stmt>
	<expr_stmt><expr><name>startinpos</name> = (((const <name>char</name> *)<name>q</name>)-2)-<name>starts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+2</expr>;</expr_stmt>
	<comment type="block">/* Fall through to report the error */</comment>

    <label><name>utf16Error</name>:</label>
	<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
	         <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
	         <argument><expr>"utf16"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>,
	         <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>(const <name>char</name> **)&amp;<name>q</name></expr></argument>,
	         <argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
    }</block></while>

    <if>if <condition>(<expr><name>byteorder</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>byteorder</name> = <name>bo</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
	<expr_stmt><expr>*<name>consumed</name> = (const <name>char</name> *)<name>q</name>-<name>starts</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* Adjust length */</comment>
    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>unicode</name></expr></argument>, <argument><expr><name>p</name> - <name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>

<label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_EncodeUTF16</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
		      <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
		      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
		      <param><decl><type><name>int</name></type> <name>byteorder</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nsize</name></decl>, <decl><type ref="prev"/><name>bytesize</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pairs</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pairs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Offsets from p for storing byte pairs in the right order. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BYTEORDER_IS_LITTLE_ENDIAN</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>ihi</name> <init>= <expr>1</expr></init>, <name>ilo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>ihi</name> <init>= <expr>0</expr></init>, <name>ilo</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORECHAR</name><parameter_list>(<param><type><name>CH</name></type></param>)</parameter_list></cpp:macro>                   \
    <cpp:value>do {                                \
        p[ihi] = ((CH) &gt;&gt; 8) &amp; 0xff;    \
        p[ilo] = (CH) &amp; 0xff;           \
        p += 2;                         \
    } while(0)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
    <for>for (<init><expr><name>i</name> = <name>pairs</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &gt;= 0x10000</expr>)</condition><then>
	    <expr_stmt><expr><name>pairs</name>++</expr>;</expr_stmt></then></if></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* 2 * (size + pairs + (byteorder == 0)) */</comment>
    <if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> ||
        <name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>pairs</name> - (<name>byteorder</name> == 0)</expr>)</condition><then>
	<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><name>nsize</name> = <name>size</name> + <name>pairs</name> + (<name>byteorder</name> == 0)</expr>;</expr_stmt>
    <expr_stmt><expr><name>bytesize</name> = <name>nsize</name> * 2</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>bytesize</name> / 2 != <name>nsize</name></expr>)</condition><then>
	<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bytesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>byteorder</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr>0xFEFF</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
        <return>return <expr><name>v</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>byteorder</name> == -1</expr>)</condition><then> <block>{
        <comment type="block">/* force LE */</comment>
        <expr_stmt><expr><name>ihi</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>ilo</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>byteorder</name> == 1</expr>)</condition><then> <block>{
        <comment type="block">/* force BE */</comment>
        <expr_stmt><expr><name>ihi</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>ilo</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
	<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>s</name>++</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
	<if>if <condition>(<expr><name>ch</name> &gt;= 0x10000</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>ch2</name> = 0xDC00 | ((<name>ch</name>-0x10000) &amp; 0x3FF)</expr>;</expr_stmt>
	    <expr_stmt><expr><name>ch</name>  = 0xD800 | ((<name>ch</name>-0x10000) &gt;&gt; 10)</expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ch2</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr><name>ch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></while>
    <return>return <expr><name>v</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STORECHAR</name></cpp:undef>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsUTF16String</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_EncodeUTF16</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- Unicode Escape Codec ----------------------------------------------- */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>_PyUnicode_Name_CAPI</name> *</type><name>ucnhash_CAPI</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUnicodeEscape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
					<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
					<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>message</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UCS4</name></type> <name>chr</name> <init>= <expr>0xffffffff</expr></init></decl>;</decl_stmt> <comment type="block">/* in case 'getcode' messes up */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Escaped strings will always be longer than the resulting
       Unicode string, so we start with size here and then reduce the
       length after conversion to the true value.
       (but if the error callback returns a long replacement string
       we'll have to allocate more space) */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
        <return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>

    <expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>s</name> &lt; <name>end</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>x</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>digits</name></decl>;</decl_stmt>

        <comment type="block">/* Non-escape characters are interpreted as Unicode ordinals */</comment>
        <if>if <condition>(<expr>*<name>s</name> != '\\'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>) *<name>s</name>++</expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
        <comment type="block">/* \ - Escapes */</comment>
        <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = *<name>s</name>++</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>s</name> &gt; <name>end</name></expr>)</condition><then>
            <expr_stmt><expr><name>c</name> = '\0'</expr>;</expr_stmt></then></if> <comment type="block">/* Invalid after \ */</comment>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{

        <comment type="block">/* \x escapes */</comment>
        <case>case <expr>'\n'</expr>: <break>break;</break>
        </case><case>case <expr>'\\'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr>'\''</expr>: <expr_stmt><expr>*<name>p</name>++ = '\''</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr>'\"'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\"'</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr>'b'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\b'</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr>'f'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\014'</expr>;</expr_stmt> <break>break;</break> <comment type="block">/* FF */</comment>
        </case><case>case <expr>'t'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\t'</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr>'n'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\n'</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr>'r'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\r'</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr>'v'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\013'</expr>;</expr_stmt> <break>break;</break> <comment type="block">/* VT */</comment>
        </case><case>case <expr>'a'</expr>: <expr_stmt><expr>*<name>p</name>++ = '\007'</expr>;</expr_stmt> <break>break;</break> <comment type="block">/* BEL, not classic C */</comment>

        <comment type="block">/* \OOO (octal) escapes */</comment>
        </case><case>case <expr>'0'</expr>: </case><case>case <expr>'1'</expr>: </case><case>case <expr>'2'</expr>: </case><case>case <expr>'3'</expr>:
        </case><case>case <expr>'4'</expr>: </case><case>case <expr>'5'</expr>: </case><case>case <expr>'6'</expr>: </case><case>case <expr>'7'</expr>:
            <expr_stmt><expr><name>x</name> = <name><name>s</name><index>[<expr>-1</expr>]</index></name> - '0'</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>s</name> &lt; <name>end</name> &amp;&amp; '0' &lt;= *<name>s</name> &amp;&amp; *<name>s</name> &lt;= '7'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;3) + *<name>s</name>++ - '0'</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>s</name> &lt; <name>end</name> &amp;&amp; '0' &lt;= *<name>s</name> &amp;&amp; *<name>s</name> &lt;= '7'</expr>)</condition><then>
                    <expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;3) + *<name>s</name>++ - '0'</expr>;</expr_stmt></then></if>
            }</block></then></if>
            <expr_stmt><expr>*<name>p</name>++ = <name>x</name></expr>;</expr_stmt>
            <break>break;</break>

        <comment type="block">/* hex escapes */</comment>
        <comment type="block">/* \xXX */</comment>
        </case><case>case <expr>'x'</expr>:
            <expr_stmt><expr><name>digits</name> = 2</expr>;</expr_stmt>
            <expr_stmt><expr><name>message</name> = "truncated \\xXX escape"</expr>;</expr_stmt>
            <goto>goto <name>hexescape</name>;</goto>

        <comment type="block">/* \uXXXX */</comment>
        </case><case>case <expr>'u'</expr>:
            <expr_stmt><expr><name>digits</name> = 4</expr>;</expr_stmt>
            <expr_stmt><expr><name>message</name> = "truncated \\uXXXX escape"</expr>;</expr_stmt>
            <goto>goto <name>hexescape</name>;</goto>

        <comment type="block">/* \UXXXXXXXX */</comment>
        </case><case>case <expr>'U'</expr>:
            <expr_stmt><expr><name>digits</name> = 8</expr>;</expr_stmt>
            <expr_stmt><expr><name>message</name> = "truncated \\UXXXXXXXX escape"</expr>;</expr_stmt>
        <label><name>hexescape</name>:</label>
            <expr_stmt><expr><name>chr</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>s</name>+<name>digits</name>&gt;<name>end</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>endinpos</name> = <name>size</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
                    <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
                    <argument><expr>"unicodeescape"</expr></argument>, <argument><expr>"end of string in escape sequence"</expr></argument>,
                    <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
                    <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>onError</name>;</goto></then></if>
                <goto>goto <name>nextByte</name>;</goto>
            }</block></then></if>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>digits</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name>) <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>endinpos</name> = (<name>s</name>+<name>i</name>+1)-<name>starts</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
                        <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
                        <argument><expr>"unicodeescape"</expr></argument>, <argument><expr><name>message</name></expr></argument>,
                        <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
                        <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <goto>goto <name>onError</name>;</goto></then></if>
                    <goto>goto <name>nextByte</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr><name>chr</name> = (<name>chr</name>&lt;&lt;4) &amp; ~0xF</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then>
                    <expr_stmt><expr><name>chr</name> += <name>c</name> - '0'</expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>c</name> &gt;= 'a' &amp;&amp; <name>c</name> &lt;= 'f'</expr>)</condition><then>
                    <expr_stmt><expr><name>chr</name> += 10 + <name>c</name> - 'a'</expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><name>chr</name> += 10 + <name>c</name> - 'A'</expr>;</expr_stmt></else></if></else></if>
            }</block></for>
            <expr_stmt><expr><name>s</name> += <name>i</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>chr</name> == 0xffffffff &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
                <comment type="block">/* _decoding_error will have already written into the
                   target buffer. */</comment>
                <break>break;</break></then></if>
        <label><name>store</name>:</label>
            <comment type="block">/* when we get here, chr is a 32-bit unicode character */</comment>
            <if>if <condition>(<expr><name>chr</name> &lt;= 0xffff</expr>)</condition><then>
                <comment type="block">/* UCS-2 character */</comment>
                <expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>) <name>chr</name></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>chr</name> &lt;= 0x10ffff</expr>)</condition><then> <block>{
                <comment type="block">/* UCS-4 character. Either store directly, or as
                   surrogate pair. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
                <expr_stmt><expr>*<name>p</name>++ = <name>chr</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><name>chr</name> -= 0x10000L</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name>++ = 0xD800 + <call>(<name>Py_UNICODE</name>) <argument_list>(<argument><expr><name>chr</name> &gt;&gt; 10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name>++ = 0xDC00 + <call>(<name>Py_UNICODE</name>) <argument_list>(<argument><expr><name>chr</name> &amp; 0x03FF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
                    <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
                    <argument><expr>"unicodeescape"</expr></argument>, <argument><expr>"illegal Unicode character"</expr></argument>,
                    <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
                    <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>onError</name>;</goto></then></if>
            }</block></else></if></else></if>
            <break>break;</break>

        <comment type="block">/* \N{name} */</comment>
        </case><case>case <expr>'N'</expr>:
            <expr_stmt><expr><name>message</name> = "malformed \\N character escape"</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ucnhash_CAPI</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <comment type="block">/* load the unicode data module */</comment>
                <decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>api</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>m</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"unicodedata"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
                    <goto>goto <name>ucnhashError</name>;</goto></then></if>
                <expr_stmt><expr><name>api</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"ucnhash_CAPI"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>api</name> == <name>NULL</name></expr>)</condition><then>
                    <goto>goto <name>ucnhashError</name>;</goto></then></if>
                <expr_stmt><expr><name>ucnhash_CAPI</name> = (<name>_PyUnicode_Name_CAPI</name> *)<call><name>PyCObject_AsVoidPtr</name><argument_list>(<argument><expr><name>api</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>api</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>ucnhash_CAPI</name> == <name>NULL</name></expr>)</condition><then>
                    <goto>goto <name>ucnhashError</name>;</goto></then></if>
            }</block></then></if>
            <if>if <condition>(<expr>*<name>s</name> == '{'</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name> <init>= <expr><name>s</name>+1</expr></init></decl>;</decl_stmt>
                <comment type="block">/* look for the closing brace */</comment>
                <while>while <condition>(<expr>*<name>s</name> != '}' &amp;&amp; <name>s</name> &lt; <name>end</name></expr>)</condition>
                    <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
                <if>if <condition>(<expr><name>s</name> &gt; <name>start</name> &amp;&amp; <name>s</name> &lt; <name>end</name> &amp;&amp; *<name>s</name> == '}'</expr>)</condition><then> <block>{
                    <comment type="block">/* found a name.  look it up in the unicode database */</comment>
                    <expr_stmt><expr><name>message</name> = "unknown Unicode character name"</expr>;</expr_stmt>
                    <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name><name>ucnhash_CAPI</name>-&gt;<name>getcode</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>s</name>-<name>start</name>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>chr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <goto>goto <name>store</name>;</goto></then></if>
                }</block></then></if>
            }</block></then></if>
            <expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
                <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
                <argument><expr>"unicodeescape"</expr></argument>, <argument><expr><name>message</name></expr></argument>,
                <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
                <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>onError</name>;</goto></then></if>
            <break>break;</break>

        </case><default>default:
            <if>if <condition>(<expr><name>s</name> &gt; <name>end</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>message</name> = "\\ at end of string"</expr>;</expr_stmt>
                <expr_stmt><expr><name>s</name>--</expr>;</expr_stmt>
                <expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
                    <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
                    <argument><expr>"unicodeescape"</expr></argument>, <argument><expr><name>message</name></expr></argument>,
                    <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
                    <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>onError</name>;</goto></then></if>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>)<name><name>s</name><index>[<expr>-1</expr>]</index></name></expr>;</expr_stmt>
            }</block></else></if>
            <break>break;</break>
        </default>}</block></switch>
        <label><name>nextByte</name>:</label>
        <empty_stmt>;</empty_stmt>
    }</block></while>
    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>

<label><name>ucnhashError</name>:</label>
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
        <argument><expr><name>PyExc_UnicodeError</name></expr></argument>,
        <argument><expr>"\\N escapes not supported (can't load unicodedata module)"</expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>

<label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Return a Unicode-Escape string version of the Unicode object.

   If quotes is true, the string is enclosed in u"" or u'' quotes as
   appropriate.

*/</comment>

<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>const Py_UNICODE *</argument>)</argument_list></macro> <macro><name>findchar</name><argument_list>(<argument>const Py_UNICODE *s</argument>,
                                      <argument>Py_ssize_t size</argument>,
                                      <argument>Py_UNICODE ch</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* like wcschr, but doesn't stop at NULL characters */</comment>

    <while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
        <if>if <condition>(<expr>*<name>s</name> == <name>ch</name></expr>)</condition><then>
            <return>return <expr><name>s</name></expr>;</return></then></if>
        <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>unicodeescape_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
                               <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
                               <param><decl><type><name>int</name></type> <name>quotes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>repr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>hexdigit</name> <init>= <expr>"0123456789abcdef"</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>expandsize</name> <init>= <expr>10</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>expandsize</name> <init>= <expr>6</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* XXX(nnorwitz): rather than over-allocating, it would be
       better to choose a different scheme.  Perhaps scan the
       first N-chars of the string and allocate based on that size.
    */</comment>
    <comment type="block">/* Initial allocation is based on the longest-possible unichr
       escape.

       In wide (UTF-32) builds '\U00xxxxxx' is 10 chars per source
       unichr, so in this case it's the longest unichr escape. In
       narrow (UTF-16) builds this is five chars per source unichr
       since there are two unichrs in the surrogate pair, so in narrow
       (UTF-16) builds it's not the longest unichr escape.

       In wide or narrow builds '\uxxxx' is 6 chars per source unichr,
       so in the narrow (UTF-16) build case it's the longest unichr
       escape.
    */</comment>

    <if>if <condition>(<expr><name>size</name> &gt; (<name>PY_SSIZE_T_MAX</name> - 2 - 1) / <name>expandsize</name></expr>)</condition><then>
	<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>repr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
        <argument><expr>2
        + <name>expandsize</name>*<name>size</name>
        + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>repr</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>quotes</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>p</name>++ = 'u'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>p</name>++ = (<call><name>findchar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>'\''</expr></argument>)</argument_list></call> &amp;&amp;
                !<call><name>findchar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call>) ? '"' : '\''</expr>;</expr_stmt>
    }</block></then></if>
    <while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>s</name>++</expr></init></decl>;</decl_stmt>

        <comment type="block">/* Escape quotes and backslashes */</comment>
        <if>if <condition>(<expr>(<name>quotes</name> &amp;&amp;
	     <name>ch</name> == (<name>Py_UNICODE</name>) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call><index>[<expr>1</expr>]</index>) || <name>ch</name> == '\\'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt>
	    <continue>continue;</continue>
        }</block></then>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
        <comment type="block">/* Map 21-bit characters to '\U00xxxxxx' */</comment>
        <else>else <if>if <condition>(<expr><name>ch</name> &gt;= 0x10000</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = 'U'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 28) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 24) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 20) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 16) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 12) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 8) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
	    <continue>continue;</continue>
        }</block></then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Map UTF-16 surrogate pairs to '\U00xxxxxx' */</comment>
	<else>else <if>if <condition>(<expr><name>ch</name> &gt;= 0xD800 &amp;&amp; <name>ch</name> &lt; 0xDC00</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ucs</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>ch2</name> = *<name>s</name>++</expr>;</expr_stmt>
	    <expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>ch2</name> &gt;= 0xDC00 &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ucs</name> = (((<name>ch</name> &amp; 0x03FF) &lt;&lt; 10) | (<name>ch2</name> &amp; 0x03FF)) + 0x00010000</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = 'U'</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 28) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 24) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 20) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 16) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 12) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 8) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 4) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ucs</name> &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
		<continue>continue;</continue>
	    }</block></then></if>
	    <comment type="block">/* Fall through: isolated surrogates are copied as-is */</comment>
	    <expr_stmt><expr><name>s</name>--</expr>;</expr_stmt>
	    <expr_stmt><expr><name>size</name>++</expr>;</expr_stmt>
	}</block></then></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Map 16-bit characters to '\uxxxx' */</comment>
        <if>if <condition>(<expr><name>ch</name> &gt;= 256</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = 'u'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 12) &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 8) &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
        }</block></then>

        <comment type="block">/* Map special whitespace to '\t', \n', '\r' */</comment>
        <else>else <if>if <condition>(<expr><name>ch</name> == '\t'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = 't'</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>ch</name> == '\n'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = 'n'</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>ch</name> == '\r'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = 'r'</expr>;</expr_stmt>
        }</block></then>

        <comment type="block">/* Map non-printable US ASCII to '\xhh' */</comment>
        <else>else <if>if <condition>(<expr><name>ch</name> &lt; ' ' || <name>ch</name> &gt;= 0x7F</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = 'x'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
        }</block></then>

        <comment type="block">/* Copy everything else as-is */</comment>
        <else>else
            <expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if>
    }</block></while>
    <if>if <condition>(<expr><name>quotes</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>p</name>++ = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call><index>[<expr>1</expr>]</index></expr>;</expr_stmt></then></if>

    <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>repr</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeUnicodeEscape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
					<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>unicodeescape_string</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsUnicodeEscapeString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_EncodeUnicodeEscape</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- Raw Unicode Escape Codec ------------------------------------------- */</comment>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeRawUnicodeEscape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
					   <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
					   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Escaped strings will always be longer than the resulting
       Unicode string, so we start with size here and then reduce the
       length after conversion to the true value. (But decoding error
       handler might have to resize the string) */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
    <expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>s</name> &lt; <name>end</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

	<comment type="block">/* Non-escape characters are interpreted as Unicode ordinals */</comment>
	<if>if <condition>(<expr>*<name>s</name> != '\\'</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>)*<name>s</name>++</expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if>
	<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>

	<comment type="block">/* \u-escapes are only interpreted iff the number of leading
	   backslashes if odd */</comment>
	<expr_stmt><expr><name>bs</name> = <name>s</name></expr>;</expr_stmt>
	<for>for (<init>;</init><condition><expr><name>s</name> &lt; <name>end</name></expr>;</condition><incr/>) <block>{
	    <if>if <condition>(<expr>*<name>s</name> != '\\'</expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>)*<name>s</name>++</expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr>((<name>s</name> - <name>bs</name>) &amp; 1) == 0 ||
	    <name>s</name> &gt;= <name>end</name> ||
	    (*<name>s</name> != 'u' &amp;&amp; *<name>s</name> != 'U')</expr>)</condition><then> <block>{
	    <continue>continue;</continue>
	}</block></then></if>
	<expr_stmt><expr><name>p</name>--</expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> = *<name>s</name>=='u' ? 4 : 8</expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>

	<comment type="block">/* \uXXXX with 4 hex digits, \Uxxxxxxxx with 8 */</comment>
	<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>x</name> = 0</expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr>++<name>s</name></expr></incr>) <block>{
	    <expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name>)*<name>s</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
		    <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
		    <argument><expr>"rawunicodeescape"</expr></argument>, <argument><expr>"truncated \\uXXXX"</expr></argument>,
		    <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
		    <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
		<goto>goto <name>nextByte</name>;</goto>
	    }</block></then></if>
	    <expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;4) &amp; ~0xF</expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then>
		<expr_stmt><expr><name>x</name> += <name>c</name> - '0'</expr>;</expr_stmt></then>
	    <else>else <if>if <condition>(<expr><name>c</name> &gt;= 'a' &amp;&amp; <name>c</name> &lt;= 'f'</expr>)</condition><then>
		<expr_stmt><expr><name>x</name> += 10 + <name>c</name> - 'a'</expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><name>x</name> += 10 + <name>c</name> - 'A'</expr>;</expr_stmt></else></if></else></if>
	}</block></for>
        <if>if <condition>(<expr><name>x</name> &lt;= 0xffff</expr>)</condition><then>
                <comment type="block">/* UCS-2 character */</comment>
                <expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>) <name>x</name></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>x</name> &lt;= 0x10ffff</expr>)</condition><then> <block>{
                <comment type="block">/* UCS-4 character. Either store directly, or as
                   surrogate pair. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
                <expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>) <name>x</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><name>x</name> -= 0x10000L</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name>++ = 0xD800 + <call>(<name>Py_UNICODE</name>) <argument_list>(<argument><expr><name>x</name> &gt;&gt; 10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name>++ = 0xDC00 + <call>(<name>Py_UNICODE</name>) <argument_list>(<argument><expr><name>x</name> &amp; 0x03FF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
                    <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
                    <argument><expr>"rawunicodeescape"</expr></argument>, <argument><expr>"\\Uxxxxxxxx out of range"</expr></argument>,
		    <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
		    <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
        }</block></else></if></else></if>
	<label><name>nextByte</name>:</label>
	<empty_stmt>;</empty_stmt>
    }</block></while>
    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeRawUnicodeEscape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
					   <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>repr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>q</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>hexdigit</name> <init>= <expr>"0123456789abcdef"</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>expandsize</name> <init>= <expr>10</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>expandsize</name> <init>= <expr>6</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> / <name>expandsize</name></expr>)</condition><then>
	<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
    
    <expr_stmt><expr><name>repr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>expandsize</name> * <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>repr</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
	<return>return <expr><name>repr</name></expr>;</return></then></if>

    <expr_stmt><expr><name>p</name> = <name>q</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>s</name>++</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
	<comment type="block">/* Map 32-bit characters to '\Uxxxxxxxx' */</comment>
	<if>if <condition>(<expr><name>ch</name> &gt;= 0x10000</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = 'U'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 28) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 24) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 20) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 16) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 12) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 8) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 15</expr>]</index></name></expr>;</expr_stmt>
        }</block></then>
        <else>else
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Map UTF-16 surrogate pairs to '\U00xxxxxx' */</comment>
	<if>if <condition>(<expr><name>ch</name> &gt;= 0xD800 &amp;&amp; <name>ch</name> &lt; 0xDC00</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ucs</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>ch2</name> = *<name>s</name>++</expr>;</expr_stmt>
	    <expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>ch2</name> &gt;= 0xDC00 &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ucs</name> = (((<name>ch</name> &amp; 0x03FF) &lt;&lt; 10) | (<name>ch2</name> &amp; 0x03FF)) + 0x00010000</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = 'U'</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 28) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 24) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 20) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 16) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 12) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 8) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 4) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ucs</name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
		<continue>continue;</continue>
	    }</block></then></if>
	    <comment type="block">/* Fall through: isolated surrogates are copied as-is */</comment>
	    <expr_stmt><expr><name>s</name>--</expr>;</expr_stmt>
	    <expr_stmt><expr><name>size</name>++</expr>;</expr_stmt>
	}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Map 16-bit characters to '\uxxxx' */</comment>
	<if>if <condition>(<expr><name>ch</name> &gt;= 256</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = 'u'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 12) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 8) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 15</expr>]</index></name></expr>;</expr_stmt>
        }</block></then>
	<comment type="block">/* Copy everything else as-is */</comment>
	<else>else
            <expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt></else></if>
    }</block></while>
    <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><name>p</name> - <name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>repr</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsRawUnicodeEscapeString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_EncodeRawUnicodeEscape</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- Unicode Internal Codec ------------------------------------------- */</comment>

<function><type><name>PyObject</name> *</type><name>_PyUnicode_DecodeUnicodeInternal</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
					   <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
					   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>unimax</name> <init>= <expr><call><name>PyUnicode_GetMax</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* XXX overflow detection missing */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>(<name>size</name>+<name>Py_UNICODE_SIZE</name>-1)/ <name>Py_UNICODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><call><name>PyUnicode_GetSize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
    <expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>s</name> &lt; <name>end</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We have to sanity check the raw data, otherwise doom looms for
           some malformed UCS-4 data. */</comment>
        <if>if <condition>(
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
            <expr>*<name>p</name> &gt; <name>unimax</name> || *<name>p</name> &lt; 0 ||
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <name>end</name>-<name>s</name> &lt; <name>Py_UNICODE_SIZE</name></expr>
            )</condition><then>
            <block>{
            <expr_stmt><expr><name>startinpos</name> = <name>s</name> - <name>starts</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>end</name>-<name>s</name> &lt; <name>Py_UNICODE_SIZE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>endinpos</name> = <name>end</name>-<name>starts</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>reason</name> = "truncated input"</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>endinpos</name> = <name>s</name> - <name>starts</name> + <name>Py_UNICODE_SIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>reason</name> = "illegal code point (&gt; 0x10FFFF)"</expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>outpos</name> = <name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
                    <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
                    <argument><expr>"unicode_internal"</expr></argument>, <argument><expr><name>reason</name></expr></argument>,
                    <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
                    <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <goto>goto <name>onError</name>;</goto>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>s</name> += <name>Py_UNICODE_SIZE</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></while>

    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* --- Latin-1 Codec ------------------------------------------------------ */</comment>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeLatin1</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
				 <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>

    <comment type="block">/* Latin-1 is equivalent to the first 256 ordinals in Unicode. */</comment>
    <if>if <condition>(<expr><name>size</name> == 1</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>r</name> <init>= <expr>*(<name>unsigned</name> <name>char</name>*)<name>s</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
    <expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition>
	<expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>)*<name>s</name>++</expr>;</expr_stmt></while>
    <return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* create or adjust a UnicodeEncodeError */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>make_encode_exception</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>exceptionObject</name> = <call><name>PyUnicodeEncodeError_Create</name><argument_list>(
	    <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
	<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_SetStart</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_SetEnd</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_SetReason</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<return>return;</return>
	<label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>exceptionObject</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/* raises a UnicodeEncodeError */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>raise_encode_exception</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>make_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>,
	<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>exceptionObject</name> != <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>PyCodec_StrictErrors</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* error handling callback helper:
   build arguments, call the callback and check the arguments,
   put the result into newpos and return the replacement string, which
   has to be freed by the caller */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>unicode_encode_call_errorhandler</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
    <param><decl><type><name>PyObject</name> **</type><name>errorHandler</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name> *</type><name>newpos</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>argparse</name> <init>= <expr>"O!n;encoding error handler must return (unicode, int) tuple"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PyObject</name> *</type><name>restuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>resunicode</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>errorHandler</name> = <call><name>PyCodec_LookupError</name><argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>make_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>,
	<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>restuple</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(
	<argument><expr>*<name>errorHandler</name></expr></argument>, <argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>restuple</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>&amp;<name><name>argparse</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>, <argument><expr><name>argparse</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>,
	<argument><expr>&amp;<name>resunicode</name></expr></argument>, <argument><expr><name>newpos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>*<name>newpos</name>&lt;0</expr>)</condition><then>
	<expr_stmt><expr>*<name>newpos</name> = <name>size</name>+*<name>newpos</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>*<name>newpos</name>&lt;0 || *<name>newpos</name>&gt;<name>size</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"position %zd from error handler out of bounds"</expr></argument>, <argument><expr>*<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>resunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>resunicode</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>unicode_encode_ucs1</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
				 <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
				 <param><decl><type><name>int</name></type> <name>limit</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* output object */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
    <comment type="block">/* pointers to the beginning and end+1 of input */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>startp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>endp</name> <init>= <expr><name>p</name> + <name>size</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* pointer to the beginning of the unencodable characters */</comment>
    <comment type="block">/* const Py_UNICODE *badp = NULL; */</comment>
    <comment type="block">/* pointer into the output */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
    <comment type="block">/* current output position */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>respos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ressize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr>(<name>limit</name> == 256) ? "latin-1" : "ascii"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name> <init>= <expr>(<name>limit</name> == 256) ? "ordinal not in range(256)" : "ordinal not in range(128)"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* the following variable is used for caching string comparisons
     * -1=not initialized, 0=unknown, 1=strict, 2=replace, 3=ignore, 4=xmlcharrefreplace */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>known_errorHandler</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <comment type="block">/* allocate enough for a simple encoding without
       replacements, if we need more, we'll resize */</comment>
    <expr_stmt><expr><name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
	<return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><name>str</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ressize</name> = <name>size</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>p</name>&lt;<name>endp</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* can we encode this? */</comment>
	<if>if <condition>(<expr><name>c</name>&lt;<name>limit</name></expr>)</condition><then> <block>{
	    <comment type="block">/* no overflow check, because we know that the space is enough */</comment>
	    <expr_stmt><expr>*<name>str</name>++ = (<name>char</name>)<name>c</name></expr>;</expr_stmt>
	    <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>unicodepos</name> <init>= <expr><name>p</name>-<name>startp</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>respos</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>uni2</name></decl>;</decl_stmt>
	    <comment type="block">/* startpos for collecting unencodable chars */</comment>
	    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>collstart</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>collend</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
	    <comment type="block">/* find all unecodable characters */</comment>
	    <while>while <condition>(<expr>(<name>collend</name> &lt; <name>endp</name>) &amp;&amp; ((*<name>collend</name>)&gt;=<name>limit</name>)</expr>)</condition>
		<expr_stmt><expr>++<name>collend</name></expr>;</expr_stmt></while>
	    <comment type="block">/* cache callback name lookup (if not done yet, i.e. it's the first error) */</comment>
	    <if>if <condition>(<expr><name>known_errorHandler</name>==-1</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>errors</name>==<name>NULL</name>) || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
		    <expr_stmt><expr><name>known_errorHandler</name> = 1</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>known_errorHandler</name> = 2</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>known_errorHandler</name> = 3</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"xmlcharrefreplace"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>known_errorHandler</name> = 4</expr>;</expr_stmt></then>
		<else>else
		    <expr_stmt><expr><name>known_errorHandler</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
	    }</block></then></if>
	    <switch>switch <condition>(<expr><name>known_errorHandler</name></expr>)</condition> <block>{
		<case>case <expr>1</expr>: <comment type="block">/* strict */</comment>
		    <expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstart</name>-<name>startp</name></expr></argument>, <argument><expr><name>collend</name>-<name>startp</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>onError</name>;</goto>
		</case><case>case <expr>2</expr>: <comment type="block">/* replace */</comment>
		    <while>while <condition>(<expr><name>collstart</name>++&lt;<name>collend</name></expr>)</condition>
			<expr_stmt><expr>*<name>str</name>++ = '?'</expr>;</expr_stmt></while> <comment type="block">/* fall through */</comment>
		</case><case>case <expr>3</expr>: <comment type="block">/* ignore */</comment>
		    <expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>4</expr>: <comment type="block">/* xmlcharrefreplace */</comment>
		    <expr_stmt><expr><name>respos</name> = <name>str</name>-<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <comment type="block">/* determine replacement size (temporarily (mis)uses p) */</comment>
		    <for>for (<init><expr><name>p</name> = <name>collstart</name></expr>, <expr><name>repsize</name> = 0</expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
			<if>if <condition>(<expr>*<name>p</name>&lt;10</expr>)</condition><then>
			    <expr_stmt><expr><name>repsize</name> += 2+1+1</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr>*<name>p</name>&lt;100</expr>)</condition><then>
			    <expr_stmt><expr><name>repsize</name> += 2+2+1</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr>*<name>p</name>&lt;1000</expr>)</condition><then>
			    <expr_stmt><expr><name>repsize</name> += 2+3+1</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr>*<name>p</name>&lt;10000</expr>)</condition><then>
			    <expr_stmt><expr><name>repsize</name> += 2+4+1</expr>;</expr_stmt></then>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifndef>
			<else>else
			    <expr_stmt><expr><name>repsize</name> += 2+5+1</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<else>else <if>if <condition>(<expr>*<name>p</name>&lt;100000</expr>)</condition><then>
			    <expr_stmt><expr><name>repsize</name> += 2+5+1</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr>*<name>p</name>&lt;1000000</expr>)</condition><then>
			    <expr_stmt><expr><name>repsize</name> += 2+6+1</expr>;</expr_stmt></then>
			<else>else
			    <expr_stmt><expr><name>repsize</name> += 2+7+1</expr>;</expr_stmt></else></if></else></if></else>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		    }</block></for>
		    <expr_stmt><expr><name>requiredsize</name> = <name>respos</name>+<name>repsize</name>+(<name>endp</name>-<name>collend</name>)</expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>requiredsize</name> &gt; <name>ressize</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>requiredsize</name>&lt;2*<name>ressize</name></expr>)</condition><then>
			    <expr_stmt><expr><name>requiredsize</name> = 2*<name>ressize</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			    <goto>goto <name>onError</name>;</goto></then></if>
			<expr_stmt><expr><name>str</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> + <name>respos</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ressize</name> = <name>requiredsize</name></expr>;</expr_stmt>
		    }</block></then></if>
		    <comment type="block">/* generate replacement (temporarily (mis)uses p) */</comment>
		    <for>for (<init><expr><name>p</name> = <name>collstart</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
			<expr_stmt><expr><name>str</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>"&amp;#%d;"</expr></argument>, <argument><expr>(<name>int</name>)*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></for>
		    <expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><default>default:
		    <expr_stmt><expr><name>repunicode</name> = <call><name>unicode_encode_call_errorhandler</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
			<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>,
			<argument><expr><name>collstart</name>-<name>startp</name></expr></argument>, <argument><expr><name>collend</name>-<name>startp</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>repunicode</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>onError</name>;</goto></then></if>
		    <comment type="block">/* need more space? (at least enough for what we
		       have+the replacement+the rest of the string, so
		       we won't have to check space for encodable characters) */</comment>
		    <expr_stmt><expr><name>respos</name> = <name>str</name>-<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>requiredsize</name> = <name>respos</name>+<name>repsize</name>+(<name>endp</name>-<name>collend</name>)</expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>requiredsize</name> &gt; <name>ressize</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>requiredsize</name>&lt;2*<name>ressize</name></expr>)</condition><then>
			    <expr_stmt><expr><name>requiredsize</name> = 2*<name>ressize</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <goto>goto <name>onError</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name>str</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> + <name>respos</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ressize</name> = <name>requiredsize</name></expr>;</expr_stmt>
		    }</block></then></if>
		    <comment type="block">/* check if there is anything unencodable in the replacement
		       and copy it to the output */</comment>
		    <for>for (<init><expr><name>uni2</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</init><condition><expr><name>repsize</name>--&gt;0</expr>;</condition> <incr><expr>++<name>uni2</name></expr>, <expr>++<name>str</name></expr></incr>) <block>{
			<expr_stmt><expr><name>c</name> = *<name>uni2</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> &gt;= <name>limit</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
				<argument><expr><name>unicodepos</name></expr></argument>, <argument><expr><name>unicodepos</name>+1</expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <goto>goto <name>onError</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr>*<name>str</name> = (<name>char</name>)<name>c</name></expr>;</expr_stmt>
		    }</block></for>
		    <expr_stmt><expr><name>p</name> = <name>startp</name> + <name>newpos</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </default>}</block></switch>
	}</block></else></if>
    }</block></while>
    <comment type="block">/* Resize if we allocated to much */</comment>
    <expr_stmt><expr><name>respos</name> = <name>str</name>-<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>respos</name>&lt;<name>ressize</name></expr>)</condition><then>
       <comment type="block">/* If this falls res will be NULL */</comment>
	<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>

    <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeLatin1</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
				 <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>unicode_encode_ucs1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr>256</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsLatin1String</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_EncodeLatin1</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- 7-bit ASCII Codec -------------------------------------------------- */</comment>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeASCII</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
				<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* ASCII is equivalent to the first 128 ordinals in Unicode. */</comment>
    <if>if <condition>(<expr><name>size</name> == 1 &amp;&amp; *(<name>unsigned</name> <name>char</name>*)<name>s</name> &lt; 128</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>r</name> <init>= <expr>*(<name>unsigned</name> <name>char</name>*)<name>s</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
    <expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr>(<name>unsigned</name> <name>char</name>)*<name>s</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>c</name> &lt; 128</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>p</name>++ = <name>c</name></expr>;</expr_stmt>
	    <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
	    <expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>endinpos</name> = <name>startinpos</name> + 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>outpos</name> = <name>p</name> - (<name>Py_UNICODE</name> *)<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
		 <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
		 <argument><expr>"ascii"</expr></argument>, <argument><expr>"ordinal not in range(128)"</expr></argument>,
		 <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
		 <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	}</block></else></if>
    }</block></while>
    <if>if <condition>(<expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeASCII</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
				<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>unicode_encode_ucs1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr>128</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsASCIIString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_EncodeASCII</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* --- MBCS codecs for Windows -------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> &lt; <name>SIZEOF_SSIZE_T</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_RETRY</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* XXX This code is limited to "true" double-byte encodings, as
   a) it assumes an incomplete character consists of a single byte, and
   b) IsDBCSLeadByte (probably) does not work for non-DBCS multi-byte
      encodings, see IsDBCSLeadByteEx documentation. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_dbcs_lead_byte</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>curr</name> <init>= <expr><name>s</name> + <name>offset</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>IsDBCSLeadByte</name><argument_list>(<argument><expr>*<name>curr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prev</name> <init>= <expr><call><name>CharPrev</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr>(<name>prev</name> == <name>curr</name>) || !<call><name>IsDBCSLeadByte</name><argument_list>(<argument><expr>*<name>prev</name></expr></argument>)</argument_list></call> || (<name>curr</name> - <name>prev</name> == 2)</expr>;</return>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * Decode MBCS string into unicode object. If 'final' is set, converts
 * trailing lead-byte too. Returns consumed size if succeed, -1 otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_mbcs</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> **</type><name>v</name></decl></param>,
			<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <comment type="block">/* MBCS string */</comment>
			<param><decl><type><name>int</name></type> <name>size</name></decl></param>, <comment type="block">/* sizeof MBCS string */</comment>
			<param><decl><type><name>int</name></type> <name>final</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>usize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Skip trailing lead-byte unless 'final' is set */</comment>
    <if>if <condition>(<expr>!<name>final</name> &amp;&amp; <name>size</name> &gt;= 1 &amp;&amp; <call><name>is_dbcs_lead_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name> - 1</expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr>--<name>size</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* First get the size of the result */</comment>
    <if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>usize</name> = <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>usize</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>-1</expr>;</return>
	}</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>*<name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<comment type="block">/* Create unicode object */</comment>
	<expr_stmt><expr>*<name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>v</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr>-1</expr>;</return></then></if>
    }</block></then>
    <else>else <block>{
	<comment type="block">/* Extend unicode object */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>n</name> + <name>usize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr>-1</expr>;</return></then></if>
    }</block></else></if>

    <comment type="block">/* Do the conversion */</comment>
    <if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>v</name></expr></argument>)</argument_list></call> + <name>n</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>0 == <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>-1</expr>;</return>
	}</block></then></if>
    }</block></then></if>

    <return>return <expr><name>size</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeMBCSStateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
					<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
					<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
					<param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
	<expr_stmt><expr>*<name>consumed</name> = 0</expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEED_RETRY</name></cpp:ifdef>
  <label><name>retry</name>:</label>
    <if>if <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name></expr>)</condition><then>
	<expr_stmt><expr><name>done</name> = <call><name>decode_mbcs</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>done</name> = <call><name>decode_mbcs</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>int</name>)<name>size</name></expr></argument>, <argument><expr>!<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>done</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
	<expr_stmt><expr>*<name>consumed</name> += <name>done</name></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEED_RETRY</name></cpp:ifdef>
    <if>if <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>s</name> += <name>done</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> -= <name>done</name></expr>;</expr_stmt>
	<goto>goto <name>retry</name>;</goto>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeMBCS</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
				<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_DecodeMBCSStateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Convert unicode into string object (MBCS).
 * Returns 0 if succeed, -1 otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_mbcs</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>repr</name></decl></param>,
			<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>, <comment type="block">/* unicode */</comment>
			<param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list> <comment type="block">/* size of unicode */</comment>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>mbcssize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* First get the size of the result */</comment>
    <if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>mbcssize</name> = <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mbcssize</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>-1</expr>;</return>
	}</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>*<name>repr</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<comment type="block">/* Create string object */</comment>
	<expr_stmt><expr>*<name>repr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mbcssize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>repr</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr>-1</expr>;</return></then></if>
    }</block></then>
    <else>else <block>{
	<comment type="block">/* Extend string object */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr>*<name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr><name>repr</name></expr></argument>, <argument><expr><name>n</name> + <name>mbcssize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr>-1</expr>;</return></then></if>
    }</block></else></if>

    <comment type="block">/* Do the conversion */</comment>
    <if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>*<name>repr</name></expr></argument>)</argument_list></call> + <name>n</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>0 == <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>mbcssize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>-1</expr>;</return>
	}</block></then></if>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeMBCS</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
				<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>repr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEED_RETRY</name></cpp:ifdef>
 <label><name>retry</name>:</label>
    <if>if <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name></expr>)</condition><then>
	<expr_stmt><expr><name>ret</name> = <call><name>encode_mbcs</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>ret</name> = <call><name>encode_mbcs</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>int</name>)<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEED_RETRY</name></cpp:ifdef>
    <if>if <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>p</name> += <name>INT_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> -= <name>INT_MAX</name></expr>;</expr_stmt>
	<goto>goto <name>retry</name>;</goto>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>repr</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsMBCSString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_EncodeMBCS</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NEED_RETRY</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<comment type="block">/* --- Character Mapping Codec -------------------------------------------- */</comment>

<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeCharmap</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
				  <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				  <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
				  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>extrachars</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>mapstring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maplen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Default to Latin-1 */</comment>
    <if>if <condition>(<expr><name>mapping</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><call><name>PyUnicode_DecodeLatin1</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
    <expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>mapstring</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maplen</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
	    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ch</name> <init>= <expr>*<name>s</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>x</name> <init>= <expr>0xfffe</expr></init></decl>;</decl_stmt> <comment type="block">/* illegal value */</comment>

	    <if>if <condition>(<expr><name>ch</name> &lt; <name>maplen</name></expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = <name><name>mapstring</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt></then></if>

	    <if>if <condition>(<expr><name>x</name> == 0xfffe</expr>)</condition><then> <block>{
		<comment type="block">/* undefined mapping */</comment>
		<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+1</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
		     <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
		     <argument><expr>"charmap"</expr></argument>, <argument><expr>"character maps to &lt;undefined&gt;"</expr></argument>,
		     <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
		     <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <goto>goto <name>onError</name>;</goto>
		}</block></then></if>
		<continue>continue;</continue>
	    }</block></then></if>
	    <expr_stmt><expr>*<name>p</name>++ = <name>x</name></expr>;</expr_stmt>
	    <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
	}</block></while>
    }</block></then>
    <else>else <block>{
	<while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
	    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ch</name> <init>= <expr>*<name>s</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>, *<decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>

	    <comment type="block">/* Get mapping (char ordinal -&gt; integer, Unicode char or None) */</comment>
	    <expr_stmt><expr><name>w</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	    <expr_stmt><expr><name>x</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <comment type="block">/* No mapping found means: mapping is undefined. */</comment>
		    <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>x</name> = <name>Py_None</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else
		    <goto>goto <name>onError</name>;</goto></else></if>
	    }</block></then></if>
    
	    <comment type="block">/* Apply mapping */</comment>
	    <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>long</name></type> <name>value</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>value</name> &lt; 0 || <name>value</name> &gt; 65535</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				    <argument><expr>"character mapping must be in range(65536)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>onError</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>value</name></expr>;</expr_stmt>
	    }</block></then>
	    <else>else <if>if <condition>(<expr><name>x</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<comment type="block">/* undefined mapping */</comment>
		<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+1</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
		     <argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
		     <argument><expr>"charmap"</expr></argument>, <argument><expr>"character maps to &lt;undefined&gt;"</expr></argument>,
		     <argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
		     <argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>onError</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<continue>continue;</continue>
	    }</block></then>
	    <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>targetsize</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
		<if>if <condition>(<expr><name>targetsize</name> == 1</expr>)</condition><then>
		    <comment type="block">/* 1-1 mapping */</comment>
		    <expr_stmt><expr>*<name>p</name>++ = *<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    
		<else>else <if>if <condition>(<expr><name>targetsize</name> &gt; 1</expr>)</condition><then> <block>{
		    <comment type="block">/* 1-n mapping */</comment>
		    <if>if <condition>(<expr><name>targetsize</name> &gt; <name>extrachars</name></expr>)</condition><then> <block>{
			<comment type="block">/* resize first */</comment>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldpos</name> <init>= <expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>needed</name> <init>= <expr>(<name>targetsize</name> - <name>extrachars</name>) + \
				     (<name>targetsize</name> &lt;&lt; 2)</expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>extrachars</name> += <name>needed</name></expr>;</expr_stmt>
			<comment type="block">/* XXX overflow detection missing */</comment>
			<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>,
					     <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>needed</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <goto>goto <name>onError</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>oldpos</name></expr>;</expr_stmt>
		    }</block></then></if>
		    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
				    <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><name>targetsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>p</name> += <name>targetsize</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>extrachars</name> -= <name>targetsize</name></expr>;</expr_stmt>
		}</block></then></if></else></if>
		<comment type="block">/* 1-0 mapping: skip the character */</comment>
	    }</block></then>
	    <else>else <block>{
		<comment type="block">/* wrong return value */</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		      <argument><expr>"character mapping must return integer, None or unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>onError</name>;</goto>
	    }</block></else></if></else></if></else></if>
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
	}</block></while>
    }</block></else></if>
    <if>if <condition>(<expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Charmap encoding: the lookup table */</comment>

<struct>struct <name>encoding_map</name><block>{
  <decl_stmt><decl><type><name>PyObject_HEAD</name>
  <name>unsigned</name> <name>char</name></type> <name><name>level1</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>count2</name></decl>, <decl><type ref="prev"/><name>count3</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>level23</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>encoding_map_size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>encoding_map</name> *</type><name>map</name> <init>= <expr>(struct <name>encoding_map</name>*)<name>obj</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>map</name></expr></argument>)</argument_list></sizeof> - 1 + 16*<name><name>map</name>-&gt;<name>count2</name></name> + 
                          128*<name><name>map</name>-&gt;<name>count3</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>encoding_map_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"size"</expr>, <expr><name>encoding_map_size</name></expr>, <expr><name>METH_NOARGS</name></expr>, 
         <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return the size (in bytes) of this object"</argument>)</argument_list></macro> }</block></expr>,
        <expr><block>{ <expr>0</expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>encoding_map_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>o</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>EncodingMapType</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
        "EncodingMap"</expr>,          <comment type="block">/*tp_name*/</comment>
        <expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>encoding_map</name></expr></argument>)</argument_list></sizeof></expr>,   <comment type="block">/*tp_basicsize*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_itemsize*/</comment>
        <comment type="block">/* methods */</comment>
        <expr><name>encoding_map_dealloc</name></expr>,   <comment type="block">/*tp_dealloc*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_print*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_getattr*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_setattr*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_compare*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_repr*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_as_number*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_as_sequence*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_as_mapping*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_hash*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_call*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_str*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_getattro*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_setattro*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_as_buffer*/</comment>
        <expr><name>Py_TPFLAGS_DEFAULT</name></expr>,     <comment type="block">/*tp_flags*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_doc*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_traverse*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_clear*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_richcompare*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_weaklistoffset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_iter*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_iternext*/</comment>
        <expr><name>encoding_map_methods</name></expr>,   <comment type="block">/*tp_methods*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_members*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_getset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_base*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dict*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_get*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_set*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dictoffset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_init*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_alloc*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_new*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_free*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_is_gc*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyObject</name>*</type>
<name>PyUnicode_BuildEncodingMap</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>string</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>decode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>encoding_map</name> *</type><name>mresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>need_dict</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>level1</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>level2</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>mlevel1</name></decl>, *<decl><type ref="prev"/><name>mlevel2</name></decl>, *<decl><type ref="prev"/><name>mlevel3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count2</name> <init>= <expr>0</expr></init>, <name>count3</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_GetSize</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> != 256</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>decode</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>level1</name></expr></argument>, <argument><expr>0xFF</expr></argument>, <argument><expr>sizeof <name>level1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>level2</name></expr></argument>, <argument><expr>0xFF</expr></argument>, <argument><expr>sizeof <name>level2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there isn't a one-to-one mapping of NULL to \0,
       or if there are non-BMP characters, we need to use
       a mapping dictionary. */</comment>
    <if>if <condition>(<expr><name><name>decode</name><index>[<expr>0</expr>]</index></name> != 0</expr>)</condition><then>
        <expr_stmt><expr><name>need_dict</name> = 1</expr>;</expr_stmt></then></if>
    <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>, <decl><type ref="prev"/><name>l2</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> == 0
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
            || <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> &gt; 0xFFFF</expr>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><then> <block>{
            <expr_stmt><expr><name>need_dict</name> = 1</expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> == 0xFFFE</expr>)</condition><then>
            <comment type="block">/* unmapped character */</comment>
            <continue>continue;</continue></then></if>
        <expr_stmt><expr><name>l1</name> = <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 11</expr>;</expr_stmt>
        <expr_stmt><expr><name>l2</name> = <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 7</expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>level1</name><index>[<expr><name>l1</name></expr>]</index></name> == 0xFF</expr>)</condition><then>
            <expr_stmt><expr><name><name>level1</name><index>[<expr><name>l1</name></expr>]</index></name> = <name>count2</name>++</expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>level2</name><index>[<expr><name>l2</name></expr>]</index></name> == 0xFF</expr>)</condition><then>
            <expr_stmt><expr><name><name>level2</name><index>[<expr><name>l2</name></expr>]</index></name> = <name>count3</name>++</expr>;</expr_stmt></then></if> 
    }</block></for>

    <if>if <condition>(<expr><name>count2</name> &gt;= 0xFF || <name>count3</name> &gt;= 0xFF</expr>)</condition><then>
        <expr_stmt><expr><name>need_dict</name> = 1</expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>need_dict</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>key</name> = <name>value</name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>key</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>value</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>key</name> || !<name>value</name></expr>)</condition><then>
                <goto>goto <name>failed1</name>;</goto></then></if>
            <if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
                <goto>goto <name>failed1</name>;</goto></then></if>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
      <label><name>failed1</name>:</label>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Create a three-level trie */</comment>
    <expr_stmt><expr><name>result</name> = <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>encoding_map</name></expr></argument>)</argument_list></sizeof> +
                             16*<name>count2</name> + 128*<name>count3</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
        <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><call><name>PyObject_Init</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>&amp;<name>EncodingMapType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mresult</name> = (struct <name>encoding_map</name>*)<name>result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mresult</name>-&gt;<name>count2</name></name> = <name>count2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mresult</name>-&gt;<name>count3</name></name> = <name>count3</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mlevel1</name> = <name><name>mresult</name>-&gt;<name>level1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mlevel2</name> = <name><name>mresult</name>-&gt;<name>level23</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mlevel3</name> = <name><name>mresult</name>-&gt;<name>level23</name></name> + 16*<name>count2</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mlevel1</name></expr></argument>, <argument><expr><name>level1</name></expr></argument>, <argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mlevel2</name></expr></argument>, <argument><expr>0xFF</expr></argument>, <argument><expr>16*<name>count2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mlevel3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>128*<name>count3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>count3</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>o1</name></decl>, <decl><type ref="prev"/><name>o2</name></decl>, <decl><type ref="prev"/><name>o3</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>, <decl><type ref="prev"/><name>i3</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> == 0xFFFE</expr>)</condition><then>
            <comment type="block">/* unmapped character */</comment>
            <continue>continue;</continue></then></if>
        <expr_stmt><expr><name>o1</name> = <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name>&gt;&gt;11</expr>;</expr_stmt>
        <expr_stmt><expr><name>o2</name> = (<name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name>&gt;&gt;7) &amp; 0xF</expr>;</expr_stmt>
        <expr_stmt><expr><name>i2</name> = 16*<name><name>mlevel1</name><index>[<expr><name>o1</name></expr>]</index></name> + <name>o2</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>mlevel2</name><index>[<expr><name>i2</name></expr>]</index></name> == 0xFF</expr>)</condition><then>
            <expr_stmt><expr><name><name>mlevel2</name><index>[<expr><name>i2</name></expr>]</index></name> = <name>count3</name>++</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>o3</name> = <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0x7F</expr>;</expr_stmt>
        <expr_stmt><expr><name>i3</name> = 128*<name><name>mlevel2</name><index>[<expr><name>i2</name></expr>]</index></name> + <name>o3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mlevel3</name><index>[<expr><name>i3</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>encoding_map_lookup</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name></type> <name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>encoding_map</name> *</type><name>map</name> <init>= <expr>(struct <name>encoding_map</name>*)<name>mapping</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l1</name> <init>= <expr><name>c</name>&gt;&gt;11</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l2</name> <init>= <expr>(<name>c</name>&gt;&gt;7) &amp; 0xF</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l3</name> <init>= <expr><name>c</name> &amp; 0x7F</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
    <if>if <condition>(<expr><name>c</name> &gt; 0xFFFF</expr>)</condition><then> <block>{
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <comment type="block">/* level 1*/</comment>
    <expr_stmt><expr><name>i</name> = <name><name>map</name>-&gt;<name>level1</name><index>[<expr><name>l1</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>i</name> == 0xFF</expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <comment type="block">/* level 2*/</comment>
    <expr_stmt><expr><name>i</name> = <name><name>map</name>-&gt;<name>level23</name><index>[<expr>16*<name>i</name>+<name>l2</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>i</name> == 0xFF</expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <comment type="block">/* level 3 */</comment>
    <expr_stmt><expr><name>i</name> = <name><name>map</name>-&gt;<name>level23</name><index>[<expr>16*<name><name>map</name>-&gt;<name>count2</name></name> + 128*<name>i</name> + <name>l3</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <return>return <expr><name>i</name></expr>;</return>
}</block></function>

<comment type="block">/* Lookup the character ch in the mapping. If the character
   can't be found, Py_None is returned (or NULL, if another
   error occurred). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>charmapencode_lookup</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name></type> <name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
	 <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>x</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <comment type="block">/* No mapping found means: mapping is undefined. */</comment>
	    <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>x</name> = <name>Py_None</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>x</name></expr>;</return>
	}</block></then> <else>else
	    <return>return <expr><name>NULL</name></expr>;</return></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>x</name> == <name>Py_None</name></expr>)</condition><then>
	<return>return <expr><name>x</name></expr>;</return></then>
    <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>long</name></type> <name>value</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>value</name> &lt; 0 || <name>value</name> &gt; 255</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"character mapping must be in range(256)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>x</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>x</name></expr>;</return></then>
    <else>else <block>{
	<comment type="block">/* wrong return value */</comment>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
	      <argument><expr>"character mapping must return integer, None or str"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></else></if></else></if></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>charmapencode_resize</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>outobj</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>outpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outsize</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* exponentially overallocate to minimize reallocations */</comment>
	<if>if <condition>(<expr><name>requiredsize</name> &lt; 2*<name>outsize</name></expr>)</condition><then>
	    <expr_stmt><expr><name>requiredsize</name> = 2*<name>outsize</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <return>return <expr>0</expr>;</return>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<typedef>typedef <type><enum>enum <name>charmapencode_result</name> <block>{ 
  <decl><name>enc_SUCCESS</name></decl>, <decl><name>enc_FAILED</name></decl>, <decl><name>enc_EXCEPTION</name></decl> 
}</block></enum></type><name>charmapencode_result</name>;</typedef>
<comment type="block">/* lookup the character, put the result in the output string and adjust
   various state variables. Reallocate the output string if not enough
   space is available. Return a new reference to the object that
   was put in the output buffer, or Py_None, if the mapping was undefined
   (in which case no character was written) or NULL, if a
   reallocation error occurred. The caller must decref the result */</comment>
<function><type><specifier>static</specifier>
<name>charmapencode_result</name></type> <name>charmapencode_output</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name></type> <name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
    <param><decl><type><name>PyObject</name> **</type><name>outobj</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>outpos</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>rep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>outstart</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outsize</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call> == &amp;<name>EncodingMapType</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>encoding_map_lookup</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name> <init>= <expr>*<name>outpos</name>+1</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>res</name> == -1</expr>)</condition><then>
            <return>return <expr><name>enc_FAILED</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>outsize</name>&lt;<name>requiredsize</name></expr>)</condition><then> 
	    <if>if <condition>(<expr>!<call><name>charmapencode_resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>outpos</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>enc_EXCEPTION</name></expr>;</return></then></if></then></if>
        <expr_stmt><expr><name>outstart</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outstart</name><index>[<expr>(*<name>outpos</name>)++</expr>]</index></name> = (<name>char</name>)<name>res</name></expr>;</expr_stmt>
	<return>return <expr><name>enc_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rep</name> = <call><name>charmapencode_lookup</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rep</name>==<name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>enc_EXCEPTION</name></expr>;</return></then>
    <else>else <if>if <condition>(<expr><name>rep</name>==<name>Py_None</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>enc_FAILED</name></expr>;</return>
    }</block></then> <else>else <block>{
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name> <init>= <expr>*<name>outpos</name>+1</expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>outsize</name>&lt;<name>requiredsize</name></expr>)</condition><then>
		<if>if <condition>(<expr>!<call><name>charmapencode_resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>outpos</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return <expr><name>enc_EXCEPTION</name></expr>;</return>
		}</block></then></if></then></if>
            <expr_stmt><expr><name>outstart</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>outstart</name><index>[<expr>(*<name>outpos</name>)++</expr>]</index></name> = (<name>char</name>)<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
	    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repchars</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name> <init>= <expr>*<name>outpos</name>+<name>repsize</name></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>outsize</name>&lt;<name>requiredsize</name></expr>)</condition><then>
		<if>if <condition>(<expr>!<call><name>charmapencode_resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>outpos</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return <expr><name>enc_EXCEPTION</name></expr>;</return>
		}</block></then></if></then></if>
            <expr_stmt><expr><name>outstart</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outstart</name> + *<name>outpos</name></expr></argument>, <argument><expr><name>repchars</name></expr></argument>, <argument><expr><name>repsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>outpos</name> += <name>repsize</name></expr>;</expr_stmt>
	}</block></else></if>
    }</block></else></if></else></if>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>enc_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/* handle an error in PyUnicode_EncodeCharmap
   Return 0 on success, -1 on error */</comment>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>charmap_encoding_error</name><parameter_list>(
    <param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>inpos</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
    <param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
    <param><decl><type><name>int</name> *</type><name>known_errorHandler</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>errorHandler</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
    <param><decl><type><name>PyObject</name> **</type><name>res</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>respos</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* initialize to prevent gcc warning */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>uni2</name></decl>;</decl_stmt>
    <comment type="block">/* startpos for collecting unencodable chars */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>collstartpos</name> <init>= <expr>*<name>inpos</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>collendpos</name> <init>= <expr>*<name>inpos</name>+1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>collpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr>"charmap"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>reason</name> <init>= <expr>"character maps to &lt;undefined&gt;"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charmapencode_result</name></type> <name>x</name></decl>;</decl_stmt>

    <comment type="block">/* find all unencodable characters */</comment>
    <while>while <condition>(<expr><name>collendpos</name> &lt; <name>size</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rep</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call> == &amp;<name>EncodingMapType</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>encoding_map_lookup</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>collendpos</name></expr>]</index></name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>res</name> != -1</expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr>++<name>collendpos</name></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if>
            
	<expr_stmt><expr><name>rep</name> = <call><name>charmapencode_lookup</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>collendpos</name></expr>]</index></name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rep</name>==<name>NULL</name></expr>)</condition><then>
	    <return>return <expr>-1</expr>;</return></then>
	<else>else <if>if <condition>(<expr><name>rep</name>!=<name>Py_None</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>++<name>collendpos</name></expr>;</expr_stmt>
    }</block></while>
    <comment type="block">/* cache callback name lookup
     * (if not done yet, i.e. it's the first error) */</comment>
    <if>if <condition>(<expr>*<name>known_errorHandler</name>==-1</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>(<name>errors</name>==<name>NULL</name>) || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
	    <expr_stmt><expr>*<name>known_errorHandler</name> = 1</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr>*<name>known_errorHandler</name> = 2</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr>*<name>known_errorHandler</name> = 3</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"xmlcharrefreplace"</expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr>*<name>known_errorHandler</name> = 4</expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr>*<name>known_errorHandler</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
    }</block></then></if>
    <switch>switch <condition>(<expr>*<name>known_errorHandler</name></expr>)</condition> <block>{
	<case>case <expr>1</expr>: <comment type="block">/* strict */</comment>
	    <expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>-1</expr>;</return>
	</case><case>case <expr>2</expr>: <comment type="block">/* replace */</comment>
	    <for>for (<init><expr><name>collpos</name> = <name>collstartpos</name></expr>;</init> <condition><expr><name>collpos</name>&lt;<name>collendpos</name></expr>;</condition> <incr><expr>++<name>collpos</name></expr></incr>) <block>{
		<expr_stmt><expr><name>x</name> = <call><name>charmapencode_output</name><argument_list>(<argument><expr>'?'</expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name>==<name>enc_EXCEPTION</name></expr>)</condition><then> <block>{
		    <return>return <expr>-1</expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>x</name>==<name>enc_FAILED</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return <expr>-1</expr>;</return>
		}</block></then></if></else></if>
	    }</block></for>
	    <comment type="block">/* fall through */</comment>
	</case><case>case <expr>3</expr>: <comment type="block">/* ignore */</comment>
	    <expr_stmt><expr>*<name>inpos</name> = <name>collendpos</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>4</expr>: <comment type="block">/* xmlcharrefreplace */</comment>
	    <comment type="block">/* generate replacement (temporarily (mis)uses p) */</comment>
	    <for>for (<init><expr><name>collpos</name> = <name>collstartpos</name></expr>;</init> <condition><expr><name>collpos</name> &lt; <name>collendpos</name></expr>;</condition> <incr><expr>++<name>collpos</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>2+29+1+1</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&amp;#%d;"</expr></argument>, <argument><expr>(<name>int</name>)<name><name>p</name><index>[<expr><name>collpos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>cp</name> = <name>buffer</name></expr>;</init> <condition><expr>*<name>cp</name></expr>;</condition> <incr><expr>++<name>cp</name></expr></incr>) <block>{
		    <expr_stmt><expr><name>x</name> = <call><name>charmapencode_output</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>x</name>==<name>enc_EXCEPTION</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then>
		    <else>else <if>if <condition>(<expr><name>x</name>==<name>enc_FAILED</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		    }</block></then></if></else></if>
		}</block></for>
	    }</block></for>
	    <expr_stmt><expr>*<name>inpos</name> = <name>collendpos</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><default>default:
	    <expr_stmt><expr><name>repunicode</name> = <call><name>unicode_encode_call_errorhandler</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr><name>errorHandler</name></expr></argument>,
		<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>exceptionObject</name></expr></argument>,
		<argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>repunicode</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	    <comment type="block">/* generate replacement  */</comment>
	    <expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>uni2</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>repsize</name>--&gt;0</expr>;</condition> <incr><expr>++<name>uni2</name></expr></incr>) <block>{
		<expr_stmt><expr><name>x</name> = <call><name>charmapencode_output</name><argument_list>(<argument><expr>*<name>uni2</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name>==<name>enc_EXCEPTION</name></expr>)</condition><then> <block>{
		    <return>return <expr>-1</expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>x</name>==<name>enc_FAILED</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return <expr>-1</expr>;</return>
		}</block></then></if></else></if>
	    }</block></for>
	    <expr_stmt><expr>*<name>inpos</name> = <name>newpos</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeCharmap</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
				  <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				  <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
				  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* output object */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* current input position */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>inpos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <comment type="block">/* current output position */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>respos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* the following variable is used for caching string comparisons
     * -1=not initialized, 0=unknown, 1=strict, 2=replace,
     * 3=ignore, 4=xmlcharrefreplace */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>known_errorHandler</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Default to Latin-1 */</comment>
    <if>if <condition>(<expr><name>mapping</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><call><name>PyUnicode_EncodeLatin1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* allocate enough for a simple encoding without
       replacements, if we need more, we'll resize */</comment>
    <expr_stmt><expr><name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
	<return>return <expr><name>res</name></expr>;</return></then></if>

    <while>while <condition>(<expr><name>inpos</name>&lt;<name>size</name></expr>)</condition> <block>{
	<comment type="block">/* try to encode it */</comment>
	<decl_stmt><decl><type><name>charmapencode_result</name></type> <name>x</name> <init>= <expr><call><name>charmapencode_output</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>inpos</name></expr>]</index></name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>respos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>x</name>==<name>enc_EXCEPTION</name></expr>)</condition><then> <comment type="block">/* error */</comment>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<if>if <condition>(<expr><name>x</name>==<name>enc_FAILED</name></expr>)</condition><then> <block>{ <comment type="block">/* unencodable character */</comment>
	    <if>if <condition>(<expr><call><name>charmap_encoding_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>inpos</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>,
		<argument><expr>&amp;<name>exc</name></expr></argument>,
		<argument><expr>&amp;<name>known_errorHandler</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
		<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>respos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<goto>goto <name>onError</name>;</goto>
	    }</block></then></if>
	}</block></then>
	<else>else
	    <comment type="block">/* done with this character =&gt; adjust input position */</comment>
	    <expr_stmt><expr>++<name>inpos</name></expr>;</expr_stmt></else></if>
    }</block></while>

    <comment type="block">/* Resize if we allocated to much */</comment>
    <if>if <condition>(<expr><name>respos</name>&lt;<call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>

    <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_AsCharmapString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
				    <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call> || <name>mapping</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_EncodeCharmap</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>mapping</name></expr></argument>,
				   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* create or adjust a UnicodeTranslateError */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>make_translate_exception</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then> <block>{
    	<expr_stmt><expr>*<name>exceptionObject</name> = <call><name>PyUnicodeTranslateError_Create</name><argument_list>(
	    <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
	<if>if <condition>(<expr><call><name>PyUnicodeTranslateError_SetStart</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>PyUnicodeTranslateError_SetEnd</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>PyUnicodeTranslateError_SetReason</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<return>return;</return>
	<label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>exceptionObject</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/* raises a UnicodeTranslateError */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>raise_translate_exception</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>make_translate_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>,
	<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>exceptionObject</name> != <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>PyCodec_StrictErrors</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* error handling callback helper:
   build arguments, call the callback and check the arguments,
   put the result into newpos and return the replacement string, which
   has to be freed by the caller */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>unicode_translate_call_errorhandler</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
    <param><decl><type><name>PyObject</name> **</type><name>errorHandler</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name> *</type><name>newpos</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>argparse</name> <init>= <expr>"O!n;translating error handler must return (unicode, int) tuple"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i_newpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>restuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>resunicode</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>errorHandler</name> = <call><name>PyCodec_LookupError</name><argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>make_translate_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>,
	<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>restuple</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(
	<argument><expr>*<name>errorHandler</name></expr></argument>, <argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>restuple</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>&amp;<name><name>argparse</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>, <argument><expr><name>argparse</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>,
	<argument><expr>&amp;<name>resunicode</name></expr></argument>, <argument><expr>&amp;<name>i_newpos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>i_newpos</name>&lt;0</expr>)</condition><then>
	<expr_stmt><expr>*<name>newpos</name> = <name>size</name>+<name>i_newpos</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr>*<name>newpos</name> = <name>i_newpos</name></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr>*<name>newpos</name>&lt;0 || *<name>newpos</name>&gt;<name>size</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"position %zd from error handler out of bounds"</expr></argument>, <argument><expr>*<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>resunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>resunicode</name></expr>;</return>
}</block></function>

<comment type="block">/* Lookup the character ch in the mapping and put the result in result,
   which must be decrefed by the caller.
   Return 0 on success, -1 on error */</comment>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>charmaptranslate_lookup</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name></type> <name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
	 <return>return <expr>-1</expr>;</return></then></if>
    <expr_stmt><expr><name>x</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <comment type="block">/* No mapping found means: use 1:1 mapping. */</comment>
	    <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>result</name> = <name>NULL</name></expr>;</expr_stmt>
	    <return>return <expr>0</expr>;</return>
	}</block></then> <else>else
	    <return>return <expr>-1</expr>;</return></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>x</name> == <name>Py_None</name></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>result</name> = <name>x</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>long</name></type> <name>value</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>max</name> <init>= <expr><call><name>PyUnicode_GetMax</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>value</name> &lt; 0 || <name>value</name> &gt; <name>max</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"character mapping must be in range(0x%lx)"</expr></argument>, <argument><expr><name>max</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>*<name>result</name> = <name>x</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>result</name> = <name>x</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
    }</block></then>
    <else>else <block>{
	<comment type="block">/* wrong return value */</comment>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
	      <argument><expr>"character mapping must return integer, None or unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></else></if></else></if></else></if></else></if>
}</block></function>
<comment type="block">/* ensure that *outobj is at least requiredsize characters long,
if not reallocate and adjust various state variables.
Return 0 on success, -1 on error */</comment>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>charmaptranslate_makespace</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>outobj</name></decl></param>, <param><decl><type><name>Py_UNICODE</name> **</type><name>outp</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldsize</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>requiredsize</name> &gt; <name>oldsize</name></expr>)</condition><then> <block>{
	<comment type="block">/* remember old output position */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name> <init>= <expr>*<name>outp</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* exponentially overallocate to minimize reallocations */</comment>
	<if>if <condition>(<expr><name>requiredsize</name> &lt; 2 * <name>oldsize</name></expr>)</condition><then>
	    <expr_stmt><expr><name>requiredsize</name> = 2 * <name>oldsize</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>outp</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call> + <name>outpos</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>
<comment type="block">/* lookup the character, put the result in the output string and adjust
   various state variables. Return a new reference to the object that
   was put in the output buffer in *result, or Py_None, if the mapping was
   undefined (in which case no character was written).
   The called must decref result.
   Return 0 on success, -1 on error. */</comment>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>charmaptranslate_output</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>startinp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>curinp</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name></type> <name>insize</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>outobj</name></decl></param>, <param><decl><type><name>Py_UNICODE</name> **</type><name>outp</name></decl></param>,
    <param><decl><type><name>PyObject</name> **</type><name>res</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>charmaptranslate_lookup</name><argument_list>(<argument><expr>*<name>curinp</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr>*<name>res</name>==<name>NULL</name></expr>)</condition><then> <block>{
	<comment type="block">/* not found =&gt; default to 1:1 mapping */</comment>
	<expr_stmt><expr>*(*<name>outp</name>)++ = *<name>curinp</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>*<name>res</name>==<name>Py_None</name></expr>)</condition><then>
	<empty_stmt>;</empty_stmt></then>
    <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/* no overflow check, because we know that the space is enough */</comment>
	<expr_stmt><expr>*(*<name>outp</name>)++ = (<name>Py_UNICODE</name>)<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>repsize</name>==1</expr>)</condition><then> <block>{
	    <comment type="block">/* no overflow check, because we know that the space is enough */</comment>
	    <expr_stmt><expr>*(*<name>outp</name>)++ = *<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>repsize</name>!=0</expr>)</condition><then> <block>{
	    <comment type="block">/* more than one character */</comment>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name> <init>= <expr>(*<name>outp</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call>) +
		(<name>insize</name> - (<name>curinp</name>-<name>startinp</name>)) +
		<name>repsize</name> - 1</expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><call><name>charmaptranslate_makespace</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>outp</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>*<name>outp</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof>*<name>repsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>outp</name> += <name>repsize</name></expr>;</expr_stmt>
	}</block></then></if></else></if>
    }</block></then>
    <else>else
	<return>return <expr>-1</expr>;</return></else></if></else></if></else></if></else></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_TranslateCharmap</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
				     <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
				     <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
				     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* output object */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* pointers to the beginning and end+1 of input */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>startp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>endp</name> <init>= <expr><name>p</name> + <name>size</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* pointer into the output */</comment>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>str</name></decl>;</decl_stmt>
    <comment type="block">/* current output position */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>respos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>reason</name> <init>= <expr>"character maps to &lt;undefined&gt;"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* the following variable is used for caching string comparisons
     * -1=not initialized, 0=unknown, 1=strict, 2=replace,
     * 3=ignore, 4=xmlcharrefreplace */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>known_errorHandler</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>mapping</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* allocate enough for a simple 1:1 translation without
       replacements, if we need more, we'll resize */</comment>
    <expr_stmt><expr><name>res</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
	<return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>p</name>&lt;<name>endp</name></expr>)</condition> <block>{
	<comment type="block">/* try to encode it */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>charmaptranslate_output</name><argument_list>(<argument><expr><name>startp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <goto>goto <name>onError</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name>!=<name>Py_None</name></expr>)</condition><then> <comment type="block">/* it worked =&gt; adjust input pointer */</comment>
	    <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt></then>
	<else>else <block>{ <comment type="block">/* untranslatable character */</comment>
	    <decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* initialize to prevent gcc warning */</comment>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>uni2</name></decl>;</decl_stmt>
	    <comment type="block">/* startpos for collecting untranslatable chars */</comment>
	    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>collstart</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>collend</name> <init>= <expr><name>p</name>+1</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>coll</name></decl>;</decl_stmt>

	    <comment type="block">/* find all untranslatable characters */</comment>
	    <while>while <condition>(<expr><name>collend</name> &lt; <name>endp</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><call><name>charmaptranslate_lookup</name><argument_list>(<argument><expr>*<name>collend</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name>!=<name>Py_None</name></expr>)</condition><then>
		    <break>break;</break></then></if>
		<expr_stmt><expr>++<name>collend</name></expr>;</expr_stmt>
	    }</block></while>
	    <comment type="block">/* cache callback name lookup
	     * (if not done yet, i.e. it's the first error) */</comment>
	    <if>if <condition>(<expr><name>known_errorHandler</name>==-1</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>errors</name>==<name>NULL</name>) || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
		    <expr_stmt><expr><name>known_errorHandler</name> = 1</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>known_errorHandler</name> = 2</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>known_errorHandler</name> = 3</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"xmlcharrefreplace"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>known_errorHandler</name> = 4</expr>;</expr_stmt></then>
		<else>else
		    <expr_stmt><expr><name>known_errorHandler</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
	    }</block></then></if>
	    <switch>switch <condition>(<expr><name>known_errorHandler</name></expr>)</condition> <block>{
		<case>case <expr>1</expr>: <comment type="block">/* strict */</comment>
		    <expr_stmt><expr><call><name>raise_translate_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstart</name>-<name>startp</name></expr></argument>, <argument><expr><name>collend</name>-<name>startp</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>onError</name>;</goto>
		</case><case>case <expr>2</expr>: <comment type="block">/* replace */</comment>
		    <comment type="block">/* No need to check for space, this is a 1:1 replacement */</comment>
		    <for>for (<init><expr><name>coll</name> = <name>collstart</name></expr>;</init> <condition><expr><name>coll</name>&lt;<name>collend</name></expr>;</condition> <incr><expr>++<name>coll</name></expr></incr>)
			<expr_stmt><expr>*<name>str</name>++ = '?'</expr>;</expr_stmt></for>
		    <comment type="block">/* fall through */</comment>
		</case><case>case <expr>3</expr>: <comment type="block">/* ignore */</comment>
		    <expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>4</expr>: <comment type="block">/* xmlcharrefreplace */</comment>
		    <comment type="block">/* generate replacement (temporarily (mis)uses p) */</comment>
		    <for>for (<init><expr><name>p</name> = <name>collstart</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>2+29+1+1</expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&amp;#%d;"</expr></argument>, <argument><expr>(<name>int</name>)*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>charmaptranslate_makespace</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>,
			    <argument><expr>(<name>str</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>)+<call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call>+(<name>endp</name>-<name>collend</name>)</expr></argument>)</argument_list></call></expr>)</condition><then>
			    <goto>goto <name>onError</name>;</goto></then></if>
			<for>for (<init><expr><name>cp</name> = <name>buffer</name></expr>;</init> <condition><expr>*<name>cp</name></expr>;</condition> <incr><expr>++<name>cp</name></expr></incr>)
			    <expr_stmt><expr>*<name>str</name>++ = *<name>cp</name></expr>;</expr_stmt></for>
		    }</block></for>
		    <expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><default>default:
		    <expr_stmt><expr><name>repunicode</name> = <call><name>unicode_translate_call_errorhandler</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
			<argument><expr><name>reason</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>,
			<argument><expr><name>collstart</name>-<name>startp</name></expr></argument>, <argument><expr><name>collend</name>-<name>startp</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>repunicode</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>onError</name>;</goto></then></if>
		    <comment type="block">/* generate replacement  */</comment>
		    <expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><call><name>charmaptranslate_makespace</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>,
			<argument><expr>(<name>str</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>)+<name>repsize</name>+(<name>endp</name>-<name>collend</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>onError</name>;</goto>
		    }</block></then></if>
		    <for>for (<init><expr><name>uni2</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>repsize</name>--&gt;0</expr>;</condition> <incr><expr>++<name>uni2</name></expr></incr>)
			<expr_stmt><expr>*<name>str</name>++ = *<name>uni2</name></expr>;</expr_stmt></for>
		    <expr_stmt><expr><name>p</name> = <name>startp</name> + <name>newpos</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </default>}</block></switch>
	}</block></else></if>
    }</block></while>
    <comment type="block">/* Resize if we allocated to much */</comment>
    <expr_stmt><expr><name>respos</name> = <name>str</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>respos</name>&lt;<call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>

    <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_Translate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
			      <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
			      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><name>result</name> = <call><name>PyUnicode_TranslateCharmap</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>mapping</name></expr></argument>,
					<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* --- Decimal Encoder ---------------------------------------------------- */</comment>

<function><type><name>int</name></type> <name>PyUnicode_EncodeDecimal</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
			    <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>,
			    <param><decl><type><name>char</name> *</type><name>output</name></decl></param>,
			    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr>"decimal"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name> <init>= <expr>"invalid decimal Unicode string"</expr></init></decl>;</decl_stmt>
    <comment type="block">/* the following variable is used for caching string comparisons
     * -1=not initialized, 0=unknown, 1=strict, 2=replace, 3=ignore, 4=xmlcharrefreplace */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>known_errorHandler</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>output</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>p</name> = <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>s</name> + <name>length</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>p</name> &lt; <name>end</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>decimal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>uni2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>collstart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>collend</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>output</name>++ = ' '</expr>;</expr_stmt>
	    <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if>
	<expr_stmt><expr><name>decimal</name> = <call><name>Py_UNICODE_TODECIMAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>decimal</name> &gt;= 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>output</name>++ = '0' + <name>decimal</name></expr>;</expr_stmt>
	    <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if>
	<if>if <condition>(<expr>0 &lt; <name>ch</name> &amp;&amp; <name>ch</name> &lt; 256</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>output</name>++ = (<name>char</name>)<name>ch</name></expr>;</expr_stmt>
	    <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if>
	<comment type="block">/* All other characters are considered unencodable */</comment>
	<expr_stmt><expr><name>collstart</name> = <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>collend</name> = <name>p</name>+1</expr>;</expr_stmt>
	<while>while <condition>(<expr><name>collend</name> &lt; <name>end</name></expr>)</condition> <block>{
	    <if>if <condition>(<expr>(0 &lt; *<name>collend</name> &amp;&amp; *<name>collend</name> &lt; 256) ||
	        !<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr>*<name>collend</name></expr></argument>)</argument_list></call> ||
	        <call><name>Py_UNICODE_TODECIMAL</name><argument_list>(<argument><expr>*<name>collend</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<break>break;</break></then></if>
	}</block></while>
	<comment type="block">/* cache callback name lookup
	 * (if not done yet, i.e. it's the first error) */</comment>
	<if>if <condition>(<expr><name>known_errorHandler</name>==-1</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>(<name>errors</name>==<name>NULL</name>) || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
		<expr_stmt><expr><name>known_errorHandler</name> = 1</expr>;</expr_stmt></then>
	    <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>known_errorHandler</name> = 2</expr>;</expr_stmt></then>
	    <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>known_errorHandler</name> = 3</expr>;</expr_stmt></then>
	    <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"xmlcharrefreplace"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>known_errorHandler</name> = 4</expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><name>known_errorHandler</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
	}</block></then></if>
	<switch>switch <condition>(<expr><name>known_errorHandler</name></expr>)</condition> <block>{
	    <case>case <expr>1</expr>: <comment type="block">/* strict */</comment>
		<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>collstart</name>-<name>s</name></expr></argument>, <argument><expr><name>collend</name>-<name>s</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>onError</name>;</goto>
	    </case><case>case <expr>2</expr>: <comment type="block">/* replace */</comment>
		<for>for (<init><expr><name>p</name> = <name>collstart</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>)
		    <expr_stmt><expr>*<name>output</name>++ = '?'</expr>;</expr_stmt></for>
		<comment type="block">/* fall through */</comment>
	    </case><case>case <expr>3</expr>: <comment type="block">/* ignore */</comment>
		<expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
		<break>break;</break>
	    </case><case>case <expr>4</expr>: <comment type="block">/* xmlcharrefreplace */</comment>
		<comment type="block">/* generate replacement (temporarily (mis)uses p) */</comment>
		<for>for (<init><expr><name>p</name> = <name>collstart</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>)
		    <expr_stmt><expr><name>output</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr>"&amp;#%d;"</expr></argument>, <argument><expr>(<name>int</name>)*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
		<expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
		<break>break;</break>
	    </case><default>default:
		<expr_stmt><expr><name>repunicode</name> = <call><name>unicode_encode_call_errorhandler</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
		    <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>,
		    <argument><expr><name>collstart</name>-<name>s</name></expr></argument>, <argument><expr><name>collend</name>-<name>s</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>repunicode</name> == <name>NULL</name></expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
		<comment type="block">/* generate replacement  */</comment>
		<expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>uni2</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>repsize</name>--&gt;0</expr>;</condition> <incr><expr>++<name>uni2</name></expr></incr>) <block>{
		    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>uni2</name></expr></init></decl>;</decl_stmt>
		    <if>if <condition>(<expr><call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr>*<name>output</name>++ = ' '</expr>;</expr_stmt></then>
		    <else>else <block>{
			<expr_stmt><expr><name>decimal</name> = <call><name>Py_UNICODE_TODECIMAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>decimal</name> &gt;= 0</expr>)</condition><then>
			    <expr_stmt><expr>*<name>output</name>++ = '0' + <name>decimal</name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr>0 &lt; <name>ch</name> &amp;&amp; <name>ch</name> &lt; 256</expr>)</condition><then>
			    <expr_stmt><expr>*<name>output</name>++ = (<name>char</name>)<name>ch</name></expr>;</expr_stmt></then>
			<else>else <block>{
			    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
				<argument><expr><name>s</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>collstart</name>-<name>s</name></expr></argument>, <argument><expr><name>collend</name>-<name>s</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <goto>goto <name>onError</name>;</goto>
			}</block></else></if></else></if>
		    }</block></else></if>
		}</block></for>
		<expr_stmt><expr><name>p</name> = <name>s</name> + <name>newpos</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</default>}</block></switch>
    }</block></while>
    <comment type="block">/* 0-terminate the output string */</comment>
    <expr_stmt><expr>*<name>output</name>++ = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* --- Helpers ------------------------------------------------------------ */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/unicodedefs.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FROM_UNICODE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/fastsearch.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/count.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/partition.h"</cpp:file></cpp:include>

<comment type="block">/* helper macro to fixup start/end slice values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIX_START_END</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro>                      \
    <cpp:value>if (start &lt; 0)                              \
        start += (obj)-&gt;length;                 \
    if (start &lt; 0)                              \
        start = 0;                              \
    if (end &gt; (obj)-&gt;length)                    \
        end = (obj)-&gt;length;                    \
    if (end &lt; 0)                                \
        end += (obj)-&gt;length;                   \
    if (end &lt; 0)                                \
        end = 0;</cpp:value></cpp:define>

<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_Count</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
                           <param><decl><type><name>PyObject</name> *</type><name>substr</name></decl></param>,
                           <param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>,
                           <param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name>*</type> <name>str_obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name>*</type> <name>sub_obj</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str_obj</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str_obj</name></expr>)</condition><then>
	<return>return <expr>-1</expr>;</return></then></if>
    <expr_stmt><expr><name>sub_obj</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>sub_obj</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>FIX_START_END</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> = <call><name>stringlib_count</name><argument_list>(
        <argument><expr><name><name>str_obj</name>-&gt;<name>str</name></name> + <name>start</name></expr></argument>, <argument><expr><name>end</name> - <name>start</name></expr></argument>, <argument><expr><name><name>sub_obj</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>sub_obj</name>-&gt;<name>length</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_Find</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
                          <param><decl><type><name>PyObject</name> *</type><name>sub</name></decl></param>,
                          <param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>,
                          <param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>,
                          <param><decl><type><name>int</name></type> <name>direction</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
	<return>return <expr>-2</expr>;</return></then></if>
    <expr_stmt><expr><name>sub</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>sub</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-2</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>direction</name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>result</name> = <call><name>stringlib_find_slice</name><argument_list>(
            <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>result</name> = <call><name>stringlib_rfind_slice</name><argument_list>(
            <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt></else></if>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>int</name></type> <name>tailmatch</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
	      <param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
	      <param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>,
	      <param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>,
	      <param><decl><type><name>int</name></type> <name>direction</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then>
        <return>return <expr>1</expr>;</return></then></if>

    <expr_stmt><expr><call><name>FIX_START_END</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>end</name> -= <name><name>substring</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>end</name> &lt; <name>start</name></expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>

    <if>if <condition>(<expr><name>direction</name> &gt; 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr>1</expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr>1</expr>;</return></then></if>
    }</block></else></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_Tailmatch</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
			<param><decl><type><name>PyObject</name> *</type><name>substr</name></decl></param>,
			<param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>,
			<param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>,
			<param><decl><type><name>int</name></type> <name>direction</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr>-1</expr>;</return></then></if>
    <expr_stmt><expr><name>substr</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>substr</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>str</name></expr></argument>,
		       <argument><expr>(<name>PyUnicodeObject</name> *)<name>substr</name></expr></argument>,
		       <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Apply fixfct filter to the Unicode object self and return a
   reference to the modified object */</comment>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>fixup</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
		<param><function_decl><type><name>int</name></type> (*<name>fixfct</name>)<parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>s</name></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{

    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>fixfct</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/* fixfct should return TRUE if it modified the buffer. If
	   FALSE, return a reference to the original buffer instead
	   (to save space, not time) */</comment>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
    }</block></then></if>
    <return>return <expr>(<name>PyObject</name>*) <name>u</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixupper</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>len</name>-- &gt; 0</expr>)</condition> <block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name></type> <name>ch</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ch</name> = <call><name>Py_UNICODE_TOUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ch</name> != *<name>s</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>s</name> = <name>ch</name></expr>;</expr_stmt>
	}</block></then></if>
        <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixlower</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>len</name>-- &gt; 0</expr>)</condition> <block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name></type> <name>ch</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ch</name> = <call><name>Py_UNICODE_TOLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ch</name> != *<name>s</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>s</name> = <name>ch</name></expr>;</expr_stmt>
	}</block></then></if>
        <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixswapcase</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>len</name>-- &gt; 0</expr>)</condition> <block>{
        <if>if <condition>(<expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>s</name> = <call><name>Py_UNICODE_TOLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>s</name> = <call><name>Py_UNICODE_TOUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixcapitalize</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>s</name> = <call><name>Py_UNICODE_TOUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
    <while>while <condition>(<expr>--<name>len</name> &gt; 0</expr>)</condition> <block>{
        <if>if <condition>(<expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>s</name> = <call><name>Py_UNICODE_TOLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixtitle</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>previous_is_cased</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr><call><name>Py_UNICODE_TOTITLE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>*<name>p</name> != <name>ch</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>p</name> = <name>ch</name></expr>;</expr_stmt>
	    <return>return <expr>1</expr>;</return>
	}</block></then>
	<else>else
	    <return>return <expr>0</expr>;</return></else></if>
    }</block></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>previous_is_cased</name></expr>)</condition><then>
	    <expr_stmt><expr>*<name>p</name> = <call><name>Py_UNICODE_TOLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr>*<name>p</name> = <call><name>Py_UNICODE_TOTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> ||
	    <call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> ||
	    <call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt></else></if>
    }</block></for>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_Join</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>separator</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>internal_separator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name></type> <name>blank</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>sep</name> <init>= <expr>&amp;<name>blank</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>seplen</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* the result */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res_alloc</name> <init>= <expr>100</expr></init></decl>;</decl_stmt>  <comment type="block">/* # allocated bytes for string in res */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res_used</name></decl>;</decl_stmt>         <comment type="block">/* # used bytes */</comment>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>res_p</name></decl>;</decl_stmt>       <comment type="block">/* pointer to free byte in res's string area */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>fseq</name></decl>;</decl_stmt>          <comment type="block">/* PySequence_Fast(seq) */</comment>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>seqlen</name></decl>;</decl_stmt>              <comment type="block">/* len(fseq) -- number of items in sequence */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fseq</name> = <call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>fseq</name> == <name>NULL</name></expr>)</condition><then> <block>{
    	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Grrrr.  A codec may be invoked to convert str objects to
     * Unicode, and so it's possible to call back into Python code
     * during PyUnicode_FromObject(), and so it's possible for a sick
     * codec to change the size of fseq (if seq is a list).  Therefore
     * we have to keep refetching the size -- can't assume seqlen
     * is invariant.
     */</comment>
    <expr_stmt><expr><name>seqlen</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If empty sequence, return u"". */</comment>
    <if>if <condition>(<expr><name>seqlen</name> == 0</expr>)</condition><then> <block>{
    	<expr_stmt><expr><name>res</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* empty sequence; return u"" */</comment>
    	<goto>goto <name>Done</name>;</goto>
    }</block></then></if>
    <comment type="block">/* If singleton sequence with an exact Unicode, return that. */</comment>
    <if>if <condition>(<expr><name>seqlen</name> == 1</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>item</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>res</name> = (<name>PyUnicodeObject</name> *)<name>item</name></expr>;</expr_stmt>
	    <goto>goto <name>Done</name>;</goto>
	}</block></then></if>
    }</block></then></if>

    <comment type="block">/* At least two items to join, or one that isn't exact Unicode. */</comment>
    <if>if <condition>(<expr><name>seqlen</name> &gt; 1</expr>)</condition><then> <block>{
        <comment type="block">/* Set up sep and seplen -- they're needed. */</comment>
    	<if>if <condition>(<expr><name>separator</name> == <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>sep</name> = &amp;<name>blank</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>seplen</name> = 1</expr>;</expr_stmt>
        }</block></then>
    	<else>else <block>{
	    <expr_stmt><expr><name>internal_separator</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>internal_separator</name> == <name>NULL</name></expr>)</condition><then>
	        <goto>goto <name>onError</name>;</goto></then></if>
	    <expr_stmt><expr><name>sep</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>internal_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>seplen</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>internal_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <comment type="block">/* In case PyUnicode_FromObject() mutated seq. */</comment>
	    <expr_stmt><expr><name>seqlen</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <comment type="block">/* Get space. */</comment>
    <expr_stmt><expr><name>res</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>res_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><name>res_p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res_used</name> = 0</expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>seqlen</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>itemlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>new_res_used</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>item</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Convert item to Unicode. */</comment>
	<if>if <condition>(<expr>! <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> &amp;&amp; ! <call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			 <argument><expr>"sequence item %zd: expected string or Unicode,"
			 " %.80s found"</expr></argument>,
			 <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <goto>goto <name>onError</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>item</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<comment type="block">/* We own a reference to item from here on. */</comment>

	<comment type="block">/* In case PyUnicode_FromObject() mutated seq. */</comment>
	<expr_stmt><expr><name>seqlen</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make sure we have enough space for the separator and the item. */</comment>
	<expr_stmt><expr><name>itemlen</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_res_used</name> = <name>res_used</name> + <name>itemlen</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>new_res_used</name> &lt; 0</expr>)</condition><then>
	    <goto>goto <name>Overflow</name>;</goto></then></if>
	<if>if <condition>(<expr><name>i</name> &lt; <name>seqlen</name> - 1</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>new_res_used</name> += <name>seplen</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>new_res_used</name> &lt; 0</expr>)</condition><then>
		<goto>goto <name>Overflow</name>;</goto></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>new_res_used</name> &gt; <name>res_alloc</name></expr>)</condition><then> <block>{
	    <comment type="block">/* double allocated size until it's big enough */</comment>
	    <do>do <block>{
	        <expr_stmt><expr><name>res_alloc</name> += <name>res_alloc</name></expr>;</expr_stmt>
	        <if>if <condition>(<expr><name>res_alloc</name> &lt;= 0</expr>)</condition><then>
	            <goto>goto <name>Overflow</name>;</goto></then></if>
	    }</block> while <condition>(<expr><name>new_res_used</name> &gt; <name>res_alloc</name></expr>)</condition>;</do>
	    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>res_alloc</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>onError</name>;</goto>
	    }</block></then></if>
            <expr_stmt><expr><name>res_p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> + <name>res_used</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Copy item, and maybe the separator. */</comment>
	<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>res_p</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>itemlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res_p</name> += <name>itemlen</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; <name>seqlen</name> - 1</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>res_p</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>res_p</name> += <name>seplen</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res_used</name> = <name>new_res_used</name></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* Shrink res to match the used area; this probably can't fail,
     * but it's cheap to check.
     */</comment>
    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>res_used</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>

 <label><name>Done</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>internal_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>res</name></expr>;</return>

 <label><name>Overflow</name>:</label>
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
                    <argument><expr>"join() result is too long for a Python string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* fall through */</comment>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>internal_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>PyUnicodeObject</name> *</type><name>pad</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
		     <param><decl><type><name>Py_ssize_t</name></type> <name>left</name></decl></param>,
		     <param><decl><type><name>Py_ssize_t</name></type> <name>right</name></decl></param>,
		     <param><decl><type><name>Py_UNICODE</name></type> <name>fill</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>left</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>left</name> = 0</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>right</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>right</name> = 0</expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>left</name> == 0 &amp;&amp; <name>right</name> == 0 &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>self</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>left</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name><name>self</name>-&gt;<name>length</name></name> ||
        <name>right</name> &gt; <name>PY_SSIZE_T_MAX</name> - (<name>left</name> + <name><name>self</name>-&gt;<name>length</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"padded string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>u</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>left</name> + <name><name>self</name>-&gt;<name>length</name></name> + <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>u</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>left</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>Py_UNICODE_FILL</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name> + <name>left</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>right</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>Py_UNICODE_FILL</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name> + <name>left</name> + <name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <return>return <expr><name>u</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_APPEND</name><parameter_list>(<param><type><name>data</name></type></param>, <param><type><name>left</name></type></param>, <param><type><name>right</name></type></param>)</parameter_list></cpp:macro>					\
	<cpp:value>str = PyUnicode_FromUnicode((data) + (left), (right) - (left));	\
	if (!str)							\
	    goto onError;						\
	if (PyList_Append(list, str)) {					\
	    Py_DECREF(str);						\
	    goto onError;						\
	}								\
        else								\
            Py_DECREF(str);</cpp:value></cpp:define>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>split_whitespace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
			   <param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
			   <param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>buf</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr/>) <block>{
	<comment type="block">/* find a token */</comment>
	<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
	<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; !<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr><name>j</name> &lt; <name>i</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
	    <expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>
    <if>if <condition>(<expr><name>j</name> &lt; <name>len</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_Splitlines</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>string</name></decl></param>,
			       <param><decl><type><name>int</name></type> <name>keepends</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>data</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>string</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>string</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>data</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

    <for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr/>) <block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>eol</name></decl>;</decl_stmt>

	<comment type="block">/* Find a line and append it */</comment>
	<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; !<call><name>BLOOM_LINEBREAK</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>

	<comment type="block">/* Skip the line break reading CRLF as one line break */</comment>
	<expr_stmt><expr><name>eol</name> = <name>i</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> == '\r' &amp;&amp; <name>i</name> + 1 &lt; <name>len</name> &amp;&amp;
		<name><name>data</name><index>[<expr><name>i</name>+1</expr>]</index></name> == '\n'</expr>)</condition><then>
		<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if>
	    <if>if <condition>(<expr><name>keepends</name></expr>)</condition><then>
		<expr_stmt><expr><name>eol</name> = <name>i</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
    }</block></for>
    <if>if <condition>(<expr><name>j</name> &lt; <name>len</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>split_char</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
		     <param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
		     <param><decl><type><name>Py_UNICODE</name></type> <name>ch</name></decl></param>,
		     <param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>buf</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr/>) <block>{
	<if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> == <name>ch</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>i</name> = <name>j</name> = <name>i</name> + 1</expr>;</expr_stmt>
	}</block></then> <else>else
	    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if>
    }</block></for>
    <if>if <condition>(<expr><name>j</name> &lt;= <name>len</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>split_substring</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
			  <param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
			  <param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
			  <param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sublen</name> <init>= <expr><name><name>substring</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>len</name> - <name>sublen</name></expr>;</condition> <incr/>) <block>{
	<if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>i</name> = <name>j</name> = <name>i</name> + <name>sublen</name></expr>;</expr_stmt>
	}</block></then> <else>else
	    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if>
    }</block></for>
    <if>if <condition>(<expr><name>j</name> &lt;= <name>len</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>rsplit_whitespace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
			    <param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
			    <param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>buf</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = <name>j</name> = <name>len</name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
	<comment type="block">/* find a token */</comment>
	<while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	    <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
	<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; !<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	    <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
	<if>if <condition>(<expr><name>j</name> &gt; <name>i</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
	    <expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>
    <if>if <condition>(<expr><name>j</name> &gt;= 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> 
<name>PyObject</name> *</type><name>rsplit_char</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
		      <param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
		      <param><decl><type><name>Py_UNICODE</name></type> <name>ch</name></decl></param>,
		      <param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>buf</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = <name>j</name> = <name>len</name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
	<if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> == <name>ch</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>j</name> = <name>i</name> = <name>i</name> - 1</expr>;</expr_stmt>
	}</block></then> <else>else
	    <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></else></if>
    }</block></for>
    <if>if <condition>(<expr><name>j</name> &gt;= -1</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> 
<name>PyObject</name> *</type><name>rsplit_substring</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
			   <param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
			   <param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
			   <param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sublen</name> <init>= <expr><name><name>substring</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = <name>len</name> - <name>sublen</name></expr>, <expr><name>j</name> = <name>len</name></expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
	<if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>i</name> + <name>sublen</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>i</name> -= <name>sublen</name></expr>;</expr_stmt>
	}</block></then> <else>else
	    <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></else></if>
    }</block></for>
    <if>if <condition>(<expr><name>j</name> &gt;= 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <return>return <expr><name>list</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SPLIT_APPEND</name></cpp:undef>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>split</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
		<param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
		<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>maxcount</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>maxcount</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><call><name>split_whitespace</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>

    <else>else <if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 1</expr>)</condition><then>
	<return>return <expr><call><name>split_char</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name><name>substring</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>

    <else>else <if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then>
    <else>else
	<return>return <expr><call><name>split_substring</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>substring</name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>rsplit</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
		 <param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>maxcount</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>maxcount</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><call><name>rsplit_whitespace</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>

    <else>else <if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 1</expr>)</condition><then>
	<return>return <expr><call><name>rsplit_char</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name><name>substring</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>

    <else>else <if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then>
    <else>else
	<return>return <expr><call><name>rsplit_substring</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>substring</name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>replace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
		  <param><decl><type><name>PyUnicodeObject</name> *</type><name>str1</name></decl></param>,
		  <param><decl><type><name>PyUnicodeObject</name> *</type><name>str2</name></decl></param>,
		  <param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>maxcount</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>maxcount</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name><name>str1</name>-&gt;<name>length</name></name> == <name><name>str2</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* same length */</comment>
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>str1</name>-&gt;<name>length</name></name> == 1</expr>)</condition><then> <block>{
            <comment type="block">/* replace characters */</comment>
            <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>u1</name></decl>, <decl><type ref="prev"/><name>u2</name></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name>findchar</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>nothing</name>;</goto></then></if>
            <expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>u1</name> = <name><name>str1</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>u2</name> = <name><name>str2</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>u</name>-&gt;<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <if>if <condition>(<expr><name><name>u</name>-&gt;<name>str</name><index>[<expr><name>i</name></expr>]</index></name> == <name>u1</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>--<name>maxcount</name> &lt; 0</expr>)</condition><then>
                        <break>break;</break></then></if>
                    <expr_stmt><expr><name><name>u</name>-&gt;<name>str</name><index>[<expr><name>i</name></expr>]</index></name> = <name>u2</name></expr>;</expr_stmt>
                }</block></then></if></for>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>i</name> = <call><name>fastsearch</name><argument_list>(
                <argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name>FAST_SEARCH</name></expr></argument>
                )</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
                <goto>goto <name>nothing</name>;</goto></then></if>
            <expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>i</name> &lt;= <name><name>self</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name></expr>)</condition>
                <if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>--<name>maxcount</name> &lt; 0</expr>)</condition><then>
                        <break>break;</break></then></if>
                    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name>+<name>i</name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>i</name> += <name><name>str1</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                }</block></then> <else>else
                    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if></while>
        }</block></else></if>
    }</block></then> <else>else <block>{

        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>product</name></decl>, <decl><type ref="prev"/><name>new_size</name></decl>, <decl><type ref="prev"/><name>delta</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>

        <comment type="block">/* replace strings */</comment>
        <expr_stmt><expr><name>n</name> = <call><name>stringlib_count</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>n</name> &gt; <name>maxcount</name></expr>)</condition><then>
            <expr_stmt><expr><name>n</name> = <name>maxcount</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
            <goto>goto <name>nothing</name>;</goto></then></if>
        <comment type="block">/* new_size = self-&gt;length + n * (str2-&gt;length - str1-&gt;length)); */</comment>
        <expr_stmt><expr><name>delta</name> = (<name><name>str2</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name>)</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>delta</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>new_size</name> = <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>product</name> = <call><name>n</name> * <argument_list>(<argument><expr><name><name>str2</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>product</name> / (<name><name>str2</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name>)) != <name>n</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
                                <argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>new_size</name> = <name><name>self</name>-&gt;<name>length</name></name> + <name>product</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>new_size</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
                                <argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
        }</block></else></if>
        <expr_stmt><expr><name>u</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> = <name><name>u</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>e</name> = <name><name>self</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>str1</name>-&gt;<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>n</name>-- &gt; 0</expr>)</condition> <block>{
                <comment type="block">/* look for next match */</comment>
                <expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
                <while>while <condition>(<expr><name>j</name> &lt;= <name>e</name></expr>)</condition> <block>{
                    <if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <break>break;</break></then></if>
                    <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
                }</block></while>
		<if>if <condition>(<expr><name>j</name> &gt; <name>i</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>j</name> &gt; <name>e</name></expr>)</condition><then>
                        <break>break;</break></then></if>
                    <comment type="block">/* copy unchanged part [i:j] */</comment>
                    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name>+<name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>p</name> += <name>j</name> - <name>i</name></expr>;</expr_stmt>
                }</block></then></if>
                <comment type="block">/* copy substitution string */</comment>
                <if>if <condition>(<expr><name><name>str2</name>-&gt;<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>p</name> += <name><name>str2</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>i</name> = <name>j</name> + <name><name>str1</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            }</block></while>
            <if>if <condition>(<expr><name>i</name> &lt; <name><name>self</name>-&gt;<name>length</name></name></expr>)</condition><then>
                <comment type="block">/* copy tail [i:] */</comment>
                <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name>+<name>i</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then> <else>else <block>{
            <comment type="block">/* interleave */</comment>
            <while>while <condition>(<expr><name>n</name> &gt; 0</expr>)</condition> <block>{
                <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name> += <name><name>str2</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>--<name>n</name> &lt;= 0</expr>)</condition><then>
                    <break>break;</break></then></if>
                <expr_stmt><expr>*<name>p</name>++ = <name><name>self</name>-&gt;<name>str</name><index>[<expr><name>i</name>++</expr>]</index></name></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name>+<name>i</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>
    <return>return <expr>(<name>PyObject</name> *) <name>u</name></expr>;</return>

<label><name>nothing</name>:</label>
    <comment type="block">/* nothing to replace; return original string (when possible) */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name> *) <name>self</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- Unicode Object Methods --------------------------------------------- */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>title__doc__</name></expr></argument>,
<argument><expr>"S.title() -&gt; unicode\n\
\n\
Return a titlecased version of S, i.e. words start with title case\n\
characters, all remaining cased characters have lower case."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_title</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixtitle</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>capitalize__doc__</name></expr></argument>,
<argument><expr>"S.capitalize() -&gt; unicode\n\
\n\
Return a capitalized version of S, i.e. make the first character\n\
have upper case."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_capitalize</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixcapitalize</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
PyDoc_STRVAR(capwords__doc__,
"S.capwords() -&gt; unicode\n\
\n\
Apply .capitalize() to all words in S and return the result with\n\
normalized whitespace (all whitespace strings are replaced by ' ').");

static PyObject*
unicode_capwords(PyUnicodeObject *self)
{
    PyObject *list;
    PyObject *item;
    Py_ssize_t i;

    <comment type="block">/* Split into words */</comment>
    list = split(self, NULL, -1);
    if (!list)
        return NULL;

    <comment type="block">/* Capitalize each word */</comment>
    for (i = 0; i &lt; PyList_GET_SIZE(list); i++) {
        item = fixup((PyUnicodeObject *)PyList_GET_ITEM(list, i),
		     fixcapitalize);
        if (item == NULL)
            goto onError;
        Py_DECREF(PyList_GET_ITEM(list, i));
        PyList_SET_ITEM(list, i, item);
    }

    <comment type="block">/* Join the words to form a new string */</comment>
    item = PyUnicode_Join(NULL, list);

onError:
    Py_DECREF(list);
    return (PyObject *)item;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Argument converter.  Coerces to a single unicode character */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_uc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>void</name> *</type><name>addr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>fillcharloc</name> <init>= <expr>(<name>Py_UNICODE</name> *)<name>addr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>uniobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>unistr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>uniobj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>uniobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"The fill character cannot be converted to Unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>uniobj</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"The fill character must be exactly one character long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>uniobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>unistr</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>uniobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>fillcharloc</name> = <name><name>unistr</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>uniobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>center__doc__</name></expr></argument>,
<argument><expr>"S.center(width[, fillchar]) -&gt; unicode\n\
\n\
Return S centered in a Unicode string of length width. Padding is\n\
done using the specified fill character (default is a space)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_center</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>marg</name></decl>, <decl><type ref="prev"/><name>left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|O&amp;:center"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr><name>convert_uc</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>length</name></name> &gt;= <name>width</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>marg</name> = <name>width</name> - <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>left</name> = <name>marg</name> / 2 + (<name>marg</name> &amp; <name>width</name> &amp; 1)</expr>;</expr_stmt>

    <return>return <expr>(<name>PyObject</name>*) <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>marg</name> - <name>left</name></expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>

<comment type="block">/* This code should go into some future Unicode collation support
   module. The basic comparison should compare ordinals on a naive
   basis (this is what Java does and thus JPython too). */</comment>

<comment type="block">/* speedy UTF-16 code point order comparison */</comment>
<comment type="block">/* gleaned from: */</comment>
<comment type="block">/* http://www-4.ibm.com/software/developer/library/utf16.html?dwzone=unicode */</comment>

static short utf16Fixup[32] =
{
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0x2000, -0x800, -0x800, -0x800, -0x800
};

static int
unicode_compare(PyUnicodeObject *str1, PyUnicodeObject *str2)
{
    Py_ssize_t len1, len2;

    Py_UNICODE *s1 = str1-&gt;str;
    Py_UNICODE *s2 = str2-&gt;str;

    len1 = str1-&gt;length;
    len2 = str2-&gt;length;

    while (len1 &gt; 0 &amp;&amp; len2 &gt; 0) {
        Py_UNICODE c1, c2;

        c1 = *s1++;
        c2 = *s2++;

	if (c1 &gt; (1&lt;&lt;11) * 26)
	    c1 += utf16Fixup[c1&gt;&gt;11];
	if (c2 &gt; (1&lt;&lt;11) * 26)
            c2 += utf16Fixup[c2&gt;&gt;11];
        <comment type="block">/* now c1 and c2 are in UTF-32-compatible order */</comment>

        if (c1 != c2)
            return (c1 &lt; c2) ? -1 : 1;

        len1--; len2--;
    }

    return (len1 &lt; len2) ? -1 : (len1 != len2);
}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>unicode_compare</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>str1</name></decl></param>, <param><decl><type><name>PyUnicodeObject</name> *</type><name>str2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s1</name> <init>= <expr><name><name>str1</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s2</name> <init>= <expr><name><name>str2</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>len1</name> = <name><name>str1</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len2</name> = <name><name>str2</name>-&gt;<name>length</name></name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>len1</name> &gt; 0 &amp;&amp; <name>len2</name> &gt; 0</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>c1</name> = *<name>s1</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>c2</name> = *<name>s2</name>++</expr>;</expr_stmt>

        <if>if <condition>(<expr><name>c1</name> != <name>c2</name></expr>)</condition><then>
            <return>return <expr>(<name>c1</name> &lt; <name>c2</name>) ? -1 : 1</expr>;</return></then></if>

        <expr_stmt><expr><name>len1</name>--</expr>;</expr_stmt> <expr_stmt><expr><name>len2</name>--</expr>;</expr_stmt>
    }</block></while>

    <return>return <expr>(<name>len1</name> &lt; <name>len2</name>) ? -1 : (<name>len1</name> != <name>len2</name>)</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>PyUnicode_Compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>,
		      <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name> <init>= <expr><name>NULL</name></expr></init>, *<name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Coerce the two arguments */</comment>
    <expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><name>v</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>

    <comment type="block">/* Shortcut for empty or interned objects */</comment>
    <if>if <condition>(<expr><name>v</name> == <name>u</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>unicode_compare</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>

<label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_RichCompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>,
                                <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>,
                                <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> = <call><name>PyUnicode_Compare</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>result</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>

    <comment type="block">/* Convert the return value to a Boolean */</comment>
    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
    <case>case <expr><name>Py_EQ</name></expr>:
        <expr_stmt><expr><name>result</name> = (<name>result</name> == 0)</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>Py_NE</name></expr>:
        <expr_stmt><expr><name>result</name> = (<name>result</name> != 0)</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>Py_LE</name></expr>:
        <expr_stmt><expr><name>result</name> = (<name>result</name> &lt;= 0)</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>Py_GE</name></expr>:
        <expr_stmt><expr><name>result</name> = (<name>result</name> &gt;= 0)</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>Py_LT</name></expr>:
        <expr_stmt><expr><name>result</name> = (<name>result</name> == -1)</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>Py_GT</name></expr>:
        <expr_stmt><expr><name>result</name> = (<name>result</name> == 1)</expr>;</expr_stmt>
        <break>break;</break>
    </case>}</block></switch>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>

 <label><name>onError</name>:</label>

    <comment type="block">/* Standard case

       Type errors mean that PyUnicode_FromObject() could not convert
       one of the arguments (usually the right hand side) to Unicode,
       ie. we can't handle the comparison request. However, it is
       possible that the other object knows a comparison method, which
       is why we return Py_NotImplemented to give the other object a
       chance.

    */</comment>
    <if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Py_NotImplemented</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>op</name> != <name>Py_EQ</name> &amp;&amp; <name>op</name> != <name>Py_NE</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Equality comparison.

       This is a special case: we silence any PyExc_UnicodeDecodeError
       and instead turn it into a PyErr_UnicodeWarning.

    */</comment>
    <if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_UnicodeDecodeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_UnicodeWarning</name></expr></argument>, 
                   <argument><expr>(<name>op</name> == <name>Py_EQ</name>) ? 
                   "Unicode equal comparison "
                   "failed to convert both arguments to Unicode - "
                   "interpreting them as being unequal" :
                   "Unicode unequal comparison "
                   "failed to convert both arguments to Unicode - "
                   "interpreting them as being unequal"</expr></argument>
                   )</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>result</name> = (<name>op</name> == <name>Py_NE</name>)</expr>;</expr_stmt>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>PyUnicode_Contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>container</name></decl></param>,
		       <param><decl><type><name>PyObject</name> *</type><name>element</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>sub</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Coerce the two arguments */</comment>
    <expr_stmt><expr><name>sub</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>sub</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
	    <argument><expr>"'in &lt;string&gt;' requires string as left operand"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>stringlib_contains_obj</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Concat to string or Unicode object giving a new Unicode object. */</comment>

<function><type><name>PyObject</name> *</type><name>PyUnicode_Concat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>,
			   <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name> <init>= <expr><name>NULL</name></expr></init>, *<name>v</name> <init>= <expr><name>NULL</name></expr></init>, *<name>w</name></decl>;</decl_stmt>

    <comment type="block">/* Coerce the two arguments */</comment>
    <expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><name>v</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>

    <comment type="block">/* Shortcuts */</comment>
    <if>if <condition>(<expr><name>v</name> == <name>unicode_empty</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>u</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>u</name> == <name>unicode_empty</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Concat the two Unicode strings */</comment>
    <expr_stmt><expr><name>w</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>length</name></name> + <name><name>v</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>u</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>str</name></name> + <name><name>u</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>w</name></expr>;</return>

<label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>count__doc__</name></expr></argument>,
<argument><expr>"S.count(sub[, start[, end]]) -&gt; int\n\
\n\
Return the number of non-overlapping occurrences of substring sub in\n\
Unicode string S[start:end].  Optional arguments start and end are\n\
interpreted as in slice notation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_count</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:count"</expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>,
		<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(
        <argument><expr>(<name>PyObject</name> *)<name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>FIX_START_END</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(
        <argument><expr><call><name>stringlib_count</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name> + <name>start</name></expr></argument>, <argument><expr><name>end</name> - <name>start</name></expr></argument>,
                        <argument><expr><name><name>substring</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>substring</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>encode__doc__</name></expr></argument>,
<argument><expr>"S.encode([encoding[,errors]]) -&gt; string or unicode\n\
\n\
Encodes S using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n\
'xmlcharrefreplace' as well as any other name registered with\n\
codecs.register_error that can handle UnicodeEncodeErrors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_encode</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|ss:encode"</expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"encoder did not return a string/unicode object "
                     "(type=%.400s)"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>decode__doc__</name></expr></argument>,
<argument><expr>"S.decode([encoding[,errors]]) -&gt; string or unicode\n\
\n\
Decodes S using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n\
as well as any other name registerd with codecs.register_error that is\n\
able to handle UnicodeDecodeErrors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_decode</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|ss:decode"</expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsDecodedObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"decoder did not return a string/unicode object "
                     "(type=%.400s)"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>v</name></expr>;</return>

 <label><name>onError</name>:</label>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>expandtabs__doc__</name></expr></argument>,
<argument><expr>"S.expandtabs([tabsize]) -&gt; unicode\n\
\n\
Return a copy of S where all tab characters are expanded using spaces.\n\
If tabsize is not given, a tab size of 8 characters is assumed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_expandtabs</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>q</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>qe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>incr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tabsize</name> <init>= <expr>8</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:expandtabs"</expr></argument>, <argument><expr>&amp;<name>tabsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* First pass: determine size of output string */</comment>
    <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt> <comment type="block">/* chars up to and including most recent \n or \r */</comment>
    <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt> <comment type="block">/* chars since most recent \n or \r (use in tab calculations) */</comment>
    <expr_stmt><expr><name>e</name> = <name><name>self</name>-&gt;<name>str</name></name> + <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt> <comment type="block">/* end of input */</comment>
    <for>for (<init><expr><name>p</name> = <name><name>self</name>-&gt;<name>str</name></name></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
        <if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>tabsize</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>incr</name> = <name>tabsize</name> - (<name>j</name> % <name>tabsize</name>)</expr>;</expr_stmt> <comment type="block">/* cannot overflow */</comment>
		<if>if <condition>(<expr><name>j</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>incr</name></expr>)</condition><then>
		    <goto>goto <name>overflow1</name>;</goto></then></if>
		<expr_stmt><expr><name>j</name> += <name>incr</name></expr>;</expr_stmt>
            }</block></then></if>
	}</block></then>
        <else>else <block>{
	    <if>if <condition>(<expr><name>j</name> &gt; <name>PY_SSIZE_T_MAX</name> - 1</expr>)</condition><then>
		<goto>goto <name>overflow1</name>;</goto></then></if>
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr>*<name>p</name> == '\n' || *<name>p</name> == '\r'</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>j</name></expr>)</condition><then>
		    <goto>goto <name>overflow1</name>;</goto></then></if>
                <expr_stmt><expr><name>i</name> += <name>j</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if></for>

    <if>if <condition>(<expr><name>i</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>j</name></expr>)</condition><then>
	<goto>goto <name>overflow1</name>;</goto></then></if>

    <comment type="block">/* Second pass: create output string and fill it */</comment>
    <expr_stmt><expr><name>u</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>i</name> + <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt> <comment type="block">/* same as in first pass */</comment>
    <expr_stmt><expr><name>q</name> = <name><name>u</name>-&gt;<name>str</name></name></expr>;</expr_stmt> <comment type="block">/* next output char */</comment>
    <expr_stmt><expr><name>qe</name> = <name><name>u</name>-&gt;<name>str</name></name> + <name><name>u</name>-&gt;<name>length</name></name></expr>;</expr_stmt> <comment type="block">/* end of output */</comment>

    <for>for (<init><expr><name>p</name> = <name><name>self</name>-&gt;<name>str</name></name></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
        <if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>tabsize</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name> = <name>tabsize</name> - (<name>j</name> % <name>tabsize</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> += <name>i</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name>--</expr>)</condition> <block>{
		    <if>if <condition>(<expr><name>q</name> &gt;= <name>qe</name></expr>)</condition><then>
			<goto>goto <name>overflow2</name>;</goto></then></if>
		    <expr_stmt><expr>*<name>q</name>++ = ' '</expr>;</expr_stmt>
                }</block></while>
	    }</block></then></if>
	}</block></then>
	<else>else <block>{
	    <if>if <condition>(<expr><name>q</name> &gt;= <name>qe</name></expr>)</condition><then>
		<goto>goto <name>overflow2</name>;</goto></then></if>
	    <expr_stmt><expr>*<name>q</name>++ = *<name>p</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr>*<name>p</name> == '\n' || *<name>p</name> == '\r'</expr>)</condition><then>
                <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt></then></if>
        }</block></else></if></for>

    <return>return <expr>(<name>PyObject</name>*) <name>u</name></expr>;</return>

  <label><name>overflow2</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>overflow1</name>:</label>
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"new string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>find__doc__</name></expr></argument>,
<argument><expr>"S.find(sub [,start [,end]]) -&gt; int\n\
\n\
Return the lowest index in S where substring sub is found,\n\
such that sub is contained within s[start:end].  Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_find</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>_ParseTupleFinds</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>stringlib_find_slice</name><argument_list>(
        <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_getitem</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>index</name> &lt; 0 || <name>index</name> &gt;= <name><name>self</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"string index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr>(<name>PyObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>str</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>unicode_hash</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Since Unicode objects compare equal to their ASCII string
       counterparts, they should use the individual character values
       as basis for their hash value.  This is needed to assure that
       strings and Unicode objects behave in the same way as
       dictionary keys. */</comment>

    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>hash</name></name> != -1</expr>)</condition><then>
	<return>return <expr><name><name>self</name>-&gt;<name>hash</name></name></expr>;</return></then></if>
    <expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> = *<name>p</name> &lt;&lt; 7</expr>;</expr_stmt>
    <while>while <condition>(<expr>--<name>len</name> &gt;= 0</expr>)</condition>
	<expr_stmt><expr><name>x</name> = (1000003*<name>x</name>) ^ *<name>p</name>++</expr>;</expr_stmt></while>
    <expr_stmt><expr><name>x</name> ^= <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
	<expr_stmt><expr><name>x</name> = -2</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>hash</name></name> = <name>x</name></expr>;</expr_stmt>
    <return>return <expr><name>x</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>index__doc__</name></expr></argument>,
<argument><expr>"S.index(sub [,start [,end]]) -&gt; int\n\
\n\
Like S.find() but raise ValueError when the substring is not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_index</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>_ParseTupleFinds</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>stringlib_find_slice</name><argument_list>(
        <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"substring not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>islower__doc__</name></expr></argument>,
<argument><expr>"S.islower() -&gt; bool\n\
\n\
Return True if all cased characters in S are lowercase and there is\n\
at least one cased character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_islower</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> || <call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr>!<name>cased</name> &amp;&amp; <call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt></then></if></else></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isupper__doc__</name></expr></argument>,
<argument><expr>"S.isupper() -&gt; bool\n\
\n\
Return True if all cased characters in S are uppercase and there is\n\
at least one cased character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isupper</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != 0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> || <call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr>!<name>cased</name> &amp;&amp; <call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt></then></if></else></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>istitle__doc__</name></expr></argument>,
<argument><expr>"S.istitle() -&gt; bool\n\
\n\
Return True if S is a titlecased string and there is at least one\n\
character in S, i.e. upper- and titlecase characters may only\n\
follow uncased characters and lowercase characters only cased ones.\n\
Return False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_istitle</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>, <decl><type ref="prev"/><name>previous_is_cased</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != 0) ||
			       (<call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != 0)</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> || <call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>previous_is_cased</name></expr>)</condition><then>
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	    <expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>!<name>previous_is_cased</name></expr>)</condition><then>
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	    <expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else
	    <expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt></else></if></else></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isspace__doc__</name></expr></argument>,
<argument><expr>"S.isspace() -&gt; bool\n\
\n\
Return True if all characters in S are whitespace\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isspace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isalpha__doc__</name></expr></argument>,
<argument><expr>"S.isalpha() -&gt; bool\n\
\n\
Return True if all characters in S are alphabetic\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isalpha</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>Py_UNICODE_ISALPHA</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISALPHA</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isalnum__doc__</name></expr></argument>,
<argument><expr>"S.isalnum() -&gt; bool\n\
\n\
Return True if all characters in S are alphanumeric\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isalnum</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>Py_UNICODE_ISALNUM</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISALNUM</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isdecimal__doc__</name></expr></argument>,
<argument><expr>"S.isdecimal() -&gt; bool\n\
\n\
Return True if there are only decimal characters in S,\n\
False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isdecimal</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>Py_UNICODE_ISDECIMAL</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISDECIMAL</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isdigit__doc__</name></expr></argument>,
<argument><expr>"S.isdigit() -&gt; bool\n\
\n\
Return True if all characters in S are digits\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isdigit</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>Py_UNICODE_ISDIGIT</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISDIGIT</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isnumeric__doc__</name></expr></argument>,
<argument><expr>"S.isnumeric() -&gt; bool\n\
\n\
Return True if there are only numeric characters in S,\n\
False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isnumeric</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Shortcut for single character strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	<call><name>Py_UNICODE_ISNUMERIC</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Special case for empty strings */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISNUMERIC</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>join__doc__</name></expr></argument>,
<argument><expr>"S.join(sequence) -&gt; unicode\n\
\n\
Return a string which is the concatenation of the strings in the\n\
sequence.  The separator between elements is S."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_join</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_Join</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>unicode_length</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name><name>self</name>-&gt;<name>length</name></name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ljust__doc__</name></expr></argument>,
<argument><expr>"S.ljust(width[, fillchar]) -&gt; int\n\
\n\
Return S left-justified in a Unicode string of length width. Padding is\n\
done using the specified fill character (default is a space)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_ljust</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|O&amp;:ljust"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr><name>convert_uc</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>length</name></name> &gt;= <name>width</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
    }</block></then></if>

    <return>return <expr>(<name>PyObject</name>*) <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>width</name> - <name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lower__doc__</name></expr></argument>,
<argument><expr>"S.lower() -&gt; unicode\n\
\n\
Return a copy of the string S converted to lowercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_lower</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixlower</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFTSTRIP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHTSTRIP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOTHSTRIP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* Arrays indexed by above */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>stripformat</name><index>[]</index></name> <init>= <expr><block>{<expr>"|O:lstrip"</expr>, <expr>"|O:rstrip"</expr>, <expr>"|O:strip"</expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRIPNAME</name><parameter_list>(<param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(stripformat[i]+3)</cpp:value></cpp:define>

<comment type="block">/* externally visible for str.strip(unicode) */</comment>
<function><type><name>PyObject</name> *</type>
<name>_PyUnicode_XStrip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>striptype</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sepobj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>sep</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sepobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>seplen</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sepobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>BLOOM_MASK</name></type> <name>sepmask</name> <init>= <expr><call><name>make_bloom_mask</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>striptype</name> != <name>RIGHTSTRIP</name></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>BLOOM_MEMBER</name><argument_list>(<argument><expr><name>sepmask</name></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
            }</block></while>
	}</block></then></if>

	<expr_stmt><expr><name>j</name> = <name>len</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>striptype</name> != <name>LEFTSTRIP</name></expr>)</condition><then> <block>{
            <do>do <block>{
                <expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>j</name> &gt;= <name>i</name> &amp;&amp; <call><name>BLOOM_MEMBER</name><argument_list>(<argument><expr><name>sepmask</name></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; <name>j</name> == <name>len</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
	}</block></then>
	<else>else
            <return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_strip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>striptype</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>striptype</name> != <name>RIGHTSTRIP</name></expr>)</condition><then> <block>{
		<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>

	<expr_stmt><expr><name>j</name> = <name>len</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>striptype</name> != <name>LEFTSTRIP</name></expr>)</condition><then> <block>{
		<do>do <block>{
			<expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
		}</block> while <condition>(<expr><name>j</name> &gt;= <name>i</name> &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; <name>j</name> == <name>len</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_argstrip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>striptype</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>(<name>char</name> *)<name><name>stripformat</name><index>[<expr><name>striptype</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>sep</name> != <name>NULL</name> &amp;&amp; <name>sep</name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>_PyUnicode_XStrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>striptype</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>sep</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>sep</name>==<name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><name>res</name> = <call><name>_PyUnicode_XStrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>striptype</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"%s arg must be None, unicode or str"</expr></argument>,
				     <argument><expr><call><name>STRIPNAME</name><argument_list>(<argument><expr><name>striptype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></else></if></else></if>
	}</block></then></if>

	<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>striptype</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>strip__doc__</name></expr></argument>,
<argument><expr>"S.strip([chars]) -&gt; unicode\n\
\n\
Return a copy of the string S with leading and trailing\n\
whitespace removed.\n\
If chars is given and not None, remove characters in chars instead.\n\
If chars is a str, it will be converted to unicode before stripping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_strip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>BOTHSTRIP</name></expr></argument>)</argument_list></call></expr>;</return></then> <comment type="block">/* Common case */</comment>
	<else>else
		<return>return <expr><call><name>do_argstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>BOTHSTRIP</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lstrip__doc__</name></expr></argument>,
<argument><expr>"S.lstrip([chars]) -&gt; unicode\n\
\n\
Return a copy of the string S with leading whitespace removed.\n\
If chars is given and not None, remove characters in chars instead.\n\
If chars is a str, it will be converted to unicode before stripping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_lstrip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>LEFTSTRIP</name></expr></argument>)</argument_list></call></expr>;</return></then> <comment type="block">/* Common case */</comment>
	<else>else
		<return>return <expr><call><name>do_argstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>LEFTSTRIP</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rstrip__doc__</name></expr></argument>,
<argument><expr>"S.rstrip([chars]) -&gt; unicode\n\
\n\
Return a copy of the string S with trailing whitespace removed.\n\
If chars is given and not None, remove characters in chars instead.\n\
If chars is a str, it will be converted to unicode before stripping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_rstrip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>RIGHTSTRIP</name></expr></argument>)</argument_list></call></expr>;</return></then> <comment type="block">/* Common case */</comment>
	<else>else
		<return>return <expr><call><name>do_argstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>RIGHTSTRIP</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_repeat</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>str</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nchars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* no repeat, return original string */</comment>
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name>*) <name>str</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* ensure # of chars needed doesn't overflow int and # of bytes
     * needed doesn't overflow size_t
     */</comment>
    <expr_stmt><expr><name>nchars</name> = <name>len</name> * <name><name>str</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len</name> &amp;&amp; <name>nchars</name> / <name>len</name> != <name><name>str</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
                        <argument><expr>"repeated string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>nbytes</name> = (<name>nchars</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nbytes</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> != <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>nchars</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
                        <argument><expr>"repeated string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>u</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>nchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>p</name> = <name><name>u</name>-&gt;<name>str</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>str</name>-&gt;<name>length</name></name> == 1 &amp;&amp; <name>len</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_UNICODE_FILL</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>done</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* number of characters copied this far */</comment>
	<if>if <condition>(<expr><name>done</name> &lt; <name>nchars</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>done</name> = <name><name>str</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
	}</block></then></if>
	<while>while <condition>(<expr><name>done</name> &lt; <name>nchars</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>(<name>done</name> &lt;= <name>nchars</name>-<name>done</name>) ? <name>done</name> : <name>nchars</name>-<name>done</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name>+<name>done</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>done</name> += <name>n</name></expr>;</expr_stmt>
	}</block></while>
    }</block></else></if>

    <return>return <expr>(<name>PyObject</name>*) <name>u</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_Replace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
			    <param><decl><type><name>PyObject</name> *</type><name>subobj</name></decl></param>,
			    <param><decl><type><name>PyObject</name> *</type><name>replobj</name></decl></param>,
			    <param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>self</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>str1</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str1</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>str2</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>replobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str2</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>result</name> = <call><name>replace</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>self</name></expr></argument>,
		     <argument><expr>(<name>PyUnicodeObject</name> *)<name>str1</name></expr></argument>,
		     <argument><expr>(<name>PyUnicodeObject</name> *)<name>str2</name></expr></argument>,
		     <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>replace__doc__</name></expr></argument>,
<argument><expr>"S.replace (old, new[, count]) -&gt; unicode\n\
\n\
Return a copy of S with all occurrences of substring\n\
old replaced by new.  If the optional argument count is\n\
given, only the first count occurrences are replaced."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_replace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>str1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>str2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO|n:replace"</expr></argument>, <argument><expr>&amp;<name>str1</name></expr></argument>, <argument><expr>&amp;<name>str2</name></expr></argument>, <argument><expr>&amp;<name>maxcount</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>str1</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str1</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>str2</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str2</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>replace</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>unicode_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>unicodeescape_string</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rfind__doc__</name></expr></argument>,
<argument><expr>"S.rfind(sub [,start [,end]]) -&gt; int\n\
\n\
Return the highest index in S where substring sub is found,\n\
such that sub is contained within s[start:end].  Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_rfind</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>_ParseTupleFinds</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>stringlib_rfind_slice</name><argument_list>(
        <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rindex__doc__</name></expr></argument>,
<argument><expr>"S.rindex(sub [,start [,end]]) -&gt; int\n\
\n\
Like S.rfind() but raise ValueError when the substring is not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_rindex</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>_ParseTupleFinds</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>stringlib_rfind_slice</name><argument_list>(
        <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"substring not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rjust__doc__</name></expr></argument>,
<argument><expr>"S.rjust(width[, fillchar]) -&gt; unicode\n\
\n\
Return S right-justified in a Unicode string of length width. Padding is\n\
done using the specified fill character (default is a space)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_rjust</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|O&amp;:rjust"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr><name>convert_uc</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>length</name></name> &gt;= <name>width</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
    }</block></then></if>

    <return>return <expr>(<name>PyObject</name>*) <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>width</name> - <name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_slice</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* standard clamping */</comment>
    <if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>end</name> &gt; <name><name>self</name>-&gt;<name>length</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>end</name> = <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>start</name> == 0 &amp;&amp; <name>end</name> == <name><name>self</name>-&gt;<name>length</name></name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* full slice, return original string */</comment>
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>start</name> &gt; <name>end</name></expr>)</condition><then>
        <expr_stmt><expr><name>start</name> = <name>end</name></expr>;</expr_stmt></then></if>
    <comment type="block">/* copy slice */</comment>
    <return>return <expr>(<name>PyObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name> + <name>start</name></expr></argument>,
					     <argument><expr><name>end</name> - <name>start</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_Split</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>,
			  <param><decl><type><name>PyObject</name> *</type><name>sep</name></decl></param>,
			  <param><decl><type><name>Py_ssize_t</name></type> <name>maxsplit</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>sep</name> != <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>sep</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>sep</name> == <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>split</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>s</name></expr></argument>, <argument><expr>(<name>PyUnicodeObject</name> *)<name>sep</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>split__doc__</name></expr></argument>,
<argument><expr>"S.split([sep [,maxsplit]]) -&gt; list of strings\n\
\n\
Return a list of the words in S, using sep as the\n\
delimiter string.  If maxsplit is given, at most maxsplit\n\
splits are done. If sep is not specified or is None, any\n\
whitespace string is a separator and empty strings are\n\
removed from the result."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_split</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|On:split"</expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>maxcount</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>substring</name> == <name>Py_None</name></expr>)</condition><then>
	<return>return <expr><call><name>split</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>split</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>PyUnicodeObject</name> *)<name>substring</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else
	<return>return <expr><call><name>PyUnicode_Split</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyUnicode_Partition</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str_in</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sep_in</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>str_obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>sep_obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>out</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str_obj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str_obj</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>sep_obj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>sep_obj</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>out</name> = <call><name>stringlib_partition</name><argument_list>(
        <argument><expr><name>str_obj</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>sep_obj</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>out</name></expr>;</return>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>PyUnicode_RPartition</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str_in</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sep_in</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>str_obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>sep_obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>out</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str_obj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str_obj</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>sep_obj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>sep_obj</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>out</name> = <call><name>stringlib_rpartition</name><argument_list>(
        <argument><expr><name>str_obj</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>sep_obj</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>out</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>partition__doc__</name></expr></argument>,
<argument><expr>"S.partition(sep) -&gt; (head, sep, tail)\n\
\n\
Search for the separator sep in S, and return the part before it,\n\
the separator itself, and the part after it.  If the separator is not\n\
found, return S and two empty strings."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_partition</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>separator</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_Partition</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rpartition__doc__</name></expr></argument>,
<argument><expr>"S.rpartition(sep) -&gt; (tail, sep, head)\n\
\n\
Search for the separator sep in S, starting at the end of S, and return\n\
the part before it, the separator itself, and the part after it.  If the\n\
separator is not found, return two empty strings and S."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_rpartition</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>separator</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_RPartition</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyUnicode_RSplit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>,
			   <param><decl><type><name>PyObject</name> *</type><name>sep</name></decl></param>,
			   <param><decl><type><name>Py_ssize_t</name></type> <name>maxsplit</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>s</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>sep</name> != <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>sep</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>sep</name> == <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>rsplit</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>s</name></expr></argument>, <argument><expr>(<name>PyUnicodeObject</name> *)<name>sep</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rsplit__doc__</name></expr></argument>,
<argument><expr>"S.rsplit([sep [,maxsplit]]) -&gt; list of strings\n\
\n\
Return a list of the words in S, using sep as the\n\
delimiter string, starting at the end of the string and\n\
working to the front.  If maxsplit is given, at most maxsplit\n\
splits are done. If sep is not specified, any whitespace string\n\
is a separator."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_rsplit</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|On:rsplit"</expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>maxcount</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>substring</name> == <name>Py_None</name></expr>)</condition><then>
	<return>return <expr><call><name>rsplit</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><call><name>rsplit</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>PyUnicodeObject</name> *)<name>substring</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else
	<return>return <expr><call><name>PyUnicode_RSplit</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>splitlines__doc__</name></expr></argument>,
<argument><expr>"S.splitlines([keepends]]) -&gt; list of strings\n\
\n\
Return a list of the lines in S, breaking at line boundaries.\n\
Line breaks are not included in the resulting list unless keepends\n\
is given and true."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_splitlines</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>keepends</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:splitlines"</expr></argument>, <argument><expr>&amp;<name>keepends</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr><call><name>PyUnicode_Splitlines</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>keepends</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>unicode_str</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>swapcase__doc__</name></expr></argument>,
<argument><expr>"S.swapcase() -&gt; unicode\n\
\n\
Return a copy of S with uppercase characters converted to lowercase\n\
and vice versa."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_swapcase</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixswapcase</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>translate__doc__</name></expr></argument>,
<argument><expr>"S.translate(table) -&gt; unicode\n\
\n\
Return a copy of the string S, where all characters have been mapped\n\
through the given translation table, which must be a mapping of\n\
Unicode ordinals to Unicode ordinals, Unicode strings or None.\n\
Unmapped characters are left untouched. Characters mapped to None\n\
are deleted."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_translate</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>table</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyUnicode_TranslateCharmap</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>,
				      <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>,
				      <argument><expr><name>table</name></expr></argument>,
				      <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>upper__doc__</name></expr></argument>,
<argument><expr>"S.upper() -&gt; unicode\n\
\n\
Return a copy of S converted to uppercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_upper</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixupper</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>zfill__doc__</name></expr></argument>,
<argument><expr>"S.zfill(width) -&gt; unicode\n\
\n\
Pad a numeric string S with zeros on the left, to fill a field\n\
of the specified width. The string S is never truncated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_zfill</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fill</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n:zfill"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>length</name></name> &gt;= <name>width</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
        }</block></then>
        <else>else
            <return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(
                <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</return></else></if>
    }</block></then></if>

    <expr_stmt><expr><name>fill</name> = <name>width</name> - <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>u</name> = <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>'0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>u</name>-&gt;<name>str</name><index>[<expr><name>fill</name></expr>]</index></name> == '+' || <name><name>u</name>-&gt;<name>str</name><index>[<expr><name>fill</name></expr>]</index></name> == '-'</expr>)</condition><then> <block>{
        <comment type="block">/* move sign to beginning of string */</comment>
        <expr_stmt><expr><name><name>u</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> = <name><name>u</name>-&gt;<name>str</name><index>[<expr><name>fill</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>u</name>-&gt;<name>str</name><index>[<expr><name>fill</name></expr>]</index></name> = '0'</expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr>(<name>PyObject</name>*) <name>u</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static PyObject*
free_listsize(PyUnicodeObject *self)
{
    return PyInt_FromLong(numfree);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>startswith__doc__</name></expr></argument>,
<argument><expr>"S.startswith(prefix[, start[, end]]) -&gt; bool\n\
\n\
Return True if S starts with the specified prefix, False otherwise.\n\
With optional start, test S beginning at that position.\n\
With optional end, stop comparing S at that position.\n\
prefix can also be a tuple of strings to try."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_startswith</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
		   <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:startswith"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
		<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(
                            <argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <comment type="block">/* nothing matched */</comment>
        <expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
         <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>endswith__doc__</name></expr></argument>,
<argument><expr>"S.endswith(suffix[, start[, end]]) -&gt; bool\n\
\n\
Return True if S ends with the specified suffix, False otherwise.\n\
With optional start, test S beginning at that position.\n\
With optional end, stop comparing S at that position.\n\
suffix can also be a tuple of strings to try."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_endswith</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:endswith"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
        <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(
                            <argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Implements do_string_format, which is unicode because of stringlib */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/string_format.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>format__doc__</name></expr></argument>,
<argument><expr>"S.format(*args, **kwargs) -&gt; unicode\n\
\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode__format__</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>format_spec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If 2.x, convert format_spec to the same type as value */</comment>
    <comment type="block">/* This is to allow things like u''.format('') */</comment>
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:__format__"</expr></argument>, <argument><expr>&amp;<name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>done</name>;</goto></then></if>
    <if>if <condition>(<expr>!(<call><name>PyBytes_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"__format__ arg must be str "
		     "or unicode, not %s"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>done</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>tmp</name> = <call><name>PyObject_Unicode</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>done</name>;</goto></then></if>
    <expr_stmt><expr><name>format_spec</name> = <name>tmp</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> = <call><name>_PyUnicode_FormatAdvanced</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
                                       <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>p_format__doc__</name></expr></argument>,
<argument><expr>"S.__format__(format_spec) -&gt; unicode\n\
\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode__sizeof__</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyUnicodeObject</name></expr></argument>)</argument_list></sizeof> +
                             <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * (<name><name>v</name>-&gt;<name>length</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sizeof__doc__</name></expr></argument>,
<argument><expr>"S.__sizeof__() -&gt; size of S in memory, in bytes\n\
\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_getnewargs</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(u#)"</expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>unicode_methods</name><index>[]</index></name> <init>= <expr><block>{

    <comment type="block">/* Order is according to common usage: often used methods should
       appear first, since lookup is done sequentially. */</comment>

    <expr><block>{<expr>"encode"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_encode</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>encode__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"replace"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_replace</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>replace__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"split"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_split</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>split__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"rsplit"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rsplit</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rsplit__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"join"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_join</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>join__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"capitalize"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_capitalize</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>capitalize__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"title"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_title</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>title__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"center"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_center</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>center__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"count"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_count</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>count__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"expandtabs"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_expandtabs</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>expandtabs__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"find"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_find</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>find__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"partition"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_partition</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>partition__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"index"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_index</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>index__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"ljust"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_ljust</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>ljust__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"lower"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_lower</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>lower__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"lstrip"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_lstrip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>lstrip__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"decode"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_decode</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>decode__doc__</name></expr>}</block></expr>,
<comment type="block">/*  {"maketrans", (PyCFunction) unicode_maketrans, METH_VARARGS, maketrans__doc__}, */</comment>
    <expr><block>{<expr>"rfind"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rfind</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rfind__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"rindex"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rindex</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rindex__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"rjust"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rjust</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rjust__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"rstrip"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rstrip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rstrip__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"rpartition"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rpartition</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>rpartition__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"splitlines"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_splitlines</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>splitlines__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"strip"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_strip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>strip__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"swapcase"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_swapcase</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>swapcase__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"translate"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_translate</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>translate__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"upper"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_upper</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>upper__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"startswith"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_startswith</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>startswith__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"endswith"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_endswith</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>endswith__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"islower"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_islower</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>islower__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"isupper"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isupper</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isupper__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"istitle"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_istitle</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>istitle__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"isspace"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isspace</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isspace__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"isdecimal"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isdecimal</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isdecimal__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"isdigit"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isdigit</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isdigit__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"isnumeric"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isnumeric</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isnumeric__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"isalpha"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isalpha</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isalpha__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"isalnum"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isalnum</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isalnum__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"zfill"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_zfill</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>zfill__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"format"</expr>, <expr>(<name>PyCFunction</name>) <name>do_string_format</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>format__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"__format__"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode__format__</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>p_format__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"_formatter_field_name_split"</expr>, <expr>(<name>PyCFunction</name>) <name>formatter_field_name_split</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"_formatter_parser"</expr>, <expr>(<name>PyCFunction</name>) <name>formatter_parser</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"__sizeof__"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode__sizeof__</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>sizeof__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
    {"capwords", (PyCFunction) unicode_capwords, METH_NOARGS, capwords__doc__},
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
    <comment type="block">/* This one is just used for debugging the implementation. */</comment>
    {"freelistsize", (PyCFunction) free_listsize, METH_NOARGS},
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr><block>{<expr>"__getnewargs__"</expr>,	<expr>(<name>PyCFunction</name>)<name>unicode_getnewargs</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_mod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
       <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
               <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
               <return>return <expr><name>Py_NotImplemented</name></expr>;</return>
       }</block></then></if>
       <return>return <expr><call><name>PyUnicode_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>unicode_as_number</name> <init>= <expr><block>{
	<expr>0</expr>,				<comment type="block">/*nb_add*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_subtract*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_multiply*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_divide*/</comment>
	<expr><name>unicode_mod</name></expr>,			<comment type="block">/*nb_remainder*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>unicode_as_sequence</name> <init>= <expr><block>{
    <expr>(<name>lenfunc</name>) <name>unicode_length</name></expr>, 		<comment type="block">/* sq_length */</comment>
    <expr><name>PyUnicode_Concat</name></expr>,		 	<comment type="block">/* sq_concat */</comment>
    <expr>(<name>ssizeargfunc</name>) <name>unicode_repeat</name></expr>, 	<comment type="block">/* sq_repeat */</comment>
    <expr>(<name>ssizeargfunc</name>) <name>unicode_getitem</name></expr>, 	<comment type="block">/* sq_item */</comment>
    <expr>(<name>ssizessizeargfunc</name>) <name>unicode_slice</name></expr>, 	<comment type="block">/* sq_slice */</comment>
    <expr>0</expr>, 					<comment type="block">/* sq_ass_item */</comment>
    <expr>0</expr>, 					<comment type="block">/* sq_ass_slice */</comment>
    <expr><name>PyUnicode_Contains</name></expr>, 		<comment type="block">/* sq_contains */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_subscript</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>item</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
            <expr_stmt><expr><name>i</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><call><name>unicode_getitem</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelength</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Py_UNICODE</name>*</type> <name>source_buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Py_UNICODE</name>*</type> <name>result_buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name>*)<name>item</name></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelength</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>slicelength</name> &lt;= 0</expr>)</condition><then> <block>{
            <return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <if>if <condition>(<expr><name>start</name> == 0 &amp;&amp; <name>step</name> == 1 &amp;&amp; <name>slicelength</name> == <name><name>self</name>-&gt;<name>length</name></name> &amp;&amp;
                   <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
        }</block></then> <else>else <if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
            <return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name> + <name>start</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>source_buf</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result_buf</name> = (<name>Py_UNICODE</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>slicelength</name>*
                                                       <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    
	    <if>if <condition>(<expr><name>result_buf</name> == <name>NULL</name></expr>)</condition><then>
		    <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>

            <for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelength</name></expr>;</condition> <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name><name>result_buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>source_buf</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>

            <expr_stmt><expr><name>result</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        }</block></else></if></else></if></else></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"string indices must be integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></else></if></else></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>unicode_as_mapping</name> <init>= <expr><block>{
    <expr>(<name>lenfunc</name>)<name>unicode_length</name></expr>,		<comment type="block">/* mp_length */</comment>
    <expr>(<name>binaryfunc</name>)<name>unicode_subscript</name></expr>,	<comment type="block">/* mp_subscript */</comment>
    <expr>(<name>objobjargproc</name>)0</expr>,			<comment type="block">/* mp_ass_subscript */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>unicode_buffer_getreadbuf</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
			  <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>,
			  <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>index</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			<argument><expr>"accessing non-existent unicode segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>ptr</name> = (<name>void</name> *) <name><name>self</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
    <return>return <expr><call><name>PyUnicode_GET_DATA_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>unicode_buffer_getwritebuf</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>,
			   <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		    <argument><expr>"cannot use unicode as modifiable buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>unicode_buffer_getsegcount</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
			   <param><decl><type><name>Py_ssize_t</name> *</type><name>lenp</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>lenp</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>lenp</name> = <call><name>PyUnicode_GET_DATA_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>unicode_buffer_getcharbuf</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
			  <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>,
			  <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>index</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			<argument><expr>"accessing non-existent unicode segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>str</name> = <call><name>_PyUnicode_AsDefaultEncodedString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr>-1</expr>;</return></then></if>
    <expr_stmt><expr>*<name>ptr</name> = (<name>void</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Helpers for PyUnicode_Format() */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>getnextarg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>arglen</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>p_argidx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>argidx</name> <init>= <expr>*<name>p_argidx</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>argidx</name> &lt; <name>arglen</name></expr>)</condition><then> <block>{
	<expr_stmt><expr>(*<name>p_argidx</name>)++</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>arglen</name> &lt; 0</expr>)</condition><then>
	    <return>return <expr><name>args</name></expr>;</return></then>
	<else>else
	    <return>return <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>argidx</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		    <argument><expr>"not enough arguments for format string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_LJUST</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_SIGN</name></cpp:macro>	<cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_BLANK</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ALT</name></cpp:macro>	<cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ZERO</name></cpp:macro>	<cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>strtounicode</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buffer</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>charbuffer</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>charbuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = <name>len</name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
	<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>Py_UNICODE</name>) <name><name>charbuffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>

    <return>return <expr><name>len</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>doubletounicode</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PyOS_ascii_formatd</name><argument_list>(<argument><expr>(<name>char</name> *)<name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>strtounicode</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>longtounicode</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>long</name></type> <name>x</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr>(<name>char</name> *)<name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>strtounicode</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* XXX To save some code duplication, formatfloat/long/int could have been
   shared with stringobject.c, converting from 8-bit to Unicode after the
   formatting is done. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>formatfloat</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buf</name></decl></param>,
	    <param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>,
	    <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
	    <param><decl><type><name>int</name></type> <name>prec</name></decl></param>,
	    <param><decl><type><name>int</name></type> <name>type</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* fmt = '%#.' + `prec` + `type`
       worst case length = 3 + 10 (len of INT_MAX) + 1 = 14 (use 20)*/</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>fmt</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
	<return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr><name>prec</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>prec</name> = 6</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>type</name> == 'f' &amp;&amp; (<call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> / 1e25) &gt;= 1e25</expr>)</condition><then>
	<expr_stmt><expr><name>type</name> = 'g'</expr>;</expr_stmt></then></if>
    <comment type="block">/* Worst case length calc to ensure no buffer overrun:

       'g' formats:
	 fmt = %#.&lt;prec&gt;g
	 buf = '-' + [0-9]*prec + '.' + 'e+' + (longest exp
	    for any double rep.)
	 len = 1 + prec + 1 + 2 + 5 = 9 + prec

       'f' formats:
	 buf = '-' + [0-9]*x + '.' + [0-9]*prec (with x &lt; 50)
	 len = 1 + 50 + 1 + prec = 52 + prec

       If prec=0 the effective precision is 1 (the leading digit is
       always given), therefore increase the length by one.

    */</comment>
    <if>if <condition>(<expr>((<name>type</name> == 'g' || <name>type</name> == 'G') &amp;&amp; 
          <name>buflen</name> &lt;= (<name>size_t</name>)10 + (<name>size_t</name>)<name>prec</name>) ||
	(<name>type</name> == 'f' &amp;&amp; <name>buflen</name> &lt;= (<name>size_t</name>)53 + (<name>size_t</name>)<name>prec</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"formatted float is too long (precision too large?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%%%s.%d%c"</expr></argument>,
		  <argument><expr>(<name>flags</name>&amp;<name>F_ALT</name>) ? "#" : ""</expr></argument>,
		  <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>doubletounicode</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>formatlong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>val</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>, <param><decl><type><name>int</name></type> <name>prec</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt> <comment type="block">/* temporary string object. */</comment>
	<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> = <call><name>_PyString_FormatLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><name><name>result</name>-&gt;<name>str</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>str</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name>*)<name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>formatint</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buf</name></decl></param>,
	  <param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>,
	  <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
	  <param><decl><type><name>int</name></type> <name>prec</name></decl></param>,
	  <param><decl><type><name>int</name></type> <name>type</name></decl></param>,
	  <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* fmt = '%#.' + `prec` + 'l' + `type`
     * worst case length = 3 + 19 (worst len of INT_MAX on 64-bit machine)
     *                     + 1 + 1
     *                   = 24
     */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>fmt</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* plenty big enough! */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>sign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr><name>x</name> &lt; 0 &amp;&amp; <name>type</name> == 'u'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>type</name> = 'd'</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>x</name> &lt; 0 &amp;&amp; (<name>type</name> == 'x' || <name>type</name> == 'X' || <name>type</name> == 'o')</expr>)</condition><then>
        <expr_stmt><expr><name>sign</name> = "-"</expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>sign</name> = ""</expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr><name>prec</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>prec</name> = 1</expr>;</expr_stmt></then></if>

    <comment type="block">/* buf = '+'/'-'/'' + '0'/'0x'/'' + '[0-9]'*max(prec, len(x in octal))
     * worst case buf = '-0x' + [0-9]*prec, where prec &gt;= 11
     */</comment>
    <if>if <condition>(<expr><name>buflen</name> &lt;= 14 || <name>buflen</name> &lt;= (<name>size_t</name>)3 + (<name>size_t</name>)<name>prec</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
    	        <argument><expr>"formatted integer is too long (precision too large?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) &amp;&amp;
        (<name>type</name> == 'x' || <name>type</name> == 'X')</expr>)</condition><then> <block>{
        <comment type="block">/* When converting under %#x or %#X, there are a number
         * of issues that cause pain:
         * - when 0 is being converted, the C standard leaves off
         *   the '0x' or '0X', which is inconsistent with other
         *   %#x/%#X conversions and inconsistent with Python's
         *   hex() function
         * - there are platforms that violate the standard and
         *   convert 0 with the '0x' or '0X'
         *   (Metrowerks, Compaq Tru64)
         * - there are platforms that give '0x' when converting
         *   under %#X, but convert 0 in accordance with the
         *   standard (OS/2 EMX)
         *
         * We can achieve the desired consistency by inserting our
         * own '0x' or '0X' prefix, and substituting %x/%X in place
         * of %#x/%#X.
         *
         * Note that this is the same approach as used in
         * formatint() in stringobject.c
         */</comment>
        <expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%s0%c%%.%dl%c"</expr></argument>,
                      <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%s%%%s.%dl%c"</expr></argument>,
                      <argument><expr><name>sign</name></expr></argument>, <argument><expr>(<name>flags</name>&amp;<name>F_ALT</name>) ? "#" : ""</expr></argument>,
                      <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><name><name>sign</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
        <return>return <expr><call><name>longtounicode</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr>-<name>x</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else
        <return>return <expr><call><name>longtounicode</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>formatchar</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buf</name></decl></param>,
           <param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>,
           <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* presume that the buffer is at least 2 characters long */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</expr_stmt>
    }</block></then>

    <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = (<name>Py_UNICODE</name>)<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</expr_stmt>
    }</block></then>

    <else>else <block>{
	<comment type="block">/* Integer input truncated to a character */</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>onError</name>;</goto></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifdef>
	<if>if <condition>(<expr><name>x</name> &lt; 0 || <name>x</name> &gt; 0x10ffff</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			    <argument><expr>"%c arg not in range(0x110000) "
			    "(wide Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>-1</expr>;</return>
	}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><name>x</name> &lt; 0 || <name>x</name> &gt; 0xffff</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			    <argument><expr>"%c arg not in range(0x10000) "
			    "(narrow Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>-1</expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = (<name>Py_UNICODE</name>) <name>x</name></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		    <argument><expr>"%c requires int or char"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* fmt%(v1,v2,...) is roughly equivalent to sprintf(fmt, v1, v2, ...)

   FORMATBUFLEN is the length of the buffer in which the floats, ints, &amp;
   chars are formatted. XXX This is a magic number. Each formatting
   routine does bounds checking to ensure no overflow, but a better
   solution may be to malloc a buffer of appropriate size for each
   format. For now, the current solution is sufficient.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORMATBUFLEN</name></cpp:macro> <cpp:value>(size_t)120</cpp:value></cpp:define>

<function><type><name>PyObject</name> *</type><name>PyUnicode_Format</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>format</name></decl></param>,
			   <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>fmt</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fmtcnt</name></decl>, <decl><type ref="prev"/><name>rescnt</name></decl>, <decl><type ref="prev"/><name>reslen</name></decl>, <decl><type ref="prev"/><name>arglen</name></decl>, <decl><type ref="prev"/><name>argidx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>args_owned</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>uformat</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>format</name> == <name>NULL</name> || <name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>uformat</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>uformat</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>fmt</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fmtcnt</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>reslen</name> = <name>rescnt</name> = <name>fmtcnt</name> + 100</expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>reslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <expr_stmt><expr><name>res</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>arglen</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>argidx</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
	<expr_stmt><expr><name>arglen</name> = -1</expr>;</expr_stmt>
	<expr_stmt><expr><name>argidx</name> = -2</expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_as_mapping</name> &amp;&amp; !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &amp;&amp;
        !<call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>PyBaseString_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>dict</name> = <name>args</name></expr>;</expr_stmt></then></if>

    <while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
	<if>if <condition>(<expr>*<name>fmt</name> != '%'</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>--<name>rescnt</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>rescnt</name> = <name>fmtcnt</name> + 100</expr>;</expr_stmt>
		<expr_stmt><expr><name>reslen</name> += <name>rescnt</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>reslen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
		<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> + <name>reslen</name> - <name>rescnt</name></expr>;</expr_stmt>
		<expr_stmt><expr>--<name>rescnt</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr>*<name>res</name>++ = *<name>fmt</name>++</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
	    <comment type="block">/* Got a format specifier */</comment>
	    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>prec</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>fill</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>isnumok</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>pbuf</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>sign</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>formatbuf</name><index>[<expr><name>FORMATBUFLEN</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* For format{float,int,char}() */</comment>

	    <expr_stmt><expr><name>fmt</name>++</expr>;</expr_stmt>
	    <if>if <condition>(<expr>*<name>fmt</name> == '('</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>keystart</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>keylen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>pcount</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				    <argument><expr>"format requires a mapping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>onError</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr>++<name>fmt</name></expr>;</expr_stmt>
		<expr_stmt><expr>--<name>fmtcnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>keystart</name> = <name>fmt</name></expr>;</expr_stmt>
		<comment type="block">/* Skip over balanced parentheses */</comment>
		<while>while <condition>(<expr><name>pcount</name> &gt; 0 &amp;&amp; --<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
		    <if>if <condition>(<expr>*<name>fmt</name> == ')'</expr>)</condition><then>
			<expr_stmt><expr>--<name>pcount</name></expr>;</expr_stmt></then>
		    <else>else <if>if <condition>(<expr>*<name>fmt</name> == '('</expr>)</condition><then>
			<expr_stmt><expr>++<name>pcount</name></expr>;</expr_stmt></then></if></else></if>
		    <expr_stmt><expr><name>fmt</name>++</expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><name>keylen</name> = <name>fmt</name> - <name>keystart</name> - 1</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fmtcnt</name> &lt; 0 || <name>pcount</name> &gt; 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				    <argument><expr>"incomplete format key"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>onError</name>;</goto>
		}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
		<comment type="block">/* keys are converted to strings using UTF-8 and
		   then looked up since Python uses strings to hold
		   variables names etc. in its namespaces and we
		   wouldn't want to break common idioms. */</comment>
		key = PyUnicode_EncodeUTF8(keystart,
					   keylen,
					   NULL);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>key</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>keystart</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
		<if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>args_owned</name> = 0</expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>args</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
		    <goto>goto <name>onError</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>args_owned</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>arglen</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><name>argidx</name> = -2</expr>;</expr_stmt>
	    }</block></then></if>
	    <while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
		<switch>switch <condition>(<expr><name>c</name> = *<name>fmt</name>++</expr>)</condition> <block>{
		<case>case <expr>'-'</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_LJUST</name></expr>;</expr_stmt> <continue>continue;</continue>
		</case><case>case <expr>'+'</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_SIGN</name></expr>;</expr_stmt> <continue>continue;</continue>
		</case><case>case <expr>' '</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_BLANK</name></expr>;</expr_stmt> <continue>continue;</continue>
		</case><case>case <expr>'#'</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_ALT</name></expr>;</expr_stmt> <continue>continue;</continue>
		</case><case>case <expr>'0'</expr>: <expr_stmt><expr><name>flags</name> |= <name>F_ZERO</name></expr>;</expr_stmt> <continue>continue;</continue>
		</case>}</block></switch>
		<break>break;</break>
	    }</block></while>
	    <if>if <condition>(<expr><name>c</name> == '*'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>v</name> = <call><name>getnextarg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>, <argument><expr>&amp;<name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
		<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				    <argument><expr>"* wants int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>onError</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>width</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>width</name> &lt; 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>flags</name> |= <name>F_LJUST</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>width</name> = -<name>width</name></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
		    <expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
	    }</block></then>
	    <else>else <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>width</name> = <name>c</name> - '0'</expr>;</expr_stmt>
		<while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
		    <expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>c</name> &lt; '0' || <name>c</name> &gt; '9'</expr>)</condition><then>
			<break>break;</break></then></if>
		    <if>if <condition>(<expr>(<name>width</name>*10) / 10 != <name>width</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"width too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>onError</name>;</goto>
		    }</block></then></if>
		    <expr_stmt><expr><name>width</name> = <name>width</name>*10 + (<name>c</name> - '0')</expr>;</expr_stmt>
		}</block></while>
	    }</block></then></if></else></if>
	    <if>if <condition>(<expr><name>c</name> == '.'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>prec</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
		    <expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>c</name> == '*'</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>v</name> = <call><name>getnextarg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>, <argument><expr>&amp;<name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>onError</name>;</goto></then></if>
		    <if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"* wants int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>onError</name>;</goto>
		    }</block></then></if>
		    <expr_stmt><expr><name>prec</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>prec</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>prec</name> = 0</expr>;</expr_stmt></then></if>
		    <if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
			<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>prec</name> = <name>c</name> - '0'</expr>;</expr_stmt>
		    <while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
			<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>fmt</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> &lt; '0' || <name>c</name> &gt; '9'</expr>)</condition><then>
			    <break>break;</break></then></if>
			<if>if <condition>(<expr>(<name>prec</name>*10) / 10 != <name>prec</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					    <argument><expr>"prec too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <goto>goto <name>onError</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name>prec</name> = <name>prec</name>*10 + (<name>c</name> - '0')</expr>;</expr_stmt>
		    }</block></while>
		}</block></then></if></else></if>
	    }</block></then></if> <comment type="block">/* prec */</comment>
	    <if>if <condition>(<expr><name>fmtcnt</name> &gt;= 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>c</name> == 'h' || <name>c</name> == 'l' || <name>c</name> == 'L'</expr>)</condition><then> <block>{
		    <if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
			<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
		}</block></then></if>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>fmtcnt</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"incomplete format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>onError</name>;</goto>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>c</name> != '%'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>v</name> = <call><name>getnextarg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>, <argument><expr>&amp;<name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
	    }</block></then></if>
	    <expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>fill</name> = ' '</expr>;</expr_stmt>
	    <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{

	    <case>case <expr>'%'</expr>:
		<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
		<comment type="block">/* presume that buffer length is at least 1 */</comment>
		<expr_stmt><expr><name><name>pbuf</name><index>[<expr>0</expr>]</index></name> = '%'</expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = 1</expr>;</expr_stmt>
		<break>break;</break>

	    </case><case>case <expr>'s'</expr>:
	    </case><case>case <expr>'r'</expr>:
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <name>c</name> == 's'</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>temp</name> = <name>v</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
		    <decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
		    <if>if <condition>(<expr><name>c</name> == 's'</expr>)</condition><then>
			<expr_stmt><expr><name>temp</name> = <call><name>PyObject_Unicode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		    <else>else
			<expr_stmt><expr><name>temp</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		    <if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>onError</name>;</goto></then></if>
                    <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <comment type="block">/* nothing to do */</comment><empty_stmt>;</empty_stmt></then>
                    <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="block">/* convert to string to Unicode */</comment>
		        <expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		        <expr_stmt><expr><name>temp</name> = <name>unicode</name></expr>;</expr_stmt>
		        <if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
			    <goto>goto <name>onError</name>;</goto></then></if>
		    }</block></then>
		    <else>else <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"%s argument has non-string str()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>onError</name>;</goto>
		    }</block></else></if></else></if>
		}</block></else></if>
		<expr_stmt><expr><name>pbuf</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>prec</name> &gt;= 0 &amp;&amp; <name>len</name> &gt; <name>prec</name></expr>)</condition><then>
		    <expr_stmt><expr><name>len</name> = <name>prec</name></expr>;</expr_stmt></then></if>
		<break>break;</break>

	    </case><case>case <expr>'i'</expr>:
	    </case><case>case <expr>'d'</expr>:
	    </case><case>case <expr>'u'</expr>:
	    </case><case>case <expr>'o'</expr>:
	    </case><case>case <expr>'x'</expr>:
	    </case><case>case <expr>'X'</expr>:
		<if>if <condition>(<expr><name>c</name> == 'i'</expr>)</condition><then>
		    <expr_stmt><expr><name>c</name> = 'd'</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>isnumok</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyNumber_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>iobj</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || (<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>iobj</name> = <name>v</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name>iobj</name> = <call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>iobj</name>==<name>NULL</name></expr>)</condition><then> <expr_stmt><expr><name>iobj</name> = <call><name>PyNumber_Long</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			}</block></else></if>
			<if>if <condition>(<expr><name>iobj</name>!=<name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>isnumok</name> = 1</expr>;</expr_stmt>
					<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>len</name> = <call><name>formatint</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>formatbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						    <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
					    <goto>goto <name>onError</name>;</goto></then></if>
					<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
				}</block></then> 
				<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>isnumok</name> = 1</expr>;</expr_stmt>
					<expr_stmt><expr><name>temp</name> = <call><name>formatlong</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr>!<name>temp</name></expr>)</condition><then>
					    <goto>goto <name>onError</name>;</goto></then></if>
					<expr_stmt><expr><name>pbuf</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
				}</block></then>
				<else>else <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></else></if></else></if>
			}</block></then></if>
		}</block></then></if>
		<if>if <condition>(<expr>!<name>isnumok</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, 
			    <argument><expr>"%%%c format: a number is required, "
                                     "not %.200s"</expr></argument>, <argument><expr>(<name>char</name>)<name>c</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>onError</name>;</goto>
		}</block></then></if>
		<if>if <condition>(<expr><name>flags</name> &amp; <name>F_ZERO</name></expr>)</condition><then>
		    <expr_stmt><expr><name>fill</name> = '0'</expr>;</expr_stmt></then></if>
		<break>break;</break>

	    </case><case>case <expr>'e'</expr>:
	    </case><case>case <expr>'E'</expr>:
	    </case><case>case <expr>'f'</expr>:
	    </case><case>case <expr>'F'</expr>:
	    </case><case>case <expr>'g'</expr>:
	    </case><case>case <expr>'G'</expr>:
		<if>if <condition>(<expr><name>c</name> == 'F'</expr>)</condition><then>
			<expr_stmt><expr><name>c</name> = 'f'</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <call><name>formatfloat</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>formatbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
		<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>flags</name> &amp; <name>F_ZERO</name></expr>)</condition><then>
		    <expr_stmt><expr><name>fill</name> = '0'</expr>;</expr_stmt></then></if>
		<break>break;</break>

	    </case><case>case <expr>'c'</expr>:
		<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <call><name>formatchar</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>formatbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
		    <goto>goto <name>onError</name>;</goto></then></if>
		<break>break;</break>

	    </case><default>default:
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			     <argument><expr>"unsupported format character '%c' (0x%x) "
			     "at index %zd"</expr></argument>,
			     <argument><expr>(31&lt;=<name>c</name> &amp;&amp; <name>c</name>&lt;=126) ? (<name>char</name>)<name>c</name> : '?'</expr></argument>,
                             <argument><expr>(<name>int</name>)<name>c</name></expr></argument>,
			     <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><name>fmt</name> - 1 -
					  <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>onError</name>;</goto>
	    </default>}</block></switch>
	    <if>if <condition>(<expr><name>sign</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>*<name>pbuf</name> == '-' || *<name>pbuf</name> == '+'</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>sign</name> = *<name>pbuf</name>++</expr>;</expr_stmt>
		    <expr_stmt><expr><name>len</name>--</expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>flags</name> &amp; <name>F_SIGN</name></expr>)</condition><then>
		    <expr_stmt><expr><name>sign</name> = '+'</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>flags</name> &amp; <name>F_BLANK</name></expr>)</condition><then>
		    <expr_stmt><expr><name>sign</name> = ' '</expr>;</expr_stmt></then>
		<else>else
		    <expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>width</name> &lt; <name>len</name></expr>)</condition><then>
		<expr_stmt><expr><name>width</name> = <name>len</name></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>rescnt</name> - (<name>sign</name> != 0) &lt; <name>width</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>reslen</name> -= <name>rescnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rescnt</name> = <name>width</name> + <name>fmtcnt</name> + 100</expr>;</expr_stmt>
		<expr_stmt><expr><name>reslen</name> += <name>rescnt</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>reslen</name> &lt; 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>onError</name>;</goto>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>reslen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>onError</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>
		    + <name>reslen</name> - <name>rescnt</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>sign</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>fill</name> != ' '</expr>)</condition><then>
		    <expr_stmt><expr>*<name>res</name>++ = <name>sign</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>rescnt</name>--</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>width</name> &gt; <name>len</name></expr>)</condition><then>
		    <expr_stmt><expr><name>width</name>--</expr>;</expr_stmt></then></if>
	    }</block></then></if>
	    <if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) &amp;&amp; (<name>c</name> == 'x' || <name>c</name> == 'X')</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>0</expr>]</index></name> == '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>1</expr>]</index></name> == <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fill</name> != ' '</expr>)</condition><then> <block>{
		    <expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
		    <expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>rescnt</name> -= 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>width</name> -= 2</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>width</name> &lt; 0</expr>)</condition><then>
		    <expr_stmt><expr><name>width</name> = 0</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>len</name> -= 2</expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>width</name> &gt; <name>len</name> &amp;&amp; !(<name>flags</name> &amp; <name>F_LJUST</name>)</expr>)</condition><then> <block>{
		<do>do <block>{
		    <expr_stmt><expr>--<name>rescnt</name></expr>;</expr_stmt>
		    <expr_stmt><expr>*<name>res</name>++ = <name>fill</name></expr>;</expr_stmt>
		}</block> while <condition>(<expr>--<name>width</name> &gt; <name>len</name></expr>)</condition>;</do>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>fill</name> == ' '</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>sign</name></expr>)</condition><then>
		    <expr_stmt><expr>*<name>res</name>++ = <name>sign</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) &amp;&amp; (<name>c</name> == 'x' || <name>c</name> == 'X')</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>0</expr>]</index></name> == '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>1</expr>]</index></name> == <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
		    <expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>res</name> += <name>len</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>rescnt</name> -= <name>len</name></expr>;</expr_stmt>
	    <while>while <condition>(<expr>--<name>width</name> &gt;= <name>len</name></expr>)</condition> <block>{
		<expr_stmt><expr>--<name>rescnt</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>res</name>++ = ' '</expr>;</expr_stmt>
	    }</block></while>
	    <if>if <condition>(<expr><name>dict</name> &amp;&amp; (<name>argidx</name> &lt; <name>arglen</name>) &amp;&amp; <name>c</name> != '%'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"not all arguments converted during string formatting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>onError</name>;</goto>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if> <comment type="block">/* '%' */</comment>
    }</block></while> <comment type="block">/* until end */</comment>
    <if>if <condition>(<expr><name>argidx</name> &lt; <name>arglen</name> &amp;&amp; !<name>dict</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"not all arguments converted during string formatting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>onError</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>reslen</name> - <name>rescnt</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	<goto>goto <name>onError</name>;</goto></then></if>
    <if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>

 <label><name>onError</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyBufferProcs</name></type> <name>unicode_as_buffer</name> <init>= <expr><block>{
    <expr>(<name>readbufferproc</name>) <name>unicode_buffer_getreadbuf</name></expr>,
    <expr>(<name>writebufferproc</name>) <name>unicode_buffer_getwritebuf</name></expr>,
    <expr>(<name>segcountproc</name>) <name>unicode_buffer_getsegcount</name></expr>,
    <expr>(<name>charbufferproc</name>) <name>unicode_buffer_getcharbuf</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"string"</expr>, <expr>"encoding"</expr>, <expr>"errors"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>type</name> != &amp;<name>PyUnicode_Type</name></expr>)</condition><then>
		<return>return <expr><call><name>unicode_subtype_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|Oss:unicode"</expr></argument>,
					  <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(<name>PyObject</name> *)<call><name>_PyUnicode_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name> &amp;&amp; <name>errors</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr><call><name>PyObject_Unicode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
	<return>return <expr><call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>tmp</name></decl>, *<decl><type ref="prev"/><name>pnew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> = (<name>PyUnicodeObject</name> *)<call><name>unicode_new</name><argument_list>(<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pnew</name> = (<name>PyUnicodeObject</name> *) <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>n</name> = <name><name>tmp</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pnew</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>pnew</name>-&gt;<name>str</name></name> = (<name>Py_UNICODE</name>*) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * (<name>n</name>+1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>pnew</name>-&gt;<name>str</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>_Py_ForgetReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>pnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>pnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>pnew</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>tmp</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pnew</name>-&gt;<name>length</name></name> = <name>n</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pnew</name>-&gt;<name>hash</name></name> = <name><name>tmp</name>-&gt;<name>hash</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>pnew</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicode_doc</name></expr></argument>,
<argument><expr>"unicode(string [, encoding[, errors]]) -&gt; object\n\
\n\
Create a new Unicode object from the given encoded string.\n\
encoding defaults to the current default string encoding.\n\
errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyUnicode_Type</name> <init>= <expr><block>{
    <expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
    "unicode"</expr>, 				<comment type="block">/* tp_name */</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyUnicodeObject</name></expr></argument>)</argument_list></sizeof></expr>, 		<comment type="block">/* tp_size */</comment>
    <expr>0</expr>, 					<comment type="block">/* tp_itemsize */</comment>
    <comment type="block">/* Slots */</comment>
    <expr>(<name>destructor</name>)<name>unicode_dealloc</name></expr>, 	<comment type="block">/* tp_dealloc */</comment>
    <expr>0</expr>, 					<comment type="block">/* tp_print */</comment>
    <expr>0</expr>,				 	<comment type="block">/* tp_getattr */</comment>
    <expr>0</expr>, 					<comment type="block">/* tp_setattr */</comment>
    <expr>0</expr>, 					<comment type="block">/* tp_compare */</comment>
    <expr><name>unicode_repr</name></expr>, 			<comment type="block">/* tp_repr */</comment>
    <expr>&amp;<name>unicode_as_number</name></expr>, 		<comment type="block">/* tp_as_number */</comment>
    <expr>&amp;<name>unicode_as_sequence</name></expr>, 		<comment type="block">/* tp_as_sequence */</comment>
    <expr>&amp;<name>unicode_as_mapping</name></expr>, 		<comment type="block">/* tp_as_mapping */</comment>
    <expr>(<name>hashfunc</name>) <name>unicode_hash</name></expr>, 		<comment type="block">/* tp_hash*/</comment>
    <expr>0</expr>, 					<comment type="block">/* tp_call*/</comment>
    <expr>(<name>reprfunc</name>) <name>unicode_str</name></expr>,	 	<comment type="block">/* tp_str */</comment>
    <expr><name>PyObject_GenericGetAttr</name></expr>, 		<comment type="block">/* tp_getattro */</comment>
    <expr>0</expr>,			 		<comment type="block">/* tp_setattro */</comment>
    <expr>&amp;<name>unicode_as_buffer</name></expr>,			<comment type="block">/* tp_as_buffer */</comment>
    <expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
	    <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_UNICODE_SUBCLASS</name></expr>,	<comment type="block">/* tp_flags */</comment>
    <expr><name>unicode_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
    <expr><name>PyUnicode_RichCompare</name></expr>,		<comment type="block">/* tp_richcompare */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
    <expr><name>unicode_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_members */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
    <expr>&amp;<name>PyBaseString_Type</name></expr>,			<comment type="block">/* tp_base */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_init */</comment>
    <expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
    <expr><name>unicode_new</name></expr>,			<comment type="block">/* tp_new */</comment>
    <expr><name>PyObject_Del</name></expr>,      		<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Initialize the Unicode implementation */</comment>

<function><type><name>void</name></type> <name>_PyUnicode_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* XXX - move this array to unicodectype.c ? */</comment>
    <decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>linebreak</name><index>[]</index></name> <init>= <expr><block>{
        <expr>0x000A</expr>, <comment type="block">/* LINE FEED */</comment>
        <expr>0x000D</expr>, <comment type="block">/* CARRIAGE RETURN */</comment>
        <expr>0x001C</expr>, <comment type="block">/* FILE SEPARATOR */</comment>
        <expr>0x001D</expr>, <comment type="block">/* GROUP SEPARATOR */</comment>
        <expr>0x001E</expr>, <comment type="block">/* RECORD SEPARATOR */</comment>
        <expr>0x0085</expr>, <comment type="block">/* NEXT LINE */</comment>
        <expr>0x2028</expr>, <comment type="block">/* LINE SEPARATOR */</comment>
        <expr>0x2029</expr>, <comment type="block">/* PARAGRAPH SEPARATOR */</comment>
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Init the implementation */</comment>
    <expr_stmt><expr><name>free_list</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numfree</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>unicode_empty</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>unicode_empty</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>unicode_default_encoding</name></expr></argument>, <argument><expr>"ascii"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<expr_stmt><expr><name><name>unicode_latin1</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt></for>
    <if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize 'unicode'"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* initialize the linebreak bloom filter */</comment>
    <expr_stmt><expr><name>bloom_linebreak</name> = <call><name>make_bloom_mask</name><argument_list>(
        <argument><expr><name>linebreak</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>linebreak</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>linebreak</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>EncodingMapType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Finalize the Unicode implementation */</comment>

<function><type><name>int</name></type>
<name>PyUnicode_ClearFreeList</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>freelist_size</name> <init>= <expr><name>numfree</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>u</name> = <name>free_list</name></expr>;</init> <condition><expr><name>u</name> != <name>NULL</name></expr>;</condition><incr/>) <block>{
	<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name> <init>= <expr><name>u</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>u</name> = *(<name>PyUnicodeObject</name> **)<name>u</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>str</name></name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>PyObject_DEL</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>defenc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numfree</name>--</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>free_list</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>numfree</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>freelist_size</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>_PyUnicode_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>unicode_empty</name> = <name>NULL</name></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr><name><name>unicode_latin1</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>unicode_latin1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>unicode_latin1</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>
    <expr_stmt><expr>(<name>void</name>)<call><name>PyUnicode_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
Local variables:
c-basic-offset: 4
indent-tabs-mode: nil
End:
*/</comment>
</unit>
