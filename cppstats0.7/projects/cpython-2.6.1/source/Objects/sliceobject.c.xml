<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/sliceobject.c"><comment type="block">/*
Written by Jim Hugunin and Chris Chase.

This includes both the singular ellipsis object and slice objects.

Guido, feel free to do whatever you want in the way of copyrights
for this file.
*/</comment>

<comment type="block">/* 
Py_Ellipsis encodes the '...' rubber index token. It is similar to
the Py_NoneStruct in that there is no way to create other objects of
this type and there is exactly one in existence.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ellipsis_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"Ellipsis"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyEllipsis_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"ellipsis"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>, <comment type="block">/*never called*/</comment>		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_compare */</comment>
	<expr><name>ellipsis_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,	<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,		<comment type="block">/* tp_flags */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyObject</name></type> <name>_Py_EllipsisObject</name> <init>= <expr><block>{
	<expr><name>_PyObject_EXTRA_INIT</name>
	1</expr>, <expr>&amp;<name>PyEllipsis_Type</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Slice object implementation

   start, stop, and step are python objects with None indicating no
   index is present.
*/</comment>

<function><type><name>PyObject</name> *</type>
<name>PySlice_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>start</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>stop</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>step</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySliceObject</name> *</type><name>obj</name> <init>= <expr><call><name>PyObject_New</name><argument_list>(<argument><expr><name>PySliceObject</name></expr></argument>, <argument><expr>&amp;<name>PySlice_Type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>step</name> == <name>NULL</name></expr>)</condition><then> <expr_stmt><expr><name>step</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>start</name> == <name>NULL</name></expr>)</condition><then> <expr_stmt><expr><name>start</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>stop</name> == <name>NULL</name></expr>)</condition><then> <expr_stmt><expr><name>stop</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>obj</name>-&gt;<name>step</name></name> = <name>step</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name>-&gt;<name>start</name></name> = <name>start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name>-&gt;<name>stop</name></name> = <name>stop</name></expr>;</expr_stmt>

	<return>return <expr>(<name>PyObject</name> *) <name>obj</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PySlice_FromIndices</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>istart</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>istop</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>, *<decl><type ref="prev"/><name>slice</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>start</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>istart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>start</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>end</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>istop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>end</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>slice</name> = <call><name>PySlice_New</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>slice</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySlice_GetIndices</name><parameter_list>(<param><decl><type><name>PySliceObject</name> *</type><name>r</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>,
                   <param><decl><type><name>Py_ssize_t</name> *</type><name>start</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>stop</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>step</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX support long ints */</comment>
	<if>if <condition>(<expr><name><name>r</name>-&gt;<name>step</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>step</name> = 1</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>step</name></name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>step</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr>*<name>step</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>step</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name><name>r</name>-&gt;<name>start</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>start</name> = *<name>step</name> &lt; 0 ? <name>length</name>-1 : 0</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>step</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr>*<name>start</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>start</name> &lt; 0</expr>)</condition><then> <expr_stmt><expr>*<name>start</name> += <name>length</name></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<if>if <condition>(<expr><name><name>r</name>-&gt;<name>stop</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>stop</name> = *<name>step</name> &lt; 0 ? -1 : <name>length</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>stop</name></name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>step</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr>*<name>stop</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>stop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>stop</name> &lt; 0</expr>)</condition><then> <expr_stmt><expr>*<name>stop</name> += <name>length</name></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<if>if <condition>(<expr>*<name>stop</name> &gt; <name>length</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>*<name>start</name> &gt;= <name>length</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>*<name>step</name> == 0</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySlice_GetIndicesEx</name><parameter_list>(<param><decl><type><name>PySliceObject</name> *</type><name>r</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>,
		     <param><decl><type><name>Py_ssize_t</name> *</type><name>start</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>stop</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>step</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>slicelength</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* this is harder to get right than you might think */</comment>

	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>defstart</name></decl>, <decl><type ref="prev"/><name>defstop</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>r</name>-&gt;<name>step</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>step</name> = 1</expr>;</expr_stmt>
	}</block></then> 
	<else>else <block>{
		<if>if <condition>(<expr>!<call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>step</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr>*<name>step</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"slice step cannot be zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></else></if>

	<expr_stmt><expr><name>defstart</name> = *<name>step</name> &lt; 0 ? <name>length</name>-1 : 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>defstop</name> = *<name>step</name> &lt; 0 ? -1 : <name>length</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>r</name>-&gt;<name>start</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>start</name> = <name>defstart</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr>!<call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr>*<name>start</name> &lt; 0</expr>)</condition><then> <expr_stmt><expr>*<name>start</name> += <name>length</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>*<name>start</name> &lt; 0</expr>)</condition><then> <expr_stmt><expr>*<name>start</name> = (*<name>step</name> &lt; 0) ? -1 : 0</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>*<name>start</name> &gt;= <name>length</name></expr>)</condition><then> 
			<expr_stmt><expr>*<name>start</name> = (*<name>step</name> &lt; 0) ? <name>length</name> - 1 : <name>length</name></expr>;</expr_stmt></then></if>
	}</block></else></if>

	<if>if <condition>(<expr><name><name>r</name>-&gt;<name>stop</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>stop</name> = <name>defstop</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr>!<call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>stop</name></name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr>*<name>stop</name> &lt; 0</expr>)</condition><then> <expr_stmt><expr>*<name>stop</name> += <name>length</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>*<name>stop</name> &lt; 0</expr>)</condition><then> <expr_stmt><expr>*<name>stop</name> = (*<name>step</name> &lt; 0) ? -1 : 0</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>*<name>stop</name> &gt;= <name>length</name></expr>)</condition><then>
			<expr_stmt><expr>*<name>stop</name> = (*<name>step</name> &lt; 0) ? <name>length</name> - 1 : <name>length</name></expr>;</expr_stmt></then></if>
	}</block></else></if>

	<if>if <condition>(<expr>(*<name>step</name> &lt; 0 &amp;&amp; *<name>stop</name> &gt;= *<name>start</name>) 
	    || (*<name>step</name> &gt; 0 &amp;&amp; *<name>start</name> &gt;= *<name>stop</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>slicelength</name> = 0</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr>*<name>step</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>slicelength</name> = (*<name>stop</name>-*<name>start</name>+1)/(*<name>step</name>)+1</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr>*<name>slicelength</name> = (*<name>stop</name>-*<name>start</name>-1)/(*<name>step</name>)+1</expr>;</expr_stmt>
	}</block></else></if></else></if>

	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slice_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>stop</name></decl>, *<decl><type ref="prev"/><name>step</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>start</name> = <name>stop</name> = <name>step</name> = <name>NULL</name></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"slice()"</expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"slice"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* This swapping of stop and start is to maintain similarity with
	   range(). */</comment>
	<if>if <condition>(<expr><name>stop</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>stop</name> = <name>start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><call><name>PySlice_New</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>slice_doc</name></expr></argument>,
<argument><expr>"slice([start,] stop[, step])\n\
\n\
Create a slice object.  This is used for extended slicing (e.g. a[0:10:2])."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>slice_dealloc</name><parameter_list>(<param><decl><type><name>PySliceObject</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>step</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>stop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slice_repr</name><parameter_list>(<param><decl><type><name>PySliceObject</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>comma</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"slice("</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>comma</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_Concat</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>stop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_Concat</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>step</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>s</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>slice_members</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"start"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySliceObject</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"stop"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySliceObject</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"step"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySliceObject</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>slice_indices</name><parameter_list>(<param><decl><type><name>PySliceObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>len</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ilen</name></decl>, <decl><type ref="prev"/><name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelength</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ilen</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>ilen</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>ilen</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, 
				 <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelength</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(nnn)"</expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>slice_indices_doc</name></expr></argument>,
<argument><expr>"S.indices(len) -&gt; (start, stop, stride)\n\
\n\
Assuming a sequence of length len, calculate the start and stop\n\
indices, and the stride length of the extended slice described by\n\
S. Out of bounds indices are clipped in a manner consistent with the\n\
handling of normal slices."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slice_reduce</name><parameter_list>(<param><decl><type><name>PySliceObject</name>*</type> <name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"O(OOO)"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>stop</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>step</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reduce_doc</name></expr></argument>, <argument><expr>"Return state information for pickling."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>slice_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"indices"</expr>,	<expr>(<name>PyCFunction</name>)<name>slice_indices</name></expr>,
	 <expr><name>METH_O</name></expr>,	<expr><name>slice_indices_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__reduce__"</expr>,	<expr>(<name>PyCFunction</name>)<name>slice_reduce</name></expr>,
	 <expr><name>METH_NOARGS</name></expr>,	<expr><name>reduce_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slice_compare</name><parameter_list>(<param><decl><type><name>PySliceObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PySliceObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>v</name> == <name>w</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyObject_Cmp</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>w</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr>-2</expr>;</return></then></if>
	<if>if <condition>(<expr><name>result</name> != 0</expr>)</condition><then>
		<return>return <expr><name>result</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyObject_Cmp</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>stop</name></name></expr></argument>, <argument><expr><name><name>w</name>-&gt;<name>stop</name></name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr>-2</expr>;</return></then></if>
	<if>if <condition>(<expr><name>result</name> != 0</expr>)</condition><then>
		<return>return <expr><name>result</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyObject_Cmp</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>step</name></name></expr></argument>, <argument><expr><name><name>w</name>-&gt;<name>step</name></name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr>-2</expr>;</return></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>slice_hash</name><parameter_list>(<param><decl><type><name>PySliceObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"unhashable type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1L</expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PySlice_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"slice"</expr>,		<comment type="block">/* Name of this type */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PySliceObject</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/* Basic object size */</comment>
	<expr>0</expr>,			<comment type="block">/* Item size for varobject */</comment>
	<expr>(<name>destructor</name>)<name>slice_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>(<name>cmpfunc</name>)<name>slice_compare</name></expr>, 		<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>slice_repr</name></expr>,   		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,	    				<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>slice_hash</name></expr>,			<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,			<comment type="block">/* tp_flags */</comment>
	<expr><name>slice_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>slice_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr><name>slice_members</name></expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>slice_new</name></expr>,				<comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>
</unit>
