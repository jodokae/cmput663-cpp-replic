<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/typeobject.c"><comment type="block">/* Type object implementation */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>


<comment type="block">/* Support type attribute cache */</comment>

<comment type="block">/* The cache can keep references to the names alive for longer than
   they normally would.  This is why the maximum size is limited to
   MCACHE_MAX_ATTR_SIZE, since it might be a problem if very large
   strings are used as attribute names. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCACHE_MAX_ATTR_SIZE</name></cpp:macro>	<cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCACHE_SIZE_EXP</name></cpp:macro>		<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCACHE_HASH</name><parameter_list>(<param><type><name>version</name></type></param>, <param><type><name>name_hash</name></type></param>)</parameter_list></cpp:macro>					\
		<cpp:value>(((unsigned int)(version) * (unsigned int)(name_hash))	\
		 &gt;&gt; (8*sizeof(unsigned int) - MCACHE_SIZE_EXP))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCACHE_HASH_METHOD</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro>                                  \
		<cpp:value>MCACHE_HASH((type)-&gt;tp_version_tag,                     \
		            ((PyStringObject *)(name))-&gt;ob_shash)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCACHE_CACHEABLE_NAME</name><parameter_list>(<param><type><name>name</name></type></param>)</parameter_list></cpp:macro>                                     \
		<cpp:value>PyString_CheckExact(name) &amp;&amp;                            \
		PyString_GET_SIZE(name) &lt;= MCACHE_MAX_ATTR_SIZE</cpp:value></cpp:define>

<struct>struct <name>method_cache_entry</name> <block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>version</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>		<comment type="block">/* reference to exactly a str or None */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>	<comment type="block">/* borrowed */</comment>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>method_cache_entry</name></type> <name><name>method_cache</name><index>[<expr>1 &lt;&lt; <name>MCACHE_SIZE_EXP</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>next_version_tag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><name>unsigned</name> <name>int</name></type>
<name>PyType_ClearCache</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cur_version_tag</name> <init>= <expr><name>next_version_tag</name> - 1</expr></init></decl>;</decl_stmt>
	
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (1 &lt;&lt; <name>MCACHE_SIZE_EXP</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name><name>method_cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>version</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>method_cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>method_cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name>next_version_tag</name> = 0</expr>;</expr_stmt>
	<comment type="block">/* mark all version tags as invalid */</comment>
	<expr_stmt><expr><call><name>PyType_Modified</name><argument_list>(<argument><expr>&amp;<name>PyBaseObject_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cur_version_tag</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyType_Modified</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Invalidate any cached data for the specified type and all
	   subclasses.  This function is called after the base
	   classes, mro, or attributes of the type are altered.

	   Invariants:

	   - Py_TPFLAGS_VALID_VERSION_TAG is never set if
	     Py_TPFLAGS_HAVE_VERSION_TAG is not set (e.g. on type
	     objects coming from non-recompiled extension modules)

	   - before Py_TPFLAGS_VALID_VERSION_TAG can be set on a type,
	     it must first be set on all super types.

	   This function clears the Py_TPFLAGS_VALID_VERSION_TAG of a
	   type (so it must first clear it on all subclasses).  The
	   tp_version_tag value is meaningless unless this flag is set.
	   We don't assign new version tags eagerly, but only as
	   needed.
	 */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>raw</name></decl>, *<decl><type ref="prev"/><name>ref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_VALID_VERSION_TAG</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>raw</name> = <name><name>type</name>-&gt;<name>tp_subclasses</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>raw</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>ref</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>raw</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ref</name> = <call><name>PyWeakref_GET_OBJECT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ref</name> != <name>Py_None</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyType_Modified</name><argument_list>(<argument><expr>(<name>PyTypeObject</name> *)<name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
	}</block></then></if>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp;= ~<name>Py_TPFLAGS_VALID_VERSION_TAG</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>type_mro_modified</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>bases</name></decl></param>)</parameter_list> <block>{
	<comment type="block">/*
	   Check that all base classes or elements of the mro of type are
	   able to be cached.  This function is called after the base
	   classes or mro of the type are altered.

	   Unset HAVE_VERSION_TAG and VALID_VERSION_TAG if the type
	   inherits from an old-style class, either directly or if it
	   appears in the MRO of a new-style class.  No support either for
	   custom MROs that include types that are not officially super
	   types.

	   Called from mro_internal, which will subsequently be called on
	   each subclass when their mro is recursively updated.
	 */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>clear</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HAVE_VERSION_TAG</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>b</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>cls</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>!<call><name>PyType_Check</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr> )</condition><then> <block>{
			<expr_stmt><expr><name>clear</name> = 1</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>

		<expr_stmt><expr><name>cls</name> = (<name>PyTypeObject</name> *)<name>b</name></expr>;</expr_stmt>

		<if>if <condition>(<expr>!<call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HAVE_VERSION_TAG</name></expr></argument>)</argument_list></call> ||
		    !<call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>clear</name> = 1</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
	}</block></for>

	<if>if <condition>(<expr><name>clear</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp;= ~(<name>Py_TPFLAGS_HAVE_VERSION_TAG</name>|
		                    <name>Py_TPFLAGS_VALID_VERSION_TAG</name>)</expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>assign_version_tag</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Ensure that the tp_version_tag is valid and set
	   Py_TPFLAGS_VALID_VERSION_TAG.  To respect the invariant, this
	   must first be done on all super classes.  Return 0 if this
	   cannot be done, 1 if Py_TPFLAGS_VALID_VERSION_TAG.
	*/</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>bases</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_VALID_VERSION_TAG</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HAVE_VERSION_TAG</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_READY</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_version_tag</name></name> = <name>next_version_tag</name>++</expr>;</expr_stmt>
	<comment type="block">/* for stress-testing: next_version_tag &amp;= 0xFF; */</comment>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_version_tag</name></name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* wrap-around or just starting Python - clear the whole
		   cache by filling names with references to Py_None.
		   Values are also set to NULL for added protection, as they
		   are borrowed reference */</comment>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (1 &lt;&lt; <name>MCACHE_SIZE_EXP</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name><name>method_cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name> = <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>method_cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>method_cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> = <name>Py_None</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<comment type="block">/* mark all version tags as invalid */</comment>
		<expr_stmt><expr><call><name>PyType_Modified</name><argument_list>(<argument><expr>&amp;<name>PyBaseObject_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>bases</name> = <name><name>type</name>-&gt;<name>tp_bases</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>b</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>assign_version_tag</name><argument_list>(<argument><expr>(<name>PyTypeObject</name> *)<name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></for>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_VALID_VERSION_TAG</name></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>type_members</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__basicsize__"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyTypeObject</name></expr></argument>,<argument><expr><name>tp_basicsize</name></expr></argument>)</argument_list></call></expr>,<expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"__itemsize__"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyTypeObject</name></expr></argument>, <argument><expr><name>tp_itemsize</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"__flags__"</expr>, <expr><name>T_LONG</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyTypeObject</name></expr></argument>, <argument><expr><name>tp_flags</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"__weakrefoffset__"</expr>, <expr><name>T_LONG</name></expr>,
	 <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyTypeObject</name></expr></argument>, <argument><expr><name>tp_weaklistoffset</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"__base__"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyTypeObject</name></expr></argument>, <argument><expr><name>tp_base</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"__dictoffset__"</expr>, <expr><name>T_LONG</name></expr>,
	 <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyTypeObject</name></expr></argument>, <argument><expr><name>tp_dictoffset</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"__mro__"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyTypeObject</name></expr></argument>, <argument><expr><name>tp_mro</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_name</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyHeapTypeObject</name>*</type> <name>et</name> <init>= <expr>(<name>PyHeapTypeObject</name>*)<name>type</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>et</name>-&gt;<name>ht_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>et</name>-&gt;<name>ht_name</name></name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>s</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>s</name> = <name><name>type</name>-&gt;<name>tp_name</name></name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></else></if>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_set_name</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyHeapTypeObject</name>*</type> <name>et</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"can't set %s.__name__"</expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"can't delete %s.__name__"</expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"can only assign string to %s.__name__, not '%s'"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
	    != (<name>size_t</name>)<call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			     <argument><expr>"__name__ must not contain null bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>et</name> = (<name>PyHeapTypeObject</name>*)<name>type</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>et</name>-&gt;<name>ht_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>et</name>-&gt;<name>ht_name</name></name> = <name>value</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_name</name></name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_module</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>mod</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>, <argument><expr>"__module__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>mod</name></expr>)</condition><then> <block>{ 
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr>"__module__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>mod</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>s</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>s</name> != <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(
			    <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><name>s</name> - <name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_set_module</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"can't set %s.__module__"</expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"can't delete %s.__module__"</expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyType_Modified</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>, <argument><expr>"__module__"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_abstractmethods</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name> <init>= <expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>,
					     <argument><expr>"__abstractmethods__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>mod</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr>"__abstractmethods__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>mod</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_set_abstractmethods</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* __abstractmethods__ should only be set once on a type, in
	   abc.ABCMeta.__new__, so this function doesn't do anything
	   special to update subclasses.
	*/</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>,
				       <argument><expr>"__abstractmethods__"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>res</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyType_Modified</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>value</name> &amp;&amp; <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_IS_ABSTRACT</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp;= ~<name>Py_TPFLAGS_IS_ABSTRACT</name></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_get_bases</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>type</name>-&gt;<name>tp_bases</name></name></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>PyTypeObject</name> *</type><name>best_base</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mro_internal</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compatible_for_assignment</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>add_subclass</name><parameter_list>(<param><decl><type><name>PyTypeObject</name>*</type></decl></param>, <param><decl><type><name>PyTypeObject</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_subclass</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_all_slots</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<typedef>typedef <function_decl><type><name>int</name></type> (*<name>update_callback</name>)<parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type></decl></param>, <param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl></typedef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>update_subclasses</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>,
			     <param><decl><type><name>update_callback</name></type> <name>callback</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recurse_down_subclasses</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>,
				   <param><decl><type><name>update_callback</name></type> <name>callback</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>mro_subclasses</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>temp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>subclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ref</name></decl>, *<decl><type ref="prev"/><name>subclasses</name></decl>, *<decl><type ref="prev"/><name>old_mro</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>subclasses</name> = <name><name>type</name>-&gt;<name>tp_subclasses</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>subclasses</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>subclasses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>subclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>ref</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>subclasses</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyWeakref_CheckRef</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subclass</name> = (<name>PyTypeObject</name> *)<call><name>PyWeakref_GET_OBJECT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>subclass</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>PyObject</name> *)<name>subclass</name> == <name>Py_None</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>subclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_mro</name> = <name><name>subclass</name>-&gt;<name>tp_mro</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>mro_internal</name><argument_list>(<argument><expr><name>subclass</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>subclass</name>-&gt;<name>tp_mro</name></name> = <name>old_mro</name></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>PyObject</name>*</type> <name>tuple</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>tuple</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>subclass</name></expr></argument>, <argument><expr><name>old_mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>tuple</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><call><name>mro_subclasses</name><argument_list>(<argument><expr><name>subclass</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_set_bases</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ob</name></decl>, *<decl><type ref="prev"/><name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>new_base</name></decl>, *<decl><type ref="prev"/><name>old_base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_bases</name></decl>, *<decl><type ref="prev"/><name>old_mro</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"can't set %s.__bases__"</expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"can't delete %s.__bases__"</expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"can only assign tuple to %s.__bases__, not %s"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"can only assign non-empty tuple to %s.__bases__, not ()"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>ob</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyClass_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyType_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
	<argument><expr>"%s.__bases__ must be tuple of old- or new-style classes, not '%s'"</expr></argument>,
				<argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr>(<name>PyTypeObject</name>*)<name>ob</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"a __bases__ item causes an inheritance cycle"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></for>

	<expr_stmt><expr><name>new_base</name> = <call><name>best_base</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<name>new_base</name></expr>)</condition><then> <block>{
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>compatible_for_assignment</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_base</name></name></expr></argument>, <argument><expr><name>new_base</name></expr></argument>, <argument><expr>"__bases__"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>new_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_bases</name> = <name><name>type</name>-&gt;<name>tp_bases</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_base</name> = <name><name>type</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_mro</name> = <name><name>type</name>-&gt;<name>tp_mro</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_bases</name></name> = <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_base</name></name> = <name>new_base</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>mro_internal</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<goto>goto <name>bail</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>temp</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>temp</name></expr>)</condition><then>
		<goto>goto <name>bail</name>;</goto></then></if>

	<expr_stmt><expr><name>r</name> = <call><name>mro_subclasses</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>r</name> &lt; 0</expr>)</condition><then> <block>{
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyList_Size</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyTypeObject</name>*</type> <name>cls</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name>*</type> <name>mro</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr>""</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>cls</name></expr></argument>, <argument><expr>&amp;<name>mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ob</name> = <name><name>cls</name>-&gt;<name>tp_mro</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cls</name>-&gt;<name>tp_mro</name></name> = <name>mro</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>bail</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* any base that was in __bases__ but now isn't, we
	   need to remove |type| from its tp_subclasses.
	   conversely, any class now in __bases__ that wasn't
	   needs to have |type| added to its subclasses. */</comment>

	<comment type="block">/* for now, sod that: just remove from all old_bases,
	   add to all new_bases */</comment>

	<for>for (<init><expr><name>i</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>old_bases</name></expr></argument>)</argument_list></call> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
		<expr_stmt><expr><name>ob</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>old_bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>remove_subclass</name><argument_list>(
				<argument><expr>(<name>PyTypeObject</name>*)<name>ob</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

	<for>for (<init><expr><name>i</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
		<expr_stmt><expr><name>ob</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>add_subclass</name><argument_list>(<argument><expr>(<name>PyTypeObject</name>*)<name>ob</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<expr_stmt><expr><name>r</name> = -1</expr>;</expr_stmt></then></if>
		}</block></then></if>
	}</block></for>

	<expr_stmt><expr><call><name>update_all_slots</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>r</name></expr>;</return>

  <label><name>bail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_mro</name></name> != <name>old_mro</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_mro</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_bases</name></name> = <name>old_bases</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_base</name></name> = <name>old_base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_mro</name></name> = <name>old_mro</name></expr>;</expr_stmt>

	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_dict</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyDictProxy_New</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_get_doc</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>) &amp;&amp; <name><name>type</name>-&gt;<name>tp_doc</name></name> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_doc</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>, <argument><expr>"__doc__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>-&gt;<name>tp_descr_get</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_descr_get</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						       <argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type___instancecheck__</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>inst</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><call><name>_PyObject_RealIsInstance</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<case>case <expr>-1</expr>:
		<return>return <expr><name>NULL</name></expr>;</return>
	</case><case>case <expr>0</expr>:
		<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
	</case><default>default:
		<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
	</default>}</block></switch>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_get_instancecheck</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name>ml</name> <init>= <expr><block>{<expr>"__instancecheck__"</expr>,
				 <expr><name>type___instancecheck__</name></expr>, <expr><name>METH_O</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>PyCFunction_New</name><argument_list>(<argument><expr>&amp;<name>ml</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type___subclasscheck__</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>inst</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><call><name>_PyObject_RealIsSubclass</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<case>case <expr>-1</expr>:
		<return>return <expr><name>NULL</name></expr>;</return>
	</case><case>case <expr>0</expr>:
		<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
	</case><default>default:
		<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
	</default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_get_subclasscheck</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name>ml</name> <init>= <expr><block>{<expr>"__subclasscheck__"</expr>,
				 <expr><name>type___subclasscheck__</name></expr>, <expr><name>METH_O</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>PyCFunction_New</name><argument_list>(<argument><expr>&amp;<name>ml</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>type_getsets</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__name__"</expr>, <expr>(<name>getter</name>)<name>type_name</name></expr>, <expr>(<name>setter</name>)<name>type_set_name</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr>"__bases__"</expr>, <expr>(<name>getter</name>)<name>type_get_bases</name></expr>, <expr>(<name>setter</name>)<name>type_set_bases</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr>"__module__"</expr>, <expr>(<name>getter</name>)<name>type_module</name></expr>, <expr>(<name>setter</name>)<name>type_set_module</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr>"__abstractmethods__"</expr>, <expr>(<name>getter</name>)<name>type_abstractmethods</name></expr>,
	 <expr>(<name>setter</name>)<name>type_set_abstractmethods</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr>"__dict__"</expr>,  <expr>(<name>getter</name>)<name>type_dict</name></expr>,  <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr>"__doc__"</expr>, <expr>(<name>getter</name>)<name>type_get_doc</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr>"__instancecheck__"</expr>, <expr>(<name>getter</name>)<name>type_get_instancecheck</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr>"__subclasscheck__"</expr>, <expr>(<name>getter</name>)<name>type_get_subclasscheck</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* This is called with type objects only. So we
	   can just compare the addresses. */</comment>
	<decl_stmt><decl><type><name>Py_uintptr_t</name></type> <name>vv</name> <init>= <expr>(<name>Py_uintptr_t</name>)<name>v</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_uintptr_t</name></type> <name>ww</name> <init>= <expr>(<name>Py_uintptr_t</name>)<name>w</name></expr></init></decl>;</decl_stmt>
	<return>return <expr>(<name>vv</name> &lt; <name>ww</name>) ? -1 : (<name>vv</name> &gt; <name>ww</name>) ? 1 : 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>type_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_uintptr_t</name></type> <name>vv</name></decl>, <decl><type ref="prev"/><name>ww</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure both arguments are types. */</comment>
	<if>if <condition>(<expr>!<call><name>PyType_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || !<call><name>PyType_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
		<goto>goto <name>out</name>;</goto>
	}</block></then></if>

	<comment type="block">/* Py3K warning if comparison isn't == or !=  */</comment>
	<if>if <condition>(<expr><name>Py_Py3kWarningFlag</name> &amp;&amp; <name>op</name> != <name>Py_EQ</name> &amp;&amp; <name>op</name> != <name>Py_NE</name> &amp;&amp;
		<call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
			   <argument><expr>"type inequality comparisons not supported "
			   "in 3.x"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Compare addresses */</comment>
	<expr_stmt><expr><name>vv</name> = (<name>Py_uintptr_t</name>)<name>v</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ww</name> = (<name>Py_uintptr_t</name>)<name>w</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Py_LT</name></expr>: <expr_stmt><expr><name>c</name> = <name>vv</name> &lt;  <name>ww</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_LE</name></expr>: <expr_stmt><expr><name>c</name> = <name>vv</name> &lt;= <name>ww</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_EQ</name></expr>: <expr_stmt><expr><name>c</name> = <name>vv</name> == <name>ww</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_NE</name></expr>: <expr_stmt><expr><name>c</name> = <name>vv</name> != <name>ww</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_GT</name></expr>: <expr_stmt><expr><name>c</name> = <name>vv</name> &gt;  <name>ww</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_GE</name></expr>: <expr_stmt><expr><name>c</name> = <name>vv</name> &gt;= <name>ww</name></expr>;</expr_stmt> <break>break;</break>
	</case><default>default:
		<expr_stmt><expr><name>result</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
		<goto>goto <name>out</name>;</goto>
	</default>}</block></switch>
	<expr_stmt><expr><name>result</name> = <name>c</name> ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>

  <comment type="block">/* incref and return */</comment>
  <label><name>out</name>:</label>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_repr</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>, *<decl><type ref="prev"/><name>rtn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>kind</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>mod</name> = <call><name>type_module</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mod</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<expr_stmt><expr><name>name</name> = <call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr>)</condition><then>
		<expr_stmt><expr><name>kind</name> = "class"</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>kind</name> = "type"</expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name>mod</name> != <name>NULL</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>rtn</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s '%s.%s'&gt;"</expr></argument>,
					  <argument><expr><name>kind</name></expr></argument>,
					  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>rtn</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s '%s'&gt;"</expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rtn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_call</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_new</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"cannot create '%.100s' instances"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>obj</name> = <call><name><name>type</name>-&gt;<name>tp_new</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>obj</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Ugly exception: when the call was type(something),
		   don't call tp_init on the result. */</comment>
		<if>if <condition>(<expr><name>type</name> == &amp;<name>PyType_Type</name> &amp;&amp;
		    <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
		    (<name>kwds</name> == <name>NULL</name> ||
		     (<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> == 0))</expr>)</condition><then>
			<return>return <expr><name>obj</name></expr>;</return></then></if>
		<comment type="block">/* If the returned object is not an instance of type,
		   it won't be initialized. */</comment>
		<if>if <condition>(<expr>!<call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>obj</name></expr>;</return></then></if>
		<expr_stmt><expr><name>type</name> = <name><name>obj</name>-&gt;<name>ob_type</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HAVE_CLASS</name></expr></argument>)</argument_list></call> &amp;&amp;
		    <name><name>type</name>-&gt;<name>tp_init</name></name> != <name>NULL</name> &amp;&amp;
		    <call><name><name>type</name>-&gt;<name>tp_init</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>obj</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>obj</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyType_GenericAlloc</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>nitems</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><call><name>_PyObject_VAR_SIZE</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>nitems</name>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* note that we need to add one, for the sentinel */</comment>

	<if>if <condition>(<expr><call><name>PyType_IS_GC</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>obj</name> = <call><name>_PyObject_GC_Malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>obj</name> = (<name>PyObject</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_itemsize</name></name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr>(<name>void</name>) <call><name>PyObject_INIT_VAR</name><argument_list>(<argument><expr>(<name>PyVarObject</name> *)<name>obj</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><call><name>PyType_IS_GC</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>obj</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyType_GenericNew</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Helpers for subtyping */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>traverse_slots</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyMemberDef</name> *</type><name>mp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mp</name> = <call><name>PyHeapType_GET_MEMBERS</name><argument_list>(<argument><expr>(<name>PyHeapTypeObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>mp</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>type</name></name> == <name>T_OBJECT_EX</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>addr</name> <init>= <expr>(<name>char</name> *)<name>self</name> + <name><name>mp</name>-&gt;<name>offset</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr>*(<name>PyObject</name> **)<name>addr</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>obj</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>visit</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
					<return>return <expr><name>err</name></expr>;</return></then></if>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>subtype_traverse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>traverseproc</name></type> <name>basetraverse</name></decl>;</decl_stmt>

	<comment type="block">/* Find the nearest base with a different tp_traverse,
	   and traverse slots while we're at it */</comment>
	<expr_stmt><expr><name>type</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>base</name> = <name>type</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>basetraverse</name> = <name><name>base</name>-&gt;<name>tp_traverse</name></name>) == <name>subtype_traverse</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>traverse_slots</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>visit</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
				<return>return <expr><name>err</name></expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>base</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_dictoffset</name></name> != <name><name>base</name>-&gt;<name>tp_dictoffset</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>dictptr</name> <init>= <expr><call><name>_PyObject_GetDictPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>dictptr</name> &amp;&amp; *<name>dictptr</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr>*<name>dictptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr>)</condition><then>
		<comment type="block">/* For a heaptype, the instances count as references
		   to the type.	 Traverse the type so the collector
		   can find cycles involving this link. */</comment>
		<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>basetraverse</name></expr>)</condition><then>
		<return>return <expr><call><name>basetraverse</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>visit</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_slots</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyMemberDef</name> *</type><name>mp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mp</name> = <call><name>PyHeapType_GET_MEMBERS</name><argument_list>(<argument><expr>(<name>PyHeapTypeObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>mp</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>type</name></name> == <name>T_OBJECT_EX</name> &amp;&amp; !(<name><name>mp</name>-&gt;<name>flags</name></name> &amp; <name>READONLY</name>)</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>addr</name> <init>= <expr>(<name>char</name> *)<name>self</name> + <name><name>mp</name>-&gt;<name>offset</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr>*(<name>PyObject</name> **)<name>addr</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>obj</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr>*(<name>PyObject</name> **)<name>addr</name> = <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>subtype_clear</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>inquiry</name></type> <name>baseclear</name></decl>;</decl_stmt>

	<comment type="block">/* Find the nearest base with a different tp_clear
	   and clear slots while we're at it */</comment>
	<expr_stmt><expr><name>type</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>base</name> = <name>type</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>baseclear</name> = <name><name>base</name>-&gt;<name>tp_clear</name></name>) == <name>subtype_clear</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>clear_slots</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>base</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

	<comment type="block">/* There's no need to clear the instance dict (if any);
	   the collector will call its tp_clear handler. */</comment>

	<if>if <condition>(<expr><name>baseclear</name></expr>)</condition><then>
		<return>return <expr><call><name>baseclear</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>subtype_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>destructor</name></type> <name>basedealloc</name></decl>;</decl_stmt>

	<comment type="block">/* Extract the type; we expect it to be a heap type */</comment>
	<expr_stmt><expr><name>type</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test whether the type has GC exactly once */</comment>

	<if>if <condition>(<expr>!<call><name>PyType_IS_GC</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* It's really rare to find a dynamic type that doesn't have
		   GC; it can only happen when deriving from 'object' and not
		   adding any slots or instance variables.  This allows
		   certain simplifications: there's no need to call
		   clear_slots(), or DECREF the dict, or clear weakrefs. */</comment>

		<comment type="block">/* Maybe call finalizer; exit early if resurrected */</comment>
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_del</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name><name>type</name>-&gt;<name>tp_del</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ob_refcnt</name></name> &gt; 0</expr>)</condition><then>
				<return>return;</return></then></if>
		}</block></then></if>

		<comment type="block">/* Find the nearest base with a different tp_dealloc */</comment>
		<expr_stmt><expr><name>base</name> = <name>type</name></expr>;</expr_stmt>
		<while>while <condition>(<expr>(<name>basedealloc</name> = <name><name>base</name>-&gt;<name>tp_dealloc</name></name>) == <name>subtype_dealloc</name></expr>)</condition> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>base</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>

		<comment type="block">/* Call the base tp_dealloc() */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>basedealloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>basedealloc</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Can't reference self beyond this point */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done */</comment>
		<return>return;</return>
	}</block></then></if>

	<comment type="block">/* We get here only if the type has GC */</comment>

	<comment type="block">/* UnTrack and re-Track around the trashcan macro, alas */</comment>
	<comment type="block">/* See explanation at end of function for full disclosure */</comment>
	<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>++<name>_PyTrash_delete_nesting</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TRASHCAN_SAFE_BEGIN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>--<name>_PyTrash_delete_nesting</name></expr>;</expr_stmt>
	<comment type="block">/* DO NOT restore GC tracking at this point.  weakref callbacks
	 * (if any, and whether directly here or indirectly in something we
	 * call) may trigger GC, and if self is tracked at that point, it
	 * will look like trash to GC and GC will try to delete self again.
	 */</comment>

	<comment type="block">/* Find the nearest base with a different tp_dealloc */</comment>
	<expr_stmt><expr><name>base</name> = <name>type</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>basedealloc</name> = <name><name>base</name>-&gt;<name>tp_dealloc</name></name>) == <name>subtype_dealloc</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>base</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

	<comment type="block">/* If we added a weaklist, we clear it.	 Do this *before* calling
	   the finalizer (__del__), clearing slots, or clearing the instance
	   dict. */</comment>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_weaklistoffset</name></name> &amp;&amp; !<name><name>base</name>-&gt;<name>tp_weaklistoffset</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* Maybe call finalizer; exit early if resurrected */</comment>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_del</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>type</name>-&gt;<name>tp_del</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ob_refcnt</name></name> &gt; 0</expr>)</condition><then>
			<goto>goto <name>endlabel</name>;</goto></then>	<comment type="block">/* resurrected */</comment>
		<else>else
			<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<comment type="block">/* New weakrefs could be created during the finalizer call.
		    If this occurs, clear them out without calling their
		    finalizers since they might rely on part of the object
		    being finalized that has already been destroyed. */</comment>
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_weaklistoffset</name></name> &amp;&amp; !<name><name>base</name>-&gt;<name>tp_weaklistoffset</name></name></expr>)</condition><then> <block>{
			<comment type="block">/* Modeled after GET_WEAKREFS_LISTPTR() */</comment>
			<decl_stmt><decl><type><name>PyWeakReference</name> **</type><name>list</name> <init>= <expr>(<name>PyWeakReference</name> **) \
				<call><name>PyObject_GET_WEAKREFS_LISTPTR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<while>while <condition>(<expr>*<name>list</name></expr>)</condition>
				<expr_stmt><expr><call><name>_PyWeakref_ClearRef</name><argument_list>(<argument><expr>*<name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
		}</block></then></if>
	}</block></then></if>

	<comment type="block">/*  Clear slots up to the nearest base with a different tp_dealloc */</comment>
	<expr_stmt><expr><name>base</name> = <name>type</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>basedealloc</name> = <name><name>base</name>-&gt;<name>tp_dealloc</name></name>) == <name>subtype_dealloc</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>clear_slots</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>base</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

	<comment type="block">/* If we added a dict, DECREF it */</comment>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_dictoffset</name></name> &amp;&amp; !<name><name>base</name>-&gt;<name>tp_dictoffset</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>dictptr</name> <init>= <expr><call><name>_PyObject_GetDictPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>dictptr</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr>*<name>dictptr</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>dict</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>dictptr</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
	}</block></then></if>

	<comment type="block">/* Call the base tp_dealloc(); first retrack self if
	 * basedealloc knows about gc.
	 */</comment>
	<if>if <condition>(<expr><call><name>PyType_IS_GC</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>basedealloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>basedealloc</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't reference self beyond this point */</comment>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>endlabel</name>:</label>
	<expr_stmt><expr>++<name>_PyTrash_delete_nesting</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TRASHCAN_SAFE_END</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>--<name>_PyTrash_delete_nesting</name></expr>;</expr_stmt>

	<comment type="block">/* Explanation of the weirdness around the trashcan macros:

	   Q. What do the trashcan macros do?

	   A. Read the comment titled "Trashcan mechanism" in object.h.
	      For one, this explains why there must be a call to GC-untrack
	      before the trashcan begin macro.	Without understanding the
	      trashcan code, the answers to the following questions don't make
	      sense.

	   Q. Why do we GC-untrack before the trashcan and then immediately
	      GC-track again afterward?

	   A. In the case that the base class is GC-aware, the base class
	      probably GC-untracks the object.	If it does that using the
	      UNTRACK macro, this will crash when the object is already
	      untracked.  Because we don't know what the base class does, the
	      only safe thing is to make sure the object is tracked when we
	      call the base class dealloc.  But...  The trashcan begin macro
	      requires that the object is *untracked* before it is called.  So
	      the dance becomes:

		 GC untrack
		 trashcan begin
		 GC track

	   Q. Why did the last question say "immediately GC-track again"?
	      It's nowhere near immediately.

	   A. Because the code *used* to re-track immediately.	Bad Idea.
	      self has a refcount of 0, and if gc ever gets its hands on it
	      (which can happen if any weakref callback gets invoked), it
	      looks like trash to gc too, and gc also tries to delete self
	      then.  But we're already deleting self.  Double dealloction is
	      a subtle disaster.

	   Q. Why the bizarre (net-zero) manipulation of
	      _PyTrash_delete_nesting around the trashcan macros?

	   A. Some base classes (e.g. list) also use the trashcan mechanism.
	      The following scenario used to be possible:

	      - suppose the trashcan level is one below the trashcan limit

	      - subtype_dealloc() is called

	      - the trashcan limit is not yet reached, so the trashcan level
		is incremented and the code between trashcan begin and end is
		executed

	      - this destroys much of the object's contents, including its
		slots and __dict__

	      - basedealloc() is called; this is really list_dealloc(), or
		some other type which also uses the trashcan macros

	      - the trashcan limit is now reached, so the object is put on the
		trashcan's to-be-deleted-later list

	      - basedealloc() returns

	      - subtype_dealloc() decrefs the object's type

	      - subtype_dealloc() returns

	      - later, the trashcan code starts deleting the objects from its
		to-be-deleted-later list

	      - subtype_dealloc() is called *AGAIN* for the same object

	      - at the very least (if the destroyed slots and __dict__ don't
		cause problems) the object's type gets decref'ed a second
		time, which is *BAD*!!!

	      The remedy is to make sure that if the code between trashcan
	      begin and end in subtype_dealloc() is called, the code between
	      trashcan begin and end in basedealloc() will also be called.
	      This is done by decrementing the level after passing into the
	      trashcan block, and incrementing it just before leaving the
	      block.

	      But now it's possible that a chain of objects consisting solely
	      of objects whose deallocator is subtype_dealloc() will defeat
	      the trashcan mechanism completely: the decremented level means
	      that the effective level never reaches the limit.	 Therefore, we
	      *increment* the level *before* entering the trashcan block, and
	      matchingly decrement it after leaving.  This means the trashcan
	      code will trigger a little early, but that's no big deal.

	   Q. Are there any live examples of code in need of all this
	      complexity?

	   A. Yes.  See SF bug 668433 for code that crashed (when Python was
	      compiled in debug mode) before the trashcan level manipulations
	      were added.  For more discussion, see SF patches 581742, 575073
	      and bug 574207.
	*/</comment>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>PyTypeObject</name> *</type><name>solid_base</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* type test with subclassing support */</comment>

<function><type><name>int</name></type>
<name>PyType_IsSubtype</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mro</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!(<name><name>a</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_CLASS</name>)</expr>)</condition><then>
		<return>return <expr><name>b</name> == <name>a</name> || <name>b</name> == &amp;<name>PyBaseObject_Type</name></expr>;</return></then></if>

	<expr_stmt><expr><name>mro</name> = <name><name>a</name>-&gt;<name>tp_mro</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mro</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Deal with multiple inheritance without recursion
		   by walking the MRO tuple */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>mro</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == (<name>PyObject</name> *)<name>b</name></expr>)</condition><then>
				<return>return <expr>1</expr>;</return></then></if>
		}</block></for>
		<return>return <expr>0</expr>;</return>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* a is not completely initilized yet; follow tp_base */</comment>
		<do>do <block>{
			<if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then>
				<return>return <expr>1</expr>;</return></then></if>
			<expr_stmt><expr><name>a</name> = <name><name>a</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
		}</block> while <condition>(<expr><name>a</name> != <name>NULL</name></expr>)</condition>;</do>
		<return>return <expr><name>b</name> == &amp;<name>PyBaseObject_Type</name></expr>;</return>
	}</block></else></if>
}</block></function>

<comment type="block">/* Internal routines to do a method lookup in the type
   without looking in the instance dictionary
   (so we can't use PyObject_GetAttr) but still binding
   it to the instance.	The arguments are the object,
   the method name as a C string, and the address of a
   static variable used to cache the interned Python string.

   Two variants:

   - lookup_maybe() returns NULL without raising an exception
     when the _PyType_Lookup() call fails;

   - lookup_method() always raises an exception upon errors.
*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lookup_maybe</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>attrstr</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>attrobj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>*<name>attrobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>attrobj</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name>attrstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>attrobj</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>*<name>attrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>f</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>(<name>f</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>-&gt;<name>tp_descr_get</name>) == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>res</name> = <call><name>f</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lookup_method</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>attrstr</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>attrobj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>lookup_maybe</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>attrstr</name></expr></argument>, <argument><expr><name>attrobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr>*<name>attrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* A variation of PyObject_CallMethod that uses lookup_method()
   instead of PyObject_GetAttrString().	 This uses the same convention
   as lookup_method to cache the interned name string object. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_method</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>nameobj</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>, *<decl><type ref="prev"/><name>func</name> <init>= <expr>0</expr></init>, *<name>retval</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_maybe</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr>*<name>nameobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>format</name> &amp;&amp; *<name>format</name></expr>)</condition><then>
		<expr_stmt><expr><name>args</name> = <call><name>Py_VaBuildValue</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<comment type="block">/* Clone of call_method() that returns NotImplemented when the lookup fails. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_maybe</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>nameobj</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>, *<decl><type ref="prev"/><name>func</name> <init>= <expr>0</expr></init>, *<name>retval</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_maybe</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>format</name> &amp;&amp; *<name>format</name></expr>)</condition><then>
		<expr_stmt><expr><name>args</name> = <call><name>Py_VaBuildValue</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>fill_classic_mro</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mro</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>bases</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <call><name>PySequence_Contains</name><argument_list>(<argument><expr><name>mro</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>!<name>i</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>mro</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>bases</name> = ((<name>PyClassObject</name> *)<name>cls</name>)-&gt;<name>cl_bases</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bases</name> &amp;&amp; <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>base</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>fill_classic_mro</name><argument_list>(<argument><expr><name>mro</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>classic_mro</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mro</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mro</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mro</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>fill_classic_mro</name><argument_list>(<argument><expr><name>mro</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<return>return <expr><name>mro</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
    Method resolution order algorithm C3 described in
    "A Monotonic Superclass Linearization for Dylan",
    by Kim Barrett, Bob Cassel, Paul Haahr,
    David A. Moon, Keith Playford, and P. Tucker Withington.
    (OOPSLA 1996)

    Some notes about the rules implied by C3:

    No duplicate bases.
    It isn't legal to repeat a class in a list of base classes.

    The next three properties are the 3 constraints in "C3".

    Local precendece order.
    If A precedes B in C's MRO, then A will precede B in the MRO of all
    subclasses of C.

    Monotonicity.
    The MRO of a class must be an extension without reordering of the
    MRO of each of its superclasses.

    Extended Precedence Graph (EPG).
    Linearization is consistent if there is a path in the EPG from
    each class to all its successors in the linearization.  See
    the paper for definition of EPG.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>tail_contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>, <param><decl><type><name>int</name></type> <name>whence</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>size</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>j</name> = <name>whence</name>+1</expr>;</init> <condition><expr><name>j</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> == <name>o</name></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>class_name</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr>"__name__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>name</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>name</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_duplicates</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<comment type="block">/* Let's use a quadratic time algorithm,
	   assuming that the bases lists is short.
	*/</comment>
	<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for (<init><expr><name>j</name> = <name>i</name> + 1</expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> == <name>o</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>o</name> = <call><name>class_name</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					     <argument><expr>"duplicate base class %s"</expr></argument>,
					     <argument><expr><name>o</name> ? <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> : "?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></for>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Raise a TypeError for an MRO order disagreement.

   It's hard to produce a good error message.  In the absence of better
   insight into error reporting, report the classes that were candidates
   to be put next into the MRO.	 There is some conflict between the
   order in which they should be put in the MRO, but it's hard to
   diagnose what constraint can't be satisfied.
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_mro_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>to_merge</name></decl></param>, <param><decl><type><name>int</name> *</type><name>remain</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>off</name></decl>, <decl><type ref="prev"/><name>to_merge_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1000</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>set</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>set</name></expr>)</condition><then> <return>return;</return></then></if>

	<expr_stmt><expr><name>to_merge_size</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>to_merge_size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>L</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>remain</name><index>[<expr><name>i</name></expr>]</index></name> &lt; <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>remain</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><name>n</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>off</name> = <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"Cannot create a \
consistent method resolution\norder (MRO) for bases"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>size_t</name>)<name>off</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>class_name</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>off</name> += <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name> + <name>off</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - <name>off</name></expr></argument>, <argument><expr>" %s"</expr></argument>,
				     <argument><expr><name>name</name> ? <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> : "?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>--<name>n</name> &amp;&amp; <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>off</name>+1</expr></argument>)</argument_list></call> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>off</name>++</expr>]</index></name> = ','</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>off</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
		}</block></then></if>
	}</block></while>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pmerge</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>acc</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>to_merge</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>to_merge_size</name></decl>, <decl><type ref="prev"/><name>empty_cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> *</type><name>remain</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>to_merge_size</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remain stores an index into each sublist of to_merge.
	   remain[i] is the index of the next base in to_merge[i]
	   that is not included in acc.
	*/</comment>
	<expr_stmt><expr><name>remain</name> = (<name>int</name> *)<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>SIZEOF_INT</name>*<name>to_merge_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>remain</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>to_merge_size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><name><name>remain</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>

  <label><name>again</name>:</label>
	<expr_stmt><expr><name>empty_cnt</name> = 0</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>to_merge_size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>candidate</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>PyObject</name> *</type><name>cur_list</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name><name>remain</name><index>[<expr><name>i</name></expr>]</index></name> &gt;= <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>cur_list</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>empty_cnt</name>++</expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>

		<comment type="block">/* Choose next candidate for MRO.

		   The input sequences alone can determine the choice.
		   If not, choose the class which appears in the MRO
		   of the earliest direct superclass of the new class.
		*/</comment>

		<expr_stmt><expr><name>candidate</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>cur_list</name></expr></argument>, <argument><expr><name><name>remain</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>to_merge_size</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>j_lst</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>tail_contains</name><argument_list>(<argument><expr><name>j_lst</name></expr></argument>, <argument><expr><name><name>remain</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<goto>goto <name>skip</name>;</goto> <comment type="block">/* continue outer loop */</comment>
			}</block></then></if>
		}</block></for>
		<expr_stmt><expr><name>ok</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>acc</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ok</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>to_merge_size</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>j_lst</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name><name>remain</name><index>[<expr><name>j</name></expr>]</index></name> &lt; <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>j_lst</name></expr></argument>)</argument_list></call> &amp;&amp;
			    <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>j_lst</name></expr></argument>, <argument><expr><name><name>remain</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> == <name>candidate</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>remain</name><index>[<expr><name>j</name></expr>]</index></name>++</expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
		<goto>goto <name>again</name>;</goto>
	  <label><name>skip</name>:</label> <empty_stmt>;</empty_stmt>
	}</block></for>

	<if>if <condition>(<expr><name>empty_cnt</name> == <name>to_merge_size</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>set_mro_error</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>, <argument><expr><name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mro_implementation</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>bases</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>to_merge</name></decl>, *<decl><type ref="prev"/><name>bases_aslist</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<comment type="block">/* Find a superclass linearization that honors the constraints
	   of the explicit lists of bases and the constraints implied by
	   each base class.

	   to_merge is a list of lists, where each list is a superclass
	   linearization implied by a base class.  The last element of
	   to_merge is the declared list of bases.
	*/</comment>

	<expr_stmt><expr><name>bases</name> = <name><name>type</name>-&gt;<name>tp_bases</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>to_merge</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>to_merge</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>base</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>parentMRO</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>parentMRO</name> = <call><name>PySequence_List</name><argument_list>(
				<argument><expr>((<name>PyTypeObject</name>*)<name>base</name>)-&gt;<name>tp_mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>parentMRO</name> = <call><name>classic_mro</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>parentMRO</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>

		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>parentMRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<expr_stmt><expr><name>bases_aslist</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bases_aslist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* This is just a basic sanity check. */</comment>
	<if>if <condition>(<expr><call><name>check_duplicates</name><argument_list>(<argument><expr><name>bases_aslist</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases_aslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>bases_aslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"[O]"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>ok</name> = <call><name>pmerge</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>to_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>to_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ok</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mro_external</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name> <init>= <expr>(<name>PyTypeObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>mro_implementation</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>mro_internal</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mro</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>, *<decl><type ref="prev"/><name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>checkit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> == &amp;<name>PyType_Type</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>mro_implementation</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>mro_str</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>checkit</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>mro</name> = <call><name>lookup_method</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>, <argument><expr>"mro"</expr></argument>, <argument><expr>&amp;<name>mro_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>mro</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>mro</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>tuple</name> = <call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>checkit</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>cls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>solid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>solid</name> = <call><name>solid_base</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>t</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>cls</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
				<continue>continue;</continue></then>
			<else>else <if>if <condition>(<expr>!<call><name>PyType_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"mro() returned a non-class ('%.500s')"</expr></argument>,
					     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if></else></if>
			<expr_stmt><expr><name>t</name> = (<name>PyTypeObject</name>*)<name>cls</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>solid</name></expr></argument>, <argument><expr><call><name>solid_base</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"mro() returned base with unsuitable layout ('%.500s')"</expr></argument>,
					     <argument><expr><name><name>t</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></for>
	}</block></then></if>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_mro</name></name> = <name>tuple</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>type_mro_modified</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_mro</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* corner case: the old-style super class might have been hidden
	   from the custom MRO */</comment>
	<expr_stmt><expr><call><name>type_mro_modified</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyType_Modified</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Calculate the best base amongst multiple base classes.
   This is the first one that's on the path to the "solid base". */</comment>

<function><type><specifier>static</specifier> <name>PyTypeObject</name> *</type>
<name>best_base</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>bases</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl>, *<decl><type ref="prev"/><name>winner</name></decl>, *<decl><type ref="prev"/><name>candidate</name></decl>, *<decl><type ref="prev"/><name>base_i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>base_proto</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>base</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>winner</name> = <name>NULL</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>base_proto</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>base_proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr>!<call><name>PyType_Check</name><argument_list>(<argument><expr><name>base_proto</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"bases must be types"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>base_i</name> = (<name>PyTypeObject</name> *)<name>base_proto</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>base_i</name>-&gt;<name>tp_dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><name>base_i</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>candidate</name> = <call><name>solid_base</name><argument_list>(<argument><expr><name>base_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>winner</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>winner</name> = <name>candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>base</name> = <name>base_i</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>winner</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<empty_stmt>;</empty_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>winner</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>winner</name> = <name>candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>base</name> = <name>base_i</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"multiple bases have "
				"instance lay-out conflict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></else></if></else></if></else></if>
	}</block></for>
	<if>if <condition>(<expr><name>base</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"a new-style class can't have only classic bases"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>base</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>extra_ivars</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>t_size</name> <init>= <expr><name><name>type</name>-&gt;<name>tp_basicsize</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>b_size</name> <init>= <expr><name><name>base</name>-&gt;<name>tp_basicsize</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>t_size</name> &gt;= <name>b_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Else type smaller than base! */</comment>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_itemsize</name></name> || <name><name>base</name>-&gt;<name>tp_itemsize</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* If itemsize is involved, stricter rules */</comment>
		<return>return <expr><name>t_size</name> != <name>b_size</name> ||
			<name><name>type</name>-&gt;<name>tp_itemsize</name></name> != <name><name>base</name>-&gt;<name>tp_itemsize</name></name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_weaklistoffset</name></name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_weaklistoffset</name></name> == 0 &amp;&amp;
	    <name><name>type</name>-&gt;<name>tp_weaklistoffset</name></name> + <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof> == <name>t_size</name> &amp;&amp;
	    <name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr>)</condition><then>
		<expr_stmt><expr><name>t_size</name> -= <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_dictoffset</name></name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_dictoffset</name></name> == 0 &amp;&amp;
	    <name><name>type</name>-&gt;<name>tp_dictoffset</name></name> + <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof> == <name>t_size</name> &amp;&amp;
	    <name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr>)</condition><then>
		<expr_stmt><expr><name>t_size</name> -= <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>

	<return>return <expr><name>t_size</name> != <name>b_size</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyTypeObject</name> *</type>
<name>solid_base</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_base</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>base</name> = <call><name>solid_base</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>base</name> = &amp;<name>PyBaseObject_Type</name></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><call><name>extra_ivars</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>type</name></expr>;</return></then>
	<else>else
		<return>return <expr><name>base</name></expr>;</return></else></if>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>object_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>object_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>update_slot</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fixup_slot_dispatchers</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Helpers for  __dict__ descriptor.  We don't want to expose the dicts
 * inherited from various builtin types.  The builtin base usually provides
 * its own __dict__ descriptor, so we use that when we can.
 */</comment>
<function><type><specifier>static</specifier> <name>PyTypeObject</name> *</type>
<name>get_builtin_base_with_dict</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<while>while <condition>(<expr><name><name>type</name>-&gt;<name>tp_base</name></name> != <name>NULL</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_dictoffset</name></name> != 0 &amp;&amp;
		    !(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>)</expr>)</condition><then>
			<return>return <expr><name>type</name></expr>;</return></then></if>
		<expr_stmt><expr><name>type</name> = <name><name>type</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_dict_descriptor</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>dict_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>dict_str</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>dict_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dict_str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>descr</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dict_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>descr</name> == <name>NULL</name> || !<call><name>PyDescr_IsData</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><name>descr</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>raise_dict_descr_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"this __dict__ descriptor does not support "
		     "'%.200s' objects"</expr></argument>, <argument><expr><name><name>obj</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>subtype_dict</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>dictptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>base</name> = <call><name>get_builtin_base_with_dict</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>base</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>func</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name> <init>= <expr><call><name>get_dict_descriptor</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>raise_dict_descr_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <name><name>descr</name>-&gt;<name>ob_type</name>-&gt;<name>tp_descr_get</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>raise_dict_descr_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><call><name>func</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>dictptr</name> = <call><name>_PyObject_GetDictPtr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dictptr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				<argument><expr>"This object has no __dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>dict</name> = *<name>dictptr</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>dictptr</name> = <name>dict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>dict</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>subtype_setdict</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>dictptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>base</name> = <call><name>get_builtin_base_with_dict</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>base</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>descrsetfunc</name></type> <name>func</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name> <init>= <expr><call><name>get_dict_descriptor</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>raise_dict_descr_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <name><name>descr</name>-&gt;<name>ob_type</name>-&gt;<name>tp_descr_set</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>raise_dict_descr_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<return>return <expr><call><name>func</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>dictptr</name> = <call><name>_PyObject_GetDictPtr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dictptr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				<argument><expr>"This object has no __dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"__dict__ must be set to a dictionary, "
			     "not a '%.200s'"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>dict</name> = *<name>dictptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>dictptr</name> = <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>subtype_getweakref</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>weaklistptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_weaklistoffset</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				<argument><expr>"This object has no __weakref__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_weaklistoffset</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_weaklistoffset</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof> &lt;=
	       <call>(<name>size_t</name>)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_basicsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>weaklistptr</name> = <call>(<name>PyObject</name> **)
		<argument_list>(<argument><expr>(<name>char</name> *)<name>obj</name> + <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_weaklistoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>weaklistptr</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>result</name> = *<name>weaklistptr</name></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Three variants on the subtype_getsets list. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>subtype_getsets_full</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__dict__"</expr>, <expr><name>subtype_dict</name></expr>, <expr><name>subtype_setdict</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"dictionary for instance variables (if defined)"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>"__weakref__"</expr>, <expr><name>subtype_getweakref</name></expr>, <expr><name>NULL</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"list of weak references to the object (if defined)"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>subtype_getsets_dict_only</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__dict__"</expr>, <expr><name>subtype_dict</name></expr>, <expr><name>subtype_setdict</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"dictionary for instance variables (if defined)"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>subtype_getsets_weakref_only</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__weakref__"</expr>, <expr><name>subtype_getweakref</name></expr>, <expr><name>NULL</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"list of weak references to the object (if defined)"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>valid_identifier</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"__slots__ items must be strings, not '%.200s'"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We must reject an empty name.  As a hack, we bump the
	   length to 1 so that the loop will balk on the trailing \0. */</comment>
	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = 1</expr>;</expr_stmt></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>p</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>!(<name>i</name> == 0 ? <call><name>isalpha</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> : <call><name>isalnum</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '_'</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"__slots__ must be identifiers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
	}</block></for>
	<return>return <expr>1</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<comment type="block">/* Replace Unicode objects in slots.  */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_unicode_to_string</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>slots</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>nslots</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>slot_name</name></decl>, *<decl><type ref="prev"/><name>new_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nslots</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>slot_name</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>tmp</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
			}</block></then></if>
			<expr_stmt><expr><name>new_name</name> = <call><name>_PyUnicode_AsDefaultEncodedString</name><argument_list>(<argument><expr><name>slot_name</name></expr></argument>,
								     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>new_name</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>slot_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>tmp</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>slots</name> = <call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>slots</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>object_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>args</name> != <name>NULL</name> &amp;&amp; <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>kwds</name> == <name>NULL</name> || <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>kwds</name> != <name>NULL</name> &amp;&amp; <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"type.__init__() takes no keyword arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>args</name> != <name>NULL</name> &amp;&amp; <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &amp;&amp;
	    (<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> != 1 &amp;&amp; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> != 3)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"type.__init__() takes 1 or 3 arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<comment type="block">/* Call object.__init__(self) now. */</comment>
	<comment type="block">/* XXX Could call super(type, cls).__init__() but what's the point? */</comment>
	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_GetSlice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>object_init</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>metatype</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>bases</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"name"</expr>, <expr>"bases"</expr>, <expr>"dict"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>slots</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>, *<decl><type ref="prev"/><name>newslots</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>, *<decl><type ref="prev"/><name>tmptype</name></decl>, *<decl><type ref="prev"/><name>winner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyHeapTypeObject</name> *</type><name>et</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyMemberDef</name> *</type><name>mp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nbases</name></decl>, <decl><type ref="prev"/><name>nslots</name></decl>, <decl><type ref="prev"/><name>slotoffset</name></decl>, <decl><type ref="prev"/><name>add_dict</name></decl>, <decl><type ref="prev"/><name>add_weak</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>may_add_dict</name></decl>, <decl><type ref="prev"/><name>may_add_weak</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>args</name> != <name>NULL</name> &amp;&amp; <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>kwds</name> == <name>NULL</name> || <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Special case: type(x) should return x-&gt;ob_type */</comment>
	<block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>nargs</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>nkwds</name> <init>= <expr><name>kwds</name> == <name>NULL</name> ? 0 : <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>PyType_CheckExact</name><argument_list>(<argument><expr><name>metatype</name></expr></argument>)</argument_list></call> &amp;&amp; <name>nargs</name> == 1 &amp;&amp; <name>nkwds</name> == 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>PyObject</name> *) <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>

		<comment type="block">/* SF bug 475327 -- if that didn't trigger, we need 3
		   arguments. but PyArg_ParseTupleAndKeywords below may give
		   a msg saying type() needs exactly 3. */</comment>
		<if>if <condition>(<expr><name>nargs</name> + <name>nkwds</name> != 3</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"type() takes 1 or 3 arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block>

	<comment type="block">/* Check arguments: (name, bases, dict) */</comment>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"SO!O!:type"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
					 <argument><expr>&amp;<name>name</name></expr></argument>,
					 <argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>, <argument><expr>&amp;<name>bases</name></expr></argument>,
					 <argument><expr>&amp;<name>PyDict_Type</name></expr></argument>, <argument><expr>&amp;<name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Determine the proper metatype to deal with this,
	   and check for metatype conflicts while we're at it.
	   Note that if some other metatype wins to contract,
	   it's possible that its instances are not types. */</comment>
	<expr_stmt><expr><name>nbases</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>winner</name> = <name>metatype</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nbases</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>tmp</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmptype</name> = <name><name>tmp</name>-&gt;<name>ob_type</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmptype</name> == &amp;<name>PyClass_Type</name></expr>)</condition><then>
			<continue>continue;</continue></then></if> <comment type="block">/* Special case classic classes */</comment>
		<if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>winner</name></expr></argument>, <argument><expr><name>tmptype</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>tmptype</name></expr></argument>, <argument><expr><name>winner</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>winner</name> = <name>tmptype</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"metaclass conflict: "
				"the metaclass of a derived class "
				"must be a (non-strict) subclass "
				"of the metaclasses of all its bases"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></for>
	<if>if <condition>(<expr><name>winner</name> != <name>metatype</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>winner</name>-&gt;<name>tp_new</name></name> != <name>type_new</name></expr>)</condition><then> <comment type="block">/* Pass it to the winner */</comment>
			<return>return <expr><call><name><name>winner</name>-&gt;<name>tp_new</name></name><argument_list>(<argument><expr><name>winner</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>metatype</name> = <name>winner</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Adjust for empty tuple bases */</comment>
	<if>if <condition>(<expr><name>nbases</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>bases</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>&amp;<name>PyBaseObject_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>nbases</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<comment type="block">/* XXX From here until type is allocated, "return NULL" leaks bases! */</comment>

	<comment type="block">/* Calculate best base, and check that all bases are type objects */</comment>
	<expr_stmt><expr><name>base</name> = <call><name>best_base</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>base</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_BASETYPE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"type '%.100s' is not an acceptable base type"</expr></argument>,
			     <argument><expr><name><name>base</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Check for a __slots__ sequence variable in dict, and count it */</comment>
	<expr_stmt><expr><name>slots</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__slots__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nslots</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>add_dict</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>add_weak</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>may_add_dict</name> = <name><name>base</name>-&gt;<name>tp_dictoffset</name></name> == 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>may_add_weak</name> = <name><name>base</name>-&gt;<name>tp_weaklistoffset</name></name> == 0 &amp;&amp; <name><name>base</name>-&gt;<name>tp_itemsize</name></name> == 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>slots</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>may_add_dict</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>add_dict</name>++</expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>may_add_weak</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>add_weak</name>++</expr>;</expr_stmt>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Have slots */</comment>

		<comment type="block">/* Make it into a tuple */</comment>
		<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>slots</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>slots</name> = <call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>slots</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Are slots allowed? */</comment>
		<expr_stmt><expr><name>nslots</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>nslots</name> &gt; 0 &amp;&amp; <name><name>base</name>-&gt;<name>tp_itemsize</name></name> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"nonempty __slots__ "
				     "not supported for subtype of '%s'"</expr></argument>,
				     <argument><expr><name><name>base</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <label><name>bad_slots</name>:</label>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<expr_stmt><expr><name>tmp</name> = <call><name>_unicode_to_string</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>nslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>bad_slots</name>;</goto></then></if>
		<if>if <condition>(<expr><name>tmp</name> != <name>slots</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slots</name> = <name>tmp</name></expr>;</expr_stmt>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* Check for valid slot names and two special cases */</comment>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nslots</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
			<if>if <condition>(<expr>!<call><name>valid_identifier</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<goto>goto <name>bad_slots</name>;</goto></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<if>if <condition>(<expr>!<name>may_add_dict</name> || <name>add_dict</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
						<argument><expr>"__dict__ slot disallowed: "
						"we already got one"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_slots</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr><name>add_dict</name>++</expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"__weakref__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<if>if <condition>(<expr>!<name>may_add_weak</name> || <name>add_weak</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
						<argument><expr>"__weakref__ slot disallowed: "
						"either we already got one, "
						"or __itemsize__ != 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_slots</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr><name>add_weak</name>++</expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>

		<comment type="block">/* Copy slots into a list, mangle names and sort them.
		   Sorted names are needed for __class__ assignment.
		   Convert them back to tuple at the end.
		*/</comment>
		<expr_stmt><expr><name>newslots</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>nslots</name> - <name>add_dict</name> - <name>add_weak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newslots</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>bad_slots</name>;</goto></then></if>
		<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nslots</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>tmp</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>add_dict</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call> == 0) ||
			    (<name>add_weak</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"__weakref__"</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
				<continue>continue;</continue></then></if>
			<expr_stmt><expr><name>tmp</name> =<call><name>_Py_Mangle</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
			    <goto>goto <name>bad_slots</name>;</goto></then></if>
			<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>newslots</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>j</name> == <name>nslots</name> - <name>add_dict</name> - <name>add_weak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nslots</name> = <name>j</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyList_Sort</name><argument_list>(<argument><expr><name>newslots</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>slots</name> = <call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>newslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>slots</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>

		<comment type="block">/* Secondary bases may provide weakrefs or dict */</comment>
		<if>if <condition>(<expr><name>nbases</name> &gt; 1 &amp;&amp;
		    ((<name>may_add_dict</name> &amp;&amp; !<name>add_dict</name>) ||
		     (<name>may_add_weak</name> &amp;&amp; !<name>add_weak</name>))</expr>)</condition><then> <block>{
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nbases</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name>tmp</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>tmp</name> == (<name>PyObject</name> *)<name>base</name></expr>)</condition><then>
					<continue>continue;</continue></then></if> <comment type="block">/* Skip primary base */</comment>
				<if>if <condition>(<expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<comment type="block">/* Classic base class provides both */</comment>
					<if>if <condition>(<expr><name>may_add_dict</name> &amp;&amp; !<name>add_dict</name></expr>)</condition><then>
						<expr_stmt><expr><name>add_dict</name>++</expr>;</expr_stmt></then></if>
					<if>if <condition>(<expr><name>may_add_weak</name> &amp;&amp; !<name>add_weak</name></expr>)</condition><then>
						<expr_stmt><expr><name>add_weak</name>++</expr>;</expr_stmt></then></if>
					<break>break;</break>
				}</block></then></if>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmptype</name> = (<name>PyTypeObject</name> *)<name>tmp</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>may_add_dict</name> &amp;&amp; !<name>add_dict</name> &amp;&amp;
				    <name><name>tmptype</name>-&gt;<name>tp_dictoffset</name></name> != 0</expr>)</condition><then>
					<expr_stmt><expr><name>add_dict</name>++</expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr><name>may_add_weak</name> &amp;&amp; !<name>add_weak</name> &amp;&amp;
				    <name><name>tmptype</name>-&gt;<name>tp_weaklistoffset</name></name> != 0</expr>)</condition><then>
					<expr_stmt><expr><name>add_weak</name>++</expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr><name>may_add_dict</name> &amp;&amp; !<name>add_dict</name></expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<if>if <condition>(<expr><name>may_add_weak</name> &amp;&amp; !<name>add_weak</name></expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<comment type="block">/* Nothing more to check */</comment>
				<break>break;</break>
			}</block></for>
		}</block></then></if>
	}</block></else></if>

	<comment type="block">/* XXX From here until type is safely allocated,
	   "return NULL" may leak slots! */</comment>

	<comment type="block">/* Allocate the type object */</comment>
	<expr_stmt><expr><name>type</name> = (<name>PyTypeObject</name> *)<call><name><name>metatype</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>metatype</name></expr></argument>, <argument><expr><name>nslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>type</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Keep name and slots alive in the extended type object */</comment>
	<expr_stmt><expr><name>et</name> = (<name>PyHeapTypeObject</name> *)<name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>et</name>-&gt;<name>ht_name</name></name> = <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>et</name>-&gt;<name>ht_slots</name></name> = <name>slots</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize tp_flags */</comment>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> = <name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HEAPTYPE</name> |
		<name>Py_TPFLAGS_BASETYPE</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GC</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_HAVE_GC</name></expr>;</expr_stmt></then></if>

	<comment type="block">/* It's a new-style number unless it specifically inherits any
	   old-style numeric behavior */</comment>
	<if>if <condition>(<expr>(<name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_CHECKTYPES</name>) ||
	    (<name><name>base</name>-&gt;<name>tp_as_number</name></name> == <name>NULL</name>)</expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_CHECKTYPES</name></expr>;</expr_stmt></then></if>

	<comment type="block">/* Initialize essential fields */</comment>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_as_number</name></name> = &amp;<name><name>et</name>-&gt;<name>as_number</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_as_sequence</name></name> = &amp;<name><name>et</name>-&gt;<name>as_sequence</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_as_mapping</name></name> = &amp;<name><name>et</name>-&gt;<name>as_mapping</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_as_buffer</name></name> = &amp;<name><name>et</name>-&gt;<name>as_buffer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_name</name></name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set tp_base and tp_bases */</comment>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_bases</name></name> = <name>bases</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_base</name></name> = <name>base</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize tp_dict from passed-in dict */</comment>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_dict</name></name> = <name>dict</name> = <call><name>PyDict_Copy</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Set __module__ in the dict */</comment>
	<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__module__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>tmp</name> = <call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>tmp</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>tmp</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__module__"</expr></argument>,
							 <argument><expr><name>tmp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
			}</block></then></if>
		}</block></then></if>
	}</block></then></if>

	<comment type="block">/* Set tp_doc to a copy of dict['__doc__'], if the latter is there
	   and is a string.  The __doc__ accessor will first look for tp_doc;
	   if that fails, it will still look into __dict__.
	*/</comment>
	<block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>doc</name> <init>= <expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__doc__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>doc</name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>n</name> <init>= <expr>(<name>size_t</name>)<call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>tp_doc</name> <init>= <expr>(<name>char</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>tp_doc</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tp_doc</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_doc</name></name> = <name>tp_doc</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block>

	<comment type="block">/* Special-case __new__: if it's a plain function,
	   make it a static function */</comment>
	<expr_stmt><expr><name>tmp</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__new__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmp</name> != <name>NULL</name> &amp;&amp; <call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>tmp</name> = <call><name>PyStaticMethod_New</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__new__"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Add descriptors for custom slots from __slots__, or for __dict__ */</comment>
	<expr_stmt><expr><name>mp</name> = <call><name>PyHeapType_GET_MEMBERS</name><argument_list>(<argument><expr><name>et</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slotoffset</name> = <name><name>base</name>-&gt;<name>tp_basicsize</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>slots</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nslots</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>mp</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name><name>mp</name>-&gt;<name>name</name></name> = <call><name>PyString_AS_STRING</name><argument_list>(
				<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mp</name>-&gt;<name>type</name></name> = <name>T_OBJECT_EX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mp</name>-&gt;<name>offset</name></name> = <name>slotoffset</name></expr>;</expr_stmt>

			<comment type="block">/* __dict__ and __weakref__ are already filtered out */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"__weakref__"</expr></argument>)</argument_list></call> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>slotoffset</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		}</block></for>
	}</block></then></if>
	<if>if <condition>(<expr><name>add_dict</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>base</name>-&gt;<name>tp_itemsize</name></name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_dictoffset</name></name> = -(<name>long</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_dictoffset</name></name> = <name>slotoffset</name></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>slotoffset</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>add_weak</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name><name>base</name>-&gt;<name>tp_itemsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_weaklistoffset</name></name> = <name>slotoffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slotoffset</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_basicsize</name></name> = <name>slotoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_itemsize</name></name> = <name><name>base</name>-&gt;<name>tp_itemsize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_members</name></name> = <call><name>PyHeapType_GET_MEMBERS</name><argument_list>(<argument><expr><name>et</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_weaklistoffset</name></name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_dictoffset</name></name></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_getset</name></name> = <name>subtype_getsets_full</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_weaklistoffset</name></name> &amp;&amp; !<name><name>type</name>-&gt;<name>tp_dictoffset</name></name></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_getset</name></name> = <name>subtype_getsets_weakref_only</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>!<name><name>type</name>-&gt;<name>tp_weaklistoffset</name></name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_dictoffset</name></name></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_getset</name></name> = <name>subtype_getsets_dict_only</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_getset</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if></else></if></else></if>

	<comment type="block">/* Special case some slots */</comment>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_dictoffset</name></name> != 0 || <name>nslots</name> &gt; 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>base</name>-&gt;<name>tp_getattr</name></name> == <name>NULL</name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_getattro</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_getattro</name></name> = <name>PyObject_GenericGetAttr</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>base</name>-&gt;<name>tp_setattr</name></name> == <name>NULL</name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_setattro</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_setattro</name></name> = <name>PyObject_GenericSetAttr</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_dealloc</name></name> = <name>subtype_dealloc</name></expr>;</expr_stmt>

	<comment type="block">/* Enable GC unless there are really no instance variables possible */</comment>
	<if>if <condition>(<expr>!(<name><name>type</name>-&gt;<name>tp_basicsize</name></name> == <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name></expr></argument>)</argument_list></sizeof> &amp;&amp;
	      <name><name>type</name>-&gt;<name>tp_itemsize</name></name> == 0)</expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_HAVE_GC</name></expr>;</expr_stmt></then></if>

	<comment type="block">/* Always override allocation strategy to use regular heap */</comment>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_alloc</name></name> = <name>PyType_GenericAlloc</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GC</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_free</name></name> = <name>PyObject_GC_Del</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_traverse</name></name> = <name>subtype_traverse</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_clear</name></name> = <name>subtype_clear</name></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_free</name></name> = <name>PyObject_Del</name></expr>;</expr_stmt></else></if>

	<comment type="block">/* Initialize the rest */</comment>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Put the proper slots in place */</comment>
	<expr_stmt><expr><call><name>fixup_slot_dispatchers</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>(<name>PyObject</name> *)<name>type</name></expr>;</return>
}</block></function>

<comment type="block">/* Internal API to look for a name through the MRO.
   This returns a borrowed reference, and doesn't set an exception! */</comment>
<function><type><name>PyObject</name> *</type>
<name>_PyType_Lookup</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mro</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>MCACHE_CACHEABLE_NAME</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> &amp;&amp;
	    <call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_VALID_VERSION_TAG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* fast path */</comment>
		<expr_stmt><expr><name>h</name> = <call><name>MCACHE_HASH_METHOD</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>method_cache</name><index>[<expr><name>h</name></expr>]</index></name>.<name>version</name> == <name><name>type</name>-&gt;<name>tp_version_tag</name></name> &amp;&amp;
		    <name><name>method_cache</name><index>[<expr><name>h</name></expr>]</index></name>.<name>name</name> == <name>name</name></expr>)</condition><then>
		    <return>return <expr><name><name>method_cache</name><index>[<expr><name>h</name></expr>]</index></name>.<name>value</name></expr>;</return></then></if>
	}</block></then></if>

	<comment type="block">/* Look in tp_dict of types in MRO */</comment>
	<expr_stmt><expr><name>mro</name> = <name><name>type</name>-&gt;<name>tp_mro</name></name></expr>;</expr_stmt>

	<comment type="block">/* If mro is NULL, the type is either not yet initialized
	   by PyType_Ready(), or already cleared by type_clear().
	   Either way the safest thing to do is to return NULL. */</comment>
	<if>if <condition>(<expr><name>mro</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>base</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>mro</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>dict</name> = ((<name>PyClassObject</name> *)<name>base</name>)-&gt;<name>cl_dict</name></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dict</name> = ((<name>PyTypeObject</name> *)<name>base</name>)-&gt;<name>tp_dict</name></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name> &amp;&amp; <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>

	<if>if <condition>(<expr><call><name>MCACHE_CACHEABLE_NAME</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>assign_version_tag</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>h</name> = <call><name>MCACHE_HASH_METHOD</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>method_cache</name><index>[<expr><name>h</name></expr>]</index></name>.<name>version</name> = <name><name>type</name>-&gt;<name>tp_version_tag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>method_cache</name><index>[<expr><name>h</name></expr>]</index></name>.<name>value</name> = <name>res</name></expr>;</expr_stmt>  <comment type="block">/* borrowed */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>method_cache</name><index>[<expr><name>h</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>method_cache</name><index>[<expr><name>h</name></expr>]</index></name>.<name>name</name> = <name>name</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* This is similar to PyObject_GenericGetAttr(),
   but uses _PyType_Lookup() instead of just looking in type-&gt;tp_dict. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_getattro</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>metatype</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>meta_attribute</name></decl>, *<decl><type ref="prev"/><name>attribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>meta_get</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize this type (we'll assume the metatype is initialized) */</comment>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<comment type="block">/* No readable descriptor found yet */</comment>
	<expr_stmt><expr><name>meta_get</name> = <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Look for the attribute in the metatype */</comment>
	<expr_stmt><expr><name>meta_attribute</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>metatype</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>meta_attribute</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>meta_get</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>meta_attribute</name></expr></argument>)</argument_list></call>-&gt;<name>tp_descr_get</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>meta_get</name> != <name>NULL</name> &amp;&amp; <call><name>PyDescr_IsData</name><argument_list>(<argument><expr><name>meta_attribute</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* Data descriptors implement tp_descr_set to intercept
			 * writes. Assume the attribute is not overridden in
			 * type's tp_dict (and bases): call the descriptor now.
			 */</comment>
			<return>return <expr><call><name>meta_get</name><argument_list>(<argument><expr><name>meta_attribute</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>,
					<argument><expr>(<name>PyObject</name> *)<name>metatype</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>meta_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* No data descriptor found on metatype. Look in tp_dict of this
	 * type and its bases */</comment>
	<expr_stmt><expr><name>attribute</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>attribute</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Implement descriptor functionality, if any */</comment>
		<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>local_get</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>attribute</name></expr></argument>)</argument_list></call>-&gt;<name>tp_descr_get</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>meta_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>local_get</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* NULL 2nd argument indicates the descriptor was
			 * found on the target object itself (or a base)  */</comment>
			<return>return <expr><call><name>local_get</name><argument_list>(<argument><expr><name>attribute</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>,
					 <argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>

		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>attribute</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* No attribute found in local __dict__ (or bases): use the
	 * descriptor from the metatype, if any */</comment>
	<if>if <condition>(<expr><name>meta_get</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> = <call><name>meta_get</name><argument_list>(<argument><expr><name>meta_attribute</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>,
			       <argument><expr>(<name>PyObject</name> *)<name>metatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meta_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* If an ordinary attribute was found on the metatype, return it now */</comment>
	<if>if <condition>(<expr><name>meta_attribute</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><name>meta_attribute</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Give up */</comment>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
			 <argument><expr>"type object '%.50s' has no attribute '%.400s'"</expr></argument>,
			 <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_setattro</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
			<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"can't set attributes of built-in/extension type '%s'"</expr></argument>,
			<argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyObject_GenericSetAttr</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<return>return <expr><call><name>update_slot</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>type_dealloc</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyHeapTypeObject</name> *</type><name>et</name></decl>;</decl_stmt>

	<comment type="block">/* Assert this is a heap-allocated type object */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>et</name> = (<name>PyHeapTypeObject</name> *)<name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_mro</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_subclasses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* A type's tp_doc is heap allocated, unlike the tp_doc slots
	 * of most other objects.  It's okay to cast it to char *.
	 */</comment>
	<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>type</name>-&gt;<name>tp_doc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>et</name>-&gt;<name>ht_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>et</name>-&gt;<name>ht_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>type_subclasses</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args_ignored</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>raw</name></decl>, *<decl><type ref="prev"/><name>ref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>raw</name> = <name><name>type</name>-&gt;<name>tp_subclasses</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>raw</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>list</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>raw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>ref</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>raw</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyWeakref_CheckRef</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ref</name> = <call><name>PyWeakref_GET_OBJECT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ref</name> != <name>Py_None</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
	<return>return <expr><name>list</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>type_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"mro"</expr>, <expr>(<name>PyCFunction</name>)<name>mro_external</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"mro() -&gt; list\nreturn a type's method resolution order"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>"__subclasses__"</expr>, <expr>(<name>PyCFunction</name>)<name>type_subclasses</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"__subclasses__() -&gt; list of immediate subclasses"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>type_doc</name></expr></argument>,
<argument><expr>"type(object) -&gt; the object's type\n"
"type(name, bases, dict) -&gt; a new type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_traverse</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Because of type_is_gc(), the collector only calls this
	   for heaptypes. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_mro</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There's no need to visit type-&gt;tp_subclasses or
	   ((PyHeapTypeObject *)type)-&gt;ht_slots, because they can't be involved
	   in cycles; tp_subclasses is a list of weak references,
	   and slots is a tuple of strings. */</comment>

	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_clear</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Because of type_is_gc(), the collector only calls this
	   for heaptypes. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The only field we need to clear is tp_mro, which is part of a
	   hard cycle (its first element is the class itself) that won't
	   be broken otherwise (it's a tuple and tuples don't have a
	   tp_clear handler).  None of the other fields need to be
	   cleared, and here's why:

	   tp_dict:
	       It is a dict, so the collector will call its tp_clear.

	   tp_cache:
	       Not used; if it were, it would be a dict.

	   tp_bases, tp_base:
	       If these are involved in a cycle, there must be at least
	       one other, mutable object in the cycle, e.g. a base
	       class's dict; the cycle will be broken that way.

	   tp_subclasses:
	       A list of weak references can't be part of a cycle; and
	       lists have their own tp_clear.

	   slots (in PyHeapTypeObject):
	       A tuple of strings can't be part of a cycle.
	*/</comment>

	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_mro</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>type_is_gc</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyType_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"type"</expr>,					<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyHeapTypeObject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyMemberDef</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_itemsize */</comment>
	<expr>(<name>destructor</name>)<name>type_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr><name>type_compare</name></expr>,				<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>type_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>_Py_HashPointer</name></expr>,		<comment type="block">/* tp_hash */</comment>
	<expr>(<name>ternaryfunc</name>)<name>type_call</name></expr>,			<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>(<name>getattrofunc</name>)<name>type_getattro</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>(<name>setattrofunc</name>)<name>type_setattro</name></expr>,		<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
		<name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_TYPE_SUBCLASS</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>type_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>type_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>type_clear</name></expr>,			<comment type="block">/* tp_clear */</comment>
	<expr><name>type_richcompare</name></expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyTypeObject</name></expr></argument>, <argument><expr><name>tp_weaklist</name></expr></argument>)</argument_list></call></expr>,	<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>type_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr><name>type_members</name></expr>,				<comment type="block">/* tp_members */</comment>
	<expr><name>type_getsets</name></expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyTypeObject</name></expr></argument>, <argument><expr><name>tp_dict</name></expr></argument>)</argument_list></call></expr>,	<comment type="block">/* tp_dictoffset */</comment>
	<expr><name>type_init</name></expr>,				<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>type_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_GC_Del</name></expr>,			<comment type="block">/* tp_free */</comment>
	<expr>(<name>inquiry</name>)<name>type_is_gc</name></expr>,			<comment type="block">/* tp_is_gc */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* The base type of all types (eventually)... except itself. */</comment>

<comment type="block">/* You may wonder why object.__new__() only complains about arguments
   when object.__init__() is not overridden, and vice versa.

   Consider the use cases:

   1. When neither is overridden, we want to hear complaints about
      excess (i.e., any) arguments, since their presence could
      indicate there's a bug.

   2. When defining an Immutable type, we are likely to override only
      __new__(), since __init__() is called too late to initialize an
      Immutable object.  Since __new__() defines the signature for the
      type, it would be a pain to have to override __init__() just to
      stop it from complaining about excess arguments.

   3. When defining a Mutable type, we are likely to override only
      __init__().  So here the converse reasoning applies: we don't
      want to have to override __new__() just to stop it from
      complaining.

   4. When __init__() is overridden, and the subclass __init__() calls
      object.__init__(), the latter should complain about excess
      arguments; ditto for __new__().

   Use cases 2 and 3 make it unattractive to unconditionally check for
   excess arguments.  The best solution that addresses all four use
   cases is as follows: __init__() complains about excess arguments
   unless __new__() is overridden and __init__() is not overridden
   (IOW, if __init__() is overridden or __new__() is not overridden);
   symmetrically, __new__() complains about excess arguments unless
   __init__() is overridden and __new__() is not overridden
   (IOW, if __new__() is overridden or __init__() is not overridden).

   However, for backwards compatibility, this breaks too much code.
   Therefore, in 2.6, we'll *warn* about excess arguments when both
   methods are overridden; for all other cases we'll use the above
   rules.

*/</comment>

<comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>excess_args</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> ||
		(<name>kwds</name> &amp;&amp; <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>object_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>excess_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_init</name></name> != <name>object_init</name> &amp;&amp;
		    <name><name>type</name>-&gt;<name>tp_new</name></name> != <name>object_new</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name>err</name> = <call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
				   <argument><expr>"object.__init__() takes no parameters"</expr></argument>,
				   <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_init</name></name> != <name>object_init</name> ||
			 <name><name>type</name>-&gt;<name>tp_new</name></name> == <name>object_new</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"object.__init__() takes no parameters"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt>
		}</block></then></if></else></if>
	}</block></then></if>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>excess_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_new</name></name> != <name>object_new</name> &amp;&amp;
		    <name><name>type</name>-&gt;<name>tp_init</name></name> != <name>object_init</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name>err</name> = <call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
				   <argument><expr>"object.__new__() takes no parameters"</expr></argument>,
				   <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_new</name></name> != <name>object_new</name> ||
			 <name><name>type</name>-&gt;<name>tp_init</name></name> == <name>object_init</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"object.__new__() takes no parameters"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt>
		}</block></then></if></else></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_IS_ABSTRACT</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>comma</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>abstract_methods</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>builtins</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>sorted</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>sorted_methods</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>joined</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>joined_str</name></decl>;</decl_stmt>

		<comment type="block">/* Compute ", ".join(sorted(type.__abstractmethods__))
		   into joined. */</comment>
		<expr_stmt><expr><name>abstract_methods</name> = <call><name>type_abstractmethods</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>abstract_methods</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<expr_stmt><expr><name>builtins</name> = <call><name>PyEval_GetBuiltins</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>builtins</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<expr_stmt><expr><name>sorted</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>, <argument><expr>"sorted"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>sorted</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<expr_stmt><expr><name>sorted_methods</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>sorted</name></expr></argument>,
							      <argument><expr><name>abstract_methods</name></expr></argument>,
							      <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>sorted_methods</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<if>if <condition>(<expr><name>comma</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>comma</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>comma</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>joined</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>comma</name></expr></argument>, <argument><expr>"join"</expr></argument>,
					     <argument><expr>"O"</expr></argument>,  <argument><expr><name>sorted_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>joined</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<expr_stmt><expr><name>joined_str</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>joined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>joined_str</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>

		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"Can't instantiate abstract class %s "
			     "with abstract methods %s"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name>joined_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<label><name>error</name>:</label>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>joined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sorted_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>abstract_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>object_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>, *<decl><type ref="prev"/><name>rtn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>type</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mod</name> = <call><name>type_module</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mod</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<expr_stmt><expr><name>name</name> = <call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>mod</name> != <name>NULL</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>rtn</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s.%s object at %p&gt;"</expr></argument>,
					  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>rtn</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s object at %p&gt;"</expr></argument>,
					  <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rtn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unaryfunc</name></type> <name>f</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>f</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_repr</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>f</name> = <name>object_repr</name></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>f</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_get_class</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>equiv_structs</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>a</name> == <name>b</name> ||
	       (<name>a</name> != <name>NULL</name> &amp;&amp;
		<name>b</name> != <name>NULL</name> &amp;&amp;
		<name><name>a</name>-&gt;<name>tp_basicsize</name></name> == <name><name>b</name>-&gt;<name>tp_basicsize</name></name> &amp;&amp;
		<name><name>a</name>-&gt;<name>tp_itemsize</name></name> == <name><name>b</name>-&gt;<name>tp_itemsize</name></name> &amp;&amp;
		<name><name>a</name>-&gt;<name>tp_dictoffset</name></name> == <name><name>b</name>-&gt;<name>tp_dictoffset</name></name> &amp;&amp;
		<name><name>a</name>-&gt;<name>tp_weaklistoffset</name></name> == <name><name>b</name>-&gt;<name>tp_weaklistoffset</name></name> &amp;&amp;
		((<name><name>a</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GC</name>) ==
		 (<name><name>b</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GC</name>)))</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>same_slots_added</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>base</name> <init>= <expr><name><name>a</name>-&gt;<name>tp_base</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>slots_a</name></decl>, *<decl><type ref="prev"/><name>slots_b</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>base</name> != <name><name>b</name>-&gt;<name>tp_base</name></name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>equiv_structs</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>equiv_structs</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<expr_stmt><expr><name>size</name> = <name><name>base</name>-&gt;<name>tp_basicsize</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>tp_dictoffset</name></name> == <name>size</name> &amp;&amp; <name><name>b</name>-&gt;<name>tp_dictoffset</name></name> == <name>size</name></expr>)</condition><then>
		<expr_stmt><expr><name>size</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>tp_weaklistoffset</name></name> == <name>size</name> &amp;&amp; <name><name>b</name>-&gt;<name>tp_weaklistoffset</name></name> == <name>size</name></expr>)</condition><then>
		<expr_stmt><expr><name>size</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>

	<comment type="block">/* Check slots compliance */</comment>
	<expr_stmt><expr><name>slots_a</name> = ((<name>PyHeapTypeObject</name> *)<name>a</name>)-&gt;<name>ht_slots</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slots_b</name> = ((<name>PyHeapTypeObject</name> *)<name>b</name>)-&gt;<name>ht_slots</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>slots_a</name> &amp;&amp; <name>slots_b</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyObject_Compare</name><argument_list>(<argument><expr><name>slots_a</name></expr></argument>, <argument><expr><name>slots_b</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name>size</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof> * <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>slots_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>size</name> == <name><name>a</name>-&gt;<name>tp_basicsize</name></name> &amp;&amp; <name>size</name> == <name><name>b</name>-&gt;<name>tp_basicsize</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compatible_for_assignment</name><parameter_list>(<param><decl><type><name>PyTypeObject</name>*</type> <name>oldto</name></decl></param>, <param><decl><type><name>PyTypeObject</name>*</type> <name>newto</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>attr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>newbase</name></decl>, *<decl><type ref="prev"/><name>oldbase</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>newto</name>-&gt;<name>tp_dealloc</name></name> != <name><name>oldto</name>-&gt;<name>tp_dealloc</name></name> ||
	    <name><name>newto</name>-&gt;<name>tp_free</name></name> != <name><name>oldto</name>-&gt;<name>tp_free</name></name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"%s assignment: "
			     "'%s' deallocator differs from '%s'"</expr></argument>,
			     <argument><expr><name>attr</name></expr></argument>,
			     <argument><expr><name><name>newto</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name><name>oldto</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>newbase</name> = <name>newto</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldbase</name> = <name>oldto</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>equiv_structs</name><argument_list>(<argument><expr><name>newbase</name></expr></argument>, <argument><expr><name><name>newbase</name>-&gt;<name>tp_base</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>newbase</name> = <name><name>newbase</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt></while>
	<while>while <condition>(<expr><call><name>equiv_structs</name><argument_list>(<argument><expr><name>oldbase</name></expr></argument>, <argument><expr><name><name>oldbase</name>-&gt;<name>tp_base</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>oldbase</name> = <name><name>oldbase</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt></while>
	<if>if <condition>(<expr><name>newbase</name> != <name>oldbase</name> &amp;&amp;
	    (<name><name>newbase</name>-&gt;<name>tp_base</name></name> != <name><name>oldbase</name>-&gt;<name>tp_base</name></name> ||
	     !<call><name>same_slots_added</name><argument_list>(<argument><expr><name>newbase</name></expr></argument>, <argument><expr><name>oldbase</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"%s assignment: "
			     "'%s' object layout differs from '%s'"</expr></argument>,
			     <argument><expr><name>attr</name></expr></argument>,
			     <argument><expr><name><name>newto</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name><name>oldto</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>object_set_class</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>oldto</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>newto</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"can't delete __class__ attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyType_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		  <argument><expr>"__class__ must be set to new-style class, not '%s' object"</expr></argument>,
		  <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>newto</name> = (<name>PyTypeObject</name> *)<name>value</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>!(<name><name>newto</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>) ||
	    !(<name><name>oldto</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>)</expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"__class__ assignment: only for heap types"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>compatible_for_assignment</name><argument_list>(<argument><expr><name>newto</name></expr></argument>, <argument><expr><name>oldto</name></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>newto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = <name>newto</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>oldto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then>
	<else>else <block>{
		<return>return <expr>-1</expr>;</return>
	}</block></else></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>object_getsets</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__class__"</expr>, <expr><name>object_get_class</name></expr>, <expr><name>object_set_class</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"the object's class"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Stuff to implement __reduce_ex__ for pickle protocols &gt;= 2.
   We fall back to helpers in copy_reg for:
   - pickle protocols &lt; 2
   - calculating the list of slot names (done only once per class)
   - the __newobj__ function (which is used as a token but never called)
*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>import_copyreg</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>copyreg_str</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>copyreg_str</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>copyreg_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"copy_reg"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>copyreg_str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<return>return <expr><call><name>PyImport_Import</name><argument_list>(<argument><expr><name>copyreg_str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slotnames</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>clsdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>copyreg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>slotnames</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyType_Check</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>clsdict</name> = ((<name>PyTypeObject</name> *)<name>cls</name>)-&gt;<name>tp_dict</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slotnames</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>clsdict</name></expr></argument>, <argument><expr>"__slotnames__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>slotnames</name> != <name>NULL</name> &amp;&amp; <call><name>PyList_Check</name><argument_list>(<argument><expr><name>slotnames</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>slotnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>slotnames</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>copyreg</name> = <call><name>import_copyreg</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>copyreg</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>slotnames</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>copyreg</name></expr></argument>, <argument><expr>"_slotnames"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>copyreg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>slotnames</name> != <name>NULL</name> &amp;&amp;
	    <name>slotnames</name> != <name>Py_None</name> &amp;&amp;
	    !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>slotnames</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"copy_reg._slotnames didn't return a list or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>slotnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slotnames</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>slotnames</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>reduce_2</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>cls</name></decl>, *<decl><type ref="prev"/><name>getnewargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name> <init>= <expr><name>NULL</name></expr></init>, *<name>args2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>getstate</name> <init>= <expr><name>NULL</name></expr></init>, *<name>state</name> <init>= <expr><name>NULL</name></expr></init>, *<name>names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>slots</name> <init>= <expr><name>NULL</name></expr></init>, *<name>listitems</name> <init>= <expr><name>NULL</name></expr></init>, *<name>dictitems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>copyreg</name> <init>= <expr><name>NULL</name></expr></init>, *<name>newobj</name> <init>= <expr><name>NULL</name></expr></init>, *<name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cls</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cls</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>getnewargs</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"__getnewargs__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>getnewargs</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>args</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>getnewargs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>getnewargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>args</name> != <name>NULL</name> &amp;&amp; !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"__getnewargs__ should return a tuple, "
				"not '%.200s'"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>end</name>;</goto>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>end</name>;</goto></then></if>

	<expr_stmt><expr><name>getstate</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"__getstate__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>getstate</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>state</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>getstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>getstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>state</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>end</name>;</goto></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>state</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>state</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>state</name> = <name>Py_None</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>names</name> = <call><name>slotnames</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>names</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>end</name>;</goto></then></if>
		<if>if <condition>(<expr><name>names</name> != <name>Py_None</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slots</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>slots</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>end</name>;</goto></then></if>
			<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
			<comment type="block">/* Can't pre-compute the list size; the list
			   is stored on the class so accessible to other
			   threads, which may be run by DECREF */</comment>
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>name</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>value</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
				<else>else <block>{
					<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
								 <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
						<goto>goto <name>end</name>;</goto></then></if>
					<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
				}</block></else></if>
			}</block></for>
			<if>if <condition>(<expr><name>n</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>state</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(NO)"</expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>state</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>end</name>;</goto></then></if>
			}</block></then></if>
		}</block></then></if>
	}</block></else></if>

	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>listitems</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>listitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>listitems</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>listitems</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>end</name>;</goto></then></if>
	}</block></else></if>

	<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>dictitems</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dictitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>dictitems</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"iteritems"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dictitems</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>end</name>;</goto></then></if>
	}</block></else></if>

	<expr_stmt><expr><name>copyreg</name> = <call><name>import_copyreg</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>copyreg</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>end</name>;</goto></then></if>
	<expr_stmt><expr><name>newobj</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>copyreg</name></expr></argument>, <argument><expr>"__newobj__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>end</name>;</goto></then></if>

	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>args2</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args2</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>end</name>;</goto></then></if>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cls</name> = <name>NULL</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args2</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<expr_stmt><expr><name>res</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr><name>newobj</name></expr></argument>, <argument><expr><name>args2</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>listitems</name></expr></argument>, <argument><expr><name>dictitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>end</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>listitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dictitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copyreg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * There were two problems when object.__reduce__ and object.__reduce_ex__
 * were implemented in the same function:
 *  - trying to pickle an object with a custom __reduce__ method that
 *    fell back to object.__reduce__ in certain circumstances led to
 *    infinite recursion at Python level and eventual RuntimeError.
 *  - Pickling objects that lied about their type by overwriting the
 *    __class__ descriptor could lead to infinite recursion at C level
 *    and eventual segfault.
 *
 * Because of backwards compatibility, the two methods still have to
 * behave in the same way, even if this is not required by the pickle
 * protocol. This common functionality was moved to the _common_reduce
 * function.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_common_reduce</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>proto</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>copyreg</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>proto</name> &gt;= 2</expr>)</condition><then>
		<return>return <expr><call><name>reduce_2</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>copyreg</name> = <call><name>import_copyreg</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>copyreg</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallMethod</name><argument_list>(<argument><expr><name>copyreg</name></expr></argument>, <argument><expr>"_reduce_ex"</expr></argument>, <argument><expr>"(Oi)"</expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>copyreg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_reduce</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>proto</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:__reduce__"</expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>_common_reduce</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_reduce_ex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>reduce</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>proto</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:__reduce_ex__"</expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>reduce</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__reduce__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>reduce</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>cls</name></decl>, *<decl><type ref="prev"/><name>clsreduce</name></decl>, *<decl><type ref="prev"/><name>objreduce</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>override</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>cls</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cls</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>reduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>clsreduce</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr>"__reduce__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>clsreduce</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>reduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>objreduce</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>PyBaseObject_Type</name>.<name>tp_dict</name></name></expr></argument>,
						 <argument><expr>"__reduce__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>override</name> = (<name>clsreduce</name> != <name>objreduce</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>clsreduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>override</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>res</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>reduce</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>reduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		}</block></then>
		<else>else
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>reduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></else></if>

	<return>return <expr><call><name>_common_reduce</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_subclasshook</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>object_subclasshook_doc</name></expr></argument>,
<argument><expr>"Abstract classes can override this to customize issubclass().\n"
"\n"
"This is invoked early on by abc.ABCMeta.__subclasscheck__().\n"
"It should return True, False or NotImplemented.  If it returns\n"
"NotImplemented, the normal algorithm is used.  Otherwise, it\n"
"overrides the normal algorithm (and the outcome is cached).\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
   from PEP 3101, this code implements:

   class object:
       def __format__(self, format_spec):
           if isinstance(format_spec, str):
               return format(str(self), format_spec)
           elif isinstance(format_spec, unicode):
               return format(unicode(self), format_spec)
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_format</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>format_spec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>self_as_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>format_meth</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:__format__"</expr></argument>, <argument><expr>&amp;<name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	        <expr_stmt><expr><name>self_as_str</name> = <call><name>PyObject_Unicode</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	        <expr_stmt><expr><name>self_as_str</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"argument to __format__ must be unicode or str"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	        <return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>

        <if>if <condition>(<expr><name>self_as_str</name> != <name>NULL</name></expr>)</condition><then> <block>{
                <comment type="block">/* find the format function */</comment>
                <expr_stmt><expr><name>format_meth</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>self_as_str</name></expr></argument>, <argument><expr>"__format__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>format_meth</name> != <name>NULL</name></expr>)</condition><then> <block>{
                       <comment type="block">/* and call it */</comment>
                        <expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>format_meth</name></expr></argument>, <argument><expr><name>format_spec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>self_as_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>format_meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>object_sizeof</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>isize</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>isize</name> = <name><name>self</name>-&gt;<name>ob_type</name>-&gt;<name>tp_itemsize</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>isize</name> &gt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <name><name>self</name>-&gt;<name>ob_type</name>-&gt;<name>ob_size</name></name> * <name>isize</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>res</name> += <name><name>self</name>-&gt;<name>ob_type</name>-&gt;<name>tp_basicsize</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>	 
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>object_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__reduce_ex__"</expr>, <expr><name>object_reduce_ex</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"helper for pickle"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>"__reduce__"</expr>, <expr><name>object_reduce</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"helper for pickle"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>"__subclasshook__"</expr>, <expr><name>object_subclasshook</name></expr>, <expr><name>METH_CLASS</name> | <name>METH_VARARGS</name></expr>,
	 <expr><name>object_subclasshook_doc</name></expr>}</block></expr>,
        <expr><block>{<expr>"__format__"</expr>, <expr><name>object_format</name></expr>, <expr><name>METH_VARARGS</name></expr>,
         <macro><name>PyDoc_STR</name><argument_list>(<argument>"default object formatter"</argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr>"__sizeof__"</expr>, <expr><name>object_sizeof</name></expr>, <expr><name>METH_NOARGS</name></expr>,
         <macro><name>PyDoc_STR</name><argument_list>(<argument>"__sizeof__() -&gt; size of object in memory, in bytes"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyBaseObject_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"object"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr><name>object_dealloc</name></expr>,				<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr><name>object_repr</name></expr>,				<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>_Py_HashPointer</name></expr>,		<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr><name>object_str</name></expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr><name>PyObject_GenericSetAttr</name></expr>,		<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr><call><name>PyDoc_STR</name><argument_list>(<argument><expr>"The most base type"</expr></argument>)</argument_list></call></expr>,	<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>object_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr><name>object_getsets</name></expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr><name>object_init</name></expr>,				<comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,			<comment type="block">/* tp_alloc */</comment>
	<expr><name>object_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_Del</name></expr>,				<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Initialize the __dict__ in a type object */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_methods</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyMethodDef</name> *</type><name>meth</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></init></decl>;</decl_stmt>

	<for>for (<init>;</init> <condition><expr><name><name>meth</name>-&gt;<name>ml_name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>meth</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>meth</name>-&gt;<name>ml_name</name></name></expr></argument>)</argument_list></call> &amp;&amp;
			!(<name><name>meth</name>-&gt;<name>ml_flags</name></name> &amp; <name>METH_COEXIST</name>)</expr>)</condition><then>
				<continue>continue;</continue></then></if>
		<if>if <condition>(<expr><name><name>meth</name>-&gt;<name>ml_flags</name></name> &amp; <name>METH_CLASS</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>meth</name>-&gt;<name>ml_flags</name></name> &amp; <name>METH_STATIC</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				     <argument><expr>"method cannot be both class and static"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>descr</name> = <call><name>PyDescr_NewClassMethod</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>meth</name>-&gt;<name>ml_flags</name></name> &amp; <name>METH_STATIC</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>cfunc</name> <init>= <expr><call><name>PyCFunction_New</name><argument_list>(<argument><expr><name>meth</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>cfunc</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><name>descr</name> = <call><name>PyStaticMethod_New</name><argument_list>(<argument><expr><name>cfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>descr</name> = <call><name>PyDescr_NewMethod</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if></else></if>
		<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>meth</name>-&gt;<name>ml_name</name></name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_members</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyMemberDef</name> *</type><name>memb</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></init></decl>;</decl_stmt>

	<for>for (<init>;</init> <condition><expr><name><name>memb</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>memb</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>memb</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><name>descr</name> = <call><name>PyDescr_NewMember</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>memb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>memb</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_getset</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyGetSetDef</name> *</type><name>gsp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></init></decl>;</decl_stmt>

	<for>for (<init>;</init> <condition><expr><name><name>gsp</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>gsp</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>gsp</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><name>descr</name> = <call><name>PyDescr_NewGetSet</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>gsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>gsp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>inherit_special</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldsize</name></decl>, <decl><type ref="prev"/><name>newsize</name></decl>;</decl_stmt>

	<comment type="block">/* Special flag magic */</comment>
	<if>if <condition>(<expr>!<name><name>type</name>-&gt;<name>tp_as_buffer</name></name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_as_buffer</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp;= ~<name>Py_TPFLAGS_HAVE_GETCHARBUFFER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |=
			<name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GETCHARBUFFER</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>!<name><name>type</name>-&gt;<name>tp_as_sequence</name></name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_as_sequence</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp;= ~<name>Py_TPFLAGS_HAVE_SEQUENCE_IN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_SEQUENCE_IN</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_INPLACEOPS</name>) !=
	    (<name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_INPLACEOPS</name>)</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(!<name><name>type</name>-&gt;<name>tp_as_number</name></name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_as_number</name></name>) ||
		    (!<name><name>type</name>-&gt;<name>tp_as_sequence</name></name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_as_sequence</name></name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp;= ~<name>Py_TPFLAGS_HAVE_INPLACEOPS</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name><name>type</name>-&gt;<name>tp_as_number</name></name> &amp;&amp; !<name><name>type</name>-&gt;<name>tp_as_sequence</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name><name>base</name>-&gt;<name>tp_flags</name></name> &amp;
					<name>Py_TPFLAGS_HAVE_INPLACEOPS</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<comment type="block">/* Wow */</comment>
	}</block></then></if>
	<if>if <condition>(<expr>!<name><name>type</name>-&gt;<name>tp_as_number</name></name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_as_number</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp;= ~<name>Py_TPFLAGS_CHECKTYPES</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_CHECKTYPES</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Copying basicsize is connected to the GC flags */</comment>
	<expr_stmt><expr><name>oldsize</name> = <name><name>base</name>-&gt;<name>tp_basicsize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newsize</name> = <name><name>type</name>-&gt;<name>tp_basicsize</name></name> ? <name><name>type</name>-&gt;<name>tp_basicsize</name></name> : <name>oldsize</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>!(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GC</name>) &amp;&amp;
	    (<name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GC</name>) &amp;&amp;
	    (<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_RICHCOMPARE</name><comment type="block">/*GC slots exist*/</comment>) &amp;&amp;
	    (!<name><name>type</name>-&gt;<name>tp_traverse</name></name> &amp;&amp; !<name><name>type</name>-&gt;<name>tp_clear</name></name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_HAVE_GC</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_traverse</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_traverse</name></name> = <name><name>base</name>-&gt;<name>tp_traverse</name></name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_clear</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_clear</name></name> = <name><name>base</name>-&gt;<name>tp_clear</name></name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_CLASS</name></expr>)</condition><then> <block>{
		<comment type="block">/* The condition below could use some explanation.
		   It appears that tp_new is not inherited for static types
		   whose base class is 'object'; this seems to be a precaution
		   so that old extension types don't suddenly become
		   callable (object.__new__ wouldn't insure the invariants
		   that the extension type's own factory function ensures).
		   Heap types, of course, are under our control, so they do
		   inherit tp_new; static extension types that specify some
		   other built-in type as the default are considered
		   new-style-aware so they also inherit object.__new__. */</comment>
		<if>if <condition>(<expr><name>base</name> != &amp;<name>PyBaseObject_Type</name> ||
		    (<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>)</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_new</name></name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_new</name></name> = <name><name>base</name>-&gt;<name>tp_new</name></name></expr>;</expr_stmt></then></if>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_basicsize</name></name> = <name>newsize</name></expr>;</expr_stmt>

	<comment type="block">/* Copy other non-function slots */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COPYVAL</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYVAL</name><parameter_list>(<param><type><name>SLOT</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>if (type-&gt;SLOT == 0) type-&gt;SLOT = base-&gt;SLOT</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>COPYVAL</name><argument_list>(<argument><expr><name>tp_itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_WEAKREFS</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>COPYVAL</name><argument_list>(<argument><expr><name>tp_weaklistoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_CLASS</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>COPYVAL</name><argument_list>(<argument><expr><name>tp_dictoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Setup fast subclass flags */</comment>
	<if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>(<name>PyTypeObject</name>*)<name>PyExc_BaseException</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_BASE_EXC_SUBCLASS</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_TYPE_SUBCLASS</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>&amp;<name>PyInt_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_INT_SUBCLASS</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>&amp;<name>PyLong_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_LONG_SUBCLASS</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>&amp;<name>PyString_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_STRING_SUBCLASS</name></expr>;</expr_stmt></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_UNICODE_SUBCLASS</name></expr>;</expr_stmt></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_TUPLE_SUBCLASS</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>&amp;<name>PyList_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_LIST_SUBCLASS</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>&amp;<name>PyDict_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_DICT_SUBCLASS</name></expr>;</expr_stmt></then></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>overrides_name</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVERRIDES_HASH</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>overrides_name(x, "__hash__")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVERRIDES_CMP</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>overrides_name(x, "__cmp__")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVERRIDES_EQ</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>overrides_name(x, "__eq__")</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>inherit_slots</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>basebase</name></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLOTDEFINED</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COPYSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COPYNUM</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COPYSEQ</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COPYMAP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COPYBUF</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOTDEFINED</name><parameter_list>(<param><type><name>SLOT</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>(base-&gt;SLOT != 0 &amp;&amp; \
	 (basebase == NULL || base-&gt;SLOT != basebase-&gt;SLOT))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYSLOT</name><parameter_list>(<param><type><name>SLOT</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>if (!type-&gt;SLOT &amp;&amp; SLOTDEFINED(SLOT)) type-&gt;SLOT = base-&gt;SLOT</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYNUM</name><parameter_list>(<param><type><name>SLOT</name></type></param>)</parameter_list></cpp:macro> <cpp:value>COPYSLOT(tp_as_number-&gt;SLOT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYSEQ</name><parameter_list>(<param><type><name>SLOT</name></type></param>)</parameter_list></cpp:macro> <cpp:value>COPYSLOT(tp_as_sequence-&gt;SLOT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYMAP</name><parameter_list>(<param><type><name>SLOT</name></type></param>)</parameter_list></cpp:macro> <cpp:value>COPYSLOT(tp_as_mapping-&gt;SLOT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYBUF</name><parameter_list>(<param><type><name>SLOT</name></type></param>)</parameter_list></cpp:macro> <cpp:value>COPYSLOT(tp_as_buffer-&gt;SLOT)</cpp:value></cpp:define>

	<comment type="block">/* This won't inherit indirect slots (from tp_as_number etc.)
	   if type doesn't provide the space. */</comment>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_as_number</name></name> != <name>NULL</name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_as_number</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>basebase</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>basebase</name>-&gt;<name>tp_as_number</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>basebase</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_subtract</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_multiply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_divide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_divmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_power</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_negative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_positive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_absolute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_nonzero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_invert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_lshift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_rshift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_and</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_xor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_coerce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_float</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_oct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_subtract</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_multiply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_divide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_power</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_lshift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_rshift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_and</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_xor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_CHECKTYPES</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_true_divide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_floor_divide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_true_divide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_inplace_floor_divide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_INDEX</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>COPYNUM</name><argument_list>(<argument><expr><name>nb_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_as_sequence</name></name> != <name>NULL</name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_as_sequence</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>basebase</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>basebase</name>-&gt;<name>tp_as_sequence</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>basebase</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_concat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_ass_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_ass_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_contains</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_inplace_concat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSEQ</name><argument_list>(<argument><expr><name>sq_inplace_repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_as_mapping</name></name> != <name>NULL</name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_as_mapping</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>basebase</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>basebase</name>-&gt;<name>tp_as_mapping</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>basebase</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>COPYMAP</name><argument_list>(<argument><expr><name>mp_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYMAP</name><argument_list>(<argument><expr><name>mp_subscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYMAP</name><argument_list>(<argument><expr><name>mp_ass_subscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_as_buffer</name></name> != <name>NULL</name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_as_buffer</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>basebase</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>basebase</name>-&gt;<name>tp_as_buffer</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>basebase</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>COPYBUF</name><argument_list>(<argument><expr><name>bf_getreadbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYBUF</name><argument_list>(<argument><expr><name>bf_getwritebuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYBUF</name><argument_list>(<argument><expr><name>bf_getsegcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYBUF</name><argument_list>(<argument><expr><name>bf_getcharbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYBUF</name><argument_list>(<argument><expr><name>bf_getbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYBUF</name><argument_list>(<argument><expr><name>bf_releasebuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>basebase</name> = <name><name>base</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_dealloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_getattr</name></name> == <name>NULL</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_getattro</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_getattr</name></name> = <name><name>base</name>-&gt;<name>tp_getattr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_getattro</name></name> = <name><name>base</name>-&gt;<name>tp_getattro</name></name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_setattr</name></name> == <name>NULL</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_setattro</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_setattr</name></name> = <name><name>base</name>-&gt;<name>tp_setattr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_setattro</name></name> = <name><name>base</name>-&gt;<name>tp_setattro</name></name></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* tp_compare see tp_richcompare */</comment>
	<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* tp_hash see tp_richcompare */</comment>
	<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_RICHCOMPARE</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_compare</name></name> == <name>NULL</name> &amp;&amp;
		    <name><name>type</name>-&gt;<name>tp_richcompare</name></name> == <name>NULL</name> &amp;&amp;
		    <name><name>type</name>-&gt;<name>tp_hash</name></name> == <name>NULL</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_compare</name></name> = <name><name>base</name>-&gt;<name>tp_compare</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_richcompare</name></name> = <name><name>base</name>-&gt;<name>tp_richcompare</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_hash</name></name> = <name><name>base</name>-&gt;<name>tp_hash</name></name></expr>;</expr_stmt>
			<comment type="block">/* Check for changes to inherited methods in Py3k*/</comment>
			<if>if <condition>(<expr><name>Py_Py3kWarningFlag</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name><name>base</name>-&gt;<name>tp_hash</name></name> &amp;&amp;
						(<name><name>base</name>-&gt;<name>tp_hash</name></name> != <name>PyObject_HashNotImplemented</name>) &amp;&amp;
						!<call><name>OVERRIDES_HASH</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><call><name>OVERRIDES_CMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"Overriding "
						  "__cmp__ blocks inheritance "
						  "of __hash__ in 3.x"</expr></argument>,
						  <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then></if>
					<if>if <condition>(<expr><call><name>OVERRIDES_EQ</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"Overriding "
						  "__eq__ blocks inheritance "
						  "of __hash__ in 3.x"</expr></argument>,
						  <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then></if>
				}</block></then></if>
			}</block></then></if>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_ITER</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_iternext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_CLASS</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_descr_get</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_descr_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_dictoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_is_gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GC</name>) ==
		    (<name><name>base</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GC</name>)</expr>)</condition><then> <block>{
			<comment type="block">/* They agree about gc. */</comment>
			<expr_stmt><expr><call><name>COPYSLOT</name><argument_list>(<argument><expr><name>tp_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr>(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_GC</name>) &amp;&amp;
			 <name><name>type</name>-&gt;<name>tp_free</name></name> == <name>NULL</name> &amp;&amp;
			 <name><name>base</name>-&gt;<name>tp_free</name></name> == <name>_PyObject_Del</name></expr>)</condition><then> <block>{
			<comment type="block">/* A bit of magic to plug in the correct default
			 * tp_free function when a derived class adds gc,
			 * didn't define tp_free, and the base uses the
			 * default non-gc tp_free.
			 */</comment>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_free</name></name> = <name>PyObject_GC_Del</name></expr>;</expr_stmt>
		}</block></then></if></else></if>
		<comment type="block">/* else they didn't agree about gc, and there isn't something
		 * obvious to be done -- the type is on its own.
		 */</comment>
	}</block></then></if>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>add_operators</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<function><type><name>int</name></type>
<name>PyType_Ready</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>, *<decl><type ref="prev"/><name>bases</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_READY</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_READYING</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> |= <name>Py_TPFLAGS_READYING</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TRACE_REFS</name></cpp:ifdef>
	<comment type="block">/* PyType_Ready is the closest thing we have to a choke point
	 * for type objects, so is the best place I can think of to try
	 * to get type objects into the doubly-linked list of all objects.
	 * Still, not all type objects go thru PyType_Ready.
	 */</comment>
	<expr_stmt><expr><call><name>_Py_AddToAllObjects</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Initialize tp_base (defaults to BaseObject unless that's us) */</comment>
	<expr_stmt><expr><name>base</name> = <name><name>type</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>base</name> == <name>NULL</name> &amp;&amp; <name>type</name> != &amp;<name>PyBaseObject_Type</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>base</name> = <name><name>type</name>-&gt;<name>tp_base</name></name> = &amp;<name>PyBaseObject_Type</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Now the only way base can still be NULL is if type is
	 * &amp;PyBaseObject_Type.
	 */</comment>

	<comment type="block">/* Initialize the base class */</comment>
	<if>if <condition>(<expr><name>base</name> &amp;&amp; <name><name>base</name>-&gt;<name>tp_dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></then></if>

	<comment type="block">/* Initialize ob_type if NULL.	This means extensions that want to be
	   compilable separately on Windows can call PyType_Ready() instead of
	   initializing the ob_type field of their type objects. */</comment>
	<comment type="block">/* The test for base != NULL is really unnecessary, since base is only
	   NULL when type is &amp;PyBaseObject_Type, and we know its ob_type is
	   not NULL (it's initialized to &amp;PyType_Type).	 But coverity doesn't
	   know that. */</comment>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> == <name>NULL</name> &amp;&amp; <name>base</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* Initialize tp_bases */</comment>
	<expr_stmt><expr><name>bases</name> = <name><name>type</name>-&gt;<name>tp_bases</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>base</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>bases</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>bases</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_bases</name></name> = <name>bases</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Initialize tp_dict */</comment>
	<expr_stmt><expr><name>dict</name> = <name><name>type</name>-&gt;<name>tp_dict</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>dict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_dict</name></name> = <name>dict</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Add type-specific descriptors to tp_dict */</comment>
	<if>if <condition>(<expr><call><name>add_operators</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_methods</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>add_methods</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_methods</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_members</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>add_members</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_members</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_getset</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>add_getset</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_getset</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></then></if>

	<comment type="block">/* Calculate method resolution order */</comment>
	<if>if <condition>(<expr><call><name>mro_internal</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>

	<comment type="block">/* Inherit special flags from dominant base */</comment>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_base</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>inherit_special</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* Initialize tp_dict properly */</comment>
	<expr_stmt><expr><name>bases</name> = <name><name>type</name>-&gt;<name>tp_mro</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bases</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>b</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>inherit_slots</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>(<name>PyTypeObject</name> *)<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>

	<comment type="block">/* Sanity check for tp_free. */</comment>
	<if>if <condition>(<expr><call><name>PyType_IS_GC</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &amp;&amp; (<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_BASETYPE</name>) &amp;&amp;
	    (<name><name>type</name>-&gt;<name>tp_free</name></name> == <name>NULL</name> || <name><name>type</name>-&gt;<name>tp_free</name></name> == <name>PyObject_Del</name>)</expr>)</condition><then> <block>{
		<comment type="block">/* This base class needs to call tp_free, but doesn't have
		 * one, or its tp_free is for non-gc'ed objects.
		 */</comment>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"type '%.100s' participates in "
			     "gc and is a base type but has inappropriate "
			     "tp_free slot"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>

	<comment type="block">/* if the type dictionary doesn't contain a __doc__, set it from
	   the tp_doc slot.
	 */</comment>
	<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>, <argument><expr>"__doc__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_doc</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>doc</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_doc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>doc</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>, <argument><expr>"__doc__"</expr></argument>, <argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>,
					     <argument><expr>"__doc__"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>

	<comment type="block">/* Some more special stuff */</comment>
	<expr_stmt><expr><name>base</name> = <name><name>type</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>base</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_as_number</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_as_number</name></name> = <name><name>base</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_as_sequence</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_as_sequence</name></name> = <name><name>base</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_as_mapping</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_as_mapping</name></name> = <name><name>base</name>-&gt;<name>tp_as_mapping</name></name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_as_buffer</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_as_buffer</name></name> = <name><name>base</name>-&gt;<name>tp_as_buffer</name></name></expr>;</expr_stmt></then></if>
	}</block></then></if>

	<comment type="block">/* Link into each base class's list of subclasses */</comment>
	<expr_stmt><expr><name>bases</name> = <name><name>type</name>-&gt;<name>tp_bases</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>b</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &amp;&amp;
		    <call><name>add_subclass</name><argument_list>(<argument><expr>(<name>PyTypeObject</name> *)<name>b</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></for>

	<comment type="block">/* All done -- set the ready flag */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> =
		(<name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; ~<name>Py_TPFLAGS_READYING</name>) | <name>Py_TPFLAGS_READY</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>

  <label><name>error</name>:</label>
	<expr_stmt><expr><name><name>type</name>-&gt;<name>tp_flags</name></name> &amp;= ~<name>Py_TPFLAGS_READYING</name></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_subclass</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>ref</name></decl>, *<decl><type ref="prev"/><name>newobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>list</name> = <name><name>base</name>-&gt;<name>tp_subclasses</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>base</name>-&gt;<name>tp_subclasses</name></name> = <name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newobj</name> = <call><name>PyWeakref_NewRef</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>ref</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyWeakref_CheckRef</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyWeakref_GET_OBJECT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> == <name>Py_None</name></expr>)</condition><then>
			<return>return <expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></while>
	<expr_stmt><expr><name>result</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_subclass</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>base</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>ref</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>list</name> = <name><name>base</name>-&gt;<name>tp_subclasses</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>ref</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyWeakref_CheckRef</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyWeakref_GET_OBJECT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> == (<name>PyObject</name>*)<name>type</name></expr>)</condition><then> <block>{
			<comment type="block">/* this can't fail, right? */</comment>
			<expr_stmt><expr><call><name>PySequence_DelItem</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		}</block></then></if>
	}</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_num_args</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>ob</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
		    <argument><expr>"PyArg_UnpackTuple() argument list is not a tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>n</name> == <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
	    <argument><expr><name>PyExc_TypeError</name></expr></argument>, 
	    <argument><expr>"expected %d arguments, got %zd"</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Generic wrappers for overloadable 'operators' such as __getitem__ */</comment>

<comment type="block">/* There's a wrapper *function* for each distinct function typedef used
   for type object slots (e.g. binaryfunc, ternaryfunc, etc.).	There's a
   wrapper *table* for each distinct operation (e.g. __len__, __add__).
   Most tables have only one entry; the tables for binary operators have two
   entries, one regular and one with reversed arguments. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_lenfunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>lenfunc</name></type> <name>func</name> <init>= <expr>(<name>lenfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_inquirypred</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>inquiry</name></type> <name>func</name> <init>= <expr>(<name>inquiry</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_binaryfunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>binaryfunc</name></type> <name>func</name> <init>= <expr>(<name>binaryfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>other</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_binaryfunc_l</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>binaryfunc</name></type> <name>func</name> <init>= <expr>(<name>binaryfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>other</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!(<name><name>self</name>-&gt;<name>ob_type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_CHECKTYPES</name>) &amp;&amp;
	    !<call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name><name>other</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_binaryfunc_r</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>binaryfunc</name></type> <name>func</name> <init>= <expr>(<name>binaryfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>other</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!(<name><name>self</name>-&gt;<name>ob_type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_CHECKTYPES</name>) &amp;&amp;
	    !<call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name><name>other</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_coercefunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>coercion</name></type> <name>func</name> <init>= <expr>(<name>coercion</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>other</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ok</name> = <call><name>func</name><argument_list>(<argument><expr>&amp;<name>self</name></expr></argument>, <argument><expr>&amp;<name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ok</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>ok</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_ternaryfunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ternaryfunc</name></type> <name>func</name> <init>= <expr>(<name>ternaryfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>third</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Note: This wrapper only works for __pow__() */</comment>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>other</name></expr></argument>, <argument><expr>&amp;<name>third</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>, <argument><expr><name>third</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_ternaryfunc_r</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ternaryfunc</name></type> <name>func</name> <init>= <expr>(<name>ternaryfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>third</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Note: This wrapper only works for __pow__() */</comment>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>other</name></expr></argument>, <argument><expr>&amp;<name>third</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>third</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_unaryfunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unaryfunc</name></type> <name>func</name> <init>= <expr>(<name>unaryfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_indexargfunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ssizeargfunc</name></type> <name>func</name> <init>= <expr>(<name>ssizeargfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>o</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>i</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>getindex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>sq</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_as_sequence</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>sq</name> &amp;&amp; <name><name>sq</name>-&gt;<name>sq_length</name></name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call>(*<name><name>sq</name>-&gt;<name>sq_length</name></name>)<argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><name>i</name> += <name>n</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>i</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_sq_item</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ssizeargfunc</name></type> <name>func</name> <init>= <expr>(<name>ssizeargfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = <call><name>getindex</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_ssizessizeargfunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ssizessizeargfunc</name></type> <name>func</name> <init>= <expr>(<name>ssizessizeargfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"nn"</expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>j</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_sq_setitem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ssizeobjargproc</name></type> <name>func</name> <init>= <expr>(<name>ssizeobjargproc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>i</name> = <call><name>getindex</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_sq_delitem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ssizeobjargproc</name></type> <name>func</name> <init>= <expr>(<name>ssizeobjargproc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <call><name>getindex</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_ssizessizeobjargproc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ssizessizeobjargproc</name></type> <name>func</name> <init>= <expr>(<name>ssizessizeobjargproc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"nnO"</expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>j</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_delslice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ssizessizeobjargproc</name></type> <name>func</name> <init>= <expr>(<name>ssizessizeobjargproc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"nn"</expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>j</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<comment type="block">/* XXX objobjproc is a misnomer; should be objargpred */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_objobjproc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>objobjproc</name></type> <name>func</name> <init>= <expr>(<name>objobjproc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>value</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_objobjargproc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>objobjargproc</name></type> <name>func</name> <init>= <expr>(<name>objobjargproc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_delitem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>objobjargproc</name></type> <name>func</name> <init>= <expr>(<name>objobjargproc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>key</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_cmpfunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>cmpfunc</name></type> <name>func</name> <init>= <expr>(<name>cmpfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>other</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call>-&gt;<name>tp_compare</name> != <name>func</name> &amp;&amp;
	    !<call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
			<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"%s.__cmp__(x,y) requires y to be a '%s', not a '%s'"</expr></argument>,
			<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
			<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
			<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Helper to check for object.__setattr__ or __delattr__ applied to a type.
   This is called the Carlo Verre hack after its discoverer. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>hackcheck</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>setattrofunc</name></type> <name>func</name></decl></param>, <param><decl><type><name>char</name> *</type><name>what</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>type</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name></expr>)</condition>
		<expr_stmt><expr><name>type</name> = <name><name>type</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt></while>
	<comment type="block">/* If type is NULL now, this is a really weird type.
	   In the spirit of backwards compatibility (?), just shut up. */</comment>
	<if>if <condition>(<expr><name>type</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_setattro</name></name> != <name>func</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"can't apply this %s to %s object"</expr></argument>,
			     <argument><expr><name>what</name></expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_setattr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>setattrofunc</name></type> <name>func</name> <init>= <expr>(<name>setattrofunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>hackcheck</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr>"__setattr__"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_delattr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>setattrofunc</name></type> <name>func</name> <init>= <expr>(<name>setattrofunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>name</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>hackcheck</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr>"__delattr__"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_hashfunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>hashfunc</name></type> <name>func</name> <init>= <expr>(<name>hashfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ternaryfunc</name></type> <name>func</name> <init>= <expr>(<name>ternaryfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_richcmpfunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>richcmpfunc</name></type> <name>func</name> <init>= <expr>(<name>richcmpfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>other</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RICHCMP_WRAPPER</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RICHCMP_WRAPPER</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>OP</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static PyObject * \
richcmp_##NAME(PyObject *self, PyObject *args, void *wrapped) \
{ \
	return wrap_richcmpfunc(self, args, wrapped, OP); \
}</cpp:value></cpp:define>

<macro><name>RICHCMP_WRAPPER</name><argument_list>(<argument>lt</argument>, <argument>Py_LT</argument>)</argument_list></macro>
<macro><name>RICHCMP_WRAPPER</name><argument_list>(<argument>le</argument>, <argument>Py_LE</argument>)</argument_list></macro>
<macro><name>RICHCMP_WRAPPER</name><argument_list>(<argument>eq</argument>, <argument>Py_EQ</argument>)</argument_list></macro>
<macro><name>RICHCMP_WRAPPER</name><argument_list>(<argument>ne</argument>, <argument>Py_NE</argument>)</argument_list></macro>
<macro><name>RICHCMP_WRAPPER</name><argument_list>(<argument>gt</argument>, <argument>Py_GT</argument>)</argument_list></macro>
<macro><name>RICHCMP_WRAPPER</name><argument_list>(<argument>ge</argument>, <argument>Py_GE</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unaryfunc</name></type> <name>func</name> <init>= <expr>(<name>unaryfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_SetNone</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_descr_get</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>func</name> <init>= <expr>(<name>descrgetfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>obj</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>obj</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>type</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>type</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>type</name> == <name>NULL</name> &amp;&amp;<name>obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"__get__(None, None) is invalid"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_descr_set</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>descrsetfunc</name></type> <name>func</name> <init>= <expr>(<name>descrsetfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>ret</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_descr_delete</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>descrsetfunc</name></type> <name>func</name> <init>= <expr>(<name>descrsetfunc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>check_num_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>obj</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>void</name> *</type><name>wrapped</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>initproc</name></type> <name>func</name> <init>= <expr>(<name>initproc</name>)<name>wrapped</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>func</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tp_new_wrapper</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>subtype</name></decl>, *<decl><type ref="prev"/><name>staticbase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg0</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>self</name> == <name>NULL</name> || !<call><name>PyType_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"__new__() called with non-type 'self'"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>type</name> = (<name>PyTypeObject</name> *)<name>self</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &lt; 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"%s.__new__(): not enough arguments"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>arg0</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyType_Check</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"%s.__new__(X): X is not a type object (%s)"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>subtype</name> = (<name>PyTypeObject</name> *)<name>arg0</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"%s.__new__(%s): %s is not a subtype of %s"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name><name>subtype</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name><name>subtype</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Check that the use doesn't do something silly and unsafe like
	   object.__new__(dict).  To do this, we check that the
	   most derived base that's not a heap type is this type. */</comment>
	<expr_stmt><expr><name>staticbase</name> = <name>subtype</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>staticbase</name> &amp;&amp; (<name><name>staticbase</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HEAPTYPE</name>)</expr>)</condition>
		<expr_stmt><expr><name>staticbase</name> = <name><name>staticbase</name>-&gt;<name>tp_base</name></name></expr>;</expr_stmt></while>
	<comment type="block">/* If staticbase is NULL now, it is a really weird type.
	   In the spirit of backwards compatibility (?), just shut up. */</comment>
	<if>if <condition>(<expr><name>staticbase</name> &amp;&amp; <name><name>staticbase</name>-&gt;<name>tp_new</name></name> != <name><name>type</name>-&gt;<name>tp_new</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"%s.__new__(%s) is not safe, use %s.__new__()"</expr></argument>,
			     <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name><name>subtype</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name>staticbase</name> == <name>NULL</name> ? "?" : <name><name>staticbase</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_GetSlice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name><name>type</name>-&gt;<name>tp_new</name></name><argument_list>(<argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>tp_new_methoddef</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__new__"</expr>, <expr>(<name>PyCFunction</name>)<name>tp_new_wrapper</name></expr>, <expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"T.__new__(S, ...) -&gt; "
		   "a new object with type S, a subtype of T"</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_tp_new_wrapper</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>, <argument><expr>"__new__"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>PyCFunction_New</name><argument_list>(<argument><expr><name>tp_new_methoddef</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></argument>, <argument><expr>"__new__"</expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Slot wrappers that call the corresponding __foo__ slot.  See comments
   below at override_slots() for more explanation. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOT0</name><parameter_list>(<param><type><name>FUNCNAME</name></type></param>, <param><type><name>OPSTR</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static PyObject * \
FUNCNAME(PyObject *self) \
{ \
	static PyObject *cache_str; \
	return call_method(self, OPSTR, &amp;cache_str, "()"); \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOT1</name><parameter_list>(<param><type><name>FUNCNAME</name></type></param>, <param><type><name>OPSTR</name></type></param>, <param><type><name>ARG1TYPE</name></type></param>, <param><type><name>ARGCODES</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static PyObject * \
FUNCNAME(PyObject *self, ARG1TYPE arg1) \
{ \
	static PyObject *cache_str; \
	return call_method(self, OPSTR, &amp;cache_str, "(" ARGCODES ")", arg1); \
}</cpp:value></cpp:define>

<comment type="block">/* Boolean helper for SLOT1BINFULL().
   right.__class__ is a nontrivial subclass of left.__class__. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>method_is_overloaded</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>b</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If right doesn't have it, it's not overloaded */</comment>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>a</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>a</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If right has it but left doesn't, it's overloaded */</comment>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>ok</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>Py_NE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ok</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<return>return <expr><name>ok</name></expr>;</return>
}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOT1BINFULL</name><parameter_list>(<param><type><name>FUNCNAME</name></type></param>, <param><type><name>TESTFUNC</name></type></param>, <param><type><name>SLOTNAME</name></type></param>, <param><type><name>OPSTR</name></type></param>, <param><type><name>ROPSTR</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static PyObject * \
FUNCNAME(PyObject *self, PyObject *other) \
{ \
	static PyObject *cache_str, *rcache_str; \
	int do_other = Py_TYPE(self) != Py_TYPE(other) &amp;&amp; \
	    Py_TYPE(other)-&gt;tp_as_number != NULL &amp;&amp; \
	    Py_TYPE(other)-&gt;tp_as_number-&gt;SLOTNAME == TESTFUNC; \
	if (Py_TYPE(self)-&gt;tp_as_number != NULL &amp;&amp; \
	    Py_TYPE(self)-&gt;tp_as_number-&gt;SLOTNAME == TESTFUNC) { \
		PyObject *r; \
		if (do_other &amp;&amp; \
		    PyType_IsSubtype(Py_TYPE(other), Py_TYPE(self)) &amp;&amp; \
		    method_is_overloaded(self, other, ROPSTR)) { \
			r = call_maybe( \
				other, ROPSTR, &amp;rcache_str, "(O)", self); \
			if (r != Py_NotImplemented) \
				return r; \
			Py_DECREF(r); \
			do_other = 0; \
		} \
		r = call_maybe( \
			self, OPSTR, &amp;cache_str, "(O)", other); \
		if (r != Py_NotImplemented || \
		    Py_TYPE(other) == Py_TYPE(self)) \
			return r; \
		Py_DECREF(r); \
	} \
	if (do_other) { \
		return call_maybe( \
			other, ROPSTR, &amp;rcache_str, "(O)", self); \
	} \
	Py_INCREF(Py_NotImplemented); \
	return Py_NotImplemented; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOT1BIN</name><parameter_list>(<param><type><name>FUNCNAME</name></type></param>, <param><type><name>SLOTNAME</name></type></param>, <param><type><name>OPSTR</name></type></param>, <param><type><name>ROPSTR</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>SLOT1BINFULL(FUNCNAME, FUNCNAME, SLOTNAME, OPSTR, ROPSTR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOT2</name><parameter_list>(<param><type><name>FUNCNAME</name></type></param>, <param><type><name>OPSTR</name></type></param>, <param><type><name>ARG1TYPE</name></type></param>, <param><type><name>ARG2TYPE</name></type></param>, <param><type><name>ARGCODES</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static PyObject * \
FUNCNAME(PyObject *self, ARG1TYPE arg1, ARG2TYPE arg2) \
{ \
	static PyObject *cache_str; \
	return call_method(self, OPSTR, &amp;cache_str, \
			   "(" ARGCODES ")", arg1, arg2); \
}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>slot_sq_length</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>len_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__len__"</expr></argument>, <argument><expr>&amp;<name>len_str</name></expr></argument>, <argument><expr>"()"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>len</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"__len__() should return &gt;= 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><name>len</name></expr>;</return>
}</block></function>

<comment type="block">/* Super-optimized version of slot_sq_item.
   Other slots could do the same... */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_sq_item</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>getitem_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>args</name> <init>= <expr><name>NULL</name></expr></init>, *<name>ival</name> <init>= <expr><name>NULL</name></expr></init>, *<name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>f</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>getitem_str</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>getitem_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__getitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>getitem_str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>getitem_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>f</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call>-&gt;<name>tp_descr_get</name>) == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name>func</name> = <call><name>f</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></else></if>
		<expr_stmt><expr><name>ival</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ival</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>args</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>retval</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>retval</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr><name>getitem_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>slot_sq_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>getslice_str</name></decl>;</decl_stmt>
	
	<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"in 3.x, __getslice__ has been removed; "
			    "use __getitem__"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__getslice__"</expr></argument>, <argument><expr>&amp;<name>getslice_str</name></expr></argument>,
		<argument><expr>"nn"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slot_sq_ass_item</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>delitem_str</name></decl>, *<decl><type ref="prev"/><name>setitem_str</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__delitem__"</expr></argument>, <argument><expr>&amp;<name>delitem_str</name></expr></argument>,
				  <argument><expr>"(n)"</expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__setitem__"</expr></argument>, <argument><expr>&amp;<name>setitem_str</name></expr></argument>,
				  <argument><expr>"(nO)"</expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slot_sq_ass_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>delslice_str</name></decl>, *<decl><type ref="prev"/><name>setslice_str</name></decl>;</decl_stmt>
	
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"in 3.x, __delslice__ has been removed; "
				   "use __delitem__"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__delslice__"</expr></argument>, <argument><expr>&amp;<name>delslice_str</name></expr></argument>,
				  <argument><expr>"(nn)"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"in 3.x, __setslice__ has been removed; "
					"use __setitem__"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>		
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__setslice__"</expr></argument>, <argument><expr>&amp;<name>setslice_str</name></expr></argument>,
			  <argument><expr>"(nnO)"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slot_sq_contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>contains_str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_maybe</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__contains__"</expr></argument>, <argument><expr>&amp;<name>contains_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name>res</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>result</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr>! <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Possible results: -1 and 1 */</comment>
		<expr_stmt><expr><name>result</name> = (<name>int</name>)<call><name>_PySequence_IterSearch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
						 <argument><expr><name>PY_ITERSEARCH_CONTAINS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>slot_mp_length</name></cpp:macro> <cpp:value>slot_sq_length</cpp:value></cpp:define>

<macro><name>SLOT1</name><argument_list>(<argument>slot_mp_subscript</argument>, <argument>"__getitem__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slot_mp_ass_subscript</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>delitem_str</name></decl>, *<decl><type ref="prev"/><name>setitem_str</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__delitem__"</expr></argument>, <argument><expr>&amp;<name>delitem_str</name></expr></argument>,
				  <argument><expr>"(O)"</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__setitem__"</expr></argument>, <argument><expr>&amp;<name>setitem_str</name></expr></argument>,
				 <argument><expr>"(OO)"</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_add</argument>, <argument>nb_add</argument>, <argument>"__add__"</argument>, <argument>"__radd__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_subtract</argument>, <argument>nb_subtract</argument>, <argument>"__sub__"</argument>, <argument>"__rsub__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_multiply</argument>, <argument>nb_multiply</argument>, <argument>"__mul__"</argument>, <argument>"__rmul__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_divide</argument>, <argument>nb_divide</argument>, <argument>"__div__"</argument>, <argument>"__rdiv__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_remainder</argument>, <argument>nb_remainder</argument>, <argument>"__mod__"</argument>, <argument>"__rmod__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_divmod</argument>, <argument>nb_divmod</argument>, <argument>"__divmod__"</argument>, <argument>"__rdivmod__"</argument>)</argument_list></macro>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>slot_nb_power</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<macro><name>SLOT1BINFULL</name><argument_list>(<argument>slot_nb_power_binary</argument>, <argument>slot_nb_power</argument>,
	     <argument>nb_power</argument>, <argument>"__pow__"</argument>, <argument>"__rpow__"</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_nb_power</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>modulus</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>pow_str</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>modulus</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr><call><name>slot_nb_power_binary</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<comment type="block">/* Three-arg power doesn't use __rpow__.  But ternary_op
	   can call this when the second argument's type uses
	   slot_nb_power, so check before calling self.__pow__. */</comment>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_as_number</name> != <name>NULL</name> &amp;&amp;
	    <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name><name>tp_as_number</name>-&gt;<name>nb_power</name></name> == <name>slot_nb_power</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__pow__"</expr></argument>, <argument><expr>&amp;<name>pow_str</name></expr></argument>,
				   <argument><expr>"(OO)"</expr></argument>, <argument><expr><name>other</name></expr></argument>, <argument><expr><name>modulus</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>

<macro><name>SLOT0</name><argument_list>(<argument>slot_nb_negative</argument>, <argument>"__neg__"</argument>)</argument_list></macro>
<macro><name>SLOT0</name><argument_list>(<argument>slot_nb_positive</argument>, <argument>"__pos__"</argument>)</argument_list></macro>
<macro><name>SLOT0</name><argument_list>(<argument>slot_nb_absolute</argument>, <argument>"__abs__"</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slot_nb_nonzero</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>nonzero_str</name></decl>, *<decl><type ref="prev"/><name>len_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_maybe</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__nonzero__"</expr></argument>, <argument><expr>&amp;<name>nonzero_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>func</name> = <call><name>lookup_maybe</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__len__"</expr></argument>, <argument><expr>&amp;<name>len_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call> ? -1 : 1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>temp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call> || <call><name>PyBool_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>result</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					     <argument><expr>"__nonzero__ should return "
					     "bool or int, returned %s"</expr></argument>,
					     <argument><expr><name><name>temp</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_nb_index</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>index_str</name></decl>;</decl_stmt>
	<return>return <expr><call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__index__"</expr></argument>, <argument><expr>&amp;<name>index_str</name></expr></argument>, <argument><expr>"()"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<macro><name>SLOT0</name><argument_list>(<argument>slot_nb_invert</argument>, <argument>"__invert__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_lshift</argument>, <argument>nb_lshift</argument>, <argument>"__lshift__"</argument>, <argument>"__rlshift__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_rshift</argument>, <argument>nb_rshift</argument>, <argument>"__rshift__"</argument>, <argument>"__rrshift__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_and</argument>, <argument>nb_and</argument>, <argument>"__and__"</argument>, <argument>"__rand__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_xor</argument>, <argument>nb_xor</argument>, <argument>"__xor__"</argument>, <argument>"__rxor__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_or</argument>, <argument>nb_or</argument>, <argument>"__or__"</argument>, <argument>"__ror__"</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slot_nb_coerce</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>a</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>coerce_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr>*<name>a</name></expr></init>, *<name>other</name> <init>= <expr>*<name>b</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> != <name>NULL</name> &amp;&amp;
	    <name><name>self</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_coerce</name></name> == <name>slot_nb_coerce</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>r</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>r</name> = <call><name>call_maybe</name><argument_list>(
			<argument><expr><name>self</name></expr></argument>, <argument><expr>"__coerce__"</expr></argument>, <argument><expr>&amp;<name>coerce_str</name></expr></argument>, <argument><expr>"(O)"</expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>r</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>r</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"__coerce__ didn't return a 2-tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr>*<name>a</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>b</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></else></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>other</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> != <name>NULL</name> &amp;&amp;
	    <name><name>other</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_coerce</name></name> == <name>slot_nb_coerce</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>r</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>r</name> = <call><name>call_maybe</name><argument_list>(
			<argument><expr><name>other</name></expr></argument>, <argument><expr>"__coerce__"</expr></argument>, <argument><expr>&amp;<name>coerce_str</name></expr></argument>, <argument><expr>"(O)"</expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>r</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>r</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"__coerce__ didn't return a 2-tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr>*<name>a</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>b</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<macro><name>SLOT0</name><argument_list>(<argument>slot_nb_int</argument>, <argument>"__int__"</argument>)</argument_list></macro>
<macro><name>SLOT0</name><argument_list>(<argument>slot_nb_long</argument>, <argument>"__long__"</argument>)</argument_list></macro>
<macro><name>SLOT0</name><argument_list>(<argument>slot_nb_float</argument>, <argument>"__float__"</argument>)</argument_list></macro>
<macro><name>SLOT0</name><argument_list>(<argument>slot_nb_oct</argument>, <argument>"__oct__"</argument>)</argument_list></macro>
<macro><name>SLOT0</name><argument_list>(<argument>slot_nb_hex</argument>, <argument>"__hex__"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_add</argument>, <argument>"__iadd__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_subtract</argument>, <argument>"__isub__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_multiply</argument>, <argument>"__imul__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_divide</argument>, <argument>"__idiv__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_remainder</argument>, <argument>"__imod__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<comment type="block">/* Can't use SLOT1 here, because nb_inplace_power is ternary */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type> 
<name>slot_nb_inplace_power</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type> <name>arg1</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg2</name></decl></param>)</parameter_list> 
<block>{ 
  <decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>cache_str</name></decl>;</decl_stmt> 
  <return>return <expr><call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__ipow__"</expr></argument>, <argument><expr>&amp;<name>cache_str</name></expr></argument>, <argument><expr>"(" "O" ")"</expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</return> 
}</block></function>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_lshift</argument>, <argument>"__ilshift__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_rshift</argument>, <argument>"__irshift__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_and</argument>, <argument>"__iand__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_xor</argument>, <argument>"__ixor__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_or</argument>, <argument>"__ior__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_floor_divide</argument>, <argument>nb_floor_divide</argument>,
	 <argument>"__floordiv__"</argument>, <argument>"__rfloordiv__"</argument>)</argument_list></macro>
<macro><name>SLOT1BIN</name><argument_list>(<argument>slot_nb_true_divide</argument>, <argument>nb_true_divide</argument>, <argument>"__truediv__"</argument>, <argument>"__rtruediv__"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_floor_divide</argument>, <argument>"__ifloordiv__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>
<macro><name>SLOT1</name><argument_list>(<argument>slot_nb_inplace_true_divide</argument>, <argument>"__itruediv__"</argument>, <argument>PyObject *</argument>, <argument>"O"</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>half_compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>cmp_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__cmp__"</expr></argument>, <argument><expr>&amp;<name>cmp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name>res</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-2</expr>;</return></then></if>
			<expr_stmt><expr><name>c</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr>-2</expr>;</return></then></if>
			<return>return <expr>(<name>c</name> &lt; 0) ? -1 : (<name>c</name> &gt; 0) ? 1 : 0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr>2</expr>;</return>
}</block></function>

<comment type="block">/* This slot is published for the benefit of try_3way_compare in object.c */</comment>
<function><type><name>int</name></type>
<name>_PyObject_SlotCompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_compare</name> == <name>_PyObject_SlotCompare</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call><name>half_compare</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> &lt;= 1</expr>)</condition><then>
			<return>return <expr><name>c</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call>-&gt;<name>tp_compare</name> == <name>_PyObject_SlotCompare</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call><name>half_compare</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> &lt; -1</expr>)</condition><then>
			<return>return <expr>-2</expr>;</return></then></if>
		<if>if <condition>(<expr><name>c</name> &lt;= 1</expr>)</condition><then>
			<return>return <expr>-<name>c</name></expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr>(<name>void</name> *)<name>self</name> &lt; (<name>void</name> *)<name>other</name> ? -1 :
		(<name>void</name> *)<name>self</name> &gt; (<name>void</name> *)<name>other</name> ? 1 : 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>repr_str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__repr__"</expr></argument>, <argument><expr>&amp;<name>repr_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s object at %p&gt;"</expr></argument>,
				   <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>str_str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__str__"</expr></argument>, <argument><expr>&amp;<name>str_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>slot_tp_repr</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>slot_tp_hash</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>hash_str</name></decl>, *<decl><type ref="prev"/><name>eq_str</name></decl>, *<decl><type ref="prev"/><name>cmp_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>h</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__hash__"</expr></argument>, <argument><expr>&amp;<name>hash_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>func</name> != <name>NULL</name> &amp;&amp; <name>func</name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>h</name> = <call><name><name>PyLong_Type</name>.<name>tp_hash</name></name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>h</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* may be None */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>func</name> = <call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__eq__"</expr></argument>, <argument><expr>&amp;<name>eq_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>func</name> = <call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__cmp__"</expr></argument>, <argument><expr>&amp;<name>cmp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>PyObject_HashNotImplemented</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>h</name> = <call><name>_Py_HashPointer</name><argument_list>(<argument><expr>(<name>void</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>h</name> == -1 &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>h</name> = -2</expr>;</expr_stmt></then></if>
	<return>return <expr><name>h</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>call_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>meth</name> <init>= <expr><call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__call__"</expr></argument>, <argument><expr>&amp;<name>call_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>meth</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>res</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>meth</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* There are two slot dispatch functions for tp_getattro.

   - slot_tp_getattro() is used when __getattribute__ is overridden
     but no __getattr__ hook is present;

   - slot_tp_getattr_hook() is used when a __getattr__ hook is present.

   The code in update_one_slot() always installs slot_tp_getattr_hook(); this
   detects the absence of __getattr__ and then installs the simpler slot if
   necessary. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_getattro</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>getattribute_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__getattribute__"</expr></argument>, <argument><expr>&amp;<name>getattribute_str</name></expr></argument>,
			   <argument><expr>"(O)"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_attribute</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>attr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>, *<decl><type ref="prev"/><name>descr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>f</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call>-&gt;<name>tp_descr_get</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>descr</name> = <call><name>f</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then>
		<else>else
			<expr_stmt><expr><name>attr</name> = <name>descr</name></expr>;</expr_stmt></else></if>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_getattr_hook</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>getattr</name></decl>, *<decl><type ref="prev"/><name>getattribute</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>getattribute_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>getattr_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>getattr_str</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>getattr_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__getattr__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>getattr_str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>getattribute_str</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>getattribute_str</name> =
			<call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__getattribute__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>getattribute_str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<comment type="block">/* speed hack: we could use lookup_maybe, but that would resolve the
	   method fully for each attribute lookup for classes with
	   __getattr__, even when the attribute is present. So we use
	   _PyType_Lookup and create the method only when needed, with
	   call_attribute. */</comment>
	<expr_stmt><expr><name>getattr</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>getattr_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>getattr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* No __getattr__ hook: use a simpler dispatcher */</comment>
		<expr_stmt><expr><name><name>tp</name>-&gt;<name>tp_getattro</name></name> = <name>slot_tp_getattro</name></expr>;</expr_stmt>
		<return>return <expr><call><name>slot_tp_getattro</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>getattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* speed hack: we could use lookup_maybe, but that would resolve the
	   method fully for each attribute lookup for classes with
	   __getattr__, even when self has the default __getattribute__
	   method. So we use _PyType_Lookup and create the method only when
	   needed, with call_attribute. */</comment>
	<expr_stmt><expr><name>getattribute</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>getattribute_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>getattribute</name> == <name>NULL</name> ||
	    (<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>getattribute</name></expr></argument>)</argument_list></call> == &amp;<name>PyWrapperDescr_Type</name> &amp;&amp;
	     ((<name>PyWrapperDescrObject</name> *)<name>getattribute</name>)-&gt;<name>d_wrapped</name> ==
	     (<name>void</name> *)<name>PyObject_GenericGetAttr</name>)</expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_GenericGetAttr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>getattribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = <call><name>call_attribute</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>getattribute</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>getattribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name> &amp;&amp; <call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = <call><name>call_attribute</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>getattr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>getattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slot_tp_setattro</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>delattr_str</name></decl>, *<decl><type ref="prev"/><name>setattr_str</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__delattr__"</expr></argument>, <argument><expr>&amp;<name>delattr_str</name></expr></argument>,
				  <argument><expr>"(O)"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__setattr__"</expr></argument>, <argument><expr>&amp;<name>setattr_str</name></expr></argument>,
				  <argument><expr>"(OO)"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>name_op</name><index>[]</index></name> <init>= <expr><block>{
    <expr>"__lt__"</expr>,
    <expr>"__le__"</expr>,
    <expr>"__eq__"</expr>,
    <expr>"__ne__"</expr>,
    <expr>"__gt__"</expr>,
    <expr>"__ge__"</expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>half_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name><name>op_str</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>name_op</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>op_str</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_richcompare</name> == <name>slot_tp_richcompare</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>half_richcompare</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>res</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call>-&gt;<name>tp_richcompare</name> == <name>slot_tp_richcompare</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>half_richcompare</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>_Py_SwappedOp</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
			<return>return <expr><name>res</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_iter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>iter_str</name></decl>, *<decl><type ref="prev"/><name>getitem_str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__iter__"</expr></argument>, <argument><expr>&amp;<name>iter_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>args</name> = <name>res</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>args</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>res</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>func</name> = <call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__getitem__"</expr></argument>, <argument><expr>&amp;<name>getitem_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"'%.200s' object is not iterable"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PySeqIter_New</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_iternext</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>next_str</name></decl>;</decl_stmt>
	<return>return <expr><call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"next"</expr></argument>, <argument><expr>&amp;<name>next_str</name></expr></argument>, <argument><expr>"()"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_descr_get</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>get</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>get_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>get_str</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>get_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__get__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>get_str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>get</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>get_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>get</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Avoid further slowdowns */</comment>
		<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_descr_get</name></name> == <name>slot_tp_descr_get</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>tp</name>-&gt;<name>tp_descr_get</name></name> = <name>NULL</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>self</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>obj</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>type</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>type</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>get</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slot_tp_descr_set</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>target</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>del_str</name></decl>, *<decl><type ref="prev"/><name>set_str</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__delete__"</expr></argument>, <argument><expr>&amp;<name>del_str</name></expr></argument>,
				  <argument><expr>"(O)"</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>call_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__set__"</expr></argument>, <argument><expr>&amp;<name>set_str</name></expr></argument>,
				  <argument><expr>"(OO)"</expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slot_tp_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>init_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>meth</name> <init>= <expr><call><name>lookup_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__init__"</expr></argument>, <argument><expr>&amp;<name>init_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>meth</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>meth</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>res</name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"__init__() should return None, not '%.200s'"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>slot_tp_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>new_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newargs</name></decl>, *<decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>new_str</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>new_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__new__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>new_str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>, <argument><expr><name>new_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newargs</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newargs</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>x</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name>x</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>slot_tp_del</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>del_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>del</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>error_type</name></decl>, *<decl><type ref="prev"/><name>error_value</name></decl>, *<decl><type ref="prev"/><name>error_traceback</name></decl>;</decl_stmt>

	<comment type="block">/* Temporarily resurrect the object. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_refcnt</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_refcnt</name></name> = 1</expr>;</expr_stmt>

	<comment type="block">/* Save the current exception, if any. */</comment>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>error_type</name></expr></argument>, <argument><expr>&amp;<name>error_value</name></expr></argument>, <argument><expr>&amp;<name>error_traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute __del__ method, if any. */</comment>
	<expr_stmt><expr><name>del</name> = <call><name>lookup_maybe</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__del__"</expr></argument>, <argument><expr>&amp;<name>del_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>del</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>del</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Restore the saved exception. */</comment>
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>error_type</name></expr></argument>, <argument><expr><name>error_value</name></expr></argument>, <argument><expr><name>error_traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Undo the temporary resurrection; can't use DECREF here, it would
	 * cause a recursive call.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_refcnt</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>--<name><name>self</name>-&gt;<name>ob_refcnt</name></name> == 0</expr>)</condition><then>
		<return>return;</return></then></if>	<comment type="block">/* this is the normal path out */</comment>

	<comment type="block">/* __del__ resurrected it!  Make it look like the original Py_DECREF
	 * never happened.
	 */</comment>
	<block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>refcnt</name> <init>= <expr><name><name>self</name>-&gt;<name>ob_refcnt</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_refcnt</name></name> = <name>refcnt</name></expr>;</expr_stmt>
	}</block>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<call><name>PyType_IS_GC</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> ||
	       <call><name>_Py_AS_GC</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name><name>gc</name>.<name>gc_refs</name></name> != <name>_PyGC_REFS_UNTRACKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If Py_REF_DEBUG, _Py_NewReference bumped _Py_RefTotal, so
	 * we need to undo that. */</comment>
	<expr_stmt><expr><name>_Py_DEC_REFTOTAL</name></expr>;</expr_stmt>
	<comment type="block">/* If Py_TRACE_REFS, _Py_NewReference re-added self to the object
	 * chain, so no more to do there.
	 * If COUNT_ALLOCS, the original decref bumped tp_frees, and
	 * _Py_NewReference bumped tp_allocs:  both of those need to be
	 * undone.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
	<expr_stmt><expr>--<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_frees</name></expr>;</expr_stmt>
	<expr_stmt><expr>--<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_allocs</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="block">/* Table mapping __foo__ names to tp_foo offsets and slot_tp_foo wrapper
   functions.  The offsets here are relative to the 'PyHeapTypeObject'
   structure, which incorporates the additional structures used for numbers,
   sequences and mappings.
   Note that multiple names may map to the same slot (e.g. __eq__,
   __ne__ etc. all map to tp_richcompare) and one name may map to multiple
   slots (e.g. __str__ affects tp_str as well as tp_repr). The table is
   terminated with an all-zero entry.  (This table is further initialized and
   sorted in init_slotdefs() below.) */</comment>

<typedef>typedef <type>struct <name>wrapperbase</name></type> <name>slotdef</name>;</typedef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TPSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FLSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ETSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SQSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MPSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NBSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UNSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IBSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BINSLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RBINSLOT</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TPSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>WRAPPER</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>{NAME, offsetof(PyTypeObject, SLOT), (void *)(FUNCTION), WRAPPER, \
	 PyDoc_STR(DOC)}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>WRAPPER</name></type></param>, <param><type><name>DOC</name></type></param>, <param><type><name>FLAGS</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>{NAME, offsetof(PyTypeObject, SLOT), (void *)(FUNCTION), WRAPPER, \
	 PyDoc_STR(DOC), FLAGS}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>WRAPPER</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>{NAME, offsetof(PyHeapTypeObject, SLOT), (void *)(FUNCTION), WRAPPER, \
	 PyDoc_STR(DOC)}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>WRAPPER</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>ETSLOT(NAME, as_sequence.SLOT, FUNCTION, WRAPPER, DOC)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MPSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>WRAPPER</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>ETSLOT(NAME, as_mapping.SLOT, FUNCTION, WRAPPER, DOC)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>WRAPPER</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>ETSLOT(NAME, as_number.SLOT, FUNCTION, WRAPPER, DOC)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>WRAPPER</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>ETSLOT(NAME, as_number.SLOT, FUNCTION, WRAPPER, \
	       "x." NAME "() &lt;==&gt; " DOC)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>WRAPPER</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>ETSLOT(NAME, as_number.SLOT, FUNCTION, WRAPPER, \
	       "x." NAME "(y) &lt;==&gt; x" DOC "y")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>ETSLOT(NAME, as_number.SLOT, FUNCTION, wrap_binaryfunc_l, \
	       "x." NAME "(y) &lt;==&gt; x" DOC "y")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RBINSLOT</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>ETSLOT(NAME, as_number.SLOT, FUNCTION, wrap_binaryfunc_r, \
	       "x." NAME "(y) &lt;==&gt; y" DOC "x")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINSLOTNOTINFIX</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>ETSLOT(NAME, as_number.SLOT, FUNCTION, wrap_binaryfunc_l, \
	       "x." NAME "(y) &lt;==&gt; " DOC)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RBINSLOTNOTINFIX</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>SLOT</name></type></param>, <param><type><name>FUNCTION</name></type></param>, <param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>ETSLOT(NAME, as_number.SLOT, FUNCTION, wrap_binaryfunc_r, \
	       "x." NAME "(y) &lt;==&gt; " DOC)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>slotdef</name></type> <name><name>slotdefs</name><index>[]</index></name> <init>= <expr><block>{
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__len__"</expr></argument>, <argument><expr><name>sq_length</name></expr></argument>, <argument><expr><name>slot_sq_length</name></expr></argument>, <argument><expr><name>wrap_lenfunc</name></expr></argument>,
	       <argument><expr>"x.__len__() &lt;==&gt; len(x)"</expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* Heap types defining __add__/__mul__ have sq_concat/sq_repeat == NULL.
	   The logic in abstract.c always falls back to nb_add/nb_multiply in
	   this case.  Defining both the nb_* and the sq_* slots to call the
	   user-defined methods has unexpected side-effects, as shown by
	   test_descr.notimplemented() */</comment>
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__add__"</expr></argument>, <argument><expr><name>sq_concat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>wrap_binaryfunc</name></expr></argument>,
	  <argument><expr>"x.__add__(y) &lt;==&gt; x+y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__mul__"</expr></argument>, <argument><expr><name>sq_repeat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>wrap_indexargfunc</name></expr></argument>,
	  <argument><expr>"x.__mul__(n) &lt;==&gt; x*n"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__rmul__"</expr></argument>, <argument><expr><name>sq_repeat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>wrap_indexargfunc</name></expr></argument>,
	  <argument><expr>"x.__rmul__(n) &lt;==&gt; n*x"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__getitem__"</expr></argument>, <argument><expr><name>sq_item</name></expr></argument>, <argument><expr><name>slot_sq_item</name></expr></argument>, <argument><expr><name>wrap_sq_item</name></expr></argument>,
	       <argument><expr>"x.__getitem__(y) &lt;==&gt; x[y]"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__getslice__"</expr></argument>, <argument><expr><name>sq_slice</name></expr></argument>, <argument><expr><name>slot_sq_slice</name></expr></argument>, <argument><expr><name>wrap_ssizessizeargfunc</name></expr></argument>,
	       <argument><expr>"x.__getslice__(i, j) &lt;==&gt; x[i:j]\n\
	       \n\
	       Use of negative indices is not supported."</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__setitem__"</expr></argument>, <argument><expr><name>sq_ass_item</name></expr></argument>, <argument><expr><name>slot_sq_ass_item</name></expr></argument>, <argument><expr><name>wrap_sq_setitem</name></expr></argument>,
	       <argument><expr>"x.__setitem__(i, y) &lt;==&gt; x[i]=y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__delitem__"</expr></argument>, <argument><expr><name>sq_ass_item</name></expr></argument>, <argument><expr><name>slot_sq_ass_item</name></expr></argument>, <argument><expr><name>wrap_sq_delitem</name></expr></argument>,
	       <argument><expr>"x.__delitem__(y) &lt;==&gt; del x[y]"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__setslice__"</expr></argument>, <argument><expr><name>sq_ass_slice</name></expr></argument>, <argument><expr><name>slot_sq_ass_slice</name></expr></argument>,
	       <argument><expr><name>wrap_ssizessizeobjargproc</name></expr></argument>,
	       <argument><expr>"x.__setslice__(i, j, y) &lt;==&gt; x[i:j]=y\n\
	       \n\
	       Use  of negative indices is not supported."</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__delslice__"</expr></argument>, <argument><expr><name>sq_ass_slice</name></expr></argument>, <argument><expr><name>slot_sq_ass_slice</name></expr></argument>, <argument><expr><name>wrap_delslice</name></expr></argument>,
	       <argument><expr>"x.__delslice__(i, j) &lt;==&gt; del x[i:j]\n\
	       \n\
	       Use of negative indices is not supported."</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__contains__"</expr></argument>, <argument><expr><name>sq_contains</name></expr></argument>, <argument><expr><name>slot_sq_contains</name></expr></argument>, <argument><expr><name>wrap_objobjproc</name></expr></argument>,
	       <argument><expr>"x.__contains__(y) &lt;==&gt; y in x"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__iadd__"</expr></argument>, <argument><expr><name>sq_inplace_concat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
	  <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"x.__iadd__(y) &lt;==&gt; x+=y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>SQSLOT</name><argument_list>(<argument><expr>"__imul__"</expr></argument>, <argument><expr><name>sq_inplace_repeat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
	  <argument><expr><name>wrap_indexargfunc</name></expr></argument>, <argument><expr>"x.__imul__(y) &lt;==&gt; x*=y"</expr></argument>)</argument_list></call></expr>,

	<expr><call><name>MPSLOT</name><argument_list>(<argument><expr>"__len__"</expr></argument>, <argument><expr><name>mp_length</name></expr></argument>, <argument><expr><name>slot_mp_length</name></expr></argument>, <argument><expr><name>wrap_lenfunc</name></expr></argument>,
	       <argument><expr>"x.__len__() &lt;==&gt; len(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MPSLOT</name><argument_list>(<argument><expr>"__getitem__"</expr></argument>, <argument><expr><name>mp_subscript</name></expr></argument>, <argument><expr><name>slot_mp_subscript</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>,
	       <argument><expr>"x.__getitem__(y) &lt;==&gt; x[y]"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MPSLOT</name><argument_list>(<argument><expr>"__setitem__"</expr></argument>, <argument><expr><name>mp_ass_subscript</name></expr></argument>, <argument><expr><name>slot_mp_ass_subscript</name></expr></argument>,
	       <argument><expr><name>wrap_objobjargproc</name></expr></argument>,
	       <argument><expr>"x.__setitem__(i, y) &lt;==&gt; x[i]=y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MPSLOT</name><argument_list>(<argument><expr>"__delitem__"</expr></argument>, <argument><expr><name>mp_ass_subscript</name></expr></argument>, <argument><expr><name>slot_mp_ass_subscript</name></expr></argument>,
	       <argument><expr><name>wrap_delitem</name></expr></argument>,
	       <argument><expr>"x.__delitem__(y) &lt;==&gt; del x[y]"</expr></argument>)</argument_list></call></expr>,

	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__add__"</expr></argument>, <argument><expr><name>nb_add</name></expr></argument>, <argument><expr><name>slot_nb_add</name></expr></argument>,
		<argument><expr>"+"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__radd__"</expr></argument>, <argument><expr><name>nb_add</name></expr></argument>, <argument><expr><name>slot_nb_add</name></expr></argument>,
		 <argument><expr>"+"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__sub__"</expr></argument>, <argument><expr><name>nb_subtract</name></expr></argument>, <argument><expr><name>slot_nb_subtract</name></expr></argument>,
		<argument><expr>"-"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rsub__"</expr></argument>, <argument><expr><name>nb_subtract</name></expr></argument>, <argument><expr><name>slot_nb_subtract</name></expr></argument>,
		 <argument><expr>"-"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__mul__"</expr></argument>, <argument><expr><name>nb_multiply</name></expr></argument>, <argument><expr><name>slot_nb_multiply</name></expr></argument>,
		<argument><expr>"*"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rmul__"</expr></argument>, <argument><expr><name>nb_multiply</name></expr></argument>, <argument><expr><name>slot_nb_multiply</name></expr></argument>,
		 <argument><expr>"*"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__div__"</expr></argument>, <argument><expr><name>nb_divide</name></expr></argument>, <argument><expr><name>slot_nb_divide</name></expr></argument>,
		<argument><expr>"/"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rdiv__"</expr></argument>, <argument><expr><name>nb_divide</name></expr></argument>, <argument><expr><name>slot_nb_divide</name></expr></argument>,
		 <argument><expr>"/"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__mod__"</expr></argument>, <argument><expr><name>nb_remainder</name></expr></argument>, <argument><expr><name>slot_nb_remainder</name></expr></argument>,
		<argument><expr>"%"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rmod__"</expr></argument>, <argument><expr><name>nb_remainder</name></expr></argument>, <argument><expr><name>slot_nb_remainder</name></expr></argument>,
		 <argument><expr>"%"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOTNOTINFIX</name><argument_list>(<argument><expr>"__divmod__"</expr></argument>, <argument><expr><name>nb_divmod</name></expr></argument>, <argument><expr><name>slot_nb_divmod</name></expr></argument>,
		<argument><expr>"divmod(x, y)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOTNOTINFIX</name><argument_list>(<argument><expr>"__rdivmod__"</expr></argument>, <argument><expr><name>nb_divmod</name></expr></argument>, <argument><expr><name>slot_nb_divmod</name></expr></argument>,
		 <argument><expr>"divmod(y, x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>NBSLOT</name><argument_list>(<argument><expr>"__pow__"</expr></argument>, <argument><expr><name>nb_power</name></expr></argument>, <argument><expr><name>slot_nb_power</name></expr></argument>, <argument><expr><name>wrap_ternaryfunc</name></expr></argument>,
	       <argument><expr>"x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z])"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>NBSLOT</name><argument_list>(<argument><expr>"__rpow__"</expr></argument>, <argument><expr><name>nb_power</name></expr></argument>, <argument><expr><name>slot_nb_power</name></expr></argument>, <argument><expr><name>wrap_ternaryfunc_r</name></expr></argument>,
	       <argument><expr>"y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z])"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__neg__"</expr></argument>, <argument><expr><name>nb_negative</name></expr></argument>, <argument><expr><name>slot_nb_negative</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>, <argument><expr>"-x"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__pos__"</expr></argument>, <argument><expr><name>nb_positive</name></expr></argument>, <argument><expr><name>slot_nb_positive</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>, <argument><expr>"+x"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__abs__"</expr></argument>, <argument><expr><name>nb_absolute</name></expr></argument>, <argument><expr><name>slot_nb_absolute</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>,
	       <argument><expr>"abs(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__nonzero__"</expr></argument>, <argument><expr><name>nb_nonzero</name></expr></argument>, <argument><expr><name>slot_nb_nonzero</name></expr></argument>, <argument><expr><name>wrap_inquirypred</name></expr></argument>,
	       <argument><expr>"x != 0"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__invert__"</expr></argument>, <argument><expr><name>nb_invert</name></expr></argument>, <argument><expr><name>slot_nb_invert</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>, <argument><expr>"~x"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__lshift__"</expr></argument>, <argument><expr><name>nb_lshift</name></expr></argument>, <argument><expr><name>slot_nb_lshift</name></expr></argument>, <argument><expr>"&lt;&lt;"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rlshift__"</expr></argument>, <argument><expr><name>nb_lshift</name></expr></argument>, <argument><expr><name>slot_nb_lshift</name></expr></argument>, <argument><expr>"&lt;&lt;"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__rshift__"</expr></argument>, <argument><expr><name>nb_rshift</name></expr></argument>, <argument><expr><name>slot_nb_rshift</name></expr></argument>, <argument><expr>"&gt;&gt;"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rrshift__"</expr></argument>, <argument><expr><name>nb_rshift</name></expr></argument>, <argument><expr><name>slot_nb_rshift</name></expr></argument>, <argument><expr>"&gt;&gt;"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__and__"</expr></argument>, <argument><expr><name>nb_and</name></expr></argument>, <argument><expr><name>slot_nb_and</name></expr></argument>, <argument><expr>"&amp;"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rand__"</expr></argument>, <argument><expr><name>nb_and</name></expr></argument>, <argument><expr><name>slot_nb_and</name></expr></argument>, <argument><expr>"&amp;"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__xor__"</expr></argument>, <argument><expr><name>nb_xor</name></expr></argument>, <argument><expr><name>slot_nb_xor</name></expr></argument>, <argument><expr>"^"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rxor__"</expr></argument>, <argument><expr><name>nb_xor</name></expr></argument>, <argument><expr><name>slot_nb_xor</name></expr></argument>, <argument><expr>"^"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__or__"</expr></argument>, <argument><expr><name>nb_or</name></expr></argument>, <argument><expr><name>slot_nb_or</name></expr></argument>, <argument><expr>"|"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__ror__"</expr></argument>, <argument><expr><name>nb_or</name></expr></argument>, <argument><expr><name>slot_nb_or</name></expr></argument>, <argument><expr>"|"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>NBSLOT</name><argument_list>(<argument><expr>"__coerce__"</expr></argument>, <argument><expr><name>nb_coerce</name></expr></argument>, <argument><expr><name>slot_nb_coerce</name></expr></argument>, <argument><expr><name>wrap_coercefunc</name></expr></argument>,
	       <argument><expr>"x.__coerce__(y) &lt;==&gt; coerce(x, y)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__int__"</expr></argument>, <argument><expr><name>nb_int</name></expr></argument>, <argument><expr><name>slot_nb_int</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>,
	       <argument><expr>"int(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__long__"</expr></argument>, <argument><expr><name>nb_long</name></expr></argument>, <argument><expr><name>slot_nb_long</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>,
	       <argument><expr>"long(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__float__"</expr></argument>, <argument><expr><name>nb_float</name></expr></argument>, <argument><expr><name>slot_nb_float</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>,
	       <argument><expr>"float(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__oct__"</expr></argument>, <argument><expr><name>nb_oct</name></expr></argument>, <argument><expr><name>slot_nb_oct</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>,
	       <argument><expr>"oct(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>UNSLOT</name><argument_list>(<argument><expr>"__hex__"</expr></argument>, <argument><expr><name>nb_hex</name></expr></argument>, <argument><expr><name>slot_nb_hex</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>,
	       <argument><expr>"hex(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>NBSLOT</name><argument_list>(<argument><expr>"__index__"</expr></argument>, <argument><expr><name>nb_index</name></expr></argument>, <argument><expr><name>slot_nb_index</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>, 
	       <argument><expr>"x[y:z] &lt;==&gt; x[y.__index__():z.__index__()]"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__iadd__"</expr></argument>, <argument><expr><name>nb_inplace_add</name></expr></argument>, <argument><expr><name>slot_nb_inplace_add</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"+"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__isub__"</expr></argument>, <argument><expr><name>nb_inplace_subtract</name></expr></argument>, <argument><expr><name>slot_nb_inplace_subtract</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"-"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__imul__"</expr></argument>, <argument><expr><name>nb_inplace_multiply</name></expr></argument>, <argument><expr><name>slot_nb_inplace_multiply</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__idiv__"</expr></argument>, <argument><expr><name>nb_inplace_divide</name></expr></argument>, <argument><expr><name>slot_nb_inplace_divide</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__imod__"</expr></argument>, <argument><expr><name>nb_inplace_remainder</name></expr></argument>, <argument><expr><name>slot_nb_inplace_remainder</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"%"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__ipow__"</expr></argument>, <argument><expr><name>nb_inplace_power</name></expr></argument>, <argument><expr><name>slot_nb_inplace_power</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"**"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__ilshift__"</expr></argument>, <argument><expr><name>nb_inplace_lshift</name></expr></argument>, <argument><expr><name>slot_nb_inplace_lshift</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"&lt;&lt;"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__irshift__"</expr></argument>, <argument><expr><name>nb_inplace_rshift</name></expr></argument>, <argument><expr><name>slot_nb_inplace_rshift</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"&gt;&gt;"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__iand__"</expr></argument>, <argument><expr><name>nb_inplace_and</name></expr></argument>, <argument><expr><name>slot_nb_inplace_and</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"&amp;"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__ixor__"</expr></argument>, <argument><expr><name>nb_inplace_xor</name></expr></argument>, <argument><expr><name>slot_nb_inplace_xor</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"^"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__ior__"</expr></argument>, <argument><expr><name>nb_inplace_or</name></expr></argument>, <argument><expr><name>slot_nb_inplace_or</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"|"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__floordiv__"</expr></argument>, <argument><expr><name>nb_floor_divide</name></expr></argument>, <argument><expr><name>slot_nb_floor_divide</name></expr></argument>, <argument><expr>"//"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rfloordiv__"</expr></argument>, <argument><expr><name>nb_floor_divide</name></expr></argument>, <argument><expr><name>slot_nb_floor_divide</name></expr></argument>, <argument><expr>"//"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>BINSLOT</name><argument_list>(<argument><expr>"__truediv__"</expr></argument>, <argument><expr><name>nb_true_divide</name></expr></argument>, <argument><expr><name>slot_nb_true_divide</name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>RBINSLOT</name><argument_list>(<argument><expr>"__rtruediv__"</expr></argument>, <argument><expr><name>nb_true_divide</name></expr></argument>, <argument><expr><name>slot_nb_true_divide</name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__ifloordiv__"</expr></argument>, <argument><expr><name>nb_inplace_floor_divide</name></expr></argument>,
	       <argument><expr><name>slot_nb_inplace_floor_divide</name></expr></argument>, <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"//"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>IBSLOT</name><argument_list>(<argument><expr>"__itruediv__"</expr></argument>, <argument><expr><name>nb_inplace_true_divide</name></expr></argument>,
	       <argument><expr><name>slot_nb_inplace_true_divide</name></expr></argument>, <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>,

	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__str__"</expr></argument>, <argument><expr><name>tp_str</name></expr></argument>, <argument><expr><name>slot_tp_str</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>,
	       <argument><expr>"x.__str__() &lt;==&gt; str(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__str__"</expr></argument>, <argument><expr><name>tp_print</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__repr__"</expr></argument>, <argument><expr><name>tp_repr</name></expr></argument>, <argument><expr><name>slot_tp_repr</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>,
	       <argument><expr>"x.__repr__() &lt;==&gt; repr(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__repr__"</expr></argument>, <argument><expr><name>tp_print</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__cmp__"</expr></argument>, <argument><expr><name>tp_compare</name></expr></argument>, <argument><expr><name>_PyObject_SlotCompare</name></expr></argument>, <argument><expr><name>wrap_cmpfunc</name></expr></argument>,
	       <argument><expr>"x.__cmp__(y) &lt;==&gt; cmp(x,y)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__hash__"</expr></argument>, <argument><expr><name>tp_hash</name></expr></argument>, <argument><expr><name>slot_tp_hash</name></expr></argument>, <argument><expr><name>wrap_hashfunc</name></expr></argument>,
	       <argument><expr>"x.__hash__() &lt;==&gt; hash(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>FLSLOT</name><argument_list>(<argument><expr>"__call__"</expr></argument>, <argument><expr><name>tp_call</name></expr></argument>, <argument><expr><name>slot_tp_call</name></expr></argument>, <argument><expr>(<name>wrapperfunc</name>)<name>wrap_call</name></expr></argument>,
	       <argument><expr>"x.__call__(...) &lt;==&gt; x(...)"</expr></argument>, <argument><expr><name>PyWrapperFlag_KEYWORDS</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__getattribute__"</expr></argument>, <argument><expr><name>tp_getattro</name></expr></argument>, <argument><expr><name>slot_tp_getattr_hook</name></expr></argument>,
	       <argument><expr><name>wrap_binaryfunc</name></expr></argument>, <argument><expr>"x.__getattribute__('name') &lt;==&gt; x.name"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__getattribute__"</expr></argument>, <argument><expr><name>tp_getattr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__getattr__"</expr></argument>, <argument><expr><name>tp_getattro</name></expr></argument>, <argument><expr><name>slot_tp_getattr_hook</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__getattr__"</expr></argument>, <argument><expr><name>tp_getattr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__setattr__"</expr></argument>, <argument><expr><name>tp_setattro</name></expr></argument>, <argument><expr><name>slot_tp_setattro</name></expr></argument>, <argument><expr><name>wrap_setattr</name></expr></argument>,
	       <argument><expr>"x.__setattr__('name', value) &lt;==&gt; x.name = value"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__setattr__"</expr></argument>, <argument><expr><name>tp_setattr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__delattr__"</expr></argument>, <argument><expr><name>tp_setattro</name></expr></argument>, <argument><expr><name>slot_tp_setattro</name></expr></argument>, <argument><expr><name>wrap_delattr</name></expr></argument>,
	       <argument><expr>"x.__delattr__('name') &lt;==&gt; del x.name"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__delattr__"</expr></argument>, <argument><expr><name>tp_setattr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__lt__"</expr></argument>, <argument><expr><name>tp_richcompare</name></expr></argument>, <argument><expr><name>slot_tp_richcompare</name></expr></argument>, <argument><expr><name>richcmp_lt</name></expr></argument>,
	       <argument><expr>"x.__lt__(y) &lt;==&gt; x&lt;y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__le__"</expr></argument>, <argument><expr><name>tp_richcompare</name></expr></argument>, <argument><expr><name>slot_tp_richcompare</name></expr></argument>, <argument><expr><name>richcmp_le</name></expr></argument>,
	       <argument><expr>"x.__le__(y) &lt;==&gt; x&lt;=y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__eq__"</expr></argument>, <argument><expr><name>tp_richcompare</name></expr></argument>, <argument><expr><name>slot_tp_richcompare</name></expr></argument>, <argument><expr><name>richcmp_eq</name></expr></argument>,
	       <argument><expr>"x.__eq__(y) &lt;==&gt; x==y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__ne__"</expr></argument>, <argument><expr><name>tp_richcompare</name></expr></argument>, <argument><expr><name>slot_tp_richcompare</name></expr></argument>, <argument><expr><name>richcmp_ne</name></expr></argument>,
	       <argument><expr>"x.__ne__(y) &lt;==&gt; x!=y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__gt__"</expr></argument>, <argument><expr><name>tp_richcompare</name></expr></argument>, <argument><expr><name>slot_tp_richcompare</name></expr></argument>, <argument><expr><name>richcmp_gt</name></expr></argument>,
	       <argument><expr>"x.__gt__(y) &lt;==&gt; x&gt;y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__ge__"</expr></argument>, <argument><expr><name>tp_richcompare</name></expr></argument>, <argument><expr><name>slot_tp_richcompare</name></expr></argument>, <argument><expr><name>richcmp_ge</name></expr></argument>,
	       <argument><expr>"x.__ge__(y) &lt;==&gt; x&gt;=y"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__iter__"</expr></argument>, <argument><expr><name>tp_iter</name></expr></argument>, <argument><expr><name>slot_tp_iter</name></expr></argument>, <argument><expr><name>wrap_unaryfunc</name></expr></argument>,
	       <argument><expr>"x.__iter__() &lt;==&gt; iter(x)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"next"</expr></argument>, <argument><expr><name>tp_iternext</name></expr></argument>, <argument><expr><name>slot_tp_iternext</name></expr></argument>, <argument><expr><name>wrap_next</name></expr></argument>,
	       <argument><expr>"x.next() -&gt; the next value, or raise StopIteration"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__get__"</expr></argument>, <argument><expr><name>tp_descr_get</name></expr></argument>, <argument><expr><name>slot_tp_descr_get</name></expr></argument>, <argument><expr><name>wrap_descr_get</name></expr></argument>,
	       <argument><expr>"descr.__get__(obj[, type]) -&gt; value"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__set__"</expr></argument>, <argument><expr><name>tp_descr_set</name></expr></argument>, <argument><expr><name>slot_tp_descr_set</name></expr></argument>, <argument><expr><name>wrap_descr_set</name></expr></argument>,
	       <argument><expr>"descr.__set__(obj, value)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__delete__"</expr></argument>, <argument><expr><name>tp_descr_set</name></expr></argument>, <argument><expr><name>slot_tp_descr_set</name></expr></argument>,
	       <argument><expr><name>wrap_descr_delete</name></expr></argument>, <argument><expr>"descr.__delete__(obj)"</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>FLSLOT</name><argument_list>(<argument><expr>"__init__"</expr></argument>, <argument><expr><name>tp_init</name></expr></argument>, <argument><expr><name>slot_tp_init</name></expr></argument>, <argument><expr>(<name>wrapperfunc</name>)<name>wrap_init</name></expr></argument>,
	       <argument><expr>"x.__init__(...) initializes x; "
	       "see x.__class__.__doc__ for signature"</expr></argument>,
	       <argument><expr><name>PyWrapperFlag_KEYWORDS</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__new__"</expr></argument>, <argument><expr><name>tp_new</name></expr></argument>, <argument><expr><name>slot_tp_new</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
	<expr><call><name>TPSLOT</name><argument_list>(<argument><expr>"__del__"</expr></argument>, <argument><expr><name>tp_del</name></expr></argument>, <argument><expr><name>slot_tp_del</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Given a type pointer and an offset gotten from a slotdef entry, return a
   pointer to the actual slot.	This is not quite the same as simply adding
   the offset to the type pointer, since it takes care to indirect through the
   proper indirection pointer (as_buffer, etc.); it returns NULL if the
   indirection pointer is NULL. */</comment>
<function><type><specifier>static</specifier> <name>void</name> **</type>
<name>slotptr</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>int</name></type> <name>ioffset</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>offset</name> <init>= <expr><name>ioffset</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Note: this depends on the order of the members of PyHeapTypeObject! */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>size_t</name>)<name>offset</name> &lt; <call><name>offsetof</name><argument_list>(<argument><expr><name>PyHeapTypeObject</name></expr></argument>, <argument><expr><name>as_buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>size_t</name>)<name>offset</name> &gt;= <call><name>offsetof</name><argument_list>(<argument><expr><name>PyHeapTypeObject</name></expr></argument>, <argument><expr><name>as_sequence</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ptr</name> = (<name>char</name> *)<name><name>type</name>-&gt;<name>tp_as_sequence</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> -= <call><name>offsetof</name><argument_list>(<argument><expr><name>PyHeapTypeObject</name></expr></argument>, <argument><expr><name>as_sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>offset</name> &gt;= <call><name>offsetof</name><argument_list>(<argument><expr><name>PyHeapTypeObject</name></expr></argument>, <argument><expr><name>as_mapping</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ptr</name> = (<name>char</name> *)<name><name>type</name>-&gt;<name>tp_as_mapping</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> -= <call><name>offsetof</name><argument_list>(<argument><expr><name>PyHeapTypeObject</name></expr></argument>, <argument><expr><name>as_mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>offset</name> &gt;= <call><name>offsetof</name><argument_list>(<argument><expr><name>PyHeapTypeObject</name></expr></argument>, <argument><expr><name>as_number</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ptr</name> = (<name>char</name> *)<name><name>type</name>-&gt;<name>tp_as_number</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> -= <call><name>offsetof</name><argument_list>(<argument><expr><name>PyHeapTypeObject</name></expr></argument>, <argument><expr><name>as_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>ptr</name> = (<name>char</name> *)<name>type</name></expr>;</expr_stmt>
	}</block></else></if></else></if></else></if>
	<if>if <condition>(<expr><name>ptr</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>ptr</name> += <name>offset</name></expr>;</expr_stmt></then></if>
	<return>return <expr>(<name>void</name> **)<name>ptr</name></expr>;</return>
}</block></function>

<comment type="block">/* Length of array of slotdef pointers used to store slots with the
   same __name__.  There should be at most MAX_EQUIV-1 slotdef entries with
   the same __name__, for any __name__. Since that's a static property, it is
   appropriate to declare fixed-size arrays for this. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_EQUIV</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/* Return a slot pointer for a given name, but ONLY if the attribute has
   exactly one slot function.  The name must be an interned string. */</comment>
<function><type><specifier>static</specifier> <name>void</name> **</type>
<name>resolve_slotdups</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX Maybe this could be optimized more -- but is it worth it? */</comment>

	<comment type="block">/* pname and ptrs act as a little cache */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>pname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>slotdef</name> *</type><name><name>ptrs</name><index>[<expr><name>MAX_EQUIV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slotdef</name> *</type><name>p</name></decl>, **<decl><type ref="prev"/><name>pp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> **</type><name>res</name></decl>, **<decl><type ref="prev"/><name>ptr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>pname</name> != <name>name</name></expr>)</condition><then> <block>{
		<comment type="block">/* Collect all slotdefs that match name into ptrs. */</comment>
		<expr_stmt><expr><name>pname</name> = <name>name</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pp</name> = <name>ptrs</name></expr>;</expr_stmt>
		<for>for (<init><expr><name>p</name> = <name>slotdefs</name></expr>;</init> <condition><expr><name><name>p</name>-&gt;<name>name_strobj</name></name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><name><name>p</name>-&gt;<name>name_strobj</name></name> == <name>name</name></expr>)</condition><then>
				<expr_stmt><expr>*<name>pp</name>++ = <name>p</name></expr>;</expr_stmt></then></if>
		}</block></for>
		<expr_stmt><expr>*<name>pp</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Look in all matching slots of the type; if exactly one of these has
	   a filled-in slot, return its value.	Otherwise return NULL. */</comment>
	<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>pp</name> = <name>ptrs</name></expr>;</init> <condition><expr>*<name>pp</name></expr>;</condition> <incr><expr><name>pp</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>ptr</name> = <call><name>slotptr</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>(*<name>pp</name>)-&gt;<name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ptr</name> == <name>NULL</name> || *<name>ptr</name> == <name>NULL</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>res</name> = <name>ptr</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* Common code for update_slots_callback() and fixup_slot_dispatchers().  This
   does some incredibly complex thinking and then sticks something into the
   slot.  (It sees if the adjacent slotdefs for the same slot have conflicting
   interests, and then stores a generic wrapper or a specific function into
   the slot.)  Return a pointer to the next slotdef with a different offset,
   because that's convenient  for fixup_slot_dispatchers(). */</comment>
<function><type><specifier>static</specifier> <name>slotdef</name> *</type>
<name>update_one_slot</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>slotdef</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyWrapperDescrObject</name> *</type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> *</type><name>generic</name> <init>= <expr><name>NULL</name></expr></init>, *<name>specific</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>use_generic</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name><name>p</name>-&gt;<name>offset</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> **</type><name>ptr</name> <init>= <expr><call><name>slotptr</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ptr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<do>do <block>{
			<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
		}</block> while <condition>(<expr><name><name>p</name>-&gt;<name>offset</name></name> == <name>offset</name></expr>)</condition>;</do>
		<return>return <expr><name>p</name></expr>;</return>
	}</block></then></if>
	<do>do <block>{
		<expr_stmt><expr><name>descr</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>name_strobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call> == &amp;<name>PyWrapperDescr_Type</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>void</name> **</type><name>tptr</name> <init>= <expr><call><name>resolve_slotdups</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>name_strobj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>tptr</name> == <name>NULL</name> || <name>tptr</name> == <name>ptr</name></expr>)</condition><then>
				<expr_stmt><expr><name>generic</name> = <name><name>p</name>-&gt;<name>function</name></name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>d</name> = (<name>PyWrapperDescrObject</name> *)<name>descr</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>d</name>-&gt;<name>d_base</name>-&gt;<name>wrapper</name></name> == <name><name>p</name>-&gt;<name>wrapper</name></name> &amp;&amp;
			    <call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>d_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<block>{
				<if>if <condition>(<expr><name>specific</name> == <name>NULL</name> ||
				    <name>specific</name> == <name><name>d</name>-&gt;<name>d_wrapped</name></name></expr>)</condition><then>
					<expr_stmt><expr><name>specific</name> = <name><name>d</name>-&gt;<name>d_wrapped</name></name></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>use_generic</name> = 1</expr>;</expr_stmt></else></if>
			}</block></then></if>
		}</block></then>
		<else>else <if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call> == &amp;<name>PyCFunction_Type</name> &amp;&amp;
			 <call><name>PyCFunction_GET_FUNCTION</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call> ==
			 (<name>PyCFunction</name>)<name>tp_new_wrapper</name> &amp;&amp;
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"__new__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<block>{
			<comment type="block">/* The __new__ wrapper is not a wrapper descriptor,
			   so must be special-cased differently.
			   If we don't do this, creating an instance will
			   always use slot_tp_new which will look up
			   __new__ in the MRO which will call tp_new_wrapper
			   which will look through the base classes looking
			   for a static base and call its tp_new (usually
			   PyType_GenericNew), after performing various
			   sanity checks and constructing a new argument
			   list.  Cut all that nonsense short -- this speeds
			   up instance creation tremendously. */</comment>
			<expr_stmt><expr><name>specific</name> = (<name>void</name> *)<name><name>type</name>-&gt;<name>tp_new</name></name></expr>;</expr_stmt>
			<comment type="block">/* XXX I'm not 100% sure that there isn't a hole
			   in this reasoning that requires additional
			   sanity checks.  I'll buy the first person to
			   point out a bug in this reasoning a beer. */</comment>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>descr</name> == <name>Py_None</name> &amp;&amp;
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"__hash__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<comment type="block">/* We specifically allow __hash__ to be set to None
			   to prevent inheritance of the default
			   implementation from object.__hash__ */</comment>
			<expr_stmt><expr><name>specific</name> = <name>PyObject_HashNotImplemented</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>use_generic</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>generic</name> = <name><name>p</name>-&gt;<name>function</name></name></expr>;</expr_stmt>
		}</block></else></if></else></if></else></if>
	}</block> while <condition>(<expr>(++<name>p</name>)-&gt;<name>offset</name> == <name>offset</name></expr>)</condition>;</do>
	<if>if <condition>(<expr><name>specific</name> &amp;&amp; !<name>use_generic</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ptr</name> = <name>specific</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr>*<name>ptr</name> = <name>generic</name></expr>;</expr_stmt></else></if>
	<return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/* In the type, update the slots whose slotdefs are gathered in the pp array.
   This is a callback for update_subclasses(). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>update_slots_callback</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>slotdef</name> **</type><name>pp</name> <init>= <expr>(<name>slotdef</name> **)<name>data</name></expr></init></decl>;</decl_stmt>

	<for>for (<init>;</init> <condition><expr>*<name>pp</name></expr>;</condition> <incr><expr><name>pp</name>++</expr></incr>)
		<expr_stmt><expr><call><name>update_one_slot</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>*<name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Comparison function for qsort() to compare slotdefs by their offset, and
   for equal offset by their address (to force a stable sort). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>slotdef_cmp</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>aa</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>slotdef</name> *</type><name>a</name> <init>= <expr>(const <name>slotdef</name> *)<name>aa</name></expr></init>, *<name>b</name> <init>= <expr>(const <name>slotdef</name> *)<name>bb</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>a</name>-&gt;<name>offset</name></name> - <name><name>b</name>-&gt;<name>offset</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>c</name> != 0</expr>)</condition><then>
		<return>return <expr><name>c</name></expr>;</return></then>
	<else>else
		<comment type="block">/* Cannot use a-b, as this gives off_t, 
		   which may lose precision when converted to int. */</comment>
		<return>return <expr>(<name>a</name> &gt; <name>b</name>) ? 1 : (<name>a</name> &lt; <name>b</name>) ? -1 : 0</expr>;</return></else></if>
}</block></function>

<comment type="block">/* Initialize the slotdefs table by adding interned string objects for the
   names and sorting the entries. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_slotdefs</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>slotdef</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>initialized</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<for>for (<init><expr><name>p</name> = <name>slotdefs</name></expr>;</init> <condition><expr><name><name>p</name>-&gt;<name>name</name></name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name><name>p</name>-&gt;<name>name_strobj</name></name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name><name>p</name>-&gt;<name>name_strobj</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Out of memory interning slotdef names"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr>(<name>void</name> *)<name>slotdefs</name></expr></argument>, <argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>p</name>-<name>slotdefs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>slotdef</name></expr></argument>)</argument_list></sizeof></expr></argument>,
	      <argument><expr><name>slotdef_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Update the slots after assignment to a class (type) attribute. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>update_slot</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>slotdef</name> *</type><name><name>ptrs</name><index>[<expr><name>MAX_EQUIV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slotdef</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slotdef</name> **</type><name>pp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>

	<comment type="block">/* Clear the VALID_VERSION flag of 'type' and all its
	   subclasses.  This could possibly be unified with the
	   update_subclasses() recursion below, but carefully:
	   they each have their own conditions on which to stop
	   recursing into subclasses. */</comment>
	<expr_stmt><expr><call><name>PyType_Modified</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_slotdefs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pp</name> = <name>ptrs</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>slotdefs</name></expr>;</init> <condition><expr><name><name>p</name>-&gt;<name>name</name></name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
		<comment type="block">/* XXX assume name is interned! */</comment>
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>name_strobj</name></name> == <name>name</name></expr>)</condition><then>
			<expr_stmt><expr>*<name>pp</name>++ = <name>p</name></expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr>*<name>pp</name> = <name>NULL</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>pp</name> = <name>ptrs</name></expr>;</init> <condition><expr>*<name>pp</name></expr>;</condition> <incr><expr><name>pp</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>p</name> = *<name>pp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> = <name><name>p</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>p</name> &gt; <name>slotdefs</name> &amp;&amp; (<name>p</name>-1)-&gt;<name>offset</name> == <name>offset</name></expr>)</condition>
			<expr_stmt><expr>--<name>p</name></expr>;</expr_stmt></while>
		<expr_stmt><expr>*<name>pp</name> = <name>p</name></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr><name><name>ptrs</name><index>[<expr>0</expr>]</index></name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if> <comment type="block">/* Not an attribute that affects any slots */</comment>
	<return>return <expr><call><name>update_subclasses</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
				 <argument><expr><name>update_slots_callback</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>ptrs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Store the proper functions in the slot dispatches at class (type)
   definition time, based upon which operations the class overrides in its
   dict. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fixup_slot_dispatchers</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>slotdef</name> *</type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_slotdefs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>slotdefs</name></expr>;</init> <condition><expr><name><name>p</name>-&gt;<name>name</name></name></expr>;</condition> <incr/>)
		<expr_stmt><expr><name>p</name> = <call><name>update_one_slot</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_all_slots</name><parameter_list>(<param><decl><type><name>PyTypeObject</name>*</type> <name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>slotdef</name> *</type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_slotdefs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>slotdefs</name></expr>;</init> <condition><expr><name><name>p</name>-&gt;<name>name</name></name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
		<comment type="block">/* update_slot returns int but can't actually fail */</comment>
		<expr_stmt><expr><call><name>update_slot</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>name_strobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
}</block></function>

<comment type="block">/* recurse_down_subclasses() and update_subclasses() are mutually
   recursive functions to call a callback for all subclasses,
   but refraining from recursing into subclasses that define 'name'. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>update_subclasses</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>,
		  <param><decl><type><name>update_callback</name></type> <name>callback</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>callback</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<return>return <expr><call><name>recurse_down_subclasses</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>recurse_down_subclasses</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>,
			<param><decl><type><name>update_callback</name></type> <name>callback</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>subclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ref</name></decl>, *<decl><type ref="prev"/><name>subclasses</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>subclasses</name> = <name><name>type</name>-&gt;<name>tp_subclasses</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>subclasses</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>subclasses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>subclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>ref</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>subclasses</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyWeakref_CheckRef</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subclass</name> = (<name>PyTypeObject</name> *)<call><name>PyWeakref_GET_OBJECT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>subclass</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>PyObject</name> *)<name>subclass</name> == <name>Py_None</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>subclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Avoid recursing down into unaffected classes */</comment>
		<expr_stmt><expr><name>dict</name> = <name><name>subclass</name>-&gt;<name>tp_dict</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dict</name> != <name>NULL</name> &amp;&amp; <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call> &amp;&amp;
		    <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr><call><name>update_subclasses</name><argument_list>(<argument><expr><name>subclass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* This function is called by PyType_Ready() to populate the type's
   dictionary with method descriptors for function slots.  For each
   function slot (like tp_repr) that's defined in the type, one or more
   corresponding descriptors are added in the type's tp_dict dictionary
   under the appropriate name (like __repr__).	Some function slots
   cause more than one descriptor to be added (for example, the nb_add
   slot adds both __add__ and __radd__ descriptors) and some function
   slots compete for the same descriptor (for example both sq_item and
   mp_subscript generate a __getitem__ descriptor).

   In the latter case, the first slotdef entry encoutered wins.	 Since
   slotdef entries are sorted by the offset of the slot in the
   PyHeapTypeObject, this gives us some control over disambiguating
   between competing slots: the members of PyHeapTypeObject are listed
   from most general to least general, so the most general slot is
   preferred.  In particular, because as_mapping comes before as_sequence,
   for a type that defines both mp_subscript and sq_item, mp_subscript
   wins.

   This only adds new descriptors and doesn't overwrite entries in
   tp_dict that were previously defined.  The descriptors contain a
   reference to the C function they must call, so that it's safe if they
   are copied into a subtype's __dict__ and the subtype has a different
   C function in its slot -- calling the method defined by the
   descriptor will call the C function that was used to create it,
   rather than the C function present in the slot when it is called.
   (This is important because a subtype may have a C function in the
   slot that calls the method from the dictionary, and we want to avoid
   infinite recursion here.) */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_operators</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slotdef</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> **</type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_slotdefs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>slotdefs</name></expr>;</init> <condition><expr><name><name>p</name>-&gt;<name>name</name></name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>wrapper</name></name> == <name>NULL</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><name>ptr</name> = <call><name>slotptr</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>ptr</name> || !*<name>ptr</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>name_strobj</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr>*<name>ptr</name> == <name>PyObject_HashNotImplemented</name></expr>)</condition><then> <block>{
			<comment type="block">/* Classes may prevent the inheritance of the tp_hash
			   slot by storing PyObject_HashNotImplemented in it. Make it
 			   visible as a None value for the __hash__ attribute. */</comment>
			<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>name_strobj</name></name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>descr</name> = <call><name>PyDescr_NewWrapper</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>name_strobj</name></name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></for>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_new</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>add_tp_new_wrapper</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Cooperative 'super' */</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyTypeObject</name> *</type><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>obj_type</name></decl>;</decl_stmt>
}</block></struct></type> <name>superobject</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>super_members</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__thisclass__"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>superobject</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
	 <expr>"the class invoking super()"</expr>}</block></expr>,
	<expr><block>{<expr>"__self__"</expr>,  <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>superobject</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
	 <expr>"the instance invoking super(); may be None"</expr>}</block></expr>,
	<expr><block>{<expr>"__self_class__"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>superobject</name></expr></argument>, <argument><expr><name>obj_type</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
	 <expr>"the type of the instance invoking super(); may be None"</expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>super_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>superobject</name> *</type><name>su</name> <init>= <expr>(<name>superobject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>su</name>-&gt;<name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>su</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>su</name>-&gt;<name>obj_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>super_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>superobject</name> *</type><name>su</name> <init>= <expr>(<name>superobject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>su</name>-&gt;<name>obj_type</name></name></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(
			<argument><expr>"&lt;super: &lt;class '%s'&gt;, &lt;%s object&gt;&gt;"</expr></argument>,
			<argument><expr><name><name>su</name>-&gt;<name>type</name></name> ? <name><name>su</name>-&gt;<name>type</name>-&gt;<name>tp_name</name></name> : "NULL"</expr></argument>,
			<argument><expr><name><name>su</name>-&gt;<name>obj_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(
			<argument><expr>"&lt;super: &lt;class '%s'&gt;, NULL&gt;"</expr></argument>,
			<argument><expr><name><name>su</name>-&gt;<name>type</name></name> ? <name><name>su</name>-&gt;<name>type</name>-&gt;<name>tp_name</name></name> : "NULL"</expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>super_getattro</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>superobject</name> *</type><name>su</name> <init>= <expr>(<name>superobject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>skip</name> <init>= <expr><name><name>su</name>-&gt;<name>obj_type</name></name> == <name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>skip</name></expr>)</condition><then> <block>{
		<comment type="block">/* We want __class__ to return the class of the super object
		   (i.e. super, or a subclass), not the class of su-&gt;obj. */</comment>
		<expr_stmt><expr><name>skip</name> = (<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> &amp;&amp;
			<call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> == 9 &amp;&amp;
			<call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call> == 0)</expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr>!<name>skip</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>mro</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>starttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>f</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>starttype</name> = <name><name>su</name>-&gt;<name>obj_type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mro</name> = <name><name>starttype</name>-&gt;<name>tp_mro</name></name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>mro</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>mro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><name><name>su</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call> == <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>mro</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<break>break;</break></then></if>
		}</block></for>
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt>
		<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>tmp</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>mro</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>dict</name> = ((<name>PyTypeObject</name> *)<name>tmp</name>)-&gt;<name>tp_dict</name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>dict</name> = ((<name>PyClassObject</name> *)<name>tmp</name>)-&gt;<name>cl_dict</name></expr>;</expr_stmt></then>
			<else>else
				<continue>continue;</continue></else></if></else></if>
			<expr_stmt><expr><name>res</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>f</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>-&gt;<name>tp_descr_get</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>tmp</name> = <call><name>f</name><argument_list>(<argument><expr><name>res</name></expr></argument>,
						<comment type="block">/* Only pass 'obj' param if
						   this is instance-mode super 
						   (See SF ID #743627)
						*/</comment>
						<argument><expr>(<name><name>su</name>-&gt;<name>obj</name></name> == (<name>PyObject</name> *)
							    <name><name>su</name>-&gt;<name>obj_type</name></name> 
							? (<name>PyObject</name> *)<name>NULL</name> 
							: <name><name>su</name>-&gt;<name>obj</name></name>)</expr></argument>,
						<argument><expr>(<name>PyObject</name> *)<name>starttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>res</name> = <name>tmp</name></expr>;</expr_stmt>
				}</block></then></if>
				<return>return <expr><name>res</name></expr>;</return>
			}</block></then></if>
		}</block></for>
	}</block></then></if>
	<return>return <expr><call><name>PyObject_GenericGetAttr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyTypeObject</name> *</type>
<name>supercheck</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Check that a super() call makes sense.  Return a type object.

	   obj can be a new-style class, or an instance of one:

	   - If it is a class, it must be a subclass of 'type'.	 This case is
	     used for class methods; the return value is obj.

	   - If it is an instance, it must be an instance of 'type'.  This is
	     the normal case; the return value is obj.__class__.

	   But... when obj is an instance, we want to allow for the case where
	   Py_TYPE(obj) is not a subclass of type, but obj.__class__ is!
	   This will allow using super() with a proxy for obj.
	*/</comment>

	<comment type="block">/* Check for first bullet above (special case) */</comment>
	<if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyType_IsSubtype</name><argument_list>(<argument><expr>(<name>PyTypeObject</name> *)<name>obj</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyTypeObject</name> *)<name>obj</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Normal case */</comment>
	<if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Try the slow way */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>class_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>class_attr</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>class_str</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>class_str</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"__class__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>class_str</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></then></if>

		<expr_stmt><expr><name>class_attr</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>class_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>class_attr</name> != <name>NULL</name> &amp;&amp;
		    <call><name>PyType_Check</name><argument_list>(<argument><expr><name>class_attr</name></expr></argument>)</argument_list></call> &amp;&amp;
		    (<name>PyTypeObject</name> *)<name>class_attr</name> != <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<block>{
			<decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><call><name>PyType_IsSubtype</name><argument_list>(
				<argument><expr>(<name>PyTypeObject</name> *)<name>class_attr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
				<return>return <expr>(<name>PyTypeObject</name> *)<name>class_attr</name></expr>;</return></then></if>
		}</block></then></if>

		<if>if <condition>(<expr><name>class_attr</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>class_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></else></if>

	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"super(type, obj): "
			"obj must be an instance or subtype of type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>super_descr_get</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>superobject</name> *</type><name>su</name> <init>= <expr>(<name>superobject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>superobject</name> *</type><name>newobj</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>obj</name> == <name>NULL</name> || <name>obj</name> == <name>Py_None</name> || <name><name>su</name>-&gt;<name>obj</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Not binding to an object, or already bound */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>self</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call> != &amp;<name>PySuper_Type</name></expr>)</condition><then>
		<comment type="block">/* If su is an instance of a (strict) subclass of super,
		   call its type */</comment>
		<return>return <expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr></argument>,
						    <argument><expr><name><name>su</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <block>{
		<comment type="block">/* Inline the common case */</comment>
		<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>obj_type</name> <init>= <expr><call><name>supercheck</name><argument_list>(<argument><expr><name><name>su</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>obj_type</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>newobj</name> = (<name>superobject</name> *)<call><name><name>PySuper_Type</name>.<name>tp_new</name></name><argument_list>(<argument><expr>&amp;<name>PySuper_Type</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>su</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newobj</name>-&gt;<name>type</name></name> = <name><name>su</name>-&gt;<name>type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newobj</name>-&gt;<name>obj</name></name> = <name>obj</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newobj</name>-&gt;<name>obj_type</name></name> = <name>obj_type</name></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>newobj</name></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>super_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>superobject</name> *</type><name>su</name> <init>= <expr>(<name>superobject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>obj_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"super"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!|O:super"</expr></argument>, <argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>obj</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>obj</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>obj</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>obj_type</name> = <call><name>supercheck</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>obj_type</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>su</name>-&gt;<name>type</name></name> = <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>su</name>-&gt;<name>obj</name></name> = <name>obj</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>su</name>-&gt;<name>obj_type</name></name> = <name>obj_type</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>super_doc</name></expr></argument>,
<argument><expr>"super(type) -&gt; unbound super object\n"
"super(type, obj) -&gt; bound super object; requires isinstance(obj, type)\n"
"super(type, type2) -&gt; bound super object; requires issubclass(type2, type)\n"
"Typical use to call a cooperative superclass method:\n"
"class C(B):\n"
"    def meth(self, arg):\n"
"	 super(C, self).meth(arg)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>super_traverse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>superobject</name> *</type><name>su</name> <init>= <expr>(<name>superobject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>su</name>-&gt;<name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>su</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>su</name>-&gt;<name>obj_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PySuper_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"super"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>superobject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr><name>super_dealloc</name></expr>,				<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr><name>super_repr</name></expr>,				<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>super_getattro</name></expr>,				<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
		<name>Py_TPFLAGS_BASETYPE</name></expr>,		<comment type="block">/* tp_flags */</comment>
	<expr><name>super_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr><name>super_traverse</name></expr>,				<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr><name>super_members</name></expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr><name>super_descr_get</name></expr>,			<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr><name>super_init</name></expr>,				<comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,			<comment type="block">/* tp_alloc */</comment>
	<expr><name>PyType_GenericNew</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_GC_Del</name></expr>,			<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>
</unit>
