<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/setobject.c">
<comment type="block">/* set object implementation 
   Written and maintained by Raymond D. Hettinger &lt;python@rcn.com&gt;
   Derived from Lib/sets.py and Objects/dictobject.c.

   Copyright (c) 2003-2007 Python Software Foundation.
   All rights reserved.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<comment type="block">/* Set a key error with the specified argument, wrapping it in a
 * tuple automatically so that tuple keys are not unpacked as the
 * exception arguments. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_key_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tup</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>tup</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>tup</name></expr>)</condition><then>
		<return>return;</return></then></if> <comment type="block">/* caller will expect error to be set anyway */</comment>
	<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* This must be &gt;= 1. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PERTURB_SHIFT</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/* Object used as dummy key to fill deleted entries */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>dummy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Initialized by first call to make_new_set() */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_REF_DEBUG</name></cpp:ifdef>
<function><type><name>PyObject</name> *</type>
<name>_PySet_Dummy</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>dummy</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_NONZERO_SET_SLOTS</name><parameter_list>(<param><type><name>so</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {				\
	(so)-&gt;table = (so)-&gt;smalltable;				\
	(so)-&gt;mask = PySet_MINSIZE - 1;				\
	(so)-&gt;hash = -1;					\
    } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY_TO_MINSIZE</name><parameter_list>(<param><type><name>so</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {				\
	memset((so)-&gt;smalltable, 0, sizeof((so)-&gt;smalltable));	\
	(so)-&gt;used = (so)-&gt;fill = 0;				\
	INIT_NONZERO_SET_SLOTS(so);				\
    } while(0)</cpp:value></cpp:define>

<comment type="block">/* Reuse scheme to save calls to malloc, free, and memset */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PySet_MAXFREELIST</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySet_MAXFREELIST</name></cpp:macro> <cpp:value>80</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PySetObject</name> *</type><name><name>free_list</name><index>[<expr><name>PySet_MAXFREELIST</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>numfree</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/*
The basic lookup function used by all operations.
This is based on Algorithm D from Knuth Vol. 3, Sec. 6.4.
Open addressing is preferred over chaining since the link overhead for
chaining would be substantial (100% with typical malloc overhead).

The initial probe index is computed as hash mod the table size. Subsequent
probe indices are computed as explained in Objects/dictobject.c.

All arithmetic on hash should ignore overflow.

Unlike the dictionary implementation, the lookkey functions can return
NULL if the rich comparison returns an error.
*/</comment>

<function><type><specifier>static</specifier> <name>setentry</name> *</type>
<name>set_lookkey</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>register</name> <name>long</name></type> <name>hash</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>perturb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>freeslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>mask</name> <init>= <expr><name><name>so</name>-&gt;<name>mask</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>table</name> <init>= <expr><name><name>so</name>-&gt;<name>table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>startkey</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = <name>hash</name> &amp; <name>mask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> = &amp;<name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name> || <name><name>entry</name>-&gt;<name>key</name></name> == <name>key</name></expr>)</condition><then>
		<return>return <expr><name>entry</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name></expr>)</condition><then>
		<expr_stmt><expr><name>freeslot</name> = <name>entry</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>hash</name></name> == <name>hash</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>startkey</name> = <name><name>entry</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<if>if <condition>(<expr><name>table</name> == <name><name>so</name>-&gt;<name>table</name></name> &amp;&amp; <name><name>entry</name>-&gt;<name>key</name></name> == <name>startkey</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
					<return>return <expr><name>entry</name></expr>;</return></then></if>
			}</block></then>
			<else>else <block>{
				<comment type="block">/* The compare did major nasty stuff to the
				 * set:  start over.
 				 */</comment>
 				<return>return <expr><call><name>set_lookkey</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
 			}</block></else></if>
		}</block></then></if>
		<expr_stmt><expr><name>freeslot</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* In the loop, key == dummy is by far (factor of 100s) the
	   least likely outcome, so test for that last. */</comment>
	<for>for (<init><expr><name>perturb</name> = <name>hash</name></expr>;</init> <condition>;</condition> <incr><expr><name>perturb</name> &gt;&gt;= <name>PERTURB_SHIFT</name></expr></incr>) <block>{
		<expr_stmt><expr><name>i</name> = (<name>i</name> &lt;&lt; 2) + <name>i</name> + <name>perturb</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>entry</name> = &amp;<name><name>table</name><index>[<expr><name>i</name> &amp; <name>mask</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>freeslot</name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>entry</name> = <name>freeslot</name></expr>;</expr_stmt></then></if>
			<break>break;</break>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>key</name></expr>)</condition><then>
			<break>break;</break></then></if>
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>hash</name></name> == <name>hash</name> &amp;&amp; <name><name>entry</name>-&gt;<name>key</name></name> != <name>dummy</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>startkey</name> = <name><name>entry</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<if>if <condition>(<expr><name>table</name> == <name><name>so</name>-&gt;<name>table</name></name> &amp;&amp; <name><name>entry</name>-&gt;<name>key</name></name> == <name>startkey</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></then>
			<else>else <block>{
				<comment type="block">/* The compare did major nasty stuff to the
				 * set:  start over.
 				 */</comment>
 				<return>return <expr><call><name>set_lookkey</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
 			}</block></else></if>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name> &amp;&amp; <name>freeslot</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>freeslot</name> = <name>entry</name></expr>;</expr_stmt></then></if></else></if>
	}</block></for>
	<return>return <expr><name>entry</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Hacked up version of set_lookkey which can assume keys are always strings;
 * This means we can always use _PyString_Eq directly and not have to check to
 * see if the comparison altered the table.
 */</comment>
<function><type><specifier>static</specifier> <name>setentry</name> *</type>
<name>set_lookkey_string</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>register</name> <name>long</name></type> <name>hash</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>perturb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>freeslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>mask</name> <init>= <expr><name><name>so</name>-&gt;<name>mask</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>table</name> <init>= <expr><name><name>so</name>-&gt;<name>table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure this function doesn't have to handle non-string keys,
	   including subclasses of str; e.g., one reason to subclass
	   strings is to override __eq__, and for speed we don't cater to
	   that here. */</comment>
	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>so</name>-&gt;<name>lookup</name></name> = <name>set_lookkey</name></expr>;</expr_stmt>
		<return>return <expr><call><name>set_lookkey</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>i</name> = <name>hash</name> &amp; <name>mask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> = &amp;<name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name> || <name><name>entry</name>-&gt;<name>key</name></name> == <name>key</name></expr>)</condition><then>
		<return>return <expr><name>entry</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name></expr>)</condition><then>
		<expr_stmt><expr><name>freeslot</name> = <name>entry</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>hash</name></name> == <name>hash</name> &amp;&amp; <call><name>_PyString_Eq</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>entry</name></expr>;</return></then></if>
		<expr_stmt><expr><name>freeslot</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* In the loop, key == dummy is by far (factor of 100s) the
	   least likely outcome, so test for that last. */</comment>
	<for>for (<init><expr><name>perturb</name> = <name>hash</name></expr>;</init> <condition>;</condition> <incr><expr><name>perturb</name> &gt;&gt;= <name>PERTURB_SHIFT</name></expr></incr>) <block>{
		<expr_stmt><expr><name>i</name> = (<name>i</name> &lt;&lt; 2) + <name>i</name> + <name>perturb</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>entry</name> = &amp;<name><name>table</name><index>[<expr><name>i</name> &amp; <name>mask</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>freeslot</name> == <name>NULL</name> ? <name>entry</name> : <name>freeslot</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>key</name>
		    || (<name><name>entry</name>-&gt;<name>hash</name></name> == <name>hash</name>
			&amp;&amp; <name><name>entry</name>-&gt;<name>key</name></name> != <name>dummy</name>
			&amp;&amp; <call><name>_PyString_Eq</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
			<return>return <expr><name>entry</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name> &amp;&amp; <name>freeslot</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>freeslot</name> = <name>entry</name></expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* NOT REACHED */</comment>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
Internal routine to insert a new key into the table.
Used by the public insert routine.
Eats a reference to key.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_insert_key</name><parameter_list>(<param><decl><type><name>register</name> <name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>long</name></type> <name>hash</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<typedef>typedef <function_decl><type><name>setentry</name> *</type>(*<name>lookupfunc</name>)<parameter_list>(<param><decl><type><name>PySetObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>long</name></type></decl></param>)</parameter_list>;</function_decl></typedef>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>so</name>-&gt;<name>lookup</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> = <call><name><name>so</name>-&gt;<name>lookup</name></name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>entry</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* UNUSED */</comment>
		<expr_stmt><expr><name><name>so</name>-&gt;<name>fill</name></name>++</expr>;</expr_stmt> 
		<expr_stmt><expr><name><name>entry</name>-&gt;<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name>-&gt;<name>hash</name></name> = <name>hash</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name>-&gt;<name>used</name></name>++</expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name></expr>)</condition><then> <block>{
		<comment type="block">/* DUMMY */</comment>
		<expr_stmt><expr><name><name>entry</name>-&gt;<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name>-&gt;<name>hash</name></name> = <name>hash</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name>-&gt;<name>used</name></name>++</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<comment type="block">/* ACTIVE */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
Internal routine used by set_table_resize() to insert an item which is
known to be absent from the set.  This routine also assumes that
the set contains no deleted entries.  Besides the performance benefit,
using set_insert_clean() in set_table_resize() is dangerous (SF bug #1456209).
Note that no refcounts are changed by this routine; if needed, the caller
is responsible for incref'ing `key`.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_insert_clean</name><parameter_list>(<param><decl><type><name>register</name> <name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>long</name></type> <name>hash</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>perturb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>mask</name> <init>= <expr>(<name>size_t</name>)<name><name>so</name>-&gt;<name>mask</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>table</name> <init>= <expr><name><name>so</name>-&gt;<name>table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = <name>hash</name> &amp; <name>mask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> = &amp;<name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>perturb</name> = <name>hash</name></expr>;</init> <condition><expr><name><name>entry</name>-&gt;<name>key</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>perturb</name> &gt;&gt;= <name>PERTURB_SHIFT</name></expr></incr>) <block>{
		<expr_stmt><expr><name>i</name> = (<name>i</name> &lt;&lt; 2) + <name>i</name> + <name>perturb</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>entry</name> = &amp;<name><name>table</name><index>[<expr><name>i</name> &amp; <name>mask</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>fill</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name>-&gt;<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name>-&gt;<name>hash</name></name> = <name>hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>used</name></name>++</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
Restructure the table by allocating a new table and reinserting all
keys again.  When entries have been deleted, the new table may
actually be smaller than the old one.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_table_resize</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>minused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>oldtable</name></decl>, *<decl><type ref="prev"/><name>newtable</name></decl>, *<decl><type ref="prev"/><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>is_oldtable_malloced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name></type> <name><name>small_copy</name><index>[<expr><name>PySet_MINSIZE</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>minused</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the smallest table size &gt; minused. */</comment>
	<for>for (<init><expr><name>newsize</name> = <name>PySet_MINSIZE</name></expr>;</init>
	     <condition><expr><name>newsize</name> &lt;= <name>minused</name> &amp;&amp; <name>newsize</name> &gt; 0</expr>;</condition>
	     <incr><expr><name>newsize</name> &lt;&lt;= 1</expr></incr>)
		<empty_stmt>;</empty_stmt></for>
	<if>if <condition>(<expr><name>newsize</name> &lt;= 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<comment type="block">/* Get space for a new table. */</comment>
	<expr_stmt><expr><name>oldtable</name> = <name><name>so</name>-&gt;<name>table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldtable</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_oldtable_malloced</name> = <name>oldtable</name> != <name><name>so</name>-&gt;<name>smalltable</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>newsize</name> == <name>PySet_MINSIZE</name></expr>)</condition><then> <block>{
		<comment type="block">/* A large table is shrinking, or we can't get any smaller. */</comment>
		<expr_stmt><expr><name>newtable</name> = <name><name>so</name>-&gt;<name>smalltable</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newtable</name> == <name>oldtable</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>so</name>-&gt;<name>fill</name></name> == <name><name>so</name>-&gt;<name>used</name></name></expr>)</condition><then> <block>{
				<comment type="block">/* No dummies, so no point doing anything. */</comment>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<comment type="block">/* We're not going to resize it, but rebuild the
			   table anyway to purge old dummy entries.
			   Subtle:  This is *necessary* if fill==size,
			   as set_lookkey needs at least one virgin slot to
			   terminate failing searches.  If fill &lt; size, it's
			   merely desirable, as dummies slow searches. */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>so</name>-&gt;<name>fill</name></name> &gt; <name><name>so</name>-&gt;<name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>small_copy</name></expr></argument>, <argument><expr><name>oldtable</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>small_copy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldtable</name> = <name>small_copy</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>newtable</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>setentry</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newtable</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></else></if>

	<comment type="block">/* Make the set empty, using the new table. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newtable</name> != <name>oldtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>table</name></name> = <name>newtable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>mask</name></name> = <name>newsize</name> - 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>newtable</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>setentry</name></expr></argument>)</argument_list></sizeof> * <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>used</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <name><name>so</name>-&gt;<name>fill</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>fill</name></name> = 0</expr>;</expr_stmt>

	<comment type="block">/* Copy the data over; this is refcount-neutral for active entries;
	   dummy entries aren't copied over, of course */</comment>
	<for>for (<init><expr><name>entry</name> = <name>oldtable</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>entry</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* UNUSED */</comment>
			<empty_stmt>;</empty_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name></expr>)</condition><then> <block>{
			<comment type="block">/* DUMMY */</comment>
			<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<comment type="block">/* ACTIVE */</comment>
			<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_insert_clean</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if></else></if>
	}</block></for>

	<if>if <condition>(<expr><name>is_oldtable_malloced</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>oldtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* CAUTION: set_add_key/entry() must guarantee it won't resize the table */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_add_entry</name><parameter_list>(<param><decl><type><name>register</name> <name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>setentry</name> *</type><name>entry</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>n_used</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>so</name>-&gt;<name>fill</name></name> &lt;= <name><name>so</name>-&gt;<name>mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* at least one empty slot */</comment>
	<expr_stmt><expr><name>n_used</name> = <name><name>so</name>-&gt;<name>used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>set_insert_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!(<name><name>so</name>-&gt;<name>used</name></name> &gt; <name>n_used</name> &amp;&amp; <name><name>so</name>-&gt;<name>fill</name></name>*3 &gt;= (<name><name>so</name>-&gt;<name>mask</name></name>+1)*2)</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>set_table_resize</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>so</name>-&gt;<name>used</name></name>&gt;50000 ? <name><name>so</name>-&gt;<name>used</name></name>*2 : <name><name>so</name>-&gt;<name>used</name></name>*4</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_add_key</name><parameter_list>(<param><decl><type><name>register</name> <name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>n_used</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>so</name>-&gt;<name>fill</name></name> &lt;= <name><name>so</name>-&gt;<name>mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* at least one empty slot */</comment>
	<expr_stmt><expr><name>n_used</name> = <name><name>so</name>-&gt;<name>used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>set_insert_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!(<name><name>so</name>-&gt;<name>used</name></name> &gt; <name>n_used</name> &amp;&amp; <name><name>so</name>-&gt;<name>fill</name></name>*3 &gt;= (<name><name>so</name>-&gt;<name>mask</name></name>+1)*2)</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>set_table_resize</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>so</name>-&gt;<name>used</name></name>&gt;50000 ? <name><name>so</name>-&gt;<name>used</name></name>*2 : <name><name>so</name>-&gt;<name>used</name></name>*4</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISCARD_NOTFOUND</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISCARD_FOUND</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_discard_entry</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>setentry</name> *</type><name>oldentry</name></decl></param>)</parameter_list>
<block>{	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_key</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entry</name> = <call>(<name><name>so</name>-&gt;<name>lookup</name></name>)<argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>oldentry</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>oldentry</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>entry</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name>  ||  <name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name></expr>)</condition><then>
		<return>return <expr><name>DISCARD_NOTFOUND</name></expr>;</return></then></if>
	<expr_stmt><expr><name>old_key</name> = <name><name>entry</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name>-&gt;<name>key</name></name> = <name>dummy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>used</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>DISCARD_FOUND</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_discard_key</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_key</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>entry</name> = <call>(<name><name>so</name>-&gt;<name>lookup</name></name>)<argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>entry</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name>  ||  <name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name></expr>)</condition><then>
		<return>return <expr><name>DISCARD_NOTFOUND</name></expr>;</return></then></if>
	<expr_stmt><expr><name>old_key</name> = <name><name>entry</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name>-&gt;<name>key</name></name> = <name>dummy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>used</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>DISCARD_FOUND</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_clear_internal</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>, *<decl><type ref="prev"/><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>table_is_malloced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fill</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name></type> <name><name>small_copy</name><index>[<expr><name>PySet_MINSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>n</name> = <name><name>so</name>-&gt;<name>mask</name></name> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>table</name> = <name><name>so</name>-&gt;<name>table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>table</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>table_is_malloced</name> = <name>table</name> != <name><name>so</name>-&gt;<name>smalltable</name></name></expr>;</expr_stmt>

	<comment type="block">/* This is delicate.  During the process of clearing the set,
	 * decrefs can cause the set to mutate.  To avoid fatal confusion
	 * (voice of experience), we have to make the set empty before
	 * clearing the slots, and never refer to anything via so-&gt;ref while
	 * clearing.
	 */</comment>
	<expr_stmt><expr><name>fill</name> = <name><name>so</name>-&gt;<name>fill</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>table_is_malloced</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>EMPTY_TO_MINSIZE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

	<else>else <if>if <condition>(<expr><name>fill</name> &gt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* It's a small table with something that needs to be cleared.
		 * Afraid the only safe way is to copy the set entries into
		 * another small table first.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>small_copy</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>small_copy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>table</name> = <name>small_copy</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EMPTY_TO_MINSIZE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<comment type="block">/* else it's a small table that's already empty */</comment>

	<comment type="block">/* Now we can finally clear things.  If C had refcounts, we could
	 * assert that the refcount on table is 1 now, i.e. that this function
	 * has unique access to it, so decref side-effects can't alter it.
	 */</comment>
	<for>for (<init><expr><name>entry</name> = <name>table</name></expr>;</init> <condition><expr><name>fill</name> &gt; 0</expr>;</condition> <incr><expr>++<name>entry</name></expr></incr>) <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &lt; <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr>--<name>fill</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
		<else>else
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></for>

	<if>if <condition>(<expr><name>table_is_malloced</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * Iterate over a set table.  Use like so:
 *
 *     Py_ssize_t pos;
 *     setentry *entry;
 *     pos = 0;   # important!  pos should not otherwise be changed by you
 *     while (set_next(yourset, &amp;pos, &amp;entry)) {
 *              Refer to borrowed reference in entry-&gt;key.
 *     }
 *
 * CAUTION:  In general, it isn't safe to use set_next in a loop that
 * mutates the table.  
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_next</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>pos_ptr</name></decl></param>, <param><decl><type><name>setentry</name> **</type><name>entry_ptr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>table</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = *<name>pos_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>table</name> = <name><name>so</name>-&gt;<name>table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = <name><name>so</name>-&gt;<name>mask</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> &lt;= <name>mask</name> &amp;&amp; (<name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> == <name>NULL</name> || <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> == <name>dummy</name>)</expr>)</condition>
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
	<expr_stmt><expr>*<name>pos_ptr</name> = <name>i</name>+1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &gt; <name>mask</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>entry_ptr</name> = &amp;<name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_dealloc</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fill</name> <init>= <expr><name><name>so</name>-&gt;<name>fill</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>Py_TRASHCAN_SAFE_BEGIN</name><argument_list>(<argument>so</argument>)</argument_list></macro>
	<if>if <condition>(<expr><name><name>so</name>-&gt;<name>weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<for>for (<init><expr><name>entry</name> = <name><name>so</name>-&gt;<name>table</name></name></expr>;</init> <condition><expr><name>fill</name> &gt; 0</expr>;</condition> <incr><expr><name>entry</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr>--<name>fill</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name><name>so</name>-&gt;<name>table</name></name> != <name><name>so</name>-&gt;<name>smalltable</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name><name>so</name>-&gt;<name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>numfree</name> &lt; <name>PySet_MAXFREELIST</name> &amp;&amp; <call><name>PyAnySet_CheckExact</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>free_list</name><index>[<expr><name>numfree</name>++</expr>]</index></name> = <name>so</name></expr>;</expr_stmt></then>
	<else>else 
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>Py_TRASHCAN_SAFE_END</name><argument_list>(<argument>so</argument>)</argument_list></macro>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_tp_print</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>emit</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>	<comment type="block">/* No separator emitted on first pass */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>separator</name> <init>= <expr>", "</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>Py_ReprEnter</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>so</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>status</name> != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>status</name></expr>;</return></then></if>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%s(...)"</expr></argument>, <argument><expr><name><name>so</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>        

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%s(["</expr></argument>, <argument><expr><name><name>so</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>fputs</name><parameter_list>(<param><decl><type><name>emit</name></type></decl></param>, <param><decl><type><name>fp</name></type></decl></param>)</parameter_list>;</function_decl>
		<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
		<name>emit</name> <init>= <expr><name>separator</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></while>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fputs</name><argument_list>(<argument><expr>"])"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>so</name></expr></argument>)</argument_list></decl>;</decl_stmt>        
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_repr</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>keys</name></decl>, *<decl><type ref="prev"/><name>result</name><init>=<expr><name>NULL</name></expr></init>, *<name>listrepr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>Py_ReprEnter</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>so</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>status</name> != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"%s(...)"</expr></argument>, <argument><expr><name><name>so</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>keys</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>keys</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>done</name>;</goto></then></if>
	<expr_stmt><expr><name>listrepr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>listrepr</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>done</name>;</goto></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"%s(%s)"</expr></argument>, <argument><expr><name><name>so</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>,
		<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>listrepr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>listrepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
	<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>set_len</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>((<name>PySetObject</name> *)<name>so</name>)-&gt;<name>used</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_merge</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>otherset</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySetObject</name> *</type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>otherset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>other</name> = (<name>PySetObject</name>*)<name>otherset</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>other</name> == <name>so</name> || <name><name>other</name>-&gt;<name>used</name></name> == 0</expr>)</condition><then>
		<comment type="block">/* a.update(a) or a.update({}); nothing to do */</comment>
		<return>return <expr>0</expr>;</return></then></if>
	<comment type="block">/* Do one big resize at the start, rather than
	 * incrementally resizing as we insert new keys.  Expect
	 * that there will be no (or few) overlapping keys.
	 */</comment>
	<if>if <condition>(<expr>(<name><name>so</name>-&gt;<name>fill</name></name> + <name><name>other</name>-&gt;<name>used</name></name>)*3 &gt;= (<name><name>so</name>-&gt;<name>mask</name></name>+1)*2</expr>)</condition><then> <block>{
	   <if>if <condition>(<expr><call><name>set_table_resize</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>(<name><name>so</name>-&gt;<name>used</name></name> + <name><name>other</name>-&gt;<name>used</name></name>)*2</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		   <return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name><name>other</name>-&gt;<name>mask</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>entry</name> = &amp;<name><name>other</name>-&gt;<name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> != <name>NULL</name> &amp;&amp; 
		    <name><name>entry</name>-&gt;<name>key</name></name> != <name>dummy</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>set_insert_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_contains_key</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>entry</name> = <call>(<name><name>so</name>-&gt;<name>lookup</name></name>)<argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>entry</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>key</name> = <name><name>entry</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
	<return>return <expr><name>key</name> != <name>NULL</name> &amp;&amp; <name>key</name> != <name>dummy</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_contains_entry</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>setentry</name> *</type><name>entry</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>lu_entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lu_entry</name> = <call>(<name><name>so</name>-&gt;<name>lookup</name></name>)<argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>lu_entry</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>key</name> = <name><name>lu_entry</name>-&gt;<name>key</name></name></expr>;</expr_stmt> 
	<return>return <expr><name>key</name> != <name>NULL</name> &amp;&amp; <name>key</name> != <name>dummy</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_pop</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>so</name>-&gt;<name>used</name></name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>, <argument><expr>"pop from an empty set"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Set entry to "the first" unused or dummy set entry.  We abuse
	 * the hash field of slot 0 to hold a search finger:
	 * If slot 0 has a value, use slot 0.
	 * Else slot 0 is being used to hold a search finger,
	 * and we use its hash value as the first index to look.
	 */</comment>
	<expr_stmt><expr><name>entry</name> = &amp;<name><name>so</name>-&gt;<name>table</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>key</name></name> == <name>NULL</name> || <name><name>entry</name>-&gt;<name>key</name></name> == <name>dummy</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name> = <name><name>entry</name>-&gt;<name>hash</name></name></expr>;</expr_stmt>
		<comment type="block">/* The hash field may be a real hash value, or it may be a
		 * legit search finger, or it may be a once-legit search
		 * finger that's out of bounds now because it wrapped around
		 * or the table shrunk -- simply make sure it's in bounds now.
		 */</comment>
		<if>if <condition>(<expr><name>i</name> &gt; <name><name>so</name>-&gt;<name>mask</name></name> || <name>i</name> &lt; 1</expr>)</condition><then>
			<expr_stmt><expr><name>i</name> = 1</expr>;</expr_stmt></then></if>	<comment type="block">/* skip slot 0 */</comment>
		<while>while <condition>(<expr>(<name>entry</name> = &amp;<name><name>so</name>-&gt;<name>table</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<name>key</name> == <name>NULL</name> || <name><name>entry</name>-&gt;<name>key</name></name>==<name>dummy</name></expr>)</condition> <block>{
			<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>i</name> &gt; <name><name>so</name>-&gt;<name>mask</name></name></expr>)</condition><then>
				<expr_stmt><expr><name>i</name> = 1</expr>;</expr_stmt></then></if>
		}</block></while>
	}</block></then></if>
	<expr_stmt><expr><name>key</name> = <name><name>entry</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name>-&gt;<name>key</name></name> = <name>dummy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>used</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>table</name><index>[<expr>0</expr>]</index></name>.<name>hash</name> = <name>i</name> + 1</expr>;</expr_stmt>  <comment type="block">/* next place to start */</comment>
	<return>return <expr><name>key</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pop_doc</name></expr></argument>, <argument><expr>"Remove and return an arbitrary set element.\n\
Raises KeyError if the set is empty."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_traverse</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>frozenset_hash</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySetObject</name> *</type><name>so</name> <init>= <expr>(<name>PySetObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>h</name></decl>, <decl><type ref="prev"/><name>hash</name> <init>= <expr>1927868237L</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>so</name>-&gt;<name>hash</name></name> != -1</expr>)</condition><then>
		<return>return <expr><name><name>so</name>-&gt;<name>hash</name></name></expr>;</return></then></if>

	<expr_stmt><expr><name>hash</name> *= <call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<comment type="block">/* Work to increase the bit dispersion for closely spaced hash
		   values.  The is important because some use cases have many 
		   combinations of a small number of elements with nearby 
		   hashes so that many distinct combinations collapse to only 
		   a handful of distinct hash values. */</comment>
		<expr_stmt><expr><name>h</name> = <name><name>entry</name>-&gt;<name>hash</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hash</name> ^= (<name>h</name> ^ (<name>h</name> &lt;&lt; 16) ^ 89869747L)  * 3644798167u</expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name>hash</name> = <name>hash</name> * 69069L + 907133923L</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
		<expr_stmt><expr><name>hash</name> = 590923713L</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>hash</name></name> = <name>hash</name></expr>;</expr_stmt>
	<return>return <expr><name>hash</name></expr>;</return>
}</block></function>

<comment type="block">/***** Set iterator type ***********************************************/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PySetObject</name> *</type><name>si_set</name></decl>;</decl_stmt> <comment type="block">/* Set to NULL when iterator is exhausted */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>si_used</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>si_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block></struct></type> <name>setiterobject</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setiter_dealloc</name><parameter_list>(<param><decl><type><name>setiterobject</name> *</type><name>si</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>si</name>-&gt;<name>si_set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>setiter_len</name><parameter_list>(<param><decl><type><name>setiterobject</name> *</type><name>si</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>si</name>-&gt;<name>si_set</name></name> != <name>NULL</name> &amp;&amp; <name><name>si</name>-&gt;<name>si_used</name></name> == <name><name>si</name>-&gt;<name>si_set</name>-&gt;<name>used</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>len</name> = <name><name>si</name>-&gt;<name>len</name></name></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>length_hint_doc</name></expr></argument>, <argument><expr>"Private method returning an estimate of len(list(it))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>setiter_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__length_hint__"</expr>, <expr>(<name>PyCFunction</name>)<name>setiter_len</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>length_hint_doc</name></expr>}</block></expr>,
 	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>setiter_iternext</name><parameter_list>(<param><decl><type><name>setiterobject</name> *</type><name>si</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PySetObject</name> *</type><name>so</name> <init>= <expr><name><name>si</name>-&gt;<name>si_set</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>so</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>si</name>-&gt;<name>si_used</name></name> != <name><name>so</name>-&gt;<name>used</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"Set changed size during iteration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>si</name>-&gt;<name>si_used</name></name> = -1</expr>;</expr_stmt> <comment type="block">/* Make this state sticky */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>i</name> = <name><name>si</name>-&gt;<name>si_pos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name>&gt;=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> = <name><name>so</name>-&gt;<name>table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = <name><name>so</name>-&gt;<name>mask</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> &lt;= <name>mask</name> &amp;&amp; (<name><name>entry</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> == <name>NULL</name> || <name><name>entry</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> == <name>dummy</name>)</expr>)</condition>
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
	<expr_stmt><expr><name><name>si</name>-&gt;<name>si_pos</name></name> = <name>i</name>+1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &gt; <name>mask</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><name><name>si</name>-&gt;<name>len</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><name>key</name> = <name><name>entry</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>key</name></expr>;</return>

<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name>-&gt;<name>si_set</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PySetIter_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"setiterator"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>setiterobject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>setiter_dealloc</name></expr>, 		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,			<comment type="block">/* tp_flags */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_doc */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr><name>PyObject_SelfIter</name></expr>,			<comment type="block">/* tp_iter */</comment>
	<expr>(<name>iternextfunc</name>)<name>setiter_iternext</name></expr>,		<comment type="block">/* tp_iternext */</comment>
	<expr><name>setiter_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_iter</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>setiterobject</name> *</type><name>si</name> <init>= <expr><call><name>PyObject_New</name><argument_list>(<argument><expr><name>setiterobject</name></expr></argument>, <argument><expr>&amp;<name>PySetIter_Type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>si</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name>-&gt;<name>si_set</name></name> = <name>so</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name>-&gt;<name>si_used</name></name> = <name><name>so</name>-&gt;<name>used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name>-&gt;<name>si_pos</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name>-&gt;<name>len</name></name> = <name><name>so</name>-&gt;<name>used</name></name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>si</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_update_internal</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>it</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>set_merge</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>dictsize</name> <init>= <expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Do one big resize at the start, rather than
		* incrementally resizing as we insert new keys.  Expect
		* that there will be no (or few) overlapping keys.
		*/</comment>
		<if>if <condition>(<expr><name>dictsize</name> == -1</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name><name>so</name>-&gt;<name>fill</name></name> + <name>dictsize</name>)*3 &gt;= (<name><name>so</name>-&gt;<name>mask</name></name>+1)*2</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>set_table_resize</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>(<name><name>so</name>-&gt;<name>used</name></name> + <name>dictsize</name>)*2</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<while>while <condition>(<expr><call><name>_PyDict_Next</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<decl_stmt><decl><type><name>setentry</name></type> <name>an_entry</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>an_entry</name>.<name>hash</name></name> = <name>hash</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>an_entry</name>.<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>set_add_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>an_entry</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></while>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<while>while <condition>(<expr>(<name>key</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
                <if>if <condition>(<expr><call><name>set_add_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
                }</block></then></if> 
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_update</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>set_update_internal</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></for>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>update_doc</name></expr></argument>, 
<argument><expr>"Update a set with the union of itself and others."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>make_new_set</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>iterable</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PySetObject</name> *</type><name>so</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>dummy</name> == <name>NULL</name></expr>)</condition><then> <block>{ <comment type="block">/* Auto-initialize dummy */</comment>
		<expr_stmt><expr><name>dummy</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"&lt;dummy key&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dummy</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<comment type="block">/* create PySetObject structure */</comment>
	<if>if <condition>(<expr><name>numfree</name> &amp;&amp;
	    (<name>type</name> == &amp;<name>PySet_Type</name>  ||  <name>type</name> == &amp;<name>PyFrozenSet_Type</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>so</name> = <name><name>free_list</name><index>[<expr>--<name>numfree</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>so</name> != <name>NULL</name> &amp;&amp; <call><name>PyAnySet_CheckExact</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call> = <name>type</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EMPTY_TO_MINSIZE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>so</name> = (<name>PySetObject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>so</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<comment type="block">/* tp_alloc has already zeroed the structure */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>so</name>-&gt;<name>table</name></name> == <name>NULL</name> &amp;&amp; <name><name>so</name>-&gt;<name>fill</name></name> == 0 &amp;&amp; <name><name>so</name>-&gt;<name>used</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INIT_NONZERO_SET_SLOTS</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name><name>so</name>-&gt;<name>lookup</name></name> = <name>set_lookkey_string</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>iterable</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>set_update_internal</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>iterable</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>

	<return>return <expr>(<name>PyObject</name> *)<name>so</name></expr>;</return>
}</block></function>

<comment type="block">/* The empty frozenset is a singleton */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>emptyfrozenset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>frozenset_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>iterable</name> <init>= <expr><name>NULL</name></expr></init>, *<name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>type</name> == &amp;<name>PyFrozenSet_Type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"frozenset()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>iterable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>type</name> != &amp;<name>PyFrozenSet_Type</name></expr>)</condition><then>
		<return>return <expr><call><name>make_new_set</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name>iterable</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* frozenset(f) is idempotent */</comment>
		<if>if <condition>(<expr><call><name>PyFrozenSet_CheckExact</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>iterable</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>make_new_set</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> == <name>NULL</name> || <call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* The empty frozenset is a singleton */</comment>
	<if>if <condition>(<expr><name>emptyfrozenset</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>emptyfrozenset</name> = <call><name>make_new_set</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>emptyfrozenset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>emptyfrozenset</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PySet_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySetObject</name> *</type><name>so</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>numfree</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>numfree</name>--</expr>;</expr_stmt>
		<expr_stmt><expr><name>so</name> = <name><name>free_list</name><index>[<expr><name>numfree</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name>emptyfrozenset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>type</name> == &amp;<name>PySet_Type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"set()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	
	<return>return <expr><call><name>make_new_set</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* set_swap_bodies() switches the contents of any two sets by moving their
   internal data pointers and, if needed, copying the internal smalltables.
   Semantically equivalent to:

     t=set(a); a.clear(); a.update(b); b.clear(); b.update(t); del t

   The function always succeeds and it leaves both objects in a stable state.
   Useful for creating temporary frozensets from sets for membership testing 
   in __contains__(), discard(), and remove().  Also useful for operations
   that update in-place (by allowing an intermediate result to be swapped 
   into one of the original inputs).
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_swap_bodies</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PySetObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>u</name></decl>;</decl_stmt>
	<function_decl><type><name>setentry</name> *</type>(*<name>f</name>)<parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>long</name></type> <name>hash</name></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>setentry</name></type> <name><name>tab</name><index>[<expr><name>PySet_MINSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>h</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>t</name> = <name><name>a</name>-&gt;<name>fill</name></name></expr>;</expr_stmt>     <expr_stmt><expr><name><name>a</name>-&gt;<name>fill</name></name>   = <name><name>b</name>-&gt;<name>fill</name></name></expr>;</expr_stmt>        <expr_stmt><expr><name><name>b</name>-&gt;<name>fill</name></name>  = <name>t</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> = <name><name>a</name>-&gt;<name>used</name></name></expr>;</expr_stmt>     <expr_stmt><expr><name><name>a</name>-&gt;<name>used</name></name>   = <name><name>b</name>-&gt;<name>used</name></name></expr>;</expr_stmt>        <expr_stmt><expr><name><name>b</name>-&gt;<name>used</name></name>  = <name>t</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> = <name><name>a</name>-&gt;<name>mask</name></name></expr>;</expr_stmt>     <expr_stmt><expr><name><name>a</name>-&gt;<name>mask</name></name>   = <name><name>b</name>-&gt;<name>mask</name></name></expr>;</expr_stmt>        <expr_stmt><expr><name><name>b</name>-&gt;<name>mask</name></name>  = <name>t</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>u</name> = <name><name>a</name>-&gt;<name>table</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>table</name></name> == <name><name>a</name>-&gt;<name>smalltable</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>u</name> = <name><name>b</name>-&gt;<name>smalltable</name></name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>table</name></name>  = <name><name>b</name>-&gt;<name>table</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>b</name>-&gt;<name>table</name></name> == <name><name>b</name>-&gt;<name>smalltable</name></name></expr>)</condition><then>
		<expr_stmt><expr><name><name>a</name>-&gt;<name>table</name></name> = <name><name>a</name>-&gt;<name>smalltable</name></name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>table</name></name> = <name>u</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>f</name> = <name><name>a</name>-&gt;<name>lookup</name></name></expr>;</expr_stmt>   <expr_stmt><expr><name><name>a</name>-&gt;<name>lookup</name></name> = <name><name>b</name>-&gt;<name>lookup</name></name></expr>;</expr_stmt>      <expr_stmt><expr><name><name>b</name>-&gt;<name>lookup</name></name> = <name>f</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>table</name></name> == <name><name>a</name>-&gt;<name>smalltable</name></name> || <name><name>b</name>-&gt;<name>table</name></name> == <name><name>b</name>-&gt;<name>smalltable</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>smalltable</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>smalltable</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>smalltable</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>smalltable</name></name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>PyFrozenSet_Type</name></expr></argument>)</argument_list></call>  &amp;&amp;
	    <call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>PyFrozenSet_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>h</name> = <name><name>a</name>-&gt;<name>hash</name></name></expr>;</expr_stmt>     <expr_stmt><expr><name><name>a</name>-&gt;<name>hash</name></name> = <name><name>b</name>-&gt;<name>hash</name></name></expr>;</expr_stmt>  <expr_stmt><expr><name><name>b</name>-&gt;<name>hash</name></name> = <name>h</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>a</name>-&gt;<name>hash</name></name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b</name>-&gt;<name>hash</name></name> = -1</expr>;</expr_stmt>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_copy</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>make_new_set</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>so</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>frozenset_copy</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyFrozenSet_CheckExact</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>so</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_copy</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>copy_doc</name></expr></argument>, <argument><expr>"Return a shallow copy of a set."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_clear</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>set_clear_internal</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>clear_doc</name></expr></argument>, <argument><expr>"Remove all elements from this set."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_union</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySetObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> = (<name>PySetObject</name> *)<call><name>set_copy</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>other</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>PyObject</name> *)<name>so</name> == <name>other</name></expr>)</condition><then>
			<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>set_update_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></for>
	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>union_doc</name></expr></argument>,
 <argument><expr>"Return the union of sets as a new set.\n\
\n\
(i.e. all elements that are in either set.)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_or</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySetObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call> || !<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>result</name> = (<name>PySetObject</name> *)<call><name>set_copy</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>(<name>PyObject</name> *)<name>so</name> == <name>other</name></expr>)</condition><then>
		<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>set_update_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_ior</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>set_update_internal</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>so</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_intersection</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySetObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>it</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>PyObject</name> *)<name>so</name> == <name>other</name></expr>)</condition><then>
		<return>return <expr><call><name>set_copy</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>result</name> = (<name>PySetObject</name> *)<call><name>make_new_set</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{		
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call> &gt; <call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>tmp</name> = (<name>PyObject</name> *)<name>so</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>so</name> = (<name>PySetObject</name> *)<name>other</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>other</name> = <name>tmp</name></expr>;</expr_stmt>
		}</block></then></if>

		<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>other</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>set_contains_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>set_add_entry</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				}</block></then></if>
			}</block></then></if>
		}</block></while>
		<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<while>while <condition>(<expr>(<name>key</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>setentry</name></type> <name>entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>hash</name> <init>= <expr><call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name><name>entry</name>.<name>hash</name></name> = <name>hash</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name>.<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> = <call><name>set_contains_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>set_add_entry</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_intersection_multi</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr>(<name>PyObject</name> *)<name>so</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><call><name>set_copy</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>newresult</name> <init>= <expr><call><name>set_intersection</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>result</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>newresult</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>newresult</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>intersection_doc</name></expr></argument>,
<argument><expr>"Return the intersection of two sets as a new set.\n\
\n\
(i.e. all elements that are in both sets.)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_intersection_update</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tmp</name> = <call><name>set_intersection</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>set_swap_bodies</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>(<name>PySetObject</name> *)<name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_intersection_update_multi</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tmp</name> = <call><name>set_intersection_multi</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>set_swap_bodies</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>(<name>PySetObject</name> *)<name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>intersection_update_doc</name></expr></argument>,
<argument><expr>"Update a set with the intersection of itself and another."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_and</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call> || !<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_intersection</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_iand</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>set_intersection_update</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>so</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_isdisjoint</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>it</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>PyObject</name> *)<name>so</name> == <name>other</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></else></if>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyAnySet_CheckExact</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{		
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call> &gt; <call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>tmp</name> = (<name>PyObject</name> *)<name>so</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>so</name> = (<name>PySetObject</name> *)<name>other</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>other</name> = <name>tmp</name></expr>;</expr_stmt>
		}</block></then></if>
		<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>other</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>set_contains_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<if>if <condition>(<expr><name>rv</name></expr>)</condition><then>
				<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
		}</block></while>
		<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<while>while <condition>(<expr>(<name>key</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>setentry</name></type> <name>entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>hash</name> <init>= <expr><call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name><name>entry</name>.<name>hash</name></name> = <name>hash</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name>.<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> = <call><name>set_contains_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></while>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isdisjoint_doc</name></expr></argument>,
<argument><expr>"Return True if two sets have a null intersection."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_difference_update_internal</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>(<name>PyObject</name> *)<name>so</name> == <name>other</name></expr>)</condition><then>
		<return>return <expr><call><name>set_clear_internal</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	
	<if>if <condition>(<expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>other</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
			<if>if <condition>(<expr><call><name>set_discard_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if></while>
	}</block></then> <else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>it</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>

		<while>while <condition>(<expr>(<name>key</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
			<if>if <condition>(<expr><call><name>set_discard_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></else></if>
	<comment type="block">/* If more than 1/5 are dummies, then resize them away. */</comment>
	<if>if <condition>(<expr>(<name><name>so</name>-&gt;<name>fill</name></name> - <name><name>so</name>-&gt;<name>used</name></name>) * 5 &lt; <name><name>so</name>-&gt;<name>mask</name></name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>set_table_resize</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>so</name>-&gt;<name>used</name></name>&gt;50000 ? <name><name>so</name>-&gt;<name>used</name></name>*2 : <name><name>so</name>-&gt;<name>used</name></name>*4</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_difference_update</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>other</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>set_difference_update_internal</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></for>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>difference_update_doc</name></expr></argument>,
<argument><expr>"Remove all elements of another set from this set."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_difference</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call>  &amp;&amp; !<call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>set_copy</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>set_difference_update_internal</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>result</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	
	<expr_stmt><expr><name>result</name> = <call><name>make_new_set</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<decl_stmt><decl><type><name>setentry</name></type> <name>entrycopy</name></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>entrycopy</name>.<name>hash</name></name> = <name><name>entry</name>-&gt;<name>hash</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entrycopy</name>.<name>key</name></name> = <name><name>entry</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<call><name>_PyDict_Contains</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>set_add_entry</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>result</name></expr></argument>, <argument><expr>&amp;<name>entrycopy</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				}</block></then></if>
			}</block></then></if>
		}</block></while>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>

	<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>set_contains_entry</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>other</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<name>rv</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>set_add_entry</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>result</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></while>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_difference_multi</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>, *<decl><type ref="prev"/><name>other</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><call><name>set_copy</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>other</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>set_difference</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name>=1</expr> ;</init> <condition><expr><name>i</name>&lt;<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>other</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>set_difference_update_internal</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>result</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>difference_doc</name></expr></argument>,
<argument><expr>"Return the difference of two or more sets as a new set.\n\
\n\
(i.e. all elements that are in this set but not the others.)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_sub</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call> || !<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_difference</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_isub</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>set_difference_update_internal</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>so</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_symmetric_difference_update</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySetObject</name> *</type><name>otherset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>PyObject</name> *)<name>so</name> == <name>other</name></expr>)</condition><then>
		<return>return <expr><call><name>set_clear</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
		<while>while <condition>(<expr><call><name>_PyDict_Next</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<decl_stmt><decl><type><name>setentry</name></type> <name>an_entry</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>an_entry</name>.<name>hash</name></name> = <name>hash</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>an_entry</name>.<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rv</name> = <call><name>set_discard_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>an_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<if>if <condition>(<expr><name>rv</name> == <name>DISCARD_NOTFOUND</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>set_add_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>an_entry</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
			}</block></then></if>
		}</block></while>
		<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>otherset</name> = (<name>PySetObject</name> *)<name>other</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>otherset</name> = (<name>PySetObject</name> *)<call><name>make_new_set</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>otherset</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></else></if>

	<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr><name>otherset</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>set_discard_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>otherset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>rv</name> == <name>DISCARD_NOTFOUND</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>set_add_entry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>otherset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></while>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>otherset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>symmetric_difference_update_doc</name></expr></argument>,
<argument><expr>"Update a set with the symmetric difference of itself and another."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_symmetric_difference</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PySetObject</name> *</type><name>otherset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>otherset</name> = (<name>PySetObject</name> *)<call><name>make_new_set</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>otherset</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>rv</name> = <call><name>set_symmetric_difference_update</name><argument_list>(<argument><expr><name>otherset</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rv</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>otherset</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>symmetric_difference_doc</name></expr></argument>,
<argument><expr>"Return the symmetric difference of two sets as a new set.\n\
\n\
(i.e. all elements that are in exactly one of the sets.)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_xor</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call> || !<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_symmetric_difference</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_ixor</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>set_symmetric_difference_update</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>so</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_issubset</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>tmp</name> = <call><name>make_new_set</name><argument_list>(<argument><expr>&amp;<name>PySet_Type</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>set_issubset</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call> &gt; <call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
		<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>

	<while>while <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>set_contains_entry</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>other</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr>!<name>rv</name></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
	}</block></while>
	<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>issubset_doc</name></expr></argument>, <argument><expr>"Report whether another set contains this set."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_issuperset</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>tmp</name> = <call><name>make_new_set</name><argument_list>(<argument><expr>&amp;<name>PySet_Type</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>set_issuperset</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_issubset</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>other</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>so</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>issuperset_doc</name></expr></argument>, <argument><expr>"Report whether this set contains another set."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_richcompare</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>r1</name></decl>, *<decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>

	<if>if<condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>op</name> == <name>Py_NE</name></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"can only compare to a set"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Py_EQ</name></expr>:
		<if>if <condition>(<expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != <call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>v</name>-&gt;<name>hash</name></name> != -1  &amp;&amp;
		    ((<name>PySetObject</name> *)<name>w</name>)-&gt;<name>hash</name> != -1 &amp;&amp;
		    <name><name>v</name>-&gt;<name>hash</name></name> != ((<name>PySetObject</name> *)<name>w</name>)-&gt;<name>hash</name></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
		<return>return <expr><call><name>set_issubset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Py_NE</name></expr>:
		<expr_stmt><expr><name>r1</name> = <call><name>set_richcompare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>r1</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>r2</name> = <call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>PyObject_Not</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>r2</name></expr>;</return>
	</case><case>case <expr><name>Py_LE</name></expr>:
		<return>return <expr><call><name>set_issubset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Py_GE</name></expr>:
		<return>return <expr><call><name>set_issuperset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Py_LT</name></expr>:
		<if>if <condition>(<expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &gt;= <call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>		
		<return>return <expr><call><name>set_issubset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Py_GT</name></expr>:
		<if>if <condition>(<expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt;= <call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
		<return>return <expr><call><name>set_issuperset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
	</case>}</block></switch>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_nocmp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"cannot compare sets using cmp()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_add</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>set_add_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>add_doc</name></expr></argument>, 
<argument><expr>"Add an element to a set.\n\
\n\
This has no effect if the element is already present."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_contains</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmpkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> = <call><name>set_contains_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PySet_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> || !<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmpkey</name> = <call><name>make_new_set</name><argument_list>(<argument><expr>&amp;<name>PyFrozenSet_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmpkey</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>set_swap_bodies</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>tmpkey</name></expr></argument>, <argument><expr>(<name>PySetObject</name> *)<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> = <call><name>set_contains</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>tmpkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_swap_bodies</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>tmpkey</name></expr></argument>, <argument><expr>(<name>PySetObject</name> *)<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmpkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_direct_contains</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>set_contains</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>contains_doc</name></expr></argument>, <argument><expr>"x.__contains__(y) &lt;==&gt; y in x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_remove</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmpkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> = <call><name>set_discard_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PySet_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> || !<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmpkey</name> = <call><name>make_new_set</name><argument_list>(<argument><expr>&amp;<name>PyFrozenSet_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmpkey</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>set_swap_bodies</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>tmpkey</name></expr></argument>, <argument><expr>(<name>PySetObject</name> *)<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> = <call><name>set_discard_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>tmpkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_swap_bodies</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>tmpkey</name></expr></argument>, <argument><expr>(<name>PySetObject</name> *)<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmpkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if> 

	<if>if <condition>(<expr><name>rv</name> == <name>DISCARD_NOTFOUND</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_key_error</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>remove_doc</name></expr></argument>,
<argument><expr>"Remove an element from a set; it must be a member.\n\
\n\
If the element is not a member, raise a KeyError."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_discard</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmpkey</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> = <call><name>set_discard_key</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PySet_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> || !<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmpkey</name> = <call><name>make_new_set</name><argument_list>(<argument><expr>&amp;<name>PyFrozenSet_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmpkey</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>set_swap_bodies</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>tmpkey</name></expr></argument>, <argument><expr>(<name>PySetObject</name> *)<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <call><name>set_discard</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>tmpkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_swap_bodies</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>tmpkey</name></expr></argument>, <argument><expr>(<name>PySetObject</name> *)<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmpkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>discard_doc</name></expr></argument>,
<argument><expr>"Remove an element from a set if it is a member.\n\
\n\
If the element is not a member, do nothing."</expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_reduce</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>keys</name><init>=<expr><name>NULL</name></expr></init>, *<name>args</name><init>=<expr><name>NULL</name></expr></init>, *<name>result</name><init>=<expr><name>NULL</name></expr></init>, *<name>dict</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>keys</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>keys</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>done</name>;</goto></then></if>
	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>done</name>;</goto></then></if>
	<expr_stmt><expr><name>dict</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>so</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dict</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reduce_doc</name></expr></argument>, <argument><expr>"Return state information for pickling."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_sizeof</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>PySetObject</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>so</name>-&gt;<name>table</name></name> != <name><name>so</name>-&gt;<name>smalltable</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <name>res</name> + (<name><name>so</name>-&gt;<name>mask</name></name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>setentry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sizeof_doc</name></expr></argument>, <argument><expr>"S.__sizeof__() -&gt; size of S in memory, in bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_init</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>iterable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>iterable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>set_clear_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>hash</name></name> = -1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>iterable</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>set_update_internal</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>set_as_sequence</name> <init>= <expr><block>{
	<expr><name>set_len</name></expr>,			<comment type="block">/* sq_length */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_concat */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_repeat */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_item */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_slice */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_ass_item */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_ass_slice */</comment>
	<expr>(<name>objobjproc</name>)<name>set_contains</name></expr>,	<comment type="block">/* sq_contains */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* set object ********************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>test_c_api</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>test_c_api_doc</name></expr></argument>, <argument><expr>"Exercises C API.  Returns True.\n\
All is well if assertions don't fail."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>set_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"add"</expr>,		<expr>(<name>PyCFunction</name>)<name>set_add</name></expr>,		<expr><name>METH_O</name></expr>,
	 <expr><name>add_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"clear"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_clear</name></expr>,		<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>clear_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__contains__"</expr>,<expr>(<name>PyCFunction</name>)<name>set_direct_contains</name></expr>,	<expr><name>METH_O</name> | <name>METH_COEXIST</name></expr>,
	 <expr><name>contains_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"copy"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_copy</name></expr>,		<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>copy_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"discard"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_discard</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>discard_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"difference"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_difference_multi</name></expr>,	<expr><name>METH_VARARGS</name></expr>,
	 <expr><name>difference_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"difference_update"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_difference_update</name></expr>,	<expr><name>METH_VARARGS</name></expr>,
	 <expr><name>difference_update_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"intersection"</expr>,<expr>(<name>PyCFunction</name>)<name>set_intersection_multi</name></expr>,	<expr><name>METH_VARARGS</name></expr>,
	 <expr><name>intersection_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"intersection_update"</expr>,<expr>(<name>PyCFunction</name>)<name>set_intersection_update_multi</name></expr>,	<expr><name>METH_VARARGS</name></expr>,
	 <expr><name>intersection_update_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"isdisjoint"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_isdisjoint</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>isdisjoint_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"issubset"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_issubset</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>issubset_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"issuperset"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_issuperset</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>issuperset_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"pop"</expr>,		<expr>(<name>PyCFunction</name>)<name>set_pop</name></expr>,		<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>pop_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__reduce__"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_reduce</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>reduce_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"remove"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_remove</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>remove_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__sizeof__"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_sizeof</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>sizeof_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"symmetric_difference"</expr>,<expr>(<name>PyCFunction</name>)<name>set_symmetric_difference</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>symmetric_difference_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"symmetric_difference_update"</expr>,<expr>(<name>PyCFunction</name>)<name>set_symmetric_difference_update</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>symmetric_difference_update_doc</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
	<expr><block>{<expr>"test_c_api"</expr>,	<expr>(<name>PyCFunction</name>)<name>test_c_api</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>test_c_api_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"union"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_union</name></expr>,		<expr><name>METH_VARARGS</name></expr>,
	 <expr><name>union_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"update"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_update</name></expr>,	<expr><name>METH_VARARGS</name></expr>,
	 <expr><name>update_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>	<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>set_as_number</name> <init>= <expr><block>{
	<expr>0</expr>,				<comment type="block">/*nb_add*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_sub</name></expr>,		<comment type="block">/*nb_subtract*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_multiply*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_divide*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_remainder*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_divmod*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_power*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_negative*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_positive*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_absolute*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_nonzero*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_invert*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_lshift*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_rshift*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_and</name></expr>,		<comment type="block">/*nb_and*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_xor</name></expr>,		<comment type="block">/*nb_xor*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_or</name></expr>,		<comment type="block">/*nb_or*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_coerce*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_int*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_long*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_float*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_oct*/</comment>
	<expr>0</expr>, 				<comment type="block">/*nb_hex*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_inplace_add*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_isub</name></expr>,		<comment type="block">/*nb_inplace_subtract*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_inplace_multiply*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_inplace_divide*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_inplace_remainder*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_inplace_power*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_inplace_lshift*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_inplace_rshift*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_iand</name></expr>,		<comment type="block">/*nb_inplace_and*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_ixor</name></expr>,		<comment type="block">/*nb_inplace_xor*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_ior</name></expr>,		<comment type="block">/*nb_inplace_or*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>set_doc</name></expr></argument>,
<argument><expr>"set(iterable) --&gt; set object\n\
\n\
Build an unordered collection of unique elements."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PySet_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"set"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PySetObject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>set_dealloc</name></expr>,	<comment type="block">/* tp_dealloc */</comment>
	<expr>(<name>printfunc</name>)<name>set_tp_print</name></expr>,	<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattr */</comment>
	<expr><name>set_nocmp</name></expr>,			<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>set_repr</name></expr>,		<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>set_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>set_as_sequence</name></expr>,		<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>PyObject_HashNotImplemented</name></expr>,	<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,	<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
		<name>Py_TPFLAGS_BASETYPE</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>set_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>set_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>set_clear_internal</name></expr>,	<comment type="block">/* tp_clear */</comment>
	<expr>(<name>richcmpfunc</name>)<name>set_richcompare</name></expr>,	<comment type="block">/* tp_richcompare */</comment>
	<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySetObject</name></expr></argument>, <argument><expr><name>weakreflist</name></expr></argument>)</argument_list></call></expr>,	<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>(<name>getiterfunc</name>)<name>set_iter</name></expr>,	<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iternext */</comment>
	<expr><name>set_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dictoffset */</comment>
	<expr>(<name>initproc</name>)<name>set_init</name></expr>,		<comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,		<comment type="block">/* tp_alloc */</comment>
	<expr><name>set_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_GC_Del</name></expr>,		<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* frozenset object ********************************************************/</comment>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>frozenset_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__contains__"</expr>,<expr>(<name>PyCFunction</name>)<name>set_direct_contains</name></expr>,	<expr><name>METH_O</name> | <name>METH_COEXIST</name></expr>,
	 <expr><name>contains_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"copy"</expr>,	<expr>(<name>PyCFunction</name>)<name>frozenset_copy</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>copy_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"difference"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_difference_multi</name></expr>,	<expr><name>METH_VARARGS</name></expr>,
	 <expr><name>difference_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"intersection"</expr>,<expr>(<name>PyCFunction</name>)<name>set_intersection_multi</name></expr>,	<expr><name>METH_VARARGS</name></expr>,
	 <expr><name>intersection_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"isdisjoint"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_isdisjoint</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>isdisjoint_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"issubset"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_issubset</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>issubset_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"issuperset"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_issuperset</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>issuperset_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__reduce__"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_reduce</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>reduce_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__sizeof__"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_sizeof</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>sizeof_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"symmetric_difference"</expr>,<expr>(<name>PyCFunction</name>)<name>set_symmetric_difference</name></expr>,	<expr><name>METH_O</name></expr>,
	 <expr><name>symmetric_difference_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"union"</expr>,	<expr>(<name>PyCFunction</name>)<name>set_union</name></expr>,		<expr><name>METH_VARARGS</name></expr>,
	 <expr><name>union_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>	<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>frozenset_as_number</name> <init>= <expr><block>{
	<expr>0</expr>,				<comment type="block">/*nb_add*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_sub</name></expr>,		<comment type="block">/*nb_subtract*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_multiply*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_divide*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_remainder*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_divmod*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_power*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_negative*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_positive*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_absolute*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_nonzero*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_invert*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_lshift*/</comment>
	<expr>0</expr>,				<comment type="block">/*nb_rshift*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_and</name></expr>,		<comment type="block">/*nb_and*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_xor</name></expr>,		<comment type="block">/*nb_xor*/</comment>
	<expr>(<name>binaryfunc</name>)<name>set_or</name></expr>,		<comment type="block">/*nb_or*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>frozenset_doc</name></expr></argument>,
<argument><expr>"frozenset(iterable) --&gt; frozenset object\n\
\n\
Build an immutable unordered collection of unique elements."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyFrozenSet_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"frozenset"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PySetObject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>set_dealloc</name></expr>,	<comment type="block">/* tp_dealloc */</comment>
	<expr>(<name>printfunc</name>)<name>set_tp_print</name></expr>,	<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattr */</comment>
	<expr><name>set_nocmp</name></expr>,			<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>set_repr</name></expr>,		<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>frozenset_as_number</name></expr>,		<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>set_as_sequence</name></expr>,		<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_mapping */</comment>
	<expr><name>frozenset_hash</name></expr>,			<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,	<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
		<name>Py_TPFLAGS_BASETYPE</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>frozenset_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>set_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>set_clear_internal</name></expr>,	<comment type="block">/* tp_clear */</comment>
	<expr>(<name>richcmpfunc</name>)<name>set_richcompare</name></expr>,	<comment type="block">/* tp_richcompare */</comment>
	<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySetObject</name></expr></argument>, <argument><expr><name>weakreflist</name></expr></argument>)</argument_list></call></expr>,	<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>(<name>getiterfunc</name>)<name>set_iter</name></expr>,		<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iternext */</comment>
	<expr><name>frozenset_methods</name></expr>,		<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,		<comment type="block">/* tp_alloc */</comment>
	<expr><name>frozenset_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_GC_Del</name></expr>,		<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/***** C API functions *************************************************/</comment>

<function><type><name>PyObject</name> *</type>
<name>PySet_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>iterable</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>make_new_set</name><argument_list>(<argument><expr>&amp;<name>PySet_Type</name></expr></argument>, <argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyFrozenSet_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>iterable</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>make_new_set</name><argument_list>(<argument><expr>&amp;<name>PyFrozenSet_Type</name></expr></argument>, <argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type>
<name>PySet_Size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>anyset</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>anyset</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>anyset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySet_Clear</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>set</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PySet_Check</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_clear_internal</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>set</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySet_Contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>anyset</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>anyset</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_contains_key</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>anyset</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySet_Discard</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>set</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PySet_Check</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_discard_key</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>set</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySet_Add</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>anyset</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PySet_Check</name><argument_list>(<argument><expr><name>anyset</name></expr></argument>)</argument_list></call> &amp;&amp; 
	    (!<call><name>PyFrozenSet_Check</name><argument_list>(<argument><expr><name>anyset</name></expr></argument>)</argument_list></call> || <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>anyset</name></expr></argument>)</argument_list></call> != 1)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_add_key</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>anyset</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PySet_Next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>set</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>pos</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry_ptr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>set</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry_ptr</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr>*<name>key</name> = <name><name>entry_ptr</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PySet_NextEntry</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>set</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>pos</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>key</name></decl></param>, <param><decl><type><name>long</name> *</type><name>hash</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>setentry</name> *</type><name>entry</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>set_next</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>set</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr>*<name>key</name> = <name><name>entry</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>hash</name> = <name><name>entry</name>-&gt;<name>hash</name></name></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PySet_Pop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>set</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PySet_Check</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_pop</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>set</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PySet_Update</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>set</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>iterable</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PySet_Check</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>set_update_internal</name><argument_list>(<argument><expr>(<name>PySetObject</name> *)<name>set</name></expr></argument>, <argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>

<comment type="block">/* Test code to be called with any three element set. 
   Returns True and original set is restored. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assertRaises</name><parameter_list>(<param><type><name>call_return_value</name></type></param>, <param><type><name>exception</name></type></param>)</parameter_list></cpp:macro>		\
	<cpp:value>do {							\
		assert(call_return_value);			\
		assert(PyErr_ExceptionMatches(exception));	\
		PyErr_Clear();					\
	} while(0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>test_c_api</name><parameter_list>(<param><decl><type><name>PySetObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>elem</name><init>=<expr><name>NULL</name></expr></init>, *<name>dup</name><init>=<expr><name>NULL</name></expr></init>, *<name>t</name></decl>, *<decl><type ref="prev"/><name>f</name></decl>, *<decl><type ref="prev"/><name>dup2</name></decl>, *<decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ob</name> <init>= <expr>(<name>PyObject</name> *)<name>so</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Verify preconditions and exercise type/size checks */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyAnySet_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyAnySet_CheckExact</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<call><name>PyFrozenSet_CheckExact</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Size</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Raise TypeError for non-iterable constructor arguments */</comment>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_New</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr></argument>, <argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PyFrozenSet_New</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr></argument>, <argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Raise TypeError for unhashable key */</comment>
	<expr_stmt><expr><name>dup</name> = <call><name>PySet_New</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Discard</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call> == -1</expr></argument>, <argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Contains</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call> == -1</expr></argument>, <argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Add</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call> == -1</expr></argument>, <argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Exercise successful pop, contains, add, and discard */</comment>
	<expr_stmt><expr><name>elem</name> = <call><name>PySet_Pop</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Contains</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> == 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Add</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Contains</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Discard</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> == 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Discard</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> == 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Exercise clear */</comment>
	<expr_stmt><expr><name>dup2</name> = <call><name>PySet_New</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Clear</name><argument_list>(<argument><expr><name>dup2</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Size</name><argument_list>(<argument><expr><name>dup2</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Raise SystemError on clear or update of frozen set */</comment>
	<expr_stmt><expr><name>f</name> = <call><name>PyFrozenSet_New</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Clear</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> == -1</expr></argument>, <argument><expr><name>PyExc_SystemError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>_PySet_Update</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call> == -1</expr></argument>, <argument><expr><name>PyExc_SystemError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Add</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Add</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == -1</expr></argument>, <argument><expr><name>PyExc_SystemError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Exercise direct iteration */</comment>
	<expr_stmt><expr><name>i</name> = 0</expr>, <expr><name>count</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>_PySet_Next</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dup</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<expr_stmt><expr><name>s</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> &amp;&amp; (<name><name>s</name><index>[<expr>0</expr>]</index></name> == 'a' || <name><name>s</name><index>[<expr>0</expr>]</index></name> == 'b' || <name><name>s</name><index>[<expr>0</expr>]</index></name> == 'c')</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>count</name> == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Exercise updates */</comment>
	<expr_stmt><expr><name>dup2</name> = <call><name>PySet_New</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>_PySet_Update</name><argument_list>(<argument><expr><name>dup2</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Size</name><argument_list>(<argument><expr><name>dup2</name></expr></argument>)</argument_list></call> == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>_PySet_Update</name><argument_list>(<argument><expr><name>dup2</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Size</name><argument_list>(<argument><expr><name>dup2</name></expr></argument>)</argument_list></call> == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Raise SystemError when self argument is not a set or frozenset. */</comment>
	<expr_stmt><expr><name>t</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Size</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> == -1</expr></argument>, <argument><expr><name>PyExc_SystemError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Contains</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == -1</expr></argument>, <argument><expr><name>PyExc_SystemError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Raise SystemError when self argument is not a set. */</comment>
	<expr_stmt><expr><name>f</name> = <call><name>PyFrozenSet_New</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_Size</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFrozenSet_CheckExact</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Discard</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == -1</expr></argument>, <argument><expr><name>PyExc_SystemError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Pop</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr></argument>, <argument><expr><name>PyExc_SystemError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Raise KeyError when popping from an empty set */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyNumber_InPlaceSubtract</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>ob</name></expr></argument>)</argument_list></call> == <name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assertRaises</name><argument_list>(<argument><expr><call><name>PySet_Pop</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr></argument>, <argument><expr><name>PyExc_KeyError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore the set from the copy using the PyNumber API */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyNumber_InPlaceOr</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call> == <name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify constructors accept NULL arguments */</comment>
	<expr_stmt><expr><name>f</name> = <call><name>PySet_New</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> = <call><name>PyFrozenSet_New</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFrozenSet_CheckExact</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>assertRaises</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
