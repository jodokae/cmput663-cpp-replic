<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/classobject.c">
<comment type="block">/* Class object implementation */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<comment type="block">/* Free list for method objects to safe malloc/free overhead
 * The im_self element is used to chain the elements.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodObject</name> *</type><name>free_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>numfree</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyMethod_MAXFREELIST</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMethod_MAXFREELIST</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TP_DESCR_GET</name><parameter_list>(<param><type><name>t</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>(PyType_HasFeature(t, Py_TPFLAGS_HAVE_CLASS) ? (t)-&gt;tp_descr_get : NULL)</cpp:value></cpp:define>

<comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>class_lookup</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
			      <param><decl><type><name>PyClassObject</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>instance_getattr1</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>instance_getattr2</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>getattrstr</name></decl>, *<decl><type ref="prev"/><name>setattrstr</name></decl>, *<decl><type ref="prev"/><name>delattrstr</name></decl>;</decl_stmt>


<function><type><name>PyObject</name> *</type>
<name>PyClass_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>bases</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
     <comment type="block">/* bases is NULL or tuple of classobjects! */</comment>
<block>{
	<decl_stmt><decl><type><name>PyClassObject</name> *</type><name>op</name></decl>, *<decl><type ref="prev"/><name>dummy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>docstr</name></decl>, *<decl><type ref="prev"/><name>modstr</name></decl>, *<decl><type ref="prev"/><name>namestr</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>docstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>docstr</name>= <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__doc__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>docstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>modstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>modstr</name>= <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__module__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>modstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>namestr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>namestr</name>= <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>namestr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"PyClass_New: name must be a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"PyClass_New: dict must be a dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>docstr</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>docstr</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>modstr</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name> <init>= <expr><call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>globals</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>modname</name> <init>= <expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>namestr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>modname</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>modstr</name></expr></argument>, <argument><expr><name>modname</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
			}</block></then></if>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>bases</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>base</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"PyClass_New: bases must be a tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>n</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>base</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<call><name>PyClass_Check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyCallable_Check</name><argument_list>(
					<argument><expr>(<name>PyObject</name> *) <name><name>base</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<return>return <expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(
						<argument><expr>(<name>PyObject</name> *) <name><name>base</name>-&gt;<name>ob_type</name></name></expr></argument>,
						<argument><expr><name>name</name></expr></argument>, <argument><expr><name>bases</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"PyClass_New: base must be a class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><name>getattrstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>getattrstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__getattr__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>getattrstr</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>alloc_error</name>;</goto></then></if>
		<expr_stmt><expr><name>setattrstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__setattr__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>setattrstr</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>alloc_error</name>;</goto></then></if>
		<expr_stmt><expr><name>delattrstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__delattr__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>delattrstr</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>alloc_error</name>;</goto></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>op</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>PyClassObject</name></expr></argument>, <argument><expr>&amp;<name>PyClass_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then> <block>{
<label><name>alloc_error</name>:</label>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>cl_bases</name></name> = <name>bases</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>cl_dict</name></name> = <name>dict</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>cl_name</name></name> = <name>name</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>op</name>-&gt;<name>cl_getattr</name></name> = <call><name>class_lookup</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>getattrstr</name></expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>cl_setattr</name></name> = <call><name>class_lookup</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>setattrstr</name></expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>cl_delattr</name></name> = <call><name>class_lookup</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>delattrstr</name></expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_getattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_setattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_delattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyMethod_Function</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>im</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyMethod_Check</name><argument_list>(<argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>((<name>PyMethodObject</name> *)<name>im</name>)-&gt;<name>im_func</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyMethod_Self</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>im</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyMethod_Check</name><argument_list>(<argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>((<name>PyMethodObject</name> *)<name>im</name>)-&gt;<name>im_self</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyMethod_Class</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>im</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyMethod_Check</name><argument_list>(<argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>((<name>PyMethodObject</name> *)<name>im</name>)-&gt;<name>im_class</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>class_doc</name></expr></argument>,
<argument><expr>"classobj(name, bases, dict)\n\
\n\
Create a class object.  The name must be a string; the second argument\n\
a tuple of classes, and the third a dictionary."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>class_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>bases</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"name"</expr>, <expr>"bases"</expr>, <expr>"dict"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"SOO"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
					 <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>bases</name></expr></argument>, <argument><expr>&amp;<name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyClass_New</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Class methods */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>class_dealloc</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_getattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_setattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_delattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>class_lookup</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>cp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyClassObject</name> **</type><name>pclass</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>cp</name>-&gt;<name>cl_dict</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>value</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>pclass</name> = <name>cp</name></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name><name>cp</name>-&gt;<name>cl_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<comment type="block">/* XXX What if one of the bases is not a class? */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>class_lookup</name><argument_list>(
			<argument><expr>(<name>PyClassObject</name> *)
			<call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name><name>cp</name>-&gt;<name>cl_bases</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pclass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>v</name></expr>;</return></then></if>
	}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>class_getattr</name><parameter_list>(<param><decl><type><name>register</name> <name>PyClassObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>sname</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyClassObject</name> *</type><name>klass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>f</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>sname</name><index>[<expr>0</expr>]</index></name> == '_' &amp;&amp; <name><name>sname</name><index>[<expr>1</expr>]</index></name> == '_'</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyEval_GetRestricted</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
			   <argument><expr>"class.__dict__ not accessible in restricted mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>op</name>-&gt;<name>cl_dict</name></name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__bases__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>op</name>-&gt;<name>cl_bases</name></name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__name__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>op</name>-&gt;<name>cl_name</name></name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>v</name> = <name>Py_None</name></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>v</name> = <name><name>op</name>-&gt;<name>cl_name</name></name></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>v</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>class_lookup</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
			     <argument><expr>"class %.50s has no attribute '%.400s'"</expr></argument>,
			     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>f</name> = <call><name>TP_DESCR_GET</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>v</name> = <call><name>f</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_slot</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>slot</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr>*<name>slot</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>slot</name> = <name>v</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_attr_slots</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyClassObject</name> *</type><name>dummy</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>set_slot</name><argument_list>(<argument><expr>&amp;<name><name>c</name>-&gt;<name>cl_getattr</name></name></expr></argument>, <argument><expr><call><name>class_lookup</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>getattrstr</name></expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_slot</name><argument_list>(<argument><expr>&amp;<name><name>c</name>-&gt;<name>cl_setattr</name></name></expr></argument>, <argument><expr><call><name>class_lookup</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>setattrstr</name></expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_slot</name><argument_list>(<argument><expr>&amp;<name><name>c</name>-&gt;<name>cl_delattr</name></name></expr></argument>, <argument><expr><call><name>class_lookup</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>delattrstr</name></expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>set_dict</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>"__dict__ must be a dictionary object"</expr>;</return></then></if>
	<expr_stmt><expr><call><name>set_slot</name><argument_list>(<argument><expr>&amp;<name><name>c</name>-&gt;<name>cl_dict</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_attr_slots</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>""</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>set_bases</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>"__bases__ must be a tuple object"</expr>;</return></then></if>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyClass_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>"__bases__ items must be classes"</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyClass_IsSubclass</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>"a __bases__ item causes an inheritance cycle"</expr>;</return></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>set_slot</name><argument_list>(<argument><expr>&amp;<name><name>c</name>-&gt;<name>cl_bases</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_attr_slots</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>""</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>set_name</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>"__name__ must be a string object"</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != (<name>size_t</name>)<call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>"__name__ must not contain null bytes"</expr>;</return></then></if>
	<expr_stmt><expr><call><name>set_slot</name><argument_list>(<argument><expr>&amp;<name><name>c</name>-&gt;<name>cl_name</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>""</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>class_setattr</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>sname</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyEval_GetRestricted</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
			   <argument><expr>"classes are read-only in restricted mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>sname</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>sname</name><index>[<expr>0</expr>]</index></name> == '_' &amp;&amp; <name><name>sname</name><index>[<expr>1</expr>]</index></name> == '_'</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>sname</name><index>[<expr><name>n</name>-1</expr>]</index></name> == '_' &amp;&amp; <name><name>sname</name><index>[<expr><name>n</name>-2</expr>]</index></name> == '_'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>err</name> = <call><name>set_dict</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__bases__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>err</name> = <call><name>set_bases</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__name__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>err</name> = <call><name>set_name</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__getattr__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>set_slot</name><argument_list>(<argument><expr>&amp;<name><name>op</name>-&gt;<name>cl_getattr</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__setattr__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>set_slot</name><argument_list>(<argument><expr>&amp;<name><name>op</name>-&gt;<name>cl_setattr</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__delattr__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>set_slot</name><argument_list>(<argument><expr>&amp;<name><name>op</name>-&gt;<name>cl_delattr</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if></else></if></else></if></else></if>
			<comment type="block">/* For the last three, we fall through to update the
			   dictionary as well. */</comment>
			<if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>*<name>err</name> == '\0'</expr>)</condition><then>
					<return>return <expr>0</expr>;</return></then></if>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_dict</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>rv</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				     <argument><expr>"class %.50s has no attribute '%.400s'"</expr></argument>,
				     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><name>rv</name></expr>;</return>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_dict</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>class_repr</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name> <init>= <expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_dict</name></name></expr></argument>, <argument><expr>"__module__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>op</name>-&gt;<name>cl_name</name></name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>name</name> = "?"</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>name</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>mod</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;class ?.%s at %p&gt;"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;class %s.%s at %p&gt;"</expr></argument>,
					   <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>name</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>class_str</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name> <init>= <expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>cl_dict</name></name></expr></argument>, <argument><expr>"__module__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name><name>op</name>-&gt;<name>cl_name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>m</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>name</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>class_repr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>mod</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>name</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>m</name>+1+<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> += <name>m</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>s</name>++ = '.'</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>class_traverse</name><parameter_list>(<param><decl><type><name>PyClassObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>cl_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>cl_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>cl_getattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>cl_setattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>cl_delattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyClass_Type</name> <init>= <expr><block>{
	<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call>
	0</expr>,
	<expr>"classobj"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyClassObject</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr>0</expr>,
	<expr>(<name>destructor</name>)<name>class_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>class_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr><name>PyInstance_New</name></expr>,				<comment type="block">/* tp_call */</comment>
	<expr>(<name>reprfunc</name>)<name>class_str</name></expr>,			<comment type="block">/* tp_str */</comment>
	<expr>(<name>getattrofunc</name>)<name>class_getattr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>(<name>setattrofunc</name>)<name>class_setattr</name></expr>,		<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,<comment type="block">/* tp_flags */</comment>
	<expr><name>class_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>class_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>class_new</name></expr>,				<comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>PyClass_IsSubclass</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>klass</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyClassObject</name> *</type><name>cp</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>klass</name> == <name>base</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><call><name>PyClass_IsSubclass</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>1</expr>;</return></then></if>
		}</block></for>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>klass</name> == <name>NULL</name> || !<call><name>PyClass_Check</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>cp</name> = (<name>PyClassObject</name> *)<name>klass</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name><name>cp</name>-&gt;<name>cl_bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>PyClass_IsSubclass</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name><name>cp</name>-&gt;<name>cl_bases</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Instance objects */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyInstance_NewRaw</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>klass</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyClass_Check</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>dict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>inst</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>PyInstanceObject</name></expr></argument>, <argument><expr>&amp;<name>PyInstance_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>inst</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>inst</name>-&gt;<name>in_weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inst</name>-&gt;<name>in_class</name></name> = (<name>PyClassObject</name> *)<name>klass</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inst</name>-&gt;<name>in_dict</name></name> = <name>dict</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>inst</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyInstance_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>klass</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyInstanceObject</name> *</type><name>inst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>init</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>initstr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>initstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>initstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__init__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>initstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>inst</name> = (<name>PyInstanceObject</name> *) <call><name>PyInstance_NewRaw</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>inst</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>init</name> = <call><name>instance_getattr2</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>initstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>init</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>(<name>arg</name> != <name>NULL</name> &amp;&amp; (!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> ||
				     <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> != 0))
		    || (<name>kw</name> != <name>NULL</name> &amp;&amp; (!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call> ||
				      <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call> != 0))</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				   <argument><expr>"this constructor takes no arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>inst</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyEval_CallObjectWithKeywords</name><argument_list>(<argument><expr><name>init</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>inst</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<if>if <condition>(<expr><name>res</name> != <name>Py_None</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					   <argument><expr>"__init__() should return None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>inst</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></else></if>
	<return>return <expr>(<name>PyObject</name> *)<name>inst</name></expr>;</return>
}</block></function>

<comment type="block">/* Instance methods */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>instance_doc</name></expr></argument>,
<argument><expr>"instance(class[, dict])\n\
\n\
Create an instance without calling its __init__() method.\n\
The class must be a classic class.\n\
If present, dict must be a dictionary or None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name>*</type> <name>type</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>klass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!|O:instance"</expr></argument>,
			      <argument><expr>&amp;<name>PyClass_Type</name></expr></argument>, <argument><expr>&amp;<name>klass</name></expr></argument>, <argument><expr>&amp;<name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>dict</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>dict</name> = <name>NULL</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		      <argument><expr>"instance() second arg must be dictionary or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if></else></if>
	<return>return <expr><call><name>PyInstance_NewRaw</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>instance_dealloc</name><parameter_list>(<param><decl><type><name>register</name> <name>PyInstanceObject</name> *</type><name>inst</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>error_type</name></decl>, *<decl><type ref="prev"/><name>error_value</name></decl>, *<decl><type ref="prev"/><name>error_traceback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>del</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>delstr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>inst</name>-&gt;<name>in_weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* Temporarily resurrect the object. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>ob_type</name></name> == &amp;<name>PyInstance_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>ob_refcnt</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inst</name>-&gt;<name>ob_refcnt</name></name> = 1</expr>;</expr_stmt>

	<comment type="block">/* Save the current exception, if any. */</comment>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>error_type</name></expr></argument>, <argument><expr>&amp;<name>error_value</name></expr></argument>, <argument><expr>&amp;<name>error_traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Execute __del__ method, if any. */</comment>
	<if>if <condition>(<expr><name>delstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>delstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__del__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>delstr</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>delstr</name> &amp;&amp; (<name>del</name> = <call><name>instance_getattr2</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>delstr</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>del</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* Restore the saved exception. */</comment>
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>error_type</name></expr></argument>, <argument><expr><name>error_value</name></expr></argument>, <argument><expr><name>error_traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Undo the temporary resurrection; can't use DECREF here, it would
	 * cause a recursive call.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>ob_refcnt</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>--<name><name>inst</name>-&gt;<name>ob_refcnt</name></name> == 0</expr>)</condition><then> <block>{

		<comment type="block">/* New weakrefs could be created during the finalizer call.
		    If this occurs, clear them out without calling their
		    finalizers since they might rely on part of the object
		    being finalized that has already been destroyed. */</comment>
		<while>while <condition>(<expr><name><name>inst</name>-&gt;<name>in_weakreflist</name></name> != <name>NULL</name></expr>)</condition> <block>{
			<expr_stmt><expr><call><name>_PyWeakref_ClearRef</name><argument_list>(<argument><expr><call>(<name>PyWeakReference</name> *)
                                            <argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_weakreflist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>

		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>refcnt</name> <init>= <expr><name><name>inst</name>-&gt;<name>ob_refcnt</name></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* __del__ resurrected it!  Make it look like the original
		 * Py_DECREF never happened.
		 */</comment>
		<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name>-&gt;<name>ob_refcnt</name></name> = <name>refcnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If Py_REF_DEBUG, _Py_NewReference bumped _Py_RefTotal, so
		 * we need to undo that. */</comment>
		<expr_stmt><expr><name>_Py_DEC_REFTOTAL</name></expr>;</expr_stmt>
		<comment type="block">/* If Py_TRACE_REFS, _Py_NewReference re-added self to the
		 * object chain, so no more to do there.
		 * If COUNT_ALLOCS, the original decref bumped tp_frees, and
		 * _Py_NewReference bumped tp_allocs: both of those need to be
		 * undone.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
		<expr_stmt><expr>--<name><name>inst</name>-&gt;<name>ob_type</name>-&gt;<name>tp_frees</name></name></expr>;</expr_stmt>
		<expr_stmt><expr>--<name><name>inst</name>-&gt;<name>ob_type</name>-&gt;<name>tp_allocs</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_getattr1</name><parameter_list>(<param><decl><type><name>register</name> <name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>sname</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>sname</name><index>[<expr>0</expr>]</index></name> == '_' &amp;&amp; <name><name>sname</name><index>[<expr>1</expr>]</index></name> == '_'</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyEval_GetRestricted</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
			<argument><expr>"instance.__dict__ not accessible in restricted mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>inst</name>-&gt;<name>in_dict</name></name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>PyObject</name> *)<name><name>inst</name>-&gt;<name>in_class</name></name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>instance_getattr2</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
			     <argument><expr>"%.50s instance has no attribute '%.400s'"</expr></argument>,
			     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_getattr2</name><parameter_list>(<param><decl><type><name>register</name> <name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyClassObject</name> *</type><name>klass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>f</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_dict</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>class_lookup</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>f</name> = <call><name>TP_DESCR_GET</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>f</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>inst</name></expr></argument>,
					<argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <name>w</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_getattr</name><parameter_list>(<param><decl><type><name>register</name> <name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>instance_getattr1</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name> &amp;&amp; (<name>func</name> = <name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_getattr</name></name>) != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>inst</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* See classobject.h comments:  this only does dict lookups, and is always
 * safe to call.
 */</comment>
<function><type><name>PyObject</name> *</type>
<name>_PyInstance_Lookup</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>pinst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyClassObject</name> *</type><name>klass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl>;</decl_stmt>	<comment type="block">/* pinst cast to the right type */</comment>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>pinst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inst</name> = (<name>PyInstanceObject</name> *)<name>pinst</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 	<expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_dict</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>v</name> = <call><name>class_lookup</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_setattr1</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_dict</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>rv</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				     <argument><expr>"%.50s instance has no attribute '%.400s'"</expr></argument>,
				     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><name>rv</name></expr>;</return>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_dict</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_setattr</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>sname</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>sname</name><index>[<expr>0</expr>]</index></name> == '_' &amp;&amp; <name><name>sname</name><index>[<expr>1</expr>]</index></name> == '_'</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>sname</name><index>[<expr><name>n</name>-1</expr>]</index></name> == '_' &amp;&amp; <name><name>sname</name><index>[<expr><name>n</name>-2</expr>]</index></name> == '_'</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyEval_GetRestricted</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				 <argument><expr>"__dict__ not accessible in restricted mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>-1</expr>;</return>
				}</block></then></if>
				<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				       <argument><expr>"__dict__ must be set to a dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				    <return>return <expr>-1</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><name>tmp</name> = <name><name>inst</name>-&gt;<name>in_dict</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inst</name>-&gt;<name>in_dict</name></name> = <name>v</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyEval_GetRestricted</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"__class__ not accessible in restricted mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>-1</expr>;</return>
				}</block></then></if>
				<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyClass_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					   <argument><expr>"__class__ must be set to a class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>-1</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><name>tmp</name> = <call>(<name>PyObject</name> *)<argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inst</name>-&gt;<name>in_class</name></name> = (<name>PyClassObject</name> *)<name>v</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>func</name> = <name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_delattr</name></name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>func</name> = <name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_setattr</name></name></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>instance_setattr1</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>inst</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>inst</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_repr</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>reprstr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>reprstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>reprstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__repr__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>reprstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>reprstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>classname</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>cname</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>classname</name> = <name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_name</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mod</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_dict</name></name></expr></argument>,
					   <argument><expr>"__module__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>classname</name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>cname</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>cname</name> = "?"</expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>mod</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;?.%s instance at %p&gt;"</expr></argument>,
						   <argument><expr><name>cname</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s.%s instance at %p&gt;"</expr></argument>,
						   <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>cname</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_str</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>strstr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>strstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>strstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__str__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>strstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>strstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>instance_repr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>instance_hash</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>outcome</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>hashstr</name></decl>, *<decl><type ref="prev"/><name>eqstr</name></decl>, *<decl><type ref="prev"/><name>cmpstr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>hashstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hashstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__hash__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hashstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>hashstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If there is no __eq__ and no __cmp__ method, we hash on the
		   address.  If an __eq__ or __cmp__ method exists, there must
		   be a __hash__. */</comment>
		<if>if <condition>(<expr><name>eqstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>eqstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__eq__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>eqstr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>eqstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmpstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>cmpstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__cmp__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>cmpstr</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr>-1</expr>;</return></then></if>
			}</block></then></if>
			<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>cmpstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(
					<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<return>return <expr>-1</expr>;</return></then></if>
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>_Py_HashPointer</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"unhashable instance"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<comment type="block">/* This already converts a -1 result to -2. */</comment>
		<expr_stmt><expr><name>outcome</name> = <call><name><name>res</name>-&gt;<name>ob_type</name>-&gt;<name>tp_hash</name></name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"__hash__() should return an int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outcome</name> = -1</expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>outcome</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_traverse</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>in_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>in_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>getitemstr</name></decl>, *<decl><type ref="prev"/><name>setitemstr</name></decl>, *<decl><type ref="prev"/><name>delitemstr</name></decl>, *<decl><type ref="prev"/><name>lenstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>iterstr</name></decl>, *<decl><type ref="prev"/><name>nextstr</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>instance_length</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outcome</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>lenstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>lenstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__len__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>lenstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>lenstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>outcome</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>outcome</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> &lt; <name>SIZEOF_INT</name></expr></cpp:if>
		<comment type="block">/* Overflow check -- range of PyInt is more than C int */</comment>
		<if>if <condition>(<expr><name>outcome</name> != (<name>int</name>)<name>outcome</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			 <argument><expr>"__len__() should return 0 &lt;= outcome &lt; 2**31"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>outcome</name> = -1</expr>;</expr_stmt>
		}</block></then>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><name>outcome</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"__len__() should return &gt;= 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>outcome</name> = -1</expr>;</expr_stmt>
		}</block></then></if></else></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"__len__() should return an int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outcome</name> = -1</expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>outcome</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_subscript</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>getitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>getitemstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__getitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>getitemstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>getitemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_ass_subscript</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>delitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>delitemstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__delitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>delitemstr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>delitemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><name>setitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>setitemstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__setitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>setitemstr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>setitemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>instance_as_mapping</name> <init>= <expr><block>{
	<expr>(<name>lenfunc</name>)<name>instance_length</name></expr>,		<comment type="block">/* mp_length */</comment>
	<expr>(<name>binaryfunc</name>)<name>instance_subscript</name></expr>,		<comment type="block">/* mp_subscript */</comment>
	<expr>(<name>objobjargproc</name>)<name>instance_ass_subscript</name></expr>,	<comment type="block">/* mp_ass_subscript */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_item</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>getitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>getitemstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__getitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>getitemstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>getitemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>"n"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_slice</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>arg</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>getslicestr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>getslicestr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>getslicestr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__getslice__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>getslicestr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>getslicestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>getitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>getitemstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__getitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>getitemstr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>getitemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>arg</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(N)"</expr></argument>, <argument><expr><call><name>_PySlice_FromIndices</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"in 3.x, __getslice__ has been removed; "
				   "use __getitem__"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>arg</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(nn)"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_ass_item</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>arg</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>delitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>delitemstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__delitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>delitemstr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>delitemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><name>setitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>setitemstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__setitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>setitemstr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>setitemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>arg</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>arg</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(nO)"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_ass_slice</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>arg</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>setslicestr</name></decl>, *<decl><type ref="prev"/><name>delslicestr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>delslicestr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>delslicestr</name> =
				<call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__delslice__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>delslicestr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>delslicestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>delitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>delitemstr</name> =
				    <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__delitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>delitemstr</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr>-1</expr>;</return></then></if>
			}</block></then></if>
			<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>delitemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>

			<expr_stmt><expr><name>arg</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(N)"</expr></argument>,
					    <argument><expr><call><name>_PySlice_FromIndices</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"in 3.x, __delslice__ has been "
				            "removed; use __delitem__"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>arg</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(nn)"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><name>setslicestr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>setslicestr</name> =
				<call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__setslice__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>setslicestr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>setslicestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>setitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>setitemstr</name> =
				    <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__setitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>setitemstr</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr>-1</expr>;</return></then></if>
			}</block></then></if>
			<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>setitemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>

			<expr_stmt><expr><name>arg</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(NO)"</expr></argument>,
					    <argument><expr><call><name>_PySlice_FromIndices</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"in 3.x, __setslice__ has been "
					   "removed; use __setitem__"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>arg</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(nnO)"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></else></if>
	<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_contains</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>member</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>__contains__</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>

	<comment type="block">/* Try __contains__ first.
	 * If that can't be done, try iterator-based searching.
	 */</comment>

	<if>if<condition>(<expr><name>__contains__</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>__contains__</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__contains__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if<condition>(<expr><name>__contains__</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>__contains__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>func</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>member</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if<condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if<condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>ret</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ret</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Couldn't find __contains__. */</comment>
	<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>rc</name></decl>;</decl_stmt>
		<comment type="block">/* Assume the failure was simply due to that there is no
		 * __contains__ attribute, and try iterating instead.
		 */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> = <call><name>_PySequence_IterSearch</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>inst</name></expr></argument>, <argument><expr><name>member</name></expr></argument>,
					    <argument><expr><name>PY_ITERSEARCH_CONTAINS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rc</name> &gt;= 0</expr>)</condition><then>
			<return>return <expr><name>rc</name> &gt; 0</expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type>
<name>instance_as_sequence</name> <init>= <expr><block>{
	<expr>(<name>lenfunc</name>)<name>instance_length</name></expr>,		<comment type="block">/* sq_length */</comment>
	<expr>0</expr>,					<comment type="block">/* sq_concat */</comment>
	<expr>0</expr>,					<comment type="block">/* sq_repeat */</comment>
	<expr>(<name>ssizeargfunc</name>)<name>instance_item</name></expr>,		<comment type="block">/* sq_item */</comment>
	<expr>(<name>ssizessizeargfunc</name>)<name>instance_slice</name></expr>,	<comment type="block">/* sq_slice */</comment>
	<expr>(<name>ssizeobjargproc</name>)<name>instance_ass_item</name></expr>,	<comment type="block">/* sq_ass_item */</comment>
	<expr>(<name>ssizessizeobjargproc</name>)<name>instance_ass_slice</name></expr>,<comment type="block">/* sq_ass_slice */</comment>
	<expr>(<name>objobjproc</name>)<name>instance_contains</name></expr>,		<comment type="block">/* sq_contains */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>generic_unary_op</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>methodname</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>methodname</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>generic_binary_op</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>char</name> *</type><name>opname</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>coerce_obj</name></decl>;</decl_stmt>

<comment type="block">/* Try one half of a binary operator involving a class instance. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>half_binop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>char</name> *</type><name>opname</name></decl></param>, <param><decl><type><name>binaryfunc</name></type> <name>thisfunc</name></decl></param>,
		<param><decl><type><name>int</name></type> <name>swapped</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>coercefunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>coerced</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>coerce_obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>coerce_obj</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__coerce__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>coerce_obj</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>coercefunc</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>coerce_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>coercefunc</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>generic_binary_op</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>coercefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>coerced</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>coercefunc</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>coercefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>coerced</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>coerced</name> == <name>Py_None</name> || <name>coerced</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>generic_binary_op</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"coercion should return None or 2-tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v1</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>v1</name>-&gt;<name>ob_type</name></name> == <name><name>v</name>-&gt;<name>ob_type</name></name> &amp;&amp; <call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* prevent recursion if __coerce__ returns self as the first
		 * argument */</comment>
		<expr_stmt><expr><name>result</name> = <call><name>generic_binary_op</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" after coercion"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name>swapped</name></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call>(<name>thisfunc</name>)<argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>result</name> = <call>(<name>thisfunc</name>)<argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Implement a binary operator involving at least one class instance. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_binop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>char</name> *</type><name>opname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ropname</name></decl></param>,
                   <param><decl><type><name>binaryfunc</name></type> <name>thisfunc</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>half_binop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>, <argument><expr><name>thisfunc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <call><name>half_binop</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>ropname</name></expr></argument>, <argument><expr><name>thisfunc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_binop_inplace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>char</name> *</type><name>iopname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>opname</name></decl></param>,
			<param><decl><type><name>char</name> *</type><name>ropname</name></decl></param>, <param><decl><type><name>binaryfunc</name></type> <name>thisfunc</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>half_binop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>iopname</name></expr></argument>, <argument><expr><name>thisfunc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <call><name>do_binop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>, <argument><expr><name>ropname</name></expr></argument>, <argument><expr><name>thisfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_coerce</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr>*<name>pv</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr>*<name>pw</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>coercefunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>coerced</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>coerce_obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>coerce_obj</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__coerce__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>coerce_obj</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>coercefunc</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>coerce_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>coercefunc</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* No __coerce__ method */</comment>
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<comment type="block">/* Has __coerce__ method: call it */</comment>
	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>coerced</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>coercefunc</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>coercefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>coerced</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* __coerce__ call raised an exception */</comment>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>coerced</name> == <name>Py_None</name> || <name>coerced</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<comment type="block">/* __coerce__ says "I can't do it" */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
		<comment type="block">/* __coerce__ return value is malformed */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			   <argument><expr>"coercion should return None or 2-tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<comment type="block">/* __coerce__ returned two new values */</comment>
	<expr_stmt><expr>*<name>pv</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>pw</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>coerced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNARY</name><parameter_list>(<param><type><name>funcname</name></type></param>, <param><type><name>methodname</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static PyObject *funcname(PyInstanceObject *self) { \
	static PyObject *o; \
	if (o == NULL) { o = PyString_InternFromString(methodname); \
			 if (o == NULL) return NULL; } \
	return generic_unary_op(self, o); \
}</cpp:value></cpp:define>

<comment type="block">/* unary function with a fallback */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNARY_FB</name><parameter_list>(<param><type><name>funcname</name></type></param>, <param><type><name>methodname</name></type></param>, <param><type><name>funcname_fb</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static PyObject *funcname(PyInstanceObject *self) { \
	static PyObject *o; \
	if (o == NULL) { o = PyString_InternFromString(methodname); \
			 if (o == NULL) return NULL; } \
	if (PyObject_HasAttr((PyObject*)self, o)) \
		return generic_unary_op(self, o); \
	else \
		return funcname_fb(self); \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY</name><parameter_list>(<param><type><name>f</name></type></param>, <param><type><name>m</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static PyObject *f(PyObject *v, PyObject *w) { \
	return do_binop(v, w, "__" m "__", "__r" m "__", n); \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY_INPLACE</name><parameter_list>(<param><type><name>f</name></type></param>, <param><type><name>m</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static PyObject *f(PyObject *v, PyObject *w) { \
	return do_binop_inplace(v, w, "__i" m "__", "__" m "__", \
			"__r" m "__", n); \
}</cpp:value></cpp:define>

<macro><name>UNARY</name><argument_list>(<argument>instance_neg</argument>, <argument>"__neg__"</argument>)</argument_list></macro>
<macro><name>UNARY</name><argument_list>(<argument>instance_pos</argument>, <argument>"__pos__"</argument>)</argument_list></macro>
<macro><name>UNARY</name><argument_list>(<argument>instance_abs</argument>, <argument>"__abs__"</argument>)</argument_list></macro>

<macro><name>BINARY</name><argument_list>(<argument>instance_or</argument>, <argument>"or"</argument>, <argument>PyNumber_Or</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_and</argument>, <argument>"and"</argument>, <argument>PyNumber_And</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_xor</argument>, <argument>"xor"</argument>, <argument>PyNumber_Xor</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_lshift</argument>, <argument>"lshift"</argument>, <argument>PyNumber_Lshift</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_rshift</argument>, <argument>"rshift"</argument>, <argument>PyNumber_Rshift</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_add</argument>, <argument>"add"</argument>, <argument>PyNumber_Add</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_sub</argument>, <argument>"sub"</argument>, <argument>PyNumber_Subtract</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_mul</argument>, <argument>"mul"</argument>, <argument>PyNumber_Multiply</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_div</argument>, <argument>"div"</argument>, <argument>PyNumber_Divide</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_mod</argument>, <argument>"mod"</argument>, <argument>PyNumber_Remainder</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_divmod</argument>, <argument>"divmod"</argument>, <argument>PyNumber_Divmod</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_floordiv</argument>, <argument>"floordiv"</argument>, <argument>PyNumber_FloorDivide</argument>)</argument_list></macro>
<macro><name>BINARY</name><argument_list>(<argument>instance_truediv</argument>, <argument>"truediv"</argument>, <argument>PyNumber_TrueDivide</argument>)</argument_list></macro>

<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_ior</argument>, <argument>"or"</argument>, <argument>PyNumber_InPlaceOr</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_ixor</argument>, <argument>"xor"</argument>, <argument>PyNumber_InPlaceXor</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_iand</argument>, <argument>"and"</argument>, <argument>PyNumber_InPlaceAnd</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_ilshift</argument>, <argument>"lshift"</argument>, <argument>PyNumber_InPlaceLshift</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_irshift</argument>, <argument>"rshift"</argument>, <argument>PyNumber_InPlaceRshift</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_iadd</argument>, <argument>"add"</argument>, <argument>PyNumber_InPlaceAdd</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_isub</argument>, <argument>"sub"</argument>, <argument>PyNumber_InPlaceSubtract</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_imul</argument>, <argument>"mul"</argument>, <argument>PyNumber_InPlaceMultiply</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_idiv</argument>, <argument>"div"</argument>, <argument>PyNumber_InPlaceDivide</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_imod</argument>, <argument>"mod"</argument>, <argument>PyNumber_InPlaceRemainder</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_ifloordiv</argument>, <argument>"floordiv"</argument>, <argument>PyNumber_InPlaceFloorDivide</argument>)</argument_list></macro>
<macro><name>BINARY_INPLACE</name><argument_list>(<argument>instance_itruediv</argument>, <argument>"truediv"</argument>, <argument>PyNumber_InPlaceTrueDivide</argument>)</argument_list></macro>

<comment type="block">/* Try a 3-way comparison, returning an int; v is an instance.  Return:
   -2 for an exception;
   -1 if v &lt; w;
   0 if v == w;
   1 if v &gt; w;
   2 if this particular 3-way comparison is not implemented or undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>half_cmp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>cmp_obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>cmp_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>cmp_obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>cmp_obj</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__cmp__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cmp_obj</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-2</expr>;</return></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>cmp_func</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>cmp_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cmp_func</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-2</expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>2</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cmp_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-2</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>cmp_func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cmp_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-2</expr>;</return></then></if>

	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>2</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>l</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>l</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"comparison did not return an int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-2</expr>;</return>
	}</block></then></if>

	<return>return <expr><name>l</name> &lt; 0 ? -1 : <name>l</name> &gt; 0 ? 1 : 0</expr>;</return>
}</block></function>

<comment type="block">/* Try a 3-way comparison, returning an int; either v or w is an instance.
   We first try a coercion.  Return:
   -2 for an exception;
   -1 if v &lt; w;
   0 if v == w;
   1 if v &gt; w;
   2 if this particular 3-way comparison is not implemented or undefined.
   THIS IS ONLY CALLED FROM object.c!
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c</name> = <call><name>PyNumber_CoerceEx</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>c</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-2</expr>;</return></then></if>
	<if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* If neither is now an instance, use regular comparison */</comment>
		<if>if <condition>(<expr>!<call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>c</name> = <call><name>PyObject_Compare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr>-2</expr>;</return></then></if>
			<return>return <expr><name>c</name> &lt; 0 ? -1 : <name>c</name> &gt; 0 ? 1 : 0</expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* The coercion didn't do anything.
		   Treat this the same as returning v and w unchanged. */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call><name>half_cmp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> &lt;= 1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>c</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call><name>half_cmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> &lt;= 1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> &gt;= -1</expr>)</condition><then>
				<expr_stmt><expr><name>c</name> = -<name>c</name></expr>;</expr_stmt></then></if>
			<return>return <expr><name>c</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>2</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instance_nonzero</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>outcome</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>nonzerostr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>nonzerostr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>nonzerostr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__nonzero__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>nonzerostr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>nonzerostr</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>lenstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>lenstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__len__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>lenstr</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<if>if <condition>(<expr>(<name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>lenstr</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Fall back to the default behavior:
			   all instances are nonzero */</comment>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"__nonzero__ should return an int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>outcome</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>outcome</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"__nonzero__ should return &gt;= 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><name>outcome</name> &gt; 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_index</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>indexstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>indexstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>indexstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__index__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>indexstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>	
	<if>if <condition>(<expr>(<name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>indexstr</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, 
				<argument><expr>"object cannot be interpreted as an index"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>


<macro><name>UNARY</name><argument_list>(<argument>instance_invert</argument>, <argument>"__invert__"</argument>)</argument_list></macro>
<macro><name>UNARY</name><argument_list>(<argument>_instance_trunc</argument>, <argument>"__trunc__"</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_int</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>truncated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>int_name</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>int_name</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>int_name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__int__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>int_name</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyObject_HasAttr</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>, <argument><expr><name>int_name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>generic_unary_op</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>int_name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>truncated</name> = <call><name>_instance_trunc</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* __trunc__ is specified to return an Integral type, but
	   int() needs to return an int. */</comment>
	<return>return <expr><call><name>_PyNumber_ConvertIntegralToInt</name><argument_list>(
		<argument><expr><name>truncated</name></expr></argument>,
		<argument><expr>"__trunc__ returned non-Integral (type %.200s)"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>UNARY_FB</name><argument_list>(<argument>instance_long</argument>, <argument>"__long__"</argument>, <argument>instance_int</argument>)</argument_list></macro>
<macro><name>UNARY</name><argument_list>(<argument>instance_float</argument>, <argument>"__float__"</argument>)</argument_list></macro>
<macro><name>UNARY</name><argument_list>(<argument>instance_oct</argument>, <argument>"__oct__"</argument>)</argument_list></macro>
<macro><name>UNARY</name><argument_list>(<argument>instance_hex</argument>, <argument>"__hex__"</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bin_power</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyNumber_Power</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* This version is for ternary calls only (z != None) */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_pow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>z</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>z</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>do_binop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>"__pow__"</expr></argument>, <argument><expr>"__rpow__"</expr></argument>, <argument><expr><name>bin_power</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

		<comment type="block">/* XXX Doesn't do coercions... */</comment>
		<expr_stmt><expr><name>func</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"__pow__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bin_inplace_power</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyNumber_InPlacePower</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_ipow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>z</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>z</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>do_binop_inplace</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>"__ipow__"</expr></argument>, <argument><expr>"__pow__"</expr></argument>,
			<argument><expr>"__rpow__"</expr></argument>, <argument><expr><name>bin_inplace_power</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* XXX Doesn't do coercions... */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>func</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"__ipow__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>instance_pow</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></else></if>
}</block></function>


<comment type="block">/* Map rich comparison operators to their __xx__ namesakes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAME_OPS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> **</type><name>name_op</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>init_name_op</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name><name>_name_op</name><index>[]</index></name> <init>= <expr><block>{
		<expr>"__lt__"</expr>,
		<expr>"__le__"</expr>,
		<expr>"__eq__"</expr>,
		<expr>"__ne__"</expr>,
		<expr>"__gt__"</expr>,
		<expr>"__ge__"</expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>name_op</name> = (<name>PyObject</name> **)<call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof> * <name>NAME_OPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>name_op</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NAME_OPS</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name><name>name_op</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name><name>_name_op</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>name_op</name><index>[<expr><name>i</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>half_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>method</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>name_op</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>init_name_op</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<comment type="block">/* If the instance doesn't define an __getattr__ method, use
	   instance_getattr2 directly because it will not set an
	   exception on failure. */</comment>
	<if>if <condition>(<expr>((<name>PyInstanceObject</name> *)<name>v</name>)-&gt;<name><name>in_class</name>-&gt;<name>cl_getattr</name></name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>method</name> = <call><name>instance_getattr2</name><argument_list>(<argument><expr>(<name>PyInstanceObject</name> *)<name>v</name></expr></argument>,
					   <argument><expr><name><name>name_op</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>method</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>name_op</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>method</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>res</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>half_richcompare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>res</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>half_richcompare</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>_Py_SwappedOp</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>res</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>


<comment type="block">/* Get the iterator */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_getiter</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>iterstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>iterstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__iter__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>iterstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>getitemstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>getitemstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__getitem__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>getitemstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr>(<name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>iterstr</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>NULL</name> &amp;&amp; !<call><name>PyIter_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"__iter__ returned non-iterator "
				     "of type '%.100s'"</expr></argument>,
				     <argument><expr><name><name>res</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>getitemstr</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"iteration over non-sequence"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PySeqIter_New</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Call the iterator's next */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_iternext</name><parameter_list>(<param><decl><type><name>PyInstanceObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>nextstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>nextstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"next"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>nextstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr>(<name>func</name> = <call><name>instance_getattr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>nextstr</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<return>return <expr><name>res</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"instance has no next() method"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instance_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>, *<decl><type ref="prev"/><name>call</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>"__call__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>call</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyInstanceObject</name> *</type><name>inst</name> <init>= <expr>(<name>PyInstanceObject</name>*) <name>func</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
			     <argument><expr>"%.200s instance has no __call__ method"</expr></argument>,
			     <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* We must check and increment the recursion depth here. Scenario:
	       class A:
	           pass
	       A.__call__ = A() # that's right
	       a = A() # ok
	       a() # infinite recursion
	   This bounces between instance_call() and PyObject_Call() without
	   ever hitting eval_frame() (which has the main recursion check). */</comment>
	<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" in __call__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>call</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>instance_as_number</name> <init>= <expr><block>{
	<expr><name>instance_add</name></expr>,			<comment type="block">/* nb_add */</comment>
	<expr><name>instance_sub</name></expr>,			<comment type="block">/* nb_subtract */</comment>
	<expr><name>instance_mul</name></expr>,			<comment type="block">/* nb_multiply */</comment>
	<expr><name>instance_div</name></expr>,			<comment type="block">/* nb_divide */</comment>
	<expr><name>instance_mod</name></expr>,			<comment type="block">/* nb_remainder */</comment>
	<expr><name>instance_divmod</name></expr>,		<comment type="block">/* nb_divmod */</comment>
	<expr><name>instance_pow</name></expr>,			<comment type="block">/* nb_power */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_neg</name></expr>,	<comment type="block">/* nb_negative */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_pos</name></expr>,	<comment type="block">/* nb_positive */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_abs</name></expr>,	<comment type="block">/* nb_absolute */</comment>
	<expr>(<name>inquiry</name>)<name>instance_nonzero</name></expr>,	<comment type="block">/* nb_nonzero */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_invert</name></expr>,	<comment type="block">/* nb_invert */</comment>
	<expr><name>instance_lshift</name></expr>,		<comment type="block">/* nb_lshift */</comment>
	<expr><name>instance_rshift</name></expr>,		<comment type="block">/* nb_rshift */</comment>
	<expr><name>instance_and</name></expr>,			<comment type="block">/* nb_and */</comment>
	<expr><name>instance_xor</name></expr>,			<comment type="block">/* nb_xor */</comment>
	<expr><name>instance_or</name></expr>,			<comment type="block">/* nb_or */</comment>
	<expr><name>instance_coerce</name></expr>,		<comment type="block">/* nb_coerce */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_int</name></expr>,	<comment type="block">/* nb_int */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_long</name></expr>,	<comment type="block">/* nb_long */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_float</name></expr>,	<comment type="block">/* nb_float */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_oct</name></expr>,	<comment type="block">/* nb_oct */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_hex</name></expr>,	<comment type="block">/* nb_hex */</comment>
	<expr><name>instance_iadd</name></expr>,			<comment type="block">/* nb_inplace_add */</comment>
	<expr><name>instance_isub</name></expr>,			<comment type="block">/* nb_inplace_subtract */</comment>
	<expr><name>instance_imul</name></expr>,			<comment type="block">/* nb_inplace_multiply */</comment>
	<expr><name>instance_idiv</name></expr>,			<comment type="block">/* nb_inplace_divide */</comment>
	<expr><name>instance_imod</name></expr>,			<comment type="block">/* nb_inplace_remainder */</comment>
	<expr><name>instance_ipow</name></expr>,			<comment type="block">/* nb_inplace_power */</comment>
	<expr><name>instance_ilshift</name></expr>,		<comment type="block">/* nb_inplace_lshift */</comment>
	<expr><name>instance_irshift</name></expr>,		<comment type="block">/* nb_inplace_rshift */</comment>
	<expr><name>instance_iand</name></expr>,			<comment type="block">/* nb_inplace_and */</comment>
	<expr><name>instance_ixor</name></expr>,			<comment type="block">/* nb_inplace_xor */</comment>
	<expr><name>instance_ior</name></expr>,			<comment type="block">/* nb_inplace_or */</comment>
	<expr><name>instance_floordiv</name></expr>,		<comment type="block">/* nb_floor_divide */</comment>
	<expr><name>instance_truediv</name></expr>,		<comment type="block">/* nb_true_divide */</comment>
	<expr><name>instance_ifloordiv</name></expr>,		<comment type="block">/* nb_inplace_floor_divide */</comment>
	<expr><name>instance_itruediv</name></expr>,		<comment type="block">/* nb_inplace_true_divide */</comment>
	<expr>(<name>unaryfunc</name>)<name>instance_index</name></expr>,	<comment type="block">/* nb_index */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyInstance_Type</name> <init>= <expr><block>{
	<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call>
	0</expr>,
	<expr>"instance"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyInstanceObject</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr>0</expr>,
	<expr>(<name>destructor</name>)<name>instance_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr><name>instance_compare</name></expr>,			<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>instance_repr</name></expr>,		<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>instance_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>instance_as_sequence</name></expr>,			<comment type="block">/* tp_as_sequence */</comment>
	<expr>&amp;<name>instance_as_mapping</name></expr>,			<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>instance_hash</name></expr>,		<comment type="block">/* tp_hash */</comment>
	<expr><name>instance_call</name></expr>,				<comment type="block">/* tp_call */</comment>
	<expr>(<name>reprfunc</name>)<name>instance_str</name></expr>,			<comment type="block">/* tp_str */</comment>
	<expr>(<name>getattrofunc</name>)<name>instance_getattr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>(<name>setattrofunc</name>)<name>instance_setattr</name></expr>,		<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> | <name>Py_TPFLAGS_CHECKTYPES</name></expr>,<comment type="block">/*tp_flags*/</comment>
	<expr><name>instance_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>instance_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr><name>instance_richcompare</name></expr>,			<comment type="block">/* tp_richcompare */</comment>
 	<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyInstanceObject</name></expr></argument>, <argument><expr><name>in_weakreflist</name></expr></argument>)</argument_list></call></expr>, <comment type="block">/* tp_weaklistoffset */</comment>
	<expr>(<name>getiterfunc</name>)<name>instance_getiter</name></expr>,		<comment type="block">/* tp_iter */</comment>
	<expr>(<name>iternextfunc</name>)<name>instance_iternext</name></expr>,	<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>instance_new</name></expr>,				<comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Instance method objects are used for two purposes:
   (a) as bound instance methods (returned by instancename.methodname)
   (b) as unbound methods (returned by ClassName.methodname)
   In case (b), im_self is NULL
*/</comment>

<function><type><name>PyObject</name> *</type>
<name>PyMethod_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>klass</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyMethodObject</name> *</type><name>im</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>im</name> = <name>free_list</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>im</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>free_list</name> = <call>(<name>PyMethodObject</name> *)<argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>im</name></expr></argument>, <argument><expr>&amp;<name>PyMethod_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numfree</name>--</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>im</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>PyMethodObject</name></expr></argument>, <argument><expr>&amp;<name>PyMethod_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>im</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></else></if>
	<expr_stmt><expr><name><name>im</name>-&gt;<name>im_weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>im</name>-&gt;<name>im_func</name></name> = <name>func</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>im</name>-&gt;<name>im_self</name></name> = <name>self</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>im</name>-&gt;<name>im_class</name></name> = <name>klass</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>im</name></expr>;</return>
}</block></function>

<comment type="block">/* Descriptors for PyMethod attributes */</comment>

<comment type="block">/* im_class, im_func and im_self are stored in the PyMethod object */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(PyMethodObject, x)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>instancemethod_memberlist</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"im_class"</expr>,	<expr><name>T_OBJECT</name></expr>,	<expr><call><name>OFF</name><argument_list>(<argument><expr><name>im_class</name></expr></argument>)</argument_list></call></expr>,	<expr><name>READONLY</name>|<name>RESTRICTED</name></expr>,
	 <expr>"the class associated with a method"</expr>}</block></expr>,
	<expr><block>{<expr>"im_func"</expr>,	<expr><name>T_OBJECT</name></expr>,	<expr><call><name>OFF</name><argument_list>(<argument><expr><name>im_func</name></expr></argument>)</argument_list></call></expr>,	<expr><name>READONLY</name>|<name>RESTRICTED</name></expr>,
	 <expr>"the function (or other callable) implementing a method"</expr>}</block></expr>,
	<expr><block>{<expr>"__func__"</expr>,	<expr><name>T_OBJECT</name></expr>,	<expr><call><name>OFF</name><argument_list>(<argument><expr><name>im_func</name></expr></argument>)</argument_list></call></expr>,	<expr><name>READONLY</name>|<name>RESTRICTED</name></expr>,
	 <expr>"the function (or other callable) implementing a method"</expr>}</block></expr>,
	<expr><block>{<expr>"im_self"</expr>,	<expr><name>T_OBJECT</name></expr>,	<expr><call><name>OFF</name><argument_list>(<argument><expr><name>im_self</name></expr></argument>)</argument_list></call></expr>,	<expr><name>READONLY</name>|<name>RESTRICTED</name></expr>,
	 <expr>"the instance to which a method is bound; None for unbound methods"</expr>}</block></expr>,
	<expr><block>{<expr>"__self__"</expr>,	<expr><name>T_OBJECT</name></expr>,	<expr><call><name>OFF</name><argument_list>(<argument><expr><name>im_self</name></expr></argument>)</argument_list></call></expr>,	<expr><name>READONLY</name>|<name>RESTRICTED</name></expr>,
	 <expr>"the instance to which a method is bound; None for unbound methods"</expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>	<comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Christian Tismer argued convincingly that method attributes should
   (nearly) always override function attributes.
   The one exception is __doc__; there's a default __doc__ which
   should only be used for the class, not for instances */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instancemethod_get_doc</name><parameter_list>(<param><decl><type><name>PyMethodObject</name> *</type><name>im</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>docstr</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>docstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>docstr</name>= <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__doc__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>docstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr><call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_func</name></name></expr></argument>, <argument><expr><name>docstr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>instancemethod_getset</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__doc__"</expr>, <expr>(<name>getter</name>)<name>instancemethod_get_doc</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instancemethod_getattro</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyMethodObject</name> *</type><name>im</name> <init>= <expr>(<name>PyMethodObject</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><name><name>obj</name>-&gt;<name>ob_type</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HAVE_CLASS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>descr</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>descr</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>f</name> <init>= <expr><call><name>TP_DESCR_GET</name><argument_list>(<argument><expr><name><name>descr</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>f</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name><name>obj</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>descr</name></expr>;</return>
		}</block></else></if>
	}</block></then></if>

	<return>return <expr><call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_func</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>instancemethod_doc</name></expr></argument>,
<argument><expr>"instancemethod(function, instance, class)\n\
\n\
Create an instance method object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instancemethod_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name>*</type> <name>type</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>classObj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"instancemethod"</expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"instancemethod"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>3</expr></argument>,
			      <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>self</name></expr></argument>, <argument><expr>&amp;<name>classObj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"first argument must be callable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>self</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>self</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name> &amp;&amp; <name>classObj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"unbound methods must have non-NULL im_class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><call><name>PyMethod_New</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>classObj</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>instancemethod_dealloc</name><parameter_list>(<param><decl><type><name>register</name> <name>PyMethodObject</name> *</type><name>im</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>im</name>-&gt;<name>im_weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>numfree</name> &lt; <name>PyMethod_MAXFREELIST</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>im</name>-&gt;<name>im_self</name></name> = (<name>PyObject</name> *)<name>free_list</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>free_list</name> = <name>im</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numfree</name>++</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instancemethod_compare</name><parameter_list>(<param><decl><type><name>PyMethodObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyMethodObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_Compare</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>im_func</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>im_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cmp</name></expr>)</condition><then>
		<return>return <expr><name>cmp</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>im_self</name></name> == <name><name>b</name>-&gt;<name>im_self</name></name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>im_self</name></name> == <name>NULL</name> || <name><name>b</name>-&gt;<name>im_self</name></name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(<name><name>a</name>-&gt;<name>im_self</name></name> &lt; <name><name>b</name>-&gt;<name>im_self</name></name>) ? -1 : 1</expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyObject_Compare</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>im_self</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>im_self</name></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instancemethod_repr</name><parameter_list>(<param><decl><type><name>PyMethodObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><name><name>a</name>-&gt;<name>im_self</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr><name><name>a</name>-&gt;<name>im_func</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>klass</name> <init>= <expr><name><name>a</name>-&gt;<name>im_class</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>funcname</name> <init>= <expr><name>NULL</name></expr></init>, *<name>klassname</name> <init>= <expr><name>NULL</name></expr></init>, *<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>sfuncname</name> <init>= <expr>"?"</expr></init>, *<name>sklassname</name> <init>= <expr>"?"</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>funcname</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>funcname</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcname</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>sfuncname</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	<if>if <condition>(<expr><name>klass</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>klassname</name> = <name>NULL</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name>klassname</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>klassname</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>klassname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>klassname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>klassname</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>sklassname</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>klassname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	}</block></else></if>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;unbound method %s.%s&gt;"</expr></argument>,
					     <argument><expr><name>sklassname</name></expr></argument>, <argument><expr><name>sfuncname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<comment type="block">/* XXX Shouldn't use repr() here! */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>selfrepr</name> <init>= <expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>selfrepr</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>fail</name>;</goto></then></if>
		<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>selfrepr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>selfrepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;bound method %s.%s of %s&gt;"</expr></argument>,
					     <argument><expr><name>sklassname</name></expr></argument>, <argument><expr><name>sfuncname</name></expr></argument>,
					     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>selfrepr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>selfrepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
  <label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>klassname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>instancemethod_hash</name><parameter_list>(<param><decl><type><name>PyMethodObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>im_self</name></name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>x</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>im_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>y</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>im_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>y</name> == -1</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>x</name> = <name>x</name> ^ <name>y</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = -2</expr>;</expr_stmt></then></if>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instancemethod_traverse</name><parameter_list>(<param><decl><type><name>PyMethodObject</name> *</type><name>im</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>getclassname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>klass</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bufsize</name> &gt; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"?"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Default outcome */</comment>
	<if>if <condition>(<expr><name>klass</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>name</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* This function cannot return an exception */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>bufsize</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>getinstclassname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>klass</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>inst</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bufsize</name> &gt; 0 &amp;&amp; (<name>size_t</name>)<name>bufsize</name> &gt; <call><name>strlen</name><argument_list>(<argument><expr>"nothing"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"nothing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>

	<expr_stmt><expr><name>klass</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>klass</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* This function cannot return an exception */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>klass</name> = <call>(<name>PyObject</name> *)<argument_list>(<argument><expr><name><name>inst</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>getclassname</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instancemethod_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><call><name>PyMethod_GET_SELF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>klass</name> <init>= <expr><call><name>PyMethod_GET_CLASS</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func</name> = <call><name>PyMethod_GET_FUNCTION</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Unbound methods must be called with an instance of
		   the class (or a derived class) as first argument */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> &gt;= 1</expr>)</condition><then>
			<expr_stmt><expr><name>self</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ok</name> &lt; 0</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></else></if>
		<if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name></type> <name><name>clsbuf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>instbuf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>getclassname</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>clsbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clsbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>getinstclassname</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>instbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>instbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"unbound method %s%s must be called with "
				     "%s instance as first argument "
				     "(got %s%s instead)"</expr></argument>,
				     <argument><expr><call><name>PyEval_GetFuncName</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><call><name>PyEval_GetFuncDesc</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><name>clsbuf</name></expr></argument>,
				     <argument><expr><name>instbuf</name></expr></argument>,
				     <argument><expr><name>self</name> == <name>NULL</name> ? "" : " instance"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>argcount</name> <init>= <expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>newarg</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr><name>argcount</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>newarg</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>newarg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argcount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>newarg</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><name>arg</name> = <name>newarg</name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>instancemethod_descr_get</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>meth</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Don't rebind an already bound method, or an unbound method
	   of a class that's not a base class of cls. */</comment>

	<if>if <condition>(<expr><call><name>PyMethod_GET_SELF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Already bound */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>meth</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* No, it is an unbound method */</comment>
	<if>if <condition>(<expr><call><name>PyMethod_GET_CLASS</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp; <name>cls</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Do subclass test.  If it fails, return meth unchanged. */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><call><name>PyObject_IsSubclass</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><call><name>PyMethod_GET_CLASS</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>ok</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>meth</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<comment type="block">/* Bind it to obj */</comment>
	<return>return <expr><call><name>PyMethod_New</name><argument_list>(<argument><expr><call><name>PyMethod_GET_FUNCTION</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyMethod_Type</name> <init>= <expr><block>{
	<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call>
	0</expr>,
	<expr>"instancemethod"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyMethodObject</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr>0</expr>,
	<expr>(<name>destructor</name>)<name>instancemethod_dealloc</name></expr>,	<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>(<name>cmpfunc</name>)<name>instancemethod_compare</name></expr>,	<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>instancemethod_repr</name></expr>,		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>instancemethod_hash</name></expr>,		<comment type="block">/* tp_hash */</comment>
	<expr><name>instancemethod_call</name></expr>,			<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>instancemethod_getattro</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr><name>PyObject_GenericSetAttr</name></expr>,		<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name>  | <name>Py_TPFLAGS_HAVE_WEAKREFS</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr><name>instancemethod_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>instancemethod_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
 	<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyMethodObject</name></expr></argument>, <argument><expr><name>im_weakreflist</name></expr></argument>)</argument_list></call></expr>, <comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr><name>instancemethod_memberlist</name></expr>,		<comment type="block">/* tp_members */</comment>
	<expr><name>instancemethod_getset</name></expr>,			<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr><name>instancemethod_descr_get</name></expr>,		<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>instancemethod_new</name></expr>,			<comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Clear out the free list */</comment>

<function><type><name>int</name></type>
<name>PyMethod_ClearFreeList</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>freelist_size</name> <init>= <expr><name>numfree</name></expr></init></decl>;</decl_stmt>
	
	<while>while <condition>(<expr><name>free_list</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyMethodObject</name> *</type><name>im</name> <init>= <expr><name>free_list</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>free_list</name> = <call>(<name>PyMethodObject</name> *)<argument_list>(<argument><expr><name><name>im</name>-&gt;<name>im_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numfree</name>--</expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>numfree</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>freelist_size</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyMethod_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr>(<name>void</name>)<call><name>PyMethod_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
