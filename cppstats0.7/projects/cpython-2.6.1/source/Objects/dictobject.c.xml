<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/dictobject.c">
<comment type="block">/* Dictionary object implementation using a hash table */</comment>

<comment type="block">/* The distribution includes a separate file, Objects/dictnotes.txt,
   describing explorations into dictionary design and optimization.
   It covers typical dictionary use patterns, the parameters for
   tuning dictionaries, and several ideas for possible optimizations.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>


<comment type="block">/* Set a key error with the specified argument, wrapping it in a
 * tuple automatically so that tuple keys are not unpacked as the
 * exception arguments. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_key_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tup</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>tup</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>tup</name></expr>)</condition><then>
		<return>return;</return></then></if> <comment type="block">/* caller will expect error to be set anyway */</comment>
	<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Define this out if you don't want conversion statistics on exit. */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SHOW_CONVERSION_COUNTS</name></cpp:undef>

<comment type="block">/* See large comment block below.  This must be &gt;= 1. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PERTURB_SHIFT</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/*
Major subtleties ahead:  Most hash schemes depend on having a "good" hash
function, in the sense of simulating randomness.  Python doesn't:  its most
important hash functions (for strings and ints) are very regular in common
cases:

&gt;&gt;&gt; map(hash, (0, 1, 2, 3))
[0, 1, 2, 3]
&gt;&gt;&gt; map(hash, ("namea", "nameb", "namec", "named"))
[-1658398457, -1658398460, -1658398459, -1658398462]
&gt;&gt;&gt;

This isn't necessarily bad!  To the contrary, in a table of size 2**i, taking
the low-order i bits as the initial table index is extremely fast, and there
are no collisions at all for dicts indexed by a contiguous range of ints.
The same is approximately true when keys are "consecutive" strings.  So this
gives better-than-random behavior in common cases, and that's very desirable.

OTOH, when collisions occur, the tendency to fill contiguous slices of the
hash table makes a good collision resolution strategy crucial.  Taking only
the last i bits of the hash code is also vulnerable:  for example, consider
[i &lt;&lt; 16 for i in range(20000)] as a set of keys.  Since ints are their own
hash codes, and this fits in a dict of size 2**15, the last 15 bits of every
hash code are all 0:  they *all* map to the same table index.

But catering to unusual cases should not slow the usual ones, so we just take
the last i bits anyway.  It's up to collision resolution to do the rest.  If
we *usually* find the key we're looking for on the first try (and, it turns
out, we usually do -- the table load factor is kept under 2/3, so the odds
are solidly in our favor), then it makes best sense to keep the initial index
computation dirt cheap.

The first half of collision resolution is to visit table indices via this
recurrence:

    j = ((5*j) + 1) mod 2**i

For any initial j in range(2**i), repeating that 2**i times generates each
int in range(2**i) exactly once (see any text on random-number generation for
proof).  By itself, this doesn't help much:  like linear probing (setting
j += 1, or j -= 1, on each loop trip), it scans the table entries in a fixed
order.  This would be bad, except that's not the only thing we do, and it's
actually *good* in the common cases where hash keys are consecutive.  In an
example that's really too small to make this entirely clear, for a table of
size 2**3 the order of indices is:

    0 -&gt; 1 -&gt; 6 -&gt; 7 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 0 [and here it's repeating]

If two things come in at index 5, the first place we look after is index 2,
not 6, so if another comes in at index 6 the collision at 5 didn't hurt it.
Linear probing is deadly in this case because there the fixed probe order
is the *same* as the order consecutive keys are likely to arrive.  But it's
extremely unlikely hash codes will follow a 5*j+1 recurrence by accident,
and certain that consecutive hash codes do not.

The other half of the strategy is to get the other bits of the hash code
into play.  This is done by initializing a (unsigned) vrbl "perturb" to the
full hash code, and changing the recurrence to:

    j = (5*j) + 1 + perturb;
    perturb &gt;&gt;= PERTURB_SHIFT;
    use j % 2**i as the next table index;

Now the probe sequence depends (eventually) on every bit in the hash code,
and the pseudo-scrambling property of recurring on 5*j+1 is more valuable,
because it quickly magnifies small differences in the bits that didn't affect
the initial index.  Note that because perturb is unsigned, if the recurrence
is executed often enough perturb eventually becomes and remains 0.  At that
point (very rarely reached) the recurrence is on (just) 5*j+1 again, and
that's certain to find an empty slot eventually (since it generates every int
in range(2**i), and we make sure there's always at least one empty slot).

Selecting a good value for PERTURB_SHIFT is a balancing act.  You want it
small so that the high bits of the hash code continue to affect the probe
sequence across iterations; but you want it large so that in really bad cases
the high-order hash bits have an effect on early iterations.  5 was "the
best" in minimizing total collisions across experiments Tim Peters ran (on
both normal and pathological cases), but 4 and 6 weren't significantly worse.

Historical:  Reimer Behrends contributed the idea of using a polynomial-based
approach, using repeated multiplication by x in GF(2**n) where an irreducible
polynomial for each table size was chosen such that x was a primitive root.
Christian Tismer later extended that to use division by x instead, as an
efficient way to get the high bits of the hash code into play.  This scheme
also gave excellent collision statistics, but was more expensive:  two
if-tests were required inside the loop; computing "the next" index took about
the same number of operations but without as much potential parallelism
(e.g., computing 5*j can go on at the same time as computing 1+perturb in the
above, and then shifting perturb can be done while the table index is being
masked); and the PyDictObject struct required a member to hold the table's
polynomial.  In Tim's experiments the current scheme ran faster, produced
equally good collision statistics, needed less code &amp; used less memory.

Theoretical Python 2.5 headache:  hash codes are only C "long", but
sizeof(Py_ssize_t) &gt; sizeof(long) may be possible.  In that case, and if a
dict is genuinely huge, then only the slots directly reachable via indexing
by a C long can be the first slot in a probe sequence.  The probe sequence
will still eventually reach every slot in the table, but the collision rate
on initial probes may be much higher than this scheme was designed for.
Getting a hash code as fat as Py_ssize_t is the only real cure.  But in
practice, this probably won't make a lick of difference for many years (at
which point everyone will have terabytes of RAM on 64-bit boxes).
*/</comment>

<comment type="block">/* Object used as dummy key to fill deleted entries */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>dummy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Initialized by first call to newPyDictObject() */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_REF_DEBUG</name></cpp:ifdef>
<function><type><name>PyObject</name> *</type>
<name>_PyDict_Dummy</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>dummy</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>PyDictEntry</name> *</type>
<name>lookdict_string</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>long</name></type> <name>hash</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_CONVERSION_COUNTS</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>created</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>converted</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_counts</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"created %ld string dicts\n"</expr></argument>, <argument><expr><name>created</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"converted %ld to normal dicts\n"</expr></argument>, <argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%.2f%% conversion rate\n"</expr></argument>, <argument><expr>(100.0*<name>converted</name>)/<name>created</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Debug statistic to compare allocations with reuse through the free list */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:undef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>count_alloc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>count_reuse</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_alloc</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Dict allocations: %" <name>PY_FORMAT_SIZE_T</name> "d\n"</expr></argument>,
		<argument><expr><name>count_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Dict reuse through freelist: %" <name>PY_FORMAT_SIZE_T</name>
		"d\n"</expr></argument>, <argument><expr><name>count_reuse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%.2f%% reuse rate\n\n"</expr></argument>,
		<argument><expr>(100.0*<name>count_reuse</name>/(<name>count_alloc</name>+<name>count_reuse</name>))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Initialization macros.
   There are two ways to create a dict:  PyDict_New() is the main C API
   function, and the tp_new slot maps to dict_new().  In the latter case we
   can save a little time over what PyDict_New does because it's guaranteed
   that the PyDictObject struct is already zeroed out.
   Everyone except dict_new() should use EMPTY_TO_MINSIZE (unless they have
   an excellent reason not to).
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_NONZERO_DICT_SLOTS</name><parameter_list>(<param><type><name>mp</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {				\
	(mp)-&gt;ma_table = (mp)-&gt;ma_smalltable;				\
	(mp)-&gt;ma_mask = PyDict_MINSIZE - 1;				\
    } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY_TO_MINSIZE</name><parameter_list>(<param><type><name>mp</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {					\
	memset((mp)-&gt;ma_smalltable, 0, sizeof((mp)-&gt;ma_smalltable));	\
	(mp)-&gt;ma_used = (mp)-&gt;ma_fill = 0;				\
	INIT_NONZERO_DICT_SLOTS(mp);					\
    } while(0)</cpp:value></cpp:define>

<comment type="block">/* Dictionary reuse scheme to save calls to malloc, free, and memset */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyDict_MAXFREELIST</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDict_MAXFREELIST</name></cpp:macro> <cpp:value>80</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyDictObject</name> *</type><name><name>free_list</name><index>[<expr><name>PyDict_MAXFREELIST</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>numfree</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>PyDict_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>op</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>numfree</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>op</name> = <name><name>free_list</name><index>[<expr>--<name>numfree</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyDict_New</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>dummy</name> == <name>NULL</name></expr>)</condition><then> <block>{ <comment type="block">/* Auto-initialize dummy */</comment>
		<expr_stmt><expr><name>dummy</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"&lt;dummy key&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dummy</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_CONVERSION_COUNTS</name></cpp:ifdef>
		<expr_stmt><expr><call><name>Py_AtExit</name><argument_list>(<argument><expr><name>show_counts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:ifdef>
		<expr_stmt><expr><call><name>Py_AtExit</name><argument_list>(<argument><expr><name>show_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
	<if>if <condition>(<expr><name>numfree</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>mp</name> = <name><name>free_list</name><index>[<expr>--<name>numfree</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>mp</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call> == &amp;<name>PyDict_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>ma_fill</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>EMPTY_TO_MINSIZE</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<comment type="block">/* At least set ma_table and ma_mask; these are wrong
			   if an empty but presized dict is added to freelist */</comment>
			<expr_stmt><expr><call><name>INIT_NONZERO_DICT_SLOTS</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>ma_used</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>ma_table</name></name> == <name><name>mp</name>-&gt;<name>ma_smalltable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>ma_mask</name></name> == <name>PyDict_MINSIZE</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:ifdef>
		<expr_stmt><expr><name>count_reuse</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>mp</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>PyDictObject</name></expr></argument>, <argument><expr>&amp;<name>PyDict_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>mp</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>EMPTY_TO_MINSIZE</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:ifdef>
		<expr_stmt><expr><name>count_alloc</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></else></if>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_lookup</name></name> = <name>lookdict_string</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_CONVERSION_COUNTS</name></cpp:ifdef>
	<expr_stmt><expr>++<name>created</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>mp</name></expr>;</return>
}</block></function>

<comment type="block">/*
The basic lookup function used by all operations.
This is based on Algorithm D from Knuth Vol. 3, Sec. 6.4.
Open addressing is preferred over chaining since the link overhead for
chaining would be substantial (100% with typical malloc overhead).

The initial probe index is computed as hash mod the table size. Subsequent
probe indices are computed as explained earlier.

All arithmetic on hash should ignore overflow.

(The details in this version are due to Tim Peters, building on many past
contributions by Reimer Behrends, Jyrki Alakuijala, Vladimir Marangozov and
Christian Tismer).

lookdict() is general-purpose, and may return NULL if (and only if) a
comparison raises an exception (this was new in Python 2.5).
lookdict_string() below is specialized to string keys, comparison of which can
never raise an exception; that function can never return NULL.  For both, when
the key isn't found a PyDictEntry* is returned for which the me_value field is
NULL; this is the slot in the dict at which the key would have been found, and
the caller can (if it wishes) add the &lt;key, value&gt; pair to the returned
PyDictEntry*.
*/</comment>
<function><type><specifier>static</specifier> <name>PyDictEntry</name> *</type>
<name>lookdict</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>register</name> <name>long</name></type> <name>hash</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>perturb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>freeslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>mask</name> <init>= <expr>(<name>size_t</name>)<name><name>mp</name>-&gt;<name>ma_mask</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep0</name> <init>= <expr><name><name>mp</name>-&gt;<name>ma_table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>startkey</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = (<name>size_t</name>)<name>hash</name> &amp; <name>mask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ep</name> = &amp;<name><name>ep0</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>NULL</name> || <name><name>ep</name>-&gt;<name>me_key</name></name> == <name>key</name></expr>)</condition><then>
		<return>return <expr><name>ep</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>dummy</name></expr>)</condition><then>
		<expr_stmt><expr><name>freeslot</name> = <name>ep</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_hash</name></name> == <name>hash</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>startkey</name> = <name><name>ep</name>-&gt;<name>me_key</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<if>if <condition>(<expr><name>ep0</name> == <name><name>mp</name>-&gt;<name>ma_table</name></name> &amp;&amp; <name><name>ep</name>-&gt;<name>me_key</name></name> == <name>startkey</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
					<return>return <expr><name>ep</name></expr>;</return></then></if>
			}</block></then>
			<else>else <block>{
				<comment type="block">/* The compare did major nasty stuff to the
				 * dict:  start over.
				 * XXX A clever adversary could prevent this
				 * XXX from terminating.
 				 */</comment>
 				<return>return <expr><call><name>lookdict</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
 			}</block></else></if>
		}</block></then></if>
		<expr_stmt><expr><name>freeslot</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* In the loop, me_key == dummy is by far (factor of 100s) the
	   least likely outcome, so test for that last. */</comment>
	<for>for (<init><expr><name>perturb</name> = <name>hash</name></expr>;</init> <condition>;</condition> <incr><expr><name>perturb</name> &gt;&gt;= <name>PERTURB_SHIFT</name></expr></incr>) <block>{
		<expr_stmt><expr><name>i</name> = (<name>i</name> &lt;&lt; 2) + <name>i</name> + <name>perturb</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>ep</name> = &amp;<name><name>ep0</name><index>[<expr><name>i</name> &amp; <name>mask</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>freeslot</name> == <name>NULL</name> ? <name>ep</name> : <name>freeslot</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>key</name></expr>)</condition><then>
			<return>return <expr><name>ep</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_hash</name></name> == <name>hash</name> &amp;&amp; <name><name>ep</name>-&gt;<name>me_key</name></name> != <name>dummy</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>startkey</name> = <name><name>ep</name>-&gt;<name>me_key</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<if>if <condition>(<expr><name>ep0</name> == <name><name>mp</name>-&gt;<name>ma_table</name></name> &amp;&amp; <name><name>ep</name>-&gt;<name>me_key</name></name> == <name>startkey</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
					<return>return <expr><name>ep</name></expr>;</return></then></if>
			}</block></then>
			<else>else <block>{
				<comment type="block">/* The compare did major nasty stuff to the
				 * dict:  start over.
				 * XXX A clever adversary could prevent this
				 * XXX from terminating.
 				 */</comment>
 				<return>return <expr><call><name>lookdict</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
 			}</block></else></if>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>dummy</name> &amp;&amp; <name>freeslot</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>freeslot</name> = <name>ep</name></expr>;</expr_stmt></then></if></else></if>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* NOT REACHED */</comment>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * Hacked up version of lookdict which can assume keys are always strings;
 * this assumption allows testing for errors during PyObject_RichCompareBool()
 * to be dropped; string-string comparisons never raise exceptions.  This also
 * means we don't need to go through PyObject_RichCompareBool(); we can always
 * use _PyString_Eq() directly.
 *
 * This is valuable because dicts with only string keys are very common.
 */</comment>
<function><type><specifier>static</specifier> <name>PyDictEntry</name> *</type>
<name>lookdict_string</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>register</name> <name>long</name></type> <name>hash</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>perturb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>freeslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>mask</name> <init>= <expr>(<name>size_t</name>)<name><name>mp</name>-&gt;<name>ma_mask</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep0</name> <init>= <expr><name><name>mp</name>-&gt;<name>ma_table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure this function doesn't have to handle non-string keys,
	   including subclasses of str; e.g., one reason to subclass
	   strings is to override __eq__, and for speed we don't cater to
	   that here. */</comment>
	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_CONVERSION_COUNTS</name></cpp:ifdef>
		<expr_stmt><expr>++<name>converted</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_lookup</name></name> = <name>lookdict</name></expr>;</expr_stmt>
		<return>return <expr><call><name>lookdict</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>i</name> = <name>hash</name> &amp; <name>mask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ep</name> = &amp;<name><name>ep0</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>NULL</name> || <name><name>ep</name>-&gt;<name>me_key</name></name> == <name>key</name></expr>)</condition><then>
		<return>return <expr><name>ep</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>dummy</name></expr>)</condition><then>
		<expr_stmt><expr><name>freeslot</name> = <name>ep</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_hash</name></name> == <name>hash</name> &amp;&amp; <call><name>_PyString_Eq</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>ep</name></expr>;</return></then></if>
		<expr_stmt><expr><name>freeslot</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* In the loop, me_key == dummy is by far (factor of 100s) the
	   least likely outcome, so test for that last. */</comment>
	<for>for (<init><expr><name>perturb</name> = <name>hash</name></expr>;</init> <condition>;</condition> <incr><expr><name>perturb</name> &gt;&gt;= <name>PERTURB_SHIFT</name></expr></incr>) <block>{
		<expr_stmt><expr><name>i</name> = (<name>i</name> &lt;&lt; 2) + <name>i</name> + <name>perturb</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>ep</name> = &amp;<name><name>ep0</name><index>[<expr><name>i</name> &amp; <name>mask</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>freeslot</name> == <name>NULL</name> ? <name>ep</name> : <name>freeslot</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>key</name>
		    || (<name><name>ep</name>-&gt;<name>me_hash</name></name> == <name>hash</name>
		        &amp;&amp; <name><name>ep</name>-&gt;<name>me_key</name></name> != <name>dummy</name>
			&amp;&amp; <call><name>_PyString_Eq</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
			<return>return <expr><name>ep</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>dummy</name> &amp;&amp; <name>freeslot</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>freeslot</name> = <name>ep</name></expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* NOT REACHED */</comment>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
Internal routine to insert a new item into the table.
Used both by the internal resize routine and by the public insert routine.
Eats a reference to key and one to value.
Returns -1 if an error occurred, or 0 on success.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>insertdict</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>long</name></type> <name>hash</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<typedef>typedef <function_decl><type><name>PyDictEntry</name> *</type>(*<name>lookupfunc</name>)<parameter_list>(<param><decl><type><name>PyDictObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>long</name></type></decl></param>)</parameter_list>;</function_decl></typedef>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>ma_lookup</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ep</name> = <call><name><name>mp</name>-&gt;<name>ma_lookup</name></name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_value</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>old_value</name> = <name><name>ep</name>-&gt;<name>me_value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_value</name></name> = <name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* which **CAN** re-enter */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_fill</name></name>++</expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_key</name></name> = <name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_hash</name></name> = (<name>Py_ssize_t</name>)<name>hash</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_value</name></name> = <name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_used</name></name>++</expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
Internal routine used by dictresize() to insert an item which is
known to be absent from the dict.  This routine also assumes that
the dict contains no deleted entries.  Besides the performance benefit,
using insertdict() in dictresize() is dangerous (SF bug #1456209).
Note that no refcounts are changed by this routine; if needed, the caller
is responsible for incref'ing `key` and `value`.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>insertdict_clean</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>long</name></type> <name>hash</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>perturb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>mask</name> <init>= <expr>(<name>size_t</name>)<name><name>mp</name>-&gt;<name>ma_mask</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep0</name> <init>= <expr><name><name>mp</name>-&gt;<name>ma_table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = <name>hash</name> &amp; <name>mask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ep</name> = &amp;<name><name>ep0</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>perturb</name> = <name>hash</name></expr>;</init> <condition><expr><name><name>ep</name>-&gt;<name>me_key</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>perturb</name> &gt;&gt;= <name>PERTURB_SHIFT</name></expr></incr>) <block>{
		<expr_stmt><expr><name>i</name> = (<name>i</name> &lt;&lt; 2) + <name>i</name> + <name>perturb</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>ep</name> = &amp;<name><name>ep0</name><index>[<expr><name>i</name> &amp; <name>mask</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_value</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_fill</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_key</name></name> = <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_hash</name></name> = (<name>Py_ssize_t</name>)<name>hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_value</name></name> = <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_used</name></name>++</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
Restructure the table by allocating a new table and reinserting all
items again.  When entries have been deleted, the new table may
actually be smaller than the old one.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dictresize</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>minused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>oldtable</name></decl>, *<decl><type ref="prev"/><name>newtable</name></decl>, *<decl><type ref="prev"/><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>is_oldtable_malloced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name></type> <name><name>small_copy</name><index>[<expr><name>PyDict_MINSIZE</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>minused</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the smallest table size &gt; minused. */</comment>
	<for>for (<init><expr><name>newsize</name> = <name>PyDict_MINSIZE</name></expr>;</init>
	     <condition><expr><name>newsize</name> &lt;= <name>minused</name> &amp;&amp; <name>newsize</name> &gt; 0</expr>;</condition>
	     <incr><expr><name>newsize</name> &lt;&lt;= 1</expr></incr>)
		<empty_stmt>;</empty_stmt></for>
	<if>if <condition>(<expr><name>newsize</name> &lt;= 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<comment type="block">/* Get space for a new table. */</comment>
	<expr_stmt><expr><name>oldtable</name> = <name><name>mp</name>-&gt;<name>ma_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldtable</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_oldtable_malloced</name> = <name>oldtable</name> != <name><name>mp</name>-&gt;<name>ma_smalltable</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>newsize</name> == <name>PyDict_MINSIZE</name></expr>)</condition><then> <block>{
		<comment type="block">/* A large table is shrinking, or we can't get any smaller. */</comment>
		<expr_stmt><expr><name>newtable</name> = <name><name>mp</name>-&gt;<name>ma_smalltable</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newtable</name> == <name>oldtable</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>ma_fill</name></name> == <name><name>mp</name>-&gt;<name>ma_used</name></name></expr>)</condition><then> <block>{
				<comment type="block">/* No dummies, so no point doing anything. */</comment>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<comment type="block">/* We're not going to resize it, but rebuild the
			   table anyway to purge old dummy entries.
			   Subtle:  This is *necessary* if fill==size,
			   as lookdict needs at least one virgin slot to
			   terminate failing searches.  If fill &lt; size, it's
			   merely desirable, as dummies slow searches. */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>ma_fill</name></name> &gt; <name><name>mp</name>-&gt;<name>ma_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>small_copy</name></expr></argument>, <argument><expr><name>oldtable</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>small_copy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldtable</name> = <name>small_copy</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>newtable</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>PyDictEntry</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newtable</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></else></if>

	<comment type="block">/* Make the dict empty, using the new table. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newtable</name> != <name>oldtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_table</name></name> = <name>newtable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_mask</name></name> = <name>newsize</name> - 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>newtable</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyDictEntry</name></expr></argument>)</argument_list></sizeof> * <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_used</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <name><name>mp</name>-&gt;<name>ma_fill</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_fill</name></name> = 0</expr>;</expr_stmt>

	<comment type="block">/* Copy the data over; this is refcount-neutral for active entries;
	   dummy entries aren't copied over, of course */</comment>
	<for>for (<init><expr><name>ep</name> = <name>oldtable</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>ep</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_value</name></name> != <name>NULL</name></expr>)</condition><then> <block>{	<comment type="block">/* active entry */</comment>
			<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>insertdict_clean</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name><name>ep</name>-&gt;<name>me_key</name></name></expr></argument>, <argument><expr>(<name>long</name>)<name><name>ep</name>-&gt;<name>me_hash</name></name></expr></argument>,
					 <argument><expr><name><name>ep</name>-&gt;<name>me_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name> != <name>NULL</name></expr>)</condition><then> <block>{	<comment type="block">/* dummy entry */</comment>
			<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_key</name></name> == <name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></else></if>
		<comment type="block">/* else key == value == NULL:  nothing to do */</comment>
	}</block></for>

	<if>if <condition>(<expr><name>is_oldtable_malloced</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>oldtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Create a new dictionary pre-sized to hold an estimated number of elements.
   Underestimates are okay because the dictionary will resize as necessary.
   Overestimates just mean the dictionary will be more sparse than usual.
*/</comment>

<function><type><name>PyObject</name> *</type>
<name>_PyDict_NewPresized</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>minused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>minused</name>&gt;5 &amp;&amp; <name>op</name> != <name>NULL</name> &amp;&amp; <call><name>dictresize</name><argument_list>(<argument><expr>(<name>PyDictObject</name> *)<name>op</name></expr></argument>, <argument><expr><name>minused</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>op</name></expr>;</return>
}</block></function>

<comment type="block">/* Note that, for historical reasons, PyDict_GetItem() suppresses all errors
 * that may occur (originally dicts supported only string keys, and exceptions
 * weren't possible).  So, while the original intent was that a NULL return
 * meant the key wasn't present, in reality it can mean that, or that an error
 * (suppressed) occurred while computing the key's hash, or that some error
 * (suppressed) occurred when comparing keys in the dict's internal probe
 * sequence.  A nasty example of the latter is when a Python-coded comparison
 * function hits a stack-depth error, which can cause this to return NULL
 * even if the key is present.
 */</comment>
<function><type><name>PyObject</name> *</type>
<name>PyDict_GetItem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>mp</name> <init>= <expr>(<name>PyDictObject</name> *)<name>op</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then>
	<block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>

	<comment type="block">/* We can arrive here with a NULL tstate during initialization:
	   try running "python -Wi" for an example related to string
	   interning.  Let's just hope that no exception occurs then... */</comment>
	<expr_stmt><expr><name>tstate</name> = <name>_PyThreadState_Current</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tstate</name> != <name>NULL</name> &amp;&amp; <name><name>tstate</name>-&gt;<name>curexc_type</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* preserve the existing exception */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>err_type</name></decl>, *<decl><type ref="prev"/><name>err_value</name></decl>, *<decl><type ref="prev"/><name>err_tb</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>err_type</name></expr></argument>, <argument><expr>&amp;<name>err_value</name></expr></argument>, <argument><expr>&amp;<name>err_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ignore errors */</comment>
		<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>err_type</name></expr></argument>, <argument><expr><name>err_value</name></expr></argument>, <argument><expr><name>err_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></else></if>
	<return>return <expr><name><name>ep</name>-&gt;<name>me_value</name></name></expr>;</return>
}</block></function>

<comment type="block">/* CAUTION: PyDict_SetItem() must guarantee that it won't resize the
 * dictionary if it's merely replacing the value for an existing key.
 * This means that it's safe to loop over a dictionary with PyDict_Next()
 * and occasionally replace a value -- but you can't insert new keys or
 * remove them.
 */</comment>
<function><type><name>int</name></type>
<name>PyDict_SetItem</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>n_used</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mp</name> = (<name>PyDictObject</name> *)<name>op</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = ((<name>PyStringObject</name> *)<name>key</name>)-&gt;<name>ob_shash</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>ma_fill</name></name> &lt;= <name><name>mp</name>-&gt;<name>ma_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* at least one empty slot */</comment>
	<expr_stmt><expr><name>n_used</name> = <name><name>mp</name>-&gt;<name>ma_used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>insertdict</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<comment type="block">/* If we added a key, we can safely resize.  Otherwise just return!
	 * If fill &gt;= 2/3 size, adjust size.  Normally, this doubles or
	 * quaduples the size, but it's also possible for the dict to shrink
	 * (if ma_fill is much larger than ma_used, meaning a lot of dict
	 * keys have been * deleted).
	 *
	 * Quadrupling the size improves average dictionary sparseness
	 * (reducing collisions) at the cost of some memory and iteration
	 * speed (which loops over every possible entry).  It also halves
	 * the number of expensive resize operations in a growing dictionary.
	 *
	 * Very large dictionaries (over 50K items) use doubling instead.
	 * This may help applications with severe memory constraints.
	 */</comment>
	<if>if <condition>(<expr>!(<name><name>mp</name>-&gt;<name>ma_used</name></name> &gt; <name>n_used</name> &amp;&amp; <name><name>mp</name>-&gt;<name>ma_fill</name></name>*3 &gt;= (<name><name>mp</name>-&gt;<name>ma_mask</name></name>+1)*2)</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>dictresize</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr>(<name><name>mp</name>-&gt;<name>ma_used</name></name> &gt; 50000 ? 2 : 4) * <name><name>mp</name>-&gt;<name>ma_used</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyDict_DelItem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_value</name></decl>, *<decl><type ref="prev"/><name>old_key</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>mp</name> = (<name>PyDictObject</name> *)<name>op</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_value</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_key_error</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>old_key</name> = <name><name>ep</name>-&gt;<name>me_key</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_key</name></name> = <name>dummy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_value</name> = <name><name>ep</name>-&gt;<name>me_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_value</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_used</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyDict_Clear</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>, *<decl><type ref="prev"/><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>table_is_malloced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fill</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name></type> <name><name>small_copy</name><index>[<expr><name>PyDict_MINSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>mp</name> = (<name>PyDictObject</name> *)<name>op</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><name>n</name> = <name><name>mp</name>-&gt;<name>ma_mask</name></name> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>table</name> = <name><name>mp</name>-&gt;<name>ma_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>table</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>table_is_malloced</name> = <name>table</name> != <name><name>mp</name>-&gt;<name>ma_smalltable</name></name></expr>;</expr_stmt>

	<comment type="block">/* This is delicate.  During the process of clearing the dict,
	 * decrefs can cause the dict to mutate.  To avoid fatal confusion
	 * (voice of experience), we have to make the dict empty before
	 * clearing the slots, and never refer to anything via mp-&gt;xxx while
	 * clearing.
	 */</comment>
	<expr_stmt><expr><name>fill</name> = <name><name>mp</name>-&gt;<name>ma_fill</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>table_is_malloced</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>EMPTY_TO_MINSIZE</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

	<else>else <if>if <condition>(<expr><name>fill</name> &gt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* It's a small table with something that needs to be cleared.
		 * Afraid the only safe way is to copy the dict entries into
		 * another small table first.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>small_copy</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>small_copy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>table</name> = <name>small_copy</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EMPTY_TO_MINSIZE</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<comment type="block">/* else it's a small table that's already empty */</comment>

	<comment type="block">/* Now we can finally clear things.  If C had refcounts, we could
	 * assert that the refcount on table is 1 now, i.e. that this function
	 * has unique access to it, so decref side-effects can't alter it.
	 */</comment>
	<for>for (<init><expr><name>ep</name> = <name>table</name></expr>;</init> <condition><expr><name>fill</name> &gt; 0</expr>;</condition> <incr><expr>++<name>ep</name></expr></incr>) <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &lt; <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr>--<name>fill</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
		<else>else
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_value</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></for>

	<if>if <condition>(<expr><name>table_is_malloced</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/*
 * Iterate over a dict.  Use like so:
 *
 *     Py_ssize_t i;
 *     PyObject *key, *value;
 *     i = 0;   # important!  i should not otherwise be changed by you
 *     while (PyDict_Next(yourdict, &amp;i, &amp;key, &amp;value)) {
 *              Refer to borrowed references in key and value.
 *     }
 *
 * CAUTION:  In general, it isn't safe to use PyDict_Next in a loop that
 * mutates the dict.  One exception:  it is safe if the loop merely changes
 * the values associated with the keys (but doesn't insert new keys or
 * delete keys), via PyDict_SetItem().
 */</comment>
<function><type><name>int</name></type>
<name>PyDict_Next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>ppos</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pkey</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pvalue</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>i</name> = *<name>ppos</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>ep</name> = ((<name>PyDictObject</name> *)<name>op</name>)-&gt;<name>ma_table</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = ((<name>PyDictObject</name> *)<name>op</name>)-&gt;<name>ma_mask</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> &lt;= <name>mask</name> &amp;&amp; <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name> == <name>NULL</name></expr>)</condition>
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
	<expr_stmt><expr>*<name>ppos</name> = <name>i</name>+1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &gt; <name>mask</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name>pkey</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>pkey</name> = <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_key</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>pvalue</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>pvalue</name> = <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name></expr>;</expr_stmt></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Internal version of PyDict_Next that returns a hash value in addition to the key and value.*/</comment>
<function><type><name>int</name></type>
<name>_PyDict_Next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>ppos</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pkey</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pvalue</name></decl></param>, <param><decl><type><name>long</name> *</type><name>phash</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>i</name> = *<name>ppos</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>ep</name> = ((<name>PyDictObject</name> *)<name>op</name>)-&gt;<name>ma_table</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = ((<name>PyDictObject</name> *)<name>op</name>)-&gt;<name>ma_mask</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> &lt;= <name>mask</name> &amp;&amp; <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name> == <name>NULL</name></expr>)</condition>
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
	<expr_stmt><expr>*<name>ppos</name> = <name>i</name>+1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &gt; <name>mask</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr>*<name>phash</name> = <call>(<name>long</name>)<argument_list>(<argument><expr><name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pkey</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>pkey</name> = <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_key</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>pvalue</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>pvalue</name> = <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name></expr>;</expr_stmt></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Methods */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dict_dealloc</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fill</name> <init>= <expr><name><name>mp</name>-&gt;<name>ma_fill</name></name></expr></init></decl>;</decl_stmt>
 	<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>Py_TRASHCAN_SAFE_BEGIN</name><argument_list>(<argument>mp</argument>)</argument_list></macro>
	<for>for (<init><expr><name>ep</name> = <name><name>mp</name>-&gt;<name>ma_table</name></name></expr>;</init> <condition><expr><name>fill</name> &gt; 0</expr>;</condition> <incr><expr><name>ep</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_key</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr>--<name>fill</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>ma_table</name></name> != <name><name>mp</name>-&gt;<name>ma_smalltable</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>ma_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>numfree</name> &lt; <name>PyDict_MAXFREELIST</name> &amp;&amp; <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call> == &amp;<name>PyDict_Type</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>free_list</name><index>[<expr><name>numfree</name>++</expr>]</index></name> = <name>mp</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>Py_TRASHCAN_SAFE_END</name><argument_list>(<argument>mp</argument>)</argument_list></macro>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dict_print</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>register</name> <name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>register</name> <name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>any</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>status</name> = <call><name>Py_ReprEnter</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>status</name> != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>status</name></expr>;</return></then></if>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"{...}"</expr></argument>)</argument_list></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"{"</expr></argument>)</argument_list></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>any</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name><name>mp</name>-&gt;<name>ma_mask</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name> <init>= <expr><name><name>mp</name>-&gt;<name>ma_table</name></name> + <name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>pvalue</name> <init>= <expr><name><name>ep</name>-&gt;<name>me_value</name></name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>pvalue</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* Prevent PyObject_Repr from deleting value during
			   key format */</comment>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>any</name>++ &gt; 0</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
				<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></decl>;</decl_stmt>
				<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>PyObject_Print</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name><name>ep</name>-&gt;<name>me_key</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>!=0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
			<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>": "</expr></argument>)</argument_list></decl>;</decl_stmt>
			<macro><name>Py_END_ALLOW_THREADS</name></macro>
			<if>if <condition>(<expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"}"</expr></argument>)</argument_list></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>mp</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_repr</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>temp</name></decl>, *<decl><type ref="prev"/><name>colon</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pieces</name> <init>= <expr><name>NULL</name></expr></init>, *<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = <call><name>Py_ReprEnter</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> != 0</expr>)</condition><then> <block>{
		<return>return <expr><name>i</name> &gt; 0 ? <call><name>PyString_FromString</name><argument_list>(<argument><expr>"{...}"</expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>ma_used</name></name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"{}"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>Done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>pieces</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pieces</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<expr_stmt><expr><name>colon</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>": "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>colon</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<comment type="block">/* Do repr() on each key+value pair, and insert ": " between them.
	   Note that repr may mutate the dict. */</comment>
	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>mp</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
		<comment type="block">/* Prevent repr from deleting value during key format. */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyString_Concat</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>colon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>Done</name>;</goto></then></if>
		<expr_stmt><expr><name>status</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* append created a new ref */</comment>
		<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
			<goto>goto <name>Done</name>;</goto></then></if>
	}</block></while>

	<comment type="block">/* Add "{}" decorations to the first and last items. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"{"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>temp</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"}"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>temp</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>temp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call> - 1</expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<comment type="block">/* Paste them all together with ", " between. */</comment>
	<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>_PyString_Join</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>Done</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>colon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>dict_length</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name><name>mp</name>-&gt;<name>ma_used</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_subscript</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>register</name> <name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>ma_table</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>v</name> = <name><name>ep</name>-&gt;<name>me_value</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* Look up __missing__ method if we're a subclass. */</comment>
		    	<decl_stmt><decl><type><name>PyObject</name> *</type><name>missing</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>missing_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>missing_str</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>missing_str</name> =
				  <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__missing__"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>missing</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>missing_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>missing</name> != <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>missing</name></expr></argument>,
					<argument><expr>(<name>PyObject</name> *)<name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>set_key_error</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dict_ass_sub</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>mp</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>mp</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>dict_as_mapping</name> <init>= <expr><block>{
	<expr>(<name>lenfunc</name>)<name>dict_length</name></expr>, <comment type="block">/*mp_length*/</comment>
	<expr>(<name>binaryfunc</name>)<name>dict_subscript</name></expr>, <comment type="block">/*mp_subscript*/</comment>
	<expr>(<name>objobjargproc</name>)<name>dict_ass_sub</name></expr>, <comment type="block">/*mp_ass_subscript*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_keys</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mask</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

  <label><name>again</name>:</label>
	<expr_stmt><expr><name>n</name> = <name><name>mp</name>-&gt;<name>ma_used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>n</name> != <name><name>mp</name>-&gt;<name>ma_used</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* Durnit.  The allocations caused the dict to resize.
		 * Just start over, this shouldn't normally happen.
		 */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>again</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>ep</name> = <name><name>mp</name>-&gt;<name>ma_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = <name><name>mp</name>-&gt;<name>ma_mask</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>mask</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name> <init>= <expr><name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_key</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>j</name> == <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_values</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mask</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

  <label><name>again</name>:</label>
	<expr_stmt><expr><name>n</name> = <name><name>mp</name>-&gt;<name>ma_used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>n</name> != <name><name>mp</name>-&gt;<name>ma_used</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* Durnit.  The allocations caused the dict to resize.
		 * Just start over, this shouldn't normally happen.
		 */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>again</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>ep</name> = <name><name>mp</name>-&gt;<name>ma_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = <name><name>mp</name>-&gt;<name>ma_mask</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>mask</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>j</name> == <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_items</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<comment type="block">/* Preallocate the list of tuples, to avoid allocations during
	 * the loop over the items, which could trigger GC, which
	 * could resize the dict. :-(
	 */</comment>
  <label><name>again</name>:</label>
	<expr_stmt><expr><name>n</name> = <name><name>mp</name>-&gt;<name>ma_used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>item</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr><name>n</name> != <name><name>mp</name>-&gt;<name>ma_used</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* Durnit.  The allocations caused the dict to resize.
		 * Just start over, this shouldn't normally happen.
		 */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>again</name>;</goto>
	}</block></then></if>
	<comment type="block">/* Nothing we do below makes any function calls. */</comment>
	<expr_stmt><expr><name>ep</name> = <name><name>mp</name>-&gt;<name>ma_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = <name><name>mp</name>-&gt;<name>ma_mask</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>mask</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>(<name>value</name>=<name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name>) != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>key</name> = <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_key</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>item</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>j</name> == <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_fromkeys</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>	<comment type="block">/* iter(seq) */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"fromkeys"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>d</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>mp</name> <init>= <expr>(<name>PyDictObject</name> *)<name>d</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>oldvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>dictresize</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<while>while <condition>(<expr><call><name>_PyDict_Next</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>oldvalue</name></expr></argument>, <argument><expr>&amp;<name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>insertdict</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></while>
		<return>return <expr><name>d</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyAnySet_CheckExact</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>mp</name> <init>= <expr>(<name>PyDictObject</name> *)<name>d</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>dictresize</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><call><name>PySet_GET_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<while>while <condition>(<expr><call><name>_PySet_NextEntry</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>insertdict</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></while>
		<return>return <expr><name>d</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then><block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<while>while <condition>(<expr>(<name>key</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
			<expr_stmt><expr><name>status</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
		}</block></while>
	}</block></then> <else>else <block>{
		<while>while <condition>(<expr>(<name>key</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
			<expr_stmt><expr><name>status</name> = <call><name>PyObject_SetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
		}</block></while>
	}</block></else></if>

	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<goto>goto <name>Fail</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>d</name></expr>;</return>

<label><name>Fail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dict_update_common</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>, <param><decl><type><name>char</name> *</type><name>methname</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>methname</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt></then>

	<else>else <if>if <condition>(<expr><name>arg</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"keys"</expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>PyDict_Merge</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>result</name> = <call><name>PyDict_MergeFromSeq2</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if></else></if>
	<if>if <condition>(<expr><name>result</name> == 0 &amp;&amp; <name>kwds</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>PyDict_Merge</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_update</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>dict_update_common</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"update"</expr></argument>)</argument_list></call> != -1</expr>)</condition><then>
		<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Update unconditionally replaces existing items.
   Merge has a 3rd argument 'override'; if set, it acts like Update,
   otherwise it leaves existing items unchanged.

   PyDict_{Update,Merge} update/merge from a mapping object.

   PyDict_MergeFromSeq2 updates/merges from any iterable object
   producing iterable objects of length 2.
*/</comment>

<function><type><name>int</name></type>
<name>PyDict_MergeFromSeq2</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>d</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>seq2</name></decl></param>, <param><decl><type><name>int</name></type> <name>override</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>	<comment type="block">/* iter(seq2) */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>	<comment type="block">/* index into seq2 of current element */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>	<comment type="block">/* seq2[i] */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>fast</name></decl>;</decl_stmt>	<comment type="block">/* item as a 2-tuple or 2-list */</comment>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>seq2</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fast</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
			<break>break;</break>
		}</block></then></if>

		<comment type="block">/* Convert item to sequence, and verify length 2. */</comment>
		<expr_stmt><expr><name>fast</name> = <call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fast</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"cannot convert dictionary update "
					"sequence element #%zd to a sequence"</expr></argument>,
					<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<goto>goto <name>Fail</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>n</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>fast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> != 2</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				     <argument><expr>"dictionary update sequence element #%zd "
				     "has length %zd; 2 is required"</expr></argument>,
				     <argument><expr><name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Fail</name>;</goto>
		}</block></then></if>

		<comment type="block">/* Update/merge with this (key, value) pair. */</comment>
		<expr_stmt><expr><name>key</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>fast</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>fast</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>override</name> || <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
	<goto>goto <name>Return</name>;</goto>
<label><name>Fail</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>fast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = -1</expr>;</expr_stmt>
<label><name>Return</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyDict_Update</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyDict_Merge</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyDict_Merge</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name></type> <name>override</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl>, *<decl><type ref="prev"/><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/* We accept for the argument either a concrete dictionary object,
	 * or an abstract "mapping" object.  For the former, we can do
	 * things quite efficiently.  For the latter, we only require that
	 * PyMapping_Keys() and PyObject_GetItem() be supported.
	 */</comment>
	<if>if <condition>(<expr><name>a</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> || <name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>mp</name> = (<name>PyDictObject</name>*)<name>a</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>other</name> = (<name>PyDictObject</name>*)<name>b</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>other</name> == <name>mp</name> || <name><name>other</name>-&gt;<name>ma_used</name></name> == 0</expr>)</condition><then>
			<comment type="block">/* a.update(a) or a.update({}); nothing to do */</comment>
			<return>return <expr>0</expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>ma_used</name></name> == 0</expr>)</condition><then>
			<comment type="block">/* Since the target dict is empty, PyDict_GetItem()
			 * always returns NULL.  Setting override to 1
			 * skips the unnecessary test.
			 */</comment>
			<expr_stmt><expr><name>override</name> = 1</expr>;</expr_stmt></then></if>
		<comment type="block">/* Do one big resize at the start, rather than
		 * incrementally resizing as we insert new items.  Expect
		 * that there will be no (or few) overlapping keys.
		 */</comment>
		<if>if <condition>(<expr>(<name><name>mp</name>-&gt;<name>ma_fill</name></name> + <name><name>other</name>-&gt;<name>ma_used</name></name>)*3 &gt;= (<name><name>mp</name>-&gt;<name>ma_mask</name></name>+1)*2</expr>)</condition><then> <block>{
		   <if>if <condition>(<expr><call><name>dictresize</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr>(<name><name>mp</name>-&gt;<name>ma_used</name></name> + <name><name>other</name>-&gt;<name>ma_used</name></name>)*2</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
			   <return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name><name>other</name>-&gt;<name>ma_mask</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>entry</name> = &amp;<name><name>other</name>-&gt;<name>ma_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>me_value</name></name> != <name>NULL</name> &amp;&amp;
			    (<name>override</name> ||
			     <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>me_key</name></name></expr></argument>)</argument_list></call> == <name>NULL</name>)</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>me_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>me_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>insertdict</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>me_key</name></name></expr></argument>,
					       <argument><expr>(<name>long</name>)<name><name>entry</name>-&gt;<name>me_hash</name></name></expr></argument>,
					       <argument><expr><name><name>entry</name>-&gt;<name>me_value</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
					<return>return <expr>-1</expr>;</return></then></if>
			}</block></then></if>
		}</block></for>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Do it the generic, slower way */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>keys</name> <init>= <expr><call><name>PyMapping_Keys</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>iter</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>keys</name> == <name>NULL</name></expr>)</condition><then>
			<comment type="block">/* Docstring says this is equivalent to E.keys() so
			 * if E doesn't have a .keys() method we want
			 * AttributeError to percolate up.  Might as well
			 * do the same for any other error.
			 */</comment>
			<return>return <expr>-1</expr>;</return></then></if>

		<expr_stmt><expr><name>iter</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>iter</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>

		<for>for (<init><expr><name>key</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>key</name></expr>;</condition> <incr><expr><name>key</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
			<if>if <condition>(<expr>!<name>override</name> &amp;&amp; <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<expr_stmt><expr><name>value</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>status</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<comment type="block">/* Iterator completed, via error */</comment>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_copy</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyDict_Copy</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>mp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyDict_Copy</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>copy</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>o</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>copy</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>copy</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyDict_Merge</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><name>copy</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type>
<name>PyDict_Size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>mp</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr>((<name>PyDictObject</name> *)<name>mp</name>)-&gt;<name>ma_used</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyDict_Keys</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>mp</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>dict_keys</name><argument_list>(<argument><expr>(<name>PyDictObject</name> *)<name>mp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyDict_Values</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>mp</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>dict_values</name><argument_list>(<argument><expr>(<name>PyDictObject</name> *)<name>mp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyDict_Items</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>mp</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>dict_items</name><argument_list>(<argument><expr>(<name>PyDictObject</name> *)<name>mp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Subroutine which returns the smallest key in a for which b's value
   is different or absent.  The value is returned too, through the
   pval argument.  Both are NULL if no key in a is found for which b's status
   differs.  The refcounts on (and only on) non-NULL *pval and function return
   values must be decremented by the caller (characterize() increments them
   to ensure that mutating comparison and PyDict_GetItem calls can't delete
   them before the caller is done looking at them). */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>characterize</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyDictObject</name> *</type><name>b</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pval</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>akey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* smallest key in a s.t. a[akey] != b[akey] */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>aval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* a[akey] */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name><name>a</name>-&gt;<name>ma_mask</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>thiskey</name></decl>, *<decl><type ref="prev"/><name>thisaval</name></decl>, *<decl><type ref="prev"/><name>thisbval</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ma_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name> == <name>NULL</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><name>thiskey</name> = <name><name>a</name>-&gt;<name>ma_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_key</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>thiskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* keep alive across compares */</comment>
		<if>if <condition>(<expr><name>akey</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>akey</name></expr></argument>, <argument><expr><name>thiskey</name></expr></argument>, <argument><expr><name>Py_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>thiskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>Fail</name>;</goto>
			}</block></then></if>
			<if>if <condition>(<expr><name>cmp</name> &gt; 0 ||
			    <name>i</name> &gt; <name><name>a</name>-&gt;<name>ma_mask</name></name> ||
			    <name><name>a</name>-&gt;<name>ma_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name> == <name>NULL</name></expr>)</condition><then>
			<block>{
				<comment type="block">/* Not the *smallest* a key; or maybe it is
				 * but the compare shrunk the dict so we can't
				 * find its associated value anymore; or
				 * maybe it is but the compare deleted the
				 * a[thiskey] entry.
				 */</comment>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>thiskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
		}</block></then></if>

		<comment type="block">/* Compare a[thiskey] to b[thiskey]; cmp &lt;- true iff equal. */</comment>
		<expr_stmt><expr><name>thisaval</name> = <name><name>a</name>-&gt;<name>ma_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>thisaval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>thisaval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* keep alive */</comment>
		<expr_stmt><expr><name>thisbval</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>b</name></expr></argument>, <argument><expr><name>thiskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>thisbval</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>cmp</name> = 0</expr>;</expr_stmt></then>
		<else>else <block>{
			<comment type="block">/* both dicts have thiskey:  same values? */</comment>
			<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(
						<argument><expr><name>thisaval</name></expr></argument>, <argument><expr><name>thisbval</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then> <block>{
		    		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>thiskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>thisaval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    		<goto>goto <name>Fail</name>;</goto>
			}</block></then></if>
		}</block></else></if>
		<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then> <block>{
			<comment type="block">/* New winner. */</comment>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>akey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>aval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>akey</name> = <name>thiskey</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>aval</name> = <name>thisaval</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>thiskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>thisaval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></for>
	<expr_stmt><expr>*<name>pval</name> = <name>aval</name></expr>;</expr_stmt>
	<return>return <expr><name>akey</name></expr>;</return>

<label><name>Fail</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>akey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>aval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>pval</name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dict_compare</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyDictObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>adiff</name></decl>, *<decl><type ref="prev"/><name>bdiff</name></decl>, *<decl><type ref="prev"/><name>aval</name></decl>, *<decl><type ref="prev"/><name>bval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<comment type="block">/* Compare lengths first */</comment>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ma_used</name></name> &lt; <name><name>b</name>-&gt;<name>ma_used</name></name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then>	<comment type="block">/* a is shorter */</comment>
	<else>else <if>if <condition>(<expr><name><name>a</name>-&gt;<name>ma_used</name></name> &gt; <name><name>b</name>-&gt;<name>ma_used</name></name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if></else></if>	<comment type="block">/* b is shorter */</comment>

	<comment type="block">/* Same length -- check all keys */</comment>
	<expr_stmt><expr><name>bdiff</name> = <name>bval</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>adiff</name> = <call><name>characterize</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>aval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>adiff</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>aval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Either an error, or a is a subset with the same length so
		 * must be equal.
		 */</comment>
		<expr_stmt><expr><name>res</name> = <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call> ? -1 : 0</expr>;</expr_stmt>
		<goto>goto <name>Finished</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>bdiff</name> = <call><name>characterize</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr>&amp;<name>bval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bdiff</name> == <name>NULL</name> &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>bval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = -1</expr>;</expr_stmt>
		<goto>goto <name>Finished</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bdiff</name></expr>)</condition><then> <block>{
		<comment type="block">/* bdiff == NULL "should be" impossible now, but perhaps
		 * the last comparison done by the characterize() on a had
		 * the side effect of making the dicts equal!
		 */</comment>
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_Compare</name><argument_list>(<argument><expr><name>adiff</name></expr></argument>, <argument><expr><name>bdiff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>res</name> == 0 &amp;&amp; <name>bval</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_Compare</name><argument_list>(<argument><expr><name>aval</name></expr></argument>, <argument><expr><name>bval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<label><name>Finished</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>adiff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bdiff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>aval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* Return 1 if dicts equal, 0 if not, -1 if error.
 * Gets out as soon as any difference is detected.
 * Uses only Py_EQ comparison.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dict_equal</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyDictObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ma_used</name></name> != <name><name>b</name>-&gt;<name>ma_used</name></name></expr>)</condition><then>
		<comment type="block">/* can't be equal if # of entries differ */</comment>
		<return>return <expr>0</expr>;</return></then></if>

	<comment type="block">/* Same # of entries -- check all of 'em.  Exit early on any diff. */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name><name>a</name>-&gt;<name>ma_mask</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>aval</name> <init>= <expr><name><name>a</name>-&gt;<name>ma_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>aval</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>bval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name> <init>= <expr><name><name>a</name>-&gt;<name>ma_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_key</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* temporarily bump aval's refcount to ensure it stays
			   alive until we're done with it */</comment>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>aval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* ditto for key */</comment>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bval</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>b</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>bval</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>aval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>aval</name></expr></argument>, <argument><expr><name>bval</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>aval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmp</name> &lt;= 0</expr>)</condition><then>  <comment type="block">/* error or not equal */</comment>
				<return>return <expr><name>cmp</name></expr>;</return></then></if>
 		}</block></then></if>
	}</block></for>
	<return>return <expr>1</expr>;</return>
 }</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name> || <name>op</name> == <name>Py_NE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>cmp</name> = <call><name>dict_equal</name><argument_list>(<argument><expr>(<name>PyDictObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyDictObject</name> *)<name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>res</name> = (<name>cmp</name> == (<name>op</name> == <name>Py_EQ</name>)) ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Py3K warning if comparison isn't == or !=  */</comment>
		<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"dict inequality comparisons not supported "
				   "in 3.x"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>res</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
 }</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_contains</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>me_value</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_has_key</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"dict.has_key() not supported in 3.x; "
			   "use the in operator"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>dict_contains</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_get</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>failobj</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"get"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>failobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>val</name> = <name><name>ep</name>-&gt;<name>me_value</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>val</name> = <name>failobj</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>val</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_setdefault</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>failobj</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"setdefault"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>failobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>val</name> = <name><name>ep</name>-&gt;<name>me_value</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>val</name> = <name>failobj</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>failobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>val</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>val</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_clear</name><parameter_list>(<param><decl><type><name>register</name> <name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_pop</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_value</name></decl>, *<decl><type ref="prev"/><name>old_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>deflt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if<condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"pop"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>deflt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>ma_used</name></name> == 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>deflt</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>deflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>deflt</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>,
				<argument><expr>"pop(): dictionary is empty"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_value</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>deflt</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>deflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>deflt</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>set_key_error</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>old_key</name> = <name><name>ep</name>-&gt;<name>me_key</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_key</name></name> = <name>dummy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_value</name> = <name><name>ep</name>-&gt;<name>me_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_value</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_used</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>old_value</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_popitem</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate the result tuple before checking the size.  Believe it
	 * or not, this allocation could trigger a garbage collection which
	 * could empty the dict, so if we checked the size first and that
	 * happened, the result would be an infinite loop (searching for an
	 * entry that no longer exists).  Note that the usual popitem()
	 * idiom is "while d: k, v = d.popitem()". so needing to throw the
	 * tuple away if the dict *is* empty isn't a significant
	 * inefficiency -- possible, but unlikely in practice.
	 */</comment>
	<expr_stmt><expr><name>res</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>ma_used</name></name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>,
				<argument><expr>"popitem(): dictionary is empty"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* Set ep to "the first" dict entry with a value.  We abuse the hash
	 * field of slot 0 to hold a search finger:
	 * If slot 0 has a value, use slot 0.
	 * Else slot 0 is being used to hold a search finger,
	 * and we use its hash value as the first index to look.
	 */</comment>
	<expr_stmt><expr><name>ep</name> = &amp;<name><name>mp</name>-&gt;<name>ma_table</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>me_value</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name> = <name><name>ep</name>-&gt;<name>me_hash</name></name></expr>;</expr_stmt>
		<comment type="block">/* The hash field may be a real hash value, or it may be a
		 * legit search finger, or it may be a once-legit search
		 * finger that's out of bounds now because it wrapped around
		 * or the table shrunk -- simply make sure it's in bounds now.
		 */</comment>
		<if>if <condition>(<expr><name>i</name> &gt; <name><name>mp</name>-&gt;<name>ma_mask</name></name> || <name>i</name> &lt; 1</expr>)</condition><then>
			<expr_stmt><expr><name>i</name> = 1</expr>;</expr_stmt></then></if>	<comment type="block">/* skip slot 0 */</comment>
		<while>while <condition>(<expr>(<name>ep</name> = &amp;<name><name>mp</name>-&gt;<name>ma_table</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<name>me_value</name> == <name>NULL</name></expr>)</condition> <block>{
			<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>i</name> &gt; <name><name>mp</name>-&gt;<name>ma_mask</name></name></expr>)</condition><then>
				<expr_stmt><expr><name>i</name> = 1</expr>;</expr_stmt></then></if>
		}</block></while>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ep</name>-&gt;<name>me_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>ep</name>-&gt;<name>me_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_key</name></name> = <name>dummy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ep</name>-&gt;<name>me_value</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_used</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mp</name>-&gt;<name>ma_table</name><index>[<expr>0</expr>]</index></name>.<name>me_value</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mp</name>-&gt;<name>ma_table</name><index>[<expr>0</expr>]</index></name>.<name>me_hash</name> = <name>i</name> + 1</expr>;</expr_stmt>  <comment type="block">/* next place to start */</comment>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dict_traverse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pv</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>pk</name></expr></argument>, <argument><expr>&amp;<name>pv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name>pk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dict_tp_clear</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>PyDictIterKey_Type</name></decl>;</decl_stmt> <comment type="block">/* Forward */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>PyDictIterValue_Type</name></decl>;</decl_stmt> <comment type="block">/* Forward */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>PyDictIterItem_Type</name></decl>;</decl_stmt> <comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>dictiter_new</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_iterkeys</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>dict</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>dictiter_new</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>&amp;<name>PyDictIterKey_Type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_itervalues</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>dict</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>dictiter_new</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>&amp;<name>PyDictIterValue_Type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_iteritems</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>dict</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>dictiter_new</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>&amp;<name>PyDictIterItem_Type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_sizeof</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>PyDictObject</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>mp</name>-&gt;<name>ma_table</name></name> != <name><name>mp</name>-&gt;<name>ma_smalltable</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <name>res</name> + (<name><name>mp</name>-&gt;<name>ma_mask</name></name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>PyDictEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>has_key__doc__</name></expr></argument>,
<argument><expr>"D.has_key(k) -&gt; True if D has a key k, else False"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>contains__doc__</name></expr></argument>,
<argument><expr>"D.__contains__(k) -&gt; True if D has a key k, else False"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getitem__doc__</name></expr></argument>, <argument><expr>"x.__getitem__(y) &lt;==&gt; x[y]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sizeof__doc__</name></expr></argument>,
<argument><expr>"D.__sizeof__() -&gt; size of D in memory, in bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>get__doc__</name></expr></argument>,
<argument><expr>"D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setdefault_doc__</name></expr></argument>,
<argument><expr>"D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pop__doc__</name></expr></argument>,
<argument><expr>"D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.\n\
If key is not found, d is returned if given, otherwise KeyError is raised"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>popitem__doc__</name></expr></argument>,
<argument><expr>"D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a\n\
2-tuple; but raise KeyError if D is empty."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>keys__doc__</name></expr></argument>,
<argument><expr>"D.keys() -&gt; list of D's keys"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>items__doc__</name></expr></argument>,
<argument><expr>"D.items() -&gt; list of D's (key, value) pairs, as 2-tuples"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>values__doc__</name></expr></argument>,
<argument><expr>"D.values() -&gt; list of D's values"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>update__doc__</name></expr></argument>,
<argument><expr>"D.update(E, **F) -&gt; None.  Update D from dict/iterable E and F.\n"
"If E has a .keys() method, does:     for k in E: D[k] = E[k]\n\
If E lacks .keys() method, does:     for (k, v) in E: D[k] = v\n\
In either case, this is followed by: for k in F: D[k] = F[k]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fromkeys__doc__</name></expr></argument>,
<argument><expr>"dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.\n\
v defaults to None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>clear__doc__</name></expr></argument>,
<argument><expr>"D.clear() -&gt; None.  Remove all items from D."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>copy__doc__</name></expr></argument>,
<argument><expr>"D.copy() -&gt; a shallow copy of D"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>iterkeys__doc__</name></expr></argument>,
<argument><expr>"D.iterkeys() -&gt; an iterator over the keys of D"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>itervalues__doc__</name></expr></argument>,
<argument><expr>"D.itervalues() -&gt; an iterator over the values of D"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>iteritems__doc__</name></expr></argument>,
<argument><expr>"D.iteritems() -&gt; an iterator over the (key, value) items of D"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>mapp_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__contains__"</expr>,<expr>(<name>PyCFunction</name>)<name>dict_contains</name></expr>,	<expr><name>METH_O</name> | <name>METH_COEXIST</name></expr>,
	 <expr><name>contains__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"__getitem__"</expr>, <expr>(<name>PyCFunction</name>)<name>dict_subscript</name></expr>,	<expr><name>METH_O</name> | <name>METH_COEXIST</name></expr>,
	 <expr><name>getitem__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"__sizeof__"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_sizeof</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>sizeof__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"has_key"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_has_key</name></expr>,      <expr><name>METH_O</name></expr>,
	 <expr><name>has_key__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"get"</expr>,         <expr>(<name>PyCFunction</name>)<name>dict_get</name></expr>,          <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>get__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"setdefault"</expr>,  <expr>(<name>PyCFunction</name>)<name>dict_setdefault</name></expr>,   <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>setdefault_doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"pop"</expr>,         <expr>(<name>PyCFunction</name>)<name>dict_pop</name></expr>,          <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>pop__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"popitem"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_popitem</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>popitem__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"keys"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_keys</name></expr>,		<expr><name>METH_NOARGS</name></expr>,
	<expr><name>keys__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"items"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_items</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>items__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"values"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_values</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>values__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"update"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_update</name></expr>,	<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
	 <expr><name>update__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"fromkeys"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_fromkeys</name></expr>,	<expr><name>METH_VARARGS</name> | <name>METH_CLASS</name></expr>,
	 <expr><name>fromkeys__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"clear"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_clear</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>clear__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"copy"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_copy</name></expr>,		<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>copy__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"iterkeys"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_iterkeys</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>iterkeys__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"itervalues"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_itervalues</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>itervalues__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"iteritems"</expr>,	<expr>(<name>PyCFunction</name>)<name>dict_iteritems</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <expr><name>iteritems__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>	<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Return 1 if `key` is in dict `op`, 0 if not, and -1 on error. */</comment>
<function><type><name>int</name></type>
<name>PyDict_Contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>mp</name> <init>= <expr>(<name>PyDictObject</name> *)<name>op</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ||
	    (<name>hash</name> = ((<name>PyStringObject</name> *) <name>key</name>)-&gt;<name>ob_shash</name>) == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hash</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hash</name> == -1</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ep</name> == <name>NULL</name> ? -1 : (<name><name>ep</name>-&gt;<name>me_value</name></name> != <name>NULL</name>)</expr>;</return>
}</block></function>

<comment type="block">/* Internal version of PyDict_Contains used when the hash value is already known */</comment>
<function><type><name>int</name></type>
<name>_PyDict_Contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>long</name></type> <name>hash</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>mp</name> <init>= <expr>(<name>PyDictObject</name> *)<name>op</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ep</name> = <call>(<name><name>mp</name>-&gt;<name>ma_lookup</name></name>)<argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ep</name> == <name>NULL</name> ? -1 : (<name><name>ep</name>-&gt;<name>me_value</name></name> != <name>NULL</name>)</expr>;</return>
}</block></function>

<comment type="block">/* Hack to implement "key in dict" */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>dict_as_sequence</name> <init>= <expr><block>{
	<expr>0</expr>,			<comment type="block">/* sq_length */</comment>
	<expr>0</expr>,			<comment type="block">/* sq_concat */</comment>
	<expr>0</expr>,			<comment type="block">/* sq_repeat */</comment>
	<expr>0</expr>,			<comment type="block">/* sq_item */</comment>
	<expr>0</expr>,			<comment type="block">/* sq_slice */</comment>
	<expr>0</expr>,			<comment type="block">/* sq_ass_item */</comment>
	<expr>0</expr>,			<comment type="block">/* sq_ass_slice */</comment>
	<expr><name>PyDict_Contains</name></expr>,	<comment type="block">/* sq_contains */</comment>
	<expr>0</expr>,			<comment type="block">/* sq_inplace_concat */</comment>
	<expr>0</expr>,			<comment type="block">/* sq_inplace_repeat */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> != <name>NULL</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_alloc</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>self</name> = <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>d</name> <init>= <expr>(<name>PyDictObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* It's guaranteed that tp-&gt;alloc zeroed out the struct. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>ma_table</name></name> == <name>NULL</name> &amp;&amp; <name><name>d</name>-&gt;<name>ma_fill</name></name> == 0 &amp;&amp; <name><name>d</name>-&gt;<name>ma_used</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INIT_NONZERO_DICT_SLOTS</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name>-&gt;<name>ma_lookup</name></name> = <name>lookdict_string</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_CONVERSION_COUNTS</name></cpp:ifdef>
		<expr_stmt><expr>++<name>created</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dict_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>dict_update_common</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"dict"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_iter</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>dict</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>dictiter_new</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>&amp;<name>PyDictIterKey_Type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>dictionary_doc</name></expr></argument>,
<argument><expr>"dict() -&gt; new empty dictionary.\n"
"dict(mapping) -&gt; new dictionary initialized from a mapping object's\n"
"    (key, value) pairs.\n"
"dict(seq) -&gt; new dictionary initialized as if via:\n"
"    d = {}\n"
"    for k, v in seq:\n"
"        d[k] = v\n"
"dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs\n"
"    in the keyword argument list.  For example:  dict(one=1, two=2)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyDict_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"dict"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyDictObject</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr>0</expr>,
	<expr>(<name>destructor</name>)<name>dict_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>(<name>printfunc</name>)<name>dict_print</name></expr>,			<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>(<name>cmpfunc</name>)<name>dict_compare</name></expr>,			<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>dict_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>dict_as_sequence</name></expr>,			<comment type="block">/* tp_as_sequence */</comment>
	<expr>&amp;<name>dict_as_mapping</name></expr>,			<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>PyObject_HashNotImplemented</name></expr>,	<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
		<name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_DICT_SUBCLASS</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>dictionary_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr><name>dict_traverse</name></expr>,				<comment type="block">/* tp_traverse */</comment>
	<expr><name>dict_tp_clear</name></expr>,				<comment type="block">/* tp_clear */</comment>
	<expr><name>dict_richcompare</name></expr>,			<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>(<name>getiterfunc</name>)<name>dict_iter</name></expr>,			<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>mapp_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr><name>dict_init</name></expr>,				<comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,			<comment type="block">/* tp_alloc */</comment>
	<expr><name>dict_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_GC_Del</name></expr>,        		<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* For backward compatibility with old dictionary interface */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyDict_GetItemString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>kv</name></decl>, *<decl><type ref="prev"/><name>rv</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>kv</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>kv</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>rv</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyDict_SetItemString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>kv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>kv</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>kv</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* XXX Should we really? */</comment>
	<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>kv</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyDict_DelItemString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>kv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>kv</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>kv</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>err</name> = <call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* Dictionary iterator types */</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyDictObject</name> *</type><name>di_dict</name></decl>;</decl_stmt> <comment type="block">/* Set to NULL when iterator is exhausted */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>di_used</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>di_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>di_result</name></decl>;</decl_stmt> <comment type="block">/* reusable result tuple for iteritems */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block></struct></type> <name>dictiterobject</name>;</typedef>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dictiter_new</name><parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>itertype</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>dictiterobject</name> *</type><name>di</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>di</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>dictiterobject</name></expr></argument>, <argument><expr><name>itertype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>di</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>di_dict</name></name> = <name>dict</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>di_used</name></name> = <name><name>dict</name>-&gt;<name>ma_used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>di_pos</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>len</name></name> = <name><name>dict</name>-&gt;<name>ma_used</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>itertype</name> == &amp;<name>PyDictIterItem_Type</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>di</name>-&gt;<name>di_result</name></name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>di</name>-&gt;<name>di_result</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else
		<expr_stmt><expr><name><name>di</name>-&gt;<name>di_result</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
	<return>return <expr>(<name>PyObject</name> *)<name>di</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dictiter_dealloc</name><parameter_list>(<param><decl><type><name>dictiterobject</name> *</type><name>di</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>di</name>-&gt;<name>di_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>di</name>-&gt;<name>di_result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dictiter_len</name><parameter_list>(<param><decl><type><name>dictiterobject</name> *</type><name>di</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>di</name>-&gt;<name>di_dict</name></name> != <name>NULL</name> &amp;&amp; <name><name>di</name>-&gt;<name>di_used</name></name> == <name><name>di</name>-&gt;<name>di_dict</name>-&gt;<name>ma_used</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>len</name> = <name><name>di</name>-&gt;<name>len</name></name></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyInt_FromSize_t</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>length_hint_doc</name></expr></argument>, <argument><expr>"Private method returning an estimate of len(list(it))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>dictiter_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__length_hint__"</expr>, <expr>(<name>PyCFunction</name>)<name>dictiter_len</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>length_hint_doc</name></expr>}</block></expr>,
 	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>dictiter_iternextkey</name><parameter_list>(<param><decl><type><name>dictiterobject</name> *</type><name>di</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>d</name> <init>= <expr><name><name>di</name>-&gt;<name>di_dict</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>di</name>-&gt;<name>di_used</name></name> != <name><name>d</name>-&gt;<name>ma_used</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"dictionary changed size during iteration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>di</name>-&gt;<name>di_used</name></name> = -1</expr>;</expr_stmt> <comment type="block">/* Make this state sticky */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>i</name> = <name><name>di</name>-&gt;<name>di_pos</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><name>ep</name> = <name><name>d</name>-&gt;<name>ma_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = <name><name>d</name>-&gt;<name>ma_mask</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> &lt;= <name>mask</name> &amp;&amp; <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name> == <name>NULL</name></expr>)</condition>
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>di_pos</name></name> = <name>i</name>+1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &gt; <name>mask</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>len</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><name>key</name> = <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_key</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>key</name></expr>;</return>

<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>di_dict</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyDictIterKey_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"dictionary-keyiterator"</expr>,		<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>dictiterobject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>dictiter_dealloc</name></expr>, 		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,			<comment type="block">/* tp_flags */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_doc */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr><name>PyObject_SelfIter</name></expr>,			<comment type="block">/* tp_iter */</comment>
	<expr>(<name>iternextfunc</name>)<name>dictiter_iternextkey</name></expr>,	<comment type="block">/* tp_iternext */</comment>
	<expr><name>dictiter_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>dictiter_iternextvalue</name><parameter_list>(<param><decl><type><name>dictiterobject</name> *</type><name>di</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>d</name> <init>= <expr><name><name>di</name>-&gt;<name>di_dict</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>di</name>-&gt;<name>di_used</name></name> != <name><name>d</name>-&gt;<name>ma_used</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"dictionary changed size during iteration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>di</name>-&gt;<name>di_used</name></name> = -1</expr>;</expr_stmt> <comment type="block">/* Make this state sticky */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>i</name> = <name><name>di</name>-&gt;<name>di_pos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = <name><name>d</name>-&gt;<name>ma_mask</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt; <name>mask</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><name>ep</name> = <name><name>d</name>-&gt;<name>ma_table</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>value</name>=<name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name>) == <name>NULL</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> &gt; <name>mask</name></expr>)</condition><then>
			<goto>goto <name>fail</name>;</goto></then></if>
	}</block></while>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>di_pos</name></name> = <name>i</name>+1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>len</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>value</name></expr>;</return>

<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>di_dict</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyDictIterValue_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"dictionary-valueiterator"</expr>,		<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>dictiterobject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>dictiter_dealloc</name></expr>, 		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,			<comment type="block">/* tp_flags */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_doc */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr><name>PyObject_SelfIter</name></expr>,			<comment type="block">/* tp_iter */</comment>
	<expr>(<name>iternextfunc</name>)<name>dictiter_iternextvalue</name></expr>,	<comment type="block">/* tp_iternext */</comment>
	<expr><name>dictiter_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>dictiter_iternextitem</name><parameter_list>(<param><decl><type><name>dictiterobject</name> *</type><name>di</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>result</name> <init>= <expr><name><name>di</name>-&gt;<name>di_result</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyDictEntry</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>d</name> <init>= <expr><name><name>di</name>-&gt;<name>di_dict</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>di</name>-&gt;<name>di_used</name></name> != <name><name>d</name>-&gt;<name>ma_used</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"dictionary changed size during iteration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>di</name>-&gt;<name>di_used</name></name> = -1</expr>;</expr_stmt> <comment type="block">/* Make this state sticky */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>i</name> = <name><name>di</name>-&gt;<name>di_pos</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><name>ep</name> = <name><name>d</name>-&gt;<name>ma_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> = <name><name>d</name>-&gt;<name>ma_mask</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> &lt;= <name>mask</name> &amp;&amp; <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name> == <name>NULL</name></expr>)</condition>
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>di_pos</name></name> = <name>i</name>+1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &gt; <name>mask</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>

	<if>if <condition>(<expr><name><name>result</name>-&gt;<name>ob_refcnt</name></name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></else></if>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>len</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><name>key</name> = <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>value</name> = <name><name>ep</name><index>[<expr><name>i</name></expr>]</index></name>.<name>me_value</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>

<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>di</name>-&gt;<name>di_dict</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyDictIterItem_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"dictionary-itemiterator"</expr>,		<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>dictiterobject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>dictiter_dealloc</name></expr>, 		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,			<comment type="block">/* tp_flags */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_doc */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr><name>PyObject_SelfIter</name></expr>,			<comment type="block">/* tp_iter */</comment>
	<expr>(<name>iternextfunc</name>)<name>dictiter_iternextitem</name></expr>,	<comment type="block">/* tp_iternext */</comment>
	<expr><name>dictiter_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
