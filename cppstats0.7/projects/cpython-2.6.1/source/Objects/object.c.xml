<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/object.c">
<comment type="block">/* Generic object operations; and implementation of None (NoObject) */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_REF_DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>_Py_RefTotal</name></decl>;</decl_stmt>

<function><type><name>Py_ssize_t</name></type>
<name>_Py_GetRefTotal</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>total</name> <init>= <expr><name>_Py_RefTotal</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* ignore the references to the dummy object of the dicts and sets
           because they are not reliable and not useful (now that the
           hash table code is well-tested) */</comment>
	<expr_stmt><expr><name>o</name> = <call><name>_PyDict_Dummy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>o</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>total</name> -= <name><name>o</name>-&gt;<name>ob_refcnt</name></name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>o</name> = <call><name>_PySet_Dummy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>o</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>total</name> -= <name><name>o</name>-&gt;<name>ob_refcnt</name></name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>total</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_REF_DEBUG */</comment>

<decl_stmt><decl><type><name>int</name></type> <name>Py_DivisionWarningFlag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Py_Py3kWarningFlag</name></decl>;</decl_stmt>

<comment type="block">/* Object allocation routines used by NEWOBJ and NEWVAROBJ macros.
   These are used by the individual routines for object creation.
   Do not call them otherwise, they do not initialize the object! */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TRACE_REFS</name></cpp:ifdef>
<comment type="block">/* Head of circular doubly-linked list of all objects.  These are linked
 * together via the _ob_prev and _ob_next members of a PyObject, which
 * exist only in a Py_TRACE_REFS build.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name></type> <name>refchain</name> <init>= <expr><block>{<expr>&amp;<name>refchain</name></expr>, <expr>&amp;<name>refchain</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Insert op at the front of the list of all objects.  If force is true,
 * op is added even if _ob_prev and _ob_next are non-NULL already.  If
 * force is false amd _ob_prev or _ob_next are non-NULL, do nothing.
 * force should be true if and only if op points to freshly allocated,
 * uninitialized memory, or you've unlinked op from the list and are
 * relinking it into the front.
 * Note that objects are normally added to the list via _Py_NewReference,
 * which is called by PyObject_Init.  Not all objects are initialized that
 * way, though; exceptions include statically allocated type objects, and
 * statically allocated singletons (like Py_True and Py_None).
 */</comment>
<function><type><name>void</name></type>
<name>_Py_AddToAllObjects</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>int</name></type> <name>force</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>  <name>Py_DEBUG</name></cpp:ifdef>
	<if>if <condition>(<expr>!<name>force</name></expr>)</condition><then> <block>{
		<comment type="block">/* If it's initialized memory, op must be in or out of
		 * the list unambiguously.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name><name>op</name>-&gt;<name>_ob_prev</name></name> == <name>NULL</name>) == (<name><name>op</name>-&gt;<name>_ob_next</name></name> == <name>NULL</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>force</name> || <name><name>op</name>-&gt;<name>_ob_prev</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>op</name>-&gt;<name>_ob_next</name></name> = <name><name>refchain</name>.<name>_ob_next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name>-&gt;<name>_ob_prev</name></name> = &amp;<name>refchain</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refchain</name>.<name>_ob_next</name>-&gt;<name>_ob_prev</name></name> = <name>op</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refchain</name>.<name>_ob_next</name></name> = <name>op</name></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* Py_TRACE_REFS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name> *</type><name>type_list</name></decl>;</decl_stmt>
<comment type="block">/* All types are added to type_list, at least when
   they get one object created. That makes them
   immortal, which unfortunately contributes to
   garbage itself. If unlist_types_without_objects
   is set, they will be removed from the type_list
   once the last object is deallocated. */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>unlist_types_without_objects</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>tuple_zero_allocs</name></decl>, <decl><type ref="prev"/><name>fast_tuple_allocs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>quick_int_allocs</name></decl>, <decl><type ref="prev"/><name>quick_neg_int_allocs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>null_strings</name></decl>, <decl><type ref="prev"/><name>one_strings</name></decl>;</decl_stmt>
<function><type><name>void</name></type>
<name>dump_counts</name><parameter_list>(<param><decl><type><name>FILE</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>tp</name> = <name>type_list</name></expr>;</init> <condition><expr><name>tp</name></expr>;</condition> <incr><expr><name>tp</name> = <name><name>tp</name>-&gt;<name>tp_next</name></name></expr></incr>)
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"%s alloc'd: %d, freed: %d, max in use: %d\n"</expr></argument>,
			<argument><expr><name><name>tp</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><name><name>tp</name>-&gt;<name>tp_allocs</name></name></expr></argument>, <argument><expr><name><name>tp</name>-&gt;<name>tp_frees</name></name></expr></argument>,
			<argument><expr><name><name>tp</name>-&gt;<name>tp_maxalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"fast tuple allocs: %d, empty: %d\n"</expr></argument>,
		<argument><expr><name>fast_tuple_allocs</name></expr></argument>, <argument><expr><name>tuple_zero_allocs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"fast int allocs: pos: %d, neg: %d\n"</expr></argument>,
		<argument><expr><name>quick_int_allocs</name></expr></argument>, <argument><expr><name>quick_neg_int_allocs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"null strings: %d, 1-strings: %d\n"</expr></argument>,
		<argument><expr><name>null_strings</name></expr></argument>, <argument><expr><name>one_strings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>get_counts</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>tp</name> = <name>type_list</name></expr>;</init> <condition><expr><name>tp</name></expr>;</condition> <incr><expr><name>tp</name> = <name><name>tp</name>-&gt;<name>tp_next</name></name></expr></incr>) <block>{
		<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(snnn)"</expr></argument>, <argument><expr><name><name>tp</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><name><name>tp</name>-&gt;<name>tp_allocs</name></name></expr></argument>,
				  <argument><expr><name><name>tp</name>-&gt;<name>tp_frees</name></name></expr></argument>, <argument><expr><name><name>tp</name>-&gt;<name>tp_maxalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>inc_count</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_next</name></name> == <name>NULL</name> &amp;&amp; <name><name>tp</name>-&gt;<name>tp_prev</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* first time; insert in linked list */</comment>
		<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_next</name></name> != <name>NULL</name></expr>)</condition><then> <comment type="block">/* sanity check */</comment>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"XXX inc_count sanity check"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>type_list</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>type_list</name>-&gt;<name>tp_prev</name></name> = <name>tp</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name><name>tp</name>-&gt;<name>tp_next</name></name> = <name>type_list</name></expr>;</expr_stmt>
		<comment type="block">/* Note that as of Python 2.2, heap-allocated type objects
		 * can go away, but this code requires that they stay alive
		 * until program exit.  That's why we're careful with
		 * refcounts here.  type_list gets a new reference to tp,
		 * while ownership of the reference type_list used to hold
		 * (if any) was transferred to tp-&gt;tp_next in the line above.
		 * tp is thus effectively immortal after this.
		 */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>type_list</name> = <name>tp</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TRACE_REFS</name></cpp:ifdef>
		<comment type="block">/* Also insert in the doubly-linked list of all objects,
		 * if not already there.
		 */</comment>
		<expr_stmt><expr><call><name>_Py_AddToAllObjects</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>tp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
	<expr_stmt><expr><name><name>tp</name>-&gt;<name>tp_allocs</name></name>++</expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_allocs</name></name> - <name><name>tp</name>-&gt;<name>tp_frees</name></name> &gt; <name><name>tp</name>-&gt;<name>tp_maxalloc</name></name></expr>)</condition><then>
		<expr_stmt><expr><name><name>tp</name>-&gt;<name>tp_maxalloc</name></name> = <name><name>tp</name>-&gt;<name>tp_allocs</name></name> - <name><name>tp</name>-&gt;<name>tp_frees</name></name></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type> <name>dec_count</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name><name>tp</name>-&gt;<name>tp_frees</name></name>++</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>unlist_types_without_objects</name> &amp;&amp;
	    <name><name>tp</name>-&gt;<name>tp_allocs</name></name> == <name><name>tp</name>-&gt;<name>tp_frees</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* unlink the type from type_list */</comment>
		<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_prev</name></name></expr>)</condition><then>
			<expr_stmt><expr><name><name>tp</name>-&gt;<name>tp_prev</name>-&gt;<name>tp_next</name></name> = <name><name>tp</name>-&gt;<name>tp_next</name></name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>type_list</name> = <name><name>tp</name>-&gt;<name>tp_next</name></name></expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_next</name></name></expr>)</condition><then>
			<expr_stmt><expr><name><name>tp</name>-&gt;<name>tp_next</name>-&gt;<name>tp_prev</name></name> = <name><name>tp</name>-&gt;<name>tp_prev</name></name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name><name>tp</name>-&gt;<name>tp_next</name></name> = <name><name>tp</name>-&gt;<name>tp_prev</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_REF_DEBUG</name></cpp:ifdef>
<comment type="block">/* Log a fatal error; doesn't return. */</comment>
<function><type><name>void</name></type>
<name>_Py_NegativeRefcount</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>300</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		      <argument><expr>"%s:%i object at %p has negative ref count "
		      "%" <name>PY_FORMAT_SIZE_T</name> "d"</expr></argument>,
		      <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>op</name>-&gt;<name>ob_refcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_REF_DEBUG */</comment>

<function><type><name>void</name></type>
<name>Py_IncRef</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>Py_DecRef</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_Init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<comment type="block">/* Any changes should be reflected in PyObject_INIT (objimpl.h) */</comment>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> = <name>tp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>op</name></expr>;</return>
}</block></function>

<function><type><name>PyVarObject</name> *</type>
<name>PyObject_InitVar</name><parameter_list>(<param><decl><type><name>PyVarObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(<name>PyVarObject</name> *) <call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<comment type="block">/* Any changes should be reflected in PyObject_INIT_VAR */</comment>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_size</name></name> = <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> = <name>tp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>op</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyObject_New</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>op</name> = (<name>PyObject</name> *) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><call><name>_PyObject_SIZE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyVarObject</name> *</type>
<name>_PyObject_NewVar</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>nitems</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyVarObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><call><name>_PyObject_VAR_SIZE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>op</name> = (<name>PyVarObject</name> *) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(<name>PyVarObject</name> *)<call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyObject_INIT_VAR</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* for binary compatibility with 2.2 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_PyObject_Del</name></cpp:undef>
<function><type><name>void</name></type>
<name>_PyObject_Del</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Implementation of PyObject_Print with recursion checking */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_print</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>, <param><decl><type><name>int</name></type> <name>nesting</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>nesting</name> &gt; 10</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"print recursion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_STACKCHECK</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyOS_CheckStack</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"stack overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Clear any previous error condition */</comment>
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"&lt;nil&gt;"</expr></argument>)</argument_list></decl>;</decl_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><name><name>op</name>-&gt;<name>ob_refcnt</name></name> &lt;= 0</expr>)</condition><then>
			<comment type="block">/* XXX(twouters) cast refcount to long until %zd is
			   universally available */</comment>
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
			<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"&lt;refcnt %ld at %p&gt;"</expr></argument>,
				<argument><expr>(<name>long</name>)<name><name>op</name>-&gt;<name>ob_refcnt</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></decl>;</decl_stmt></then></if>
			<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<else>else <if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_print</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>flags</name> &amp; <name>Py_PRINT_RAW</name></expr>)</condition><then>
				<expr_stmt><expr><name>s</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>s</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = -1</expr>;</expr_stmt></then>
			<else>else <block>{
				<expr_stmt><expr><name>ret</name> = <call><name>internal_print</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>Py_PRINT_RAW</name></expr></argument>,
						     <argument><expr><name>nesting</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>ret</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_print</name>)(<name>op</name>, <name>fp</name>, <name>flags</name>)</expr>;</expr_stmt></else></if></else>
	}</block></else></if>
	<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = -1</expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_Print</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>internal_print</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* For debugging convenience.  See Misc/gdbinit for some useful gdb hooks */</comment>
<function><type><name>void</name></type> <name>_PyObject_Dump</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"NULL\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"object  : "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>)<call><name>PyObject_Print</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* XXX(twouters) cast refcount to long until %zd is
		   universally available */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"\n"
			"type    : %s\n"
			"refcount: %ld\n"
			"address : %p\n"</expr></argument>,
			<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>==<name>NULL</name> ? "NULL" : <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
			<argument><expr>(<name>long</name>)<name><name>op</name>-&gt;<name>ob_refcnt</name></name></expr></argument>,
			<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_Repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_STACKCHECK</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyOS_CheckStack</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"stack overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"&lt;NULL&gt;"</expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_repr</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s object at %p&gt;"</expr></argument>,
					   <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_repr</name>)(<name>v</name>)</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name>*</type> <name>str</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>str</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>str</name></expr>)</condition><then>
				<expr_stmt><expr><name>res</name> = <name>str</name></expr>;</expr_stmt></then>
			<else>else
				<return>return <expr><name>NULL</name></expr>;</return></else></if>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"__repr__ returned non-string (type %.200s)"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></else></if></else></if>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyObject_Str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>type_ok</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"&lt;NULL&gt;"</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_str</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* It is possible for a type to have a tp_str representation that loops
	   infinitely. */</comment>
	<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" while getting the str of an object"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_str</name>)(<name>v</name>)</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>type_ok</name> = <call><name>PyString_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr_stmt><expr><name>type_ok</name> = <name>type_ok</name> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>!<name>type_ok</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"__str__ returned non-string (type %.200s)"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_Str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>_PyObject_Str</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name>*</type> <name>str</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>str</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>str</name></expr>)</condition><then>
			<expr_stmt><expr><name>res</name> = <name>str</name></expr>;</expr_stmt></then>
		<else>else
		    	<return>return <expr><name>NULL</name></expr>;</return></else></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<function><type><name>PyObject</name> *</type>
<name>PyObject_Unicode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>unicode_method_found</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>unicodestr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"&lt;NULL&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>str</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then></if></else></if>

	<comment type="block">/* Try the __unicode__ method */</comment>
	<if>if <condition>(<expr><name>unicodestr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>unicodestr</name>= <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__unicode__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>unicodestr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* We're an instance of a classic class */</comment>
		<comment type="block">/* Try __unicode__ from the instance -- alas we have no type */</comment>
		<expr_stmt><expr><name>func</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>unicodestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>unicode_method_found</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
		}</block></else></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Not a classic class instance, try __unicode__ from type */</comment>
		<comment type="block">/* _PyType_Lookup doesn't create a reference */</comment>
		<expr_stmt><expr><name>func</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>unicodestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>unicode_method_found</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></else></if>

	<comment type="block">/* Didn't find __unicode__ */</comment>
	<if>if <condition>(<expr>!<name>unicode_method_found</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* For a Unicode subtype that's didn't overwrite __unicode__,
			   return a true Unicode object with the same data. */</comment>
			<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
						     <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> = <name>v</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_str</name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>res</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_str</name>)(<name>v</name>)</expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>res</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		}</block></else></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = <name>str</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Helper to warn about deprecated tp_compare return values.  Return:
   -2 for an exception;
   -1 if v &lt;  w;
    0 if v == w;
    1 if v  &gt; w.
   (This function cannot return 2.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>adjust_tp_compare</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>c</name> != -1 &amp;&amp; <name>c</name> != -2</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
				       <argument><expr>"tp_compare didn't return -1 or -2 "
				       "for exception"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else
				<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		}</block></then></if>
		<return>return <expr>-2</expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>c</name> &lt; -1 || <name>c</name> &gt; 1</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
			       <argument><expr>"tp_compare didn't return -1, 0 or 1"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-2</expr>;</return></then>
		<else>else
			<return>return <expr><name>c</name> &lt; -1 ? -1 : 1</expr>;</return></else></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> &gt;= -1 &amp;&amp; <name>c</name> &lt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>c</name></expr>;</return>
	}</block></else></if></else></if>
}</block></function>


<comment type="block">/* Macro to get the tp_richcompare field of a type if defined */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RICHCOMPARE</name><parameter_list>(<param><type><name>t</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(PyType_HasFeature((t), Py_TPFLAGS_HAVE_RICHCOMPARE) \
                         ? (t)-&gt;tp_richcompare : NULL)</cpp:value></cpp:define>

<comment type="block">/* Map rich comparison operators to their swapped version, e.g. LT --&gt; GT */</comment>
<decl_stmt><decl><type><name>int</name></type> <name><name>_Py_SwappedOp</name><index>[]</index></name> <init>= <expr><block>{<expr><name>Py_GT</name></expr>, <expr><name>Py_GE</name></expr>, <expr><name>Py_EQ</name></expr>, <expr><name>Py_NE</name></expr>, <expr><name>Py_LT</name></expr>, <expr><name>Py_LE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Try a genuine rich comparison, returning an object.  Return:
   NULL for exception;
   NotImplemented if this particular rich comparison is not implemented or
     undefined;
   some object not equal to NotImplemented if it is implemented
     (this latter object may not be a Boolean).
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>try_rich_compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>richcmpfunc</name></type> <name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name></name> != <name><name>w</name>-&gt;<name>ob_type</name></name> &amp;&amp;
	    <call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call> &amp;&amp;
	    (<name>f</name> = <call><name>RICHCOMPARE</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call>(*<name>f</name>)<argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>_Py_SwappedOp</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>res</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>f</name> = <call><name>RICHCOMPARE</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call>(*<name>f</name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
			<return>return <expr><name>res</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>f</name> = <call><name>RICHCOMPARE</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><call>(*<name>f</name>)<argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>_Py_SwappedOp</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>res</name> = <name>Py_NotImplemented</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* Try a genuine rich comparison, returning an int.  Return:
   -1 for exception (including the case where try_rich_compare() returns an
      object that's not a Boolean);
    0 if the outcome is false;
    1 if the outcome is true;
    2 if this particular rich comparison is not implemented or undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>try_rich_compare_bool</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>RICHCOMPARE</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call> == <name>NULL</name> &amp;&amp; <call><name>RICHCOMPARE</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>2</expr>;</return></then></if> <comment type="block">/* Shortcut, avoid INCREF+DECREF */</comment>
	<expr_stmt><expr><name>res</name> = <call><name>try_rich_compare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>res</name> == <name>Py_NotImplemented</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>2</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/* Try rich comparisons to determine a 3-way comparison.  Return:
   -2 for an exception;
   -1 if v  &lt; w;
    0 if v == w;
    1 if v  &gt; w;
    2 if this particular rich comparison is not implemented or undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>try_rich_to_3way_compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<struct><specifier>static</specifier> struct <block>{ <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>outcome</name></decl>;</decl_stmt> }</block> <decl><name><name>tries</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{
		<comment type="block">/* Try this operator, and if it is true, use this outcome: */</comment>
		<expr><block>{<expr><name>Py_EQ</name></expr>, <expr>0</expr>}</block></expr>,
		<expr><block>{<expr><name>Py_LT</name></expr>, <expr>-1</expr>}</block></expr>,
		<expr><block>{<expr><name>Py_GT</name></expr>, <expr>1</expr>}</block></expr>,
	}</block></expr></init></decl>;</struct>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>RICHCOMPARE</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call> == <name>NULL</name> &amp;&amp; <call><name>RICHCOMPARE</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>2</expr>;</return></then></if> <comment type="block">/* Shortcut */</comment>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<switch>switch <condition>(<expr><call><name>try_rich_compare_bool</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name><name>tries</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<case>case <expr>-1</expr>:
			<return>return <expr>-2</expr>;</return>
		</case><case>case <expr>1</expr>:
			<return>return <expr><name><name>tries</name><index>[<expr><name>i</name></expr>]</index></name>.<name>outcome</name></expr>;</return>
		</case>}</block></switch>
	}</block></for>

	<return>return <expr>2</expr>;</return>
}</block></function>

<comment type="block">/* Try a 3-way comparison, returning an int.  Return:
   -2 for an exception;
   -1 if v &lt;  w;
    0 if v == w;
    1 if v  &gt; w;
    2 if this particular 3-way comparison is not implemented or undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>try_3way_compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cmpfunc</name></type> <name>f</name></decl>;</decl_stmt>

	<comment type="block">/* Comparisons involving instances are given to instance_compare,
	   which has the same return conventions as this function. */</comment>

	<expr_stmt><expr><name>f</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_compare</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call>(*<name>f</name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call>(*<name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_compare</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* If both have the same (non-NULL) tp_compare, use it. */</comment>
	<if>if <condition>(<expr><name>f</name> != <name>NULL</name> &amp;&amp; <name>f</name> == <name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_compare</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call>(*<name>f</name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>adjust_tp_compare</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* If either tp_compare is _PyObject_SlotCompare, that's safe. */</comment>
	<if>if <condition>(<expr><name>f</name> == <name>_PyObject_SlotCompare</name> ||
	    <name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_compare</name></name> == <name>_PyObject_SlotCompare</name></expr>)</condition><then>
		<return>return <expr><call><name>_PyObject_SlotCompare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* If we're here, v and w,
	    a) are not instances;
	    b) have different types or a type without tp_compare; and
	    c) don't have a user-defined tp_compare.
	   tp_compare implementations in C assume that both arguments
	   have their type, so we give up if the coercion fails or if
	   it yields types which are still incompatible (which can
	   happen with a user-defined nb_coerce).
	*/</comment>
	<expr_stmt><expr><name>c</name> = <call><name>PyNumber_CoerceEx</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>c</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-2</expr>;</return></then></if>
	<if>if <condition>(<expr><name>c</name> &gt; 0</expr>)</condition><then>
		<return>return <expr>2</expr>;</return></then></if>
	<expr_stmt><expr><name>f</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_compare</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> != <name>NULL</name> &amp;&amp; <name>f</name> == <name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_compare</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call>(*<name>f</name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>adjust_tp_compare</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* No comparison defined */</comment>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>2</expr>;</return>
}</block></function>

<comment type="block">/* Final fallback 3-way comparison, returning an int.  Return:
   -2 if an error occurred;
   -1 if v &lt;  w;
    0 if v == w;
    1 if v &gt;  w.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>default_3way_compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>vname</name></decl>, *<decl><type ref="prev"/><name>wname</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name></name> == <name><name>w</name>-&gt;<name>ob_type</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* When comparing these pointers, they must be cast to
		 * integer types (i.e. Py_uintptr_t, our spelling of C9X's
		 * uintptr_t).  ANSI specifies that pointer compares other
		 * than == and != to non-related structures are undefined.
		 */</comment>
		<decl_stmt><decl><type><name>Py_uintptr_t</name></type> <name>vv</name> <init>= <expr>(<name>Py_uintptr_t</name>)<name>v</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_uintptr_t</name></type> <name>ww</name> <init>= <expr>(<name>Py_uintptr_t</name>)<name>w</name></expr></init></decl>;</decl_stmt>
		<return>return <expr>(<name>vv</name> &lt; <name>ww</name>) ? -1 : (<name>vv</name> &gt; <name>ww</name>) ? 1 : 0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* None is smaller than anything */</comment>
	<if>if <condition>(<expr><name>v</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>w</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<comment type="block">/* different type: compare type names; numbers are smaller */</comment>
	<if>if <condition>(<expr><call><name>PyNumber_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>vname</name> = ""</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>vname</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><call><name>PyNumber_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>wname</name> = ""</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>wname</name> = <name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>c</name> = <call><name>strcmp</name><argument_list>(<argument><expr><name>vname</name></expr></argument>, <argument><expr><name>wname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>c</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>c</name> &gt; 0</expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<comment type="block">/* Same type name, or (more likely) incomparable numeric types */</comment>
	<return>return <expr>(<call>(<name>Py_uintptr_t</name>)<argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call> &lt; <call>(
		<name>Py_uintptr_t</name>)<argument_list>(<argument><expr><name><name>w</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call>) ? -1 : 1</expr>;</return>
}</block></function>

<comment type="block">/* Do a 3-way comparison, by hook or by crook.  Return:
   -2 for an exception (but see below);
   -1 if v &lt;  w;
    0 if v == w;
    1 if v &gt;  w;
   BUT: if the object implements a tp_compare function, it returns
   whatever this function returns (whether with an exception or not).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>do_cmp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cmpfunc</name></type> <name>f</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name></name> == <name><name>w</name>-&gt;<name>ob_type</name></name>
	    &amp;&amp; (<name>f</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_compare</name></name>) != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call>(*<name>f</name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* Instance tp_compare has a different signature.
			   But if it returns undefined we fall through. */</comment>
			<if>if <condition>(<expr><name>c</name> != 2</expr>)</condition><then>
				<return>return <expr><name>c</name></expr>;</return></then></if>
			<comment type="block">/* Else fall through to try_rich_to_3way_compare() */</comment>
		}</block></then>
		<else>else
			<return>return <expr><call><name>adjust_tp_compare</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then></if>
	<comment type="block">/* We only get here if one of the following is true:
	   a) v and w have different types
	   b) v and w have the same type, which doesn't have tp_compare
	   c) v and w are instances, and either __cmp__ is not defined or
	      __cmp__ returns NotImplemented
	*/</comment>
	<expr_stmt><expr><name>c</name> = <call><name>try_rich_to_3way_compare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>c</name> &lt; 2</expr>)</condition><then>
		<return>return <expr><name>c</name></expr>;</return></then></if>
	<expr_stmt><expr><name>c</name> = <call><name>try_3way_compare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>c</name> &lt; 2</expr>)</condition><then>
		<return>return <expr><name>c</name></expr>;</return></then></if>
	<return>return <expr><call><name>default_3way_compare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Compare v to w.  Return
   -1 if v &lt;  w or exception (PyErr_Occurred() true in latter case).
    0 if v == w.
    1 if v &gt; w.
   XXX The docs (C API manual) say the return value is undefined in case
   XXX of error.
*/</comment>
<function><type><name>int</name></type>
<name>PyObject_Compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>w</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" in cmp"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>do_cmp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name> &lt; 0 ? -1 : <name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Return (new reference to) Py_True or Py_False. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>convert_3way_to_object</name><parameter_list>(<param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Py_LT</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> &lt;  0</expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_LE</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> &lt;= 0</expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_EQ</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> == 0</expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_NE</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> != 0</expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_GT</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> &gt;  0</expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Py_GE</name></expr>: <expr_stmt><expr><name>c</name> = <name>c</name> &gt;= 0</expr>;</expr_stmt> <break>break;</break>
	</case>}</block></switch>
	<expr_stmt><expr><name>result</name> = <name>c</name> ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* We want a rich comparison but don't have one.  Try a 3-way cmp instead.
   Return
   NULL      if error
   Py_True   if v op w
   Py_False  if not (v op w)
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>try_3way_to_rich_compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c</name> = <call><name>try_3way_compare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>c</name> &gt;= 2</expr>)</condition><then> <block>{

		<comment type="block">/* Py3K warning if types are not equal and comparison isn't == or !=  */</comment>
		<if>if <condition>(<expr><name>Py_Py3kWarningFlag</name> &amp;&amp;
		    <name><name>v</name>-&gt;<name>ob_type</name></name> != <name><name>w</name>-&gt;<name>ob_type</name></name> &amp;&amp; <name>op</name> != <name>Py_EQ</name> &amp;&amp; <name>op</name> != <name>Py_NE</name> &amp;&amp;
		    <call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
			       <argument><expr>"comparing unequal types not supported "
			       "in 3.x"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>

		<expr_stmt><expr><name>c</name> = <call><name>default_3way_compare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>c</name> &lt;= -2</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>convert_3way_to_object</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Do rich comparison on v and w.  Return
   NULL      if error
   Else a new reference to an object other than Py_NotImplemented, usually(?):
   Py_True   if v op w
   Py_False  if not (v op w)
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_richcmp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> = <call><name>try_rich_compare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
		<return>return <expr><name>res</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>try_3way_to_rich_compare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Return:
   NULL for exception;
   some object not equal to NotImplemented if it is implemented
     (this latter object may not be a Boolean).
*/</comment>
<function><type><name>PyObject</name> *</type>
<name>PyObject_RichCompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Py_LT</name> &lt;= <name>op</name> &amp;&amp; <name>op</name> &lt;= <name>Py_GE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" in cmp"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* If the types are equal, and not old-style instances, try to
	   get out cheap (don't bother with coercions etc.). */</comment>
	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name></name> == <name><name>w</name>-&gt;<name>ob_type</name></name> &amp;&amp; !<call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>cmpfunc</name></type> <name>fcmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>richcmpfunc</name></type> <name>frich</name> <init>= <expr><call><name>RICHCOMPARE</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* If the type has richcmp, try it first.  try_rich_compare
		   tries it two-sided, which is not needed since we've a
		   single type only. */</comment>
		<if>if <condition>(<expr><name>frich</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>res</name> = <call>(*<name>frich</name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>res</name> != <name>Py_NotImplemented</name></expr>)</condition><then>
				<goto>goto <name>Done</name>;</goto></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<comment type="block">/* No richcmp, or this particular richmp not implemented.
		   Try 3-way cmp. */</comment>
		<expr_stmt><expr><name>fcmp</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_compare</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fcmp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call>(*<name>fcmp</name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>c</name> = <call><name>adjust_tp_compare</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> == -2</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt>
				<goto>goto <name>Done</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name>res</name> = <call><name>convert_3way_to_object</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Done</name>;</goto>
		}</block></then></if>
	}</block></then></if>

	<comment type="block">/* Fast path not taken, or couldn't deliver a useful result. */</comment>
	<expr_stmt><expr><name>res</name> = <call><name>do_richcmp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Done</name>:</label>
	<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* Return -1 if error; 1 if v op w; 0 if not (v op w). */</comment>
<function><type><name>int</name></type>
<name>PyObject_RichCompareBool</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

	<comment type="block">/* Quick result when objects are the same.
	   Guarantees that identity implies equality. */</comment>
	<if>if <condition>(<expr><name>v</name> == <name>w</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then>
		<else>else <if>if <condition>(<expr><name>op</name> == <name>Py_NE</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if></else></if>
	}</block></then></if>

	<expr_stmt><expr><name>res</name> = <call><name>PyObject_RichCompare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyBool_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>ok</name> = (<name>res</name> == <name>Py_True</name>)</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/* Set of hash utility functions to help maintaining the invariant that
	if a==b then hash(a)==hash(b)

   All the utility functions (_Py_Hash*()) return "-1" to signify an error.
*/</comment>

<function><type><name>long</name></type>
<name>_Py_HashDouble</name><parameter_list>(<param><decl><type><name>double</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>intpart</name></decl>, <decl><type ref="prev"/><name>fractpart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>expo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>hipart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>		<comment type="block">/* the final hash value */</comment>
	<comment type="block">/* This is designed so that Python numbers of different types
	 * that compare equal hash to the same value; otherwise comparisons
	 * of mapping keys will turn out weird.
	 */</comment>

	<expr_stmt><expr><name>fractpart</name> = <call><name>modf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>intpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fractpart</name> == 0.0</expr>)</condition><then> <block>{
		<comment type="block">/* This must return the same hash as an equal int or long. */</comment>
		<if>if <condition>(<expr><name>intpart</name> &gt; <name>LONG_MAX</name> || -<name>intpart</name> &gt; <name>LONG_MAX</name></expr>)</condition><then> <block>{
			<comment type="block">/* Convert to long and use its hash. */</comment>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>plong</name></decl>;</decl_stmt>	<comment type="block">/* converted to Python long */</comment>
			<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>intpart</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<comment type="block">/* can't convert to long int -- arbitrary */</comment>
				<expr_stmt><expr><name>v</name> = <name>v</name> &lt; 0 ? -271828.0 : 314159.0</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>plong</name> = <call><name>PyLong_FromDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>plong</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><name>x</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>plong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>x</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Fits in a C long == a Python int, so is its own hash. */</comment>
		<expr_stmt><expr><name>x</name> = (<name>long</name>)<name>intpart</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
			<expr_stmt><expr><name>x</name> = -2</expr>;</expr_stmt></then></if>
		<return>return <expr><name>x</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* The fractional part is non-zero, so we don't have to worry about
	 * making this match the hash of some other type.
	 * Use frexp to get at the bits in the double.
	 * Since the VAX D double format has 56 mantissa bits, which is the
	 * most of any double format in use, each of these parts may have as
	 * many as (but no more than) 56 significant bits.
	 * So, assuming sizeof(long) &gt;= 4, each part can be broken into two
	 * longs; frexp and multiplication are used to do that.
	 * Also, since the Cray double format has 15 exponent bits, which is
	 * the most of any double format in use, shifting the exponent field
	 * left by 15 won't overflow a long (again assuming sizeof(long) &gt;= 4).
	 */</comment>
	<expr_stmt><expr><name>v</name> = <call><name>frexp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>expo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> *= 2147483648.0</expr>;</expr_stmt>	<comment type="block">/* 2**31 */</comment>
	<expr_stmt><expr><name>hipart</name> = (<name>long</name>)<name>v</name></expr>;</expr_stmt>	<comment type="block">/* take the top 32 bits */</comment>
	<expr_stmt><expr><name>v</name> = (<name>v</name> - (<name>double</name>)<name>hipart</name>) * 2147483648.0</expr>;</expr_stmt> <comment type="block">/* get the next 32 bits */</comment>
	<expr_stmt><expr><name>x</name> = <name>hipart</name> + (<name>long</name>)<name>v</name> + (<name>expo</name> &lt;&lt; 15)</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = -2</expr>;</expr_stmt></then></if>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<function><type><name>long</name></type>
<name>_Py_HashPointer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt;= <name>SIZEOF_VOID_P</name></expr></cpp:if>
	<return>return <expr>(<name>long</name>)<name>p</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* convert to a Python long and hash that */</comment>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>longobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>longobj</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = -1</expr>;</expr_stmt>
		<goto>goto <name>finally</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>x</name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>longobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>finally</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>longobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>x</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>long</name></type>
<name>PyObject_HashNotImplemented</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"unhashable type: '%.200s'"</expr></argument>,
		     <argument><expr><name><name>self</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>long</name></type>
<name>PyObject_Hash</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_hash</name></name> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call>(*<name><name>tp</name>-&gt;<name>tp_hash</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_compare</name></name> == <name>NULL</name> &amp;&amp; <call><name>RICHCOMPARE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>_Py_HashPointer</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return> <comment type="block">/* Use address as hash value */</comment>
	}</block></then></if>
	<comment type="block">/* If there's a cmp but no hash defined, the object can't be hashed */</comment>
	<return>return <expr><call><name>PyObject_HashNotImplemented</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_GetAttrString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_getattr</name> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_getattr</name>)(<name>v</name>, (<name>char</name>*)<name>name</name>)</expr>;</return></then></if>
	<expr_stmt><expr><name>w</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_HasAttrString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_SetAttrString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_setattr</name> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_setattr</name>)(<name>v</name>, (<name>char</name>*)<name>name</name>, <name>w</name>)</expr>;</return></then></if>
	<expr_stmt><expr><name>s</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyObject_SetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_GetAttr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<comment type="block">/* The Unicode to string conversion is done here because the
		   existing tp_getattro slots expect a string object as name
		   and we wouldn't want to break those. */</comment>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>name</name> = <call><name>_PyUnicode_AsDefaultEncodedString</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></then>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"attribute name must be string, not '%.200s'"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></else></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_getattro</name></name> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call>(*<name><name>tp</name>-&gt;<name>tp_getattro</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_getattr</name></name> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call>(*<name><name>tp</name>-&gt;<name>tp_getattr</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
		     <argument><expr>"'%.50s' object has no attribute '%.400s'"</expr></argument>,
		     <argument><expr><name><name>tp</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_HasAttr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_SetAttr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<comment type="block">/* The Unicode to string conversion is done here because the
		   existing tp_setattro slots expect a string object as name
		   and we wouldn't want to break those. */</comment>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>name</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"attribute name must be string, not '%.200s'"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></else></if>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_setattro</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err</name> = <call>(*<name><name>tp</name>-&gt;<name>tp_setattro</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>err</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_setattr</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err</name> = <call>(*<name><name>tp</name>-&gt;<name>tp_setattr</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>err</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_getattr</name></name> == <name>NULL</name> &amp;&amp; <name><name>tp</name>-&gt;<name>tp_getattro</name></name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"'%.100s' object has no attributes "
			     "(%s .%.100s)"</expr></argument>,
			     <argument><expr><name><name>tp</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name>value</name>==<name>NULL</name> ? "del" : "assign to"</expr></argument>,
			     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"'%.100s' object has only read-only attributes "
			     "(%s .%.100s)"</expr></argument>,
			     <argument><expr><name><name>tp</name>-&gt;<name>tp_name</name></name></expr></argument>,
			     <argument><expr><name>value</name>==<name>NULL</name> ? "del" : "assign to"</expr></argument>,
			     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* Helper to get a pointer to an object's __dict__ slot, if any */</comment>

<function><type><name>PyObject</name> **</type>
<name>_PyObject_GetDictPtr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>dictoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!(<name><name>tp</name>-&gt;<name>tp_flags</name></name> &amp; <name>Py_TPFLAGS_HAVE_CLASS</name>)</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>dictoffset</name> = <name><name>tp</name>-&gt;<name>tp_dictoffset</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dictoffset</name> == 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>dictoffset</name> &lt; 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>tsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tsize</name> = ((<name>PyVarObject</name> *)<name>obj</name>)-&gt;<name>ob_size</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tsize</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>tsize</name> = -<name>tsize</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>size</name> = <call><name>_PyObject_VAR_SIZE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dictoffset</name> += (<name>long</name>)<name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictoffset</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictoffset</name> % <name>SIZEOF_VOID_P</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><call>(<name>PyObject</name> **) <argument_list>(<argument><expr>(<name>char</name> *)<name>obj</name> + <name>dictoffset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyObject_SelfIter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>obj</name></expr>;</return>
}</block></function>

<comment type="block">/* Generic GetAttr functions - put these in your tp_[gs]etattro slot */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyObject_GenericGetAttr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>descrgetfunc</name></type> <name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>dictoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>dictptr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<comment type="block">/* The Unicode to string conversion is done here because the
		   existing tp_setattro slots expect a string object as name
		   and we wouldn't want to break those. */</comment>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>name</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></then>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"attribute name must be string, not '%.200s'"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></else></if>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>done</name>;</goto></then></if>
	}</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if> <comment type="block">/* XXX this is not quite _PyType_Lookup anymore */</comment>
	<comment type="block">/* Inline _PyType_Lookup */</comment>
	{
		Py_ssize_t i, n;
		PyObject *mro, *base, *dict;

		<comment type="block">/* Look in tp_dict of types in MRO */</comment>
		mro = tp-&gt;tp_mro;
		assert(mro != NULL);
		assert(PyTuple_Check(mro));
		n = PyTuple_GET_SIZE(mro);
		for (i = 0; i &lt; n; i++) {
			base = PyTuple_GET_ITEM(mro, i);
			if (PyClass_Check(base))
				dict = ((PyClassObject *)base)-&gt;cl_dict;
			else {
				assert(PyType_Check(base));
				dict = ((PyTypeObject *)base)-&gt;tp_dict;
			}
			assert(dict &amp;&amp; PyDict_Check(dict));
			descr = PyDict_GetItem(dict, name);
			if (descr != NULL)
				break;
		}
	}
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>descr</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>f</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>descr</name> != <name>NULL</name> &amp;&amp;
	    <call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name><name>descr</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HAVE_CLASS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>f</name> = <name><name>descr</name>-&gt;<name>ob_type</name>-&gt;<name>tp_descr_get</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>f</name> != <name>NULL</name> &amp;&amp; <call><name>PyDescr_IsData</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>res</name> = <call><name>f</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name><name>obj</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>done</name>;</goto>
		}</block></then></if>
	}</block></then></if>

	<comment type="block">/* Inline _PyObject_GetDictPtr */</comment>
	<expr_stmt><expr><name>dictoffset</name> = <name><name>tp</name>-&gt;<name>tp_dictoffset</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dictoffset</name> != 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>dictoffset</name> &lt; 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>tsize</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tsize</name> = ((<name>PyVarObject</name> *)<name>obj</name>)-&gt;<name>ob_size</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>tsize</name> &lt; 0</expr>)</condition><then>
				<expr_stmt><expr><name>tsize</name> = -<name>tsize</name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>size</name> = <call><name>_PyObject_VAR_SIZE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>dictoffset</name> += (<name>long</name>)<name>size</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictoffset</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dictoffset</name> % <name>SIZEOF_VOID_P</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>dictptr</name> = <call>(<name>PyObject</name> **) <argument_list>(<argument><expr>(<name>char</name> *)<name>obj</name> + <name>dictoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dict</name> = *<name>dictptr</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dict</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>done</name>;</goto>
			}</block></then></if>
                        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>f</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	}</block></then></if>

	<if>if <condition>(<expr><name>descr</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <name>descr</name></expr>;</expr_stmt>
		<comment type="block">/* descr was already increfed above */</comment>
		<goto>goto <name>done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
		     <argument><expr>"'%.50s' object has no attribute '%.400s'"</expr></argument>,
		     <argument><expr><name><name>tp</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>done</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyObject_GenericSetAttr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>descrsetfunc</name></type> <name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>dictptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<comment type="block">/* The Unicode to string conversion is done here because the
		   existing tp_setattro slots expect a string object as name
		   and we wouldn't want to break those. */</comment>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>name</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"attribute name must be string, not '%.200s'"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></else></if>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name><name>tp</name>-&gt;<name>tp_dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>done</name>;</goto></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>descr</name> = <call><name>_PyType_Lookup</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>descr</name> != <name>NULL</name> &amp;&amp;
	    <call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name><name>descr</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HAVE_CLASS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>f</name> = <name><name>descr</name>-&gt;<name>ob_type</name>-&gt;<name>tp_descr_set</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>f</name> != <name>NULL</name> &amp;&amp; <call><name>PyDescr_IsData</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>res</name> = <call><name>f</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>done</name>;</goto>
		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>dictptr</name> = <call><name>_PyObject_GetDictPtr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dictptr</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr>*<name>dictptr</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>dict</name> == <name>NULL</name> &amp;&amp; <name>value</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>dict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>done</name>;</goto></then></if>
			<expr_stmt><expr>*<name>dictptr</name> = <name>dict</name></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>dict</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>res</name> = <call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>res</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr><name>res</name> &lt; 0 &amp;&amp; <call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>done</name>;</goto>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>f</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	}</block></then></if>

	<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
			     <argument><expr>"'%.100s' object has no attribute '%.200s'"</expr></argument>,
			     <argument><expr><name><name>tp</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
		     <argument><expr>"'%.50s' object attribute '%.400s' is read-only"</expr></argument>,
		     <argument><expr><name><name>tp</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>done</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* Test a value used as condition, e.g., in a for or if statement.
   Return -1 if an error occurred */</comment>

<function><type><name>int</name></type>
<name>PyObject_IsTrue</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>Py_True</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>Py_False</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then>
	<else>else <if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> != <name>NULL</name> &amp;&amp;
		 <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_nonzero</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call>(*<name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_nonzero</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name></name> != <name>NULL</name> &amp;&amp;
		 <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name>-&gt;<name>mp_length</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call>(*<name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_mapping</name>-&gt;<name>mp_length</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name> != <name>NULL</name> &amp;&amp;
		 <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_length</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call>(*<name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_length</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<return>return <expr>1</expr>;</return></else></if></else></if></else></if></else></if>
	<comment type="block">/* if it is negative, it should be either -1 or -2 */</comment>
	<return>return <expr>(<name>res</name> &gt; 0) ? 1 : <call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* equivalent of 'not v'
   Return -1 if an error occurred */</comment>

<function><type><name>int</name></type>
<name>PyObject_Not</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>res</name></expr>;</return></then></if>
	<return>return <expr><name>res</name> == 0</expr>;</return>
}</block></function>

<comment type="block">/* Coerce two numeric types to the "larger" one.
   Increment the reference count on each argument.
   Return value:
   -1 if an error occurred;
   0 if the coercion succeeded (and then the reference counts are increased);
   1 if no coercion is possible (and no error is raised).
*/</comment>
<function><type><name>int</name></type>
<name>PyNumber_CoerceEx</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name> <init>= <expr>*<name>pv</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>w</name> <init>= <expr>*<name>pw</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<comment type="block">/* Shortcut only for old-style types */</comment>
	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name></name> == <name><name>w</name>-&gt;<name>ob_type</name></name> &amp;&amp;
	    !<call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_TPFLAGS_CHECKTYPES</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> &amp;&amp; <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_coerce</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call>(*<name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_coerce</name></name>)<argument_list>(<argument><expr><name>pv</name></expr></argument>, <argument><expr><name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> &lt;= 0</expr>)</condition><then>
			<return>return <expr><name>res</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name> &amp;&amp; <name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_coerce</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call>(*<name><name>w</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name>-&gt;<name>nb_coerce</name></name>)<argument_list>(<argument><expr><name>pw</name></expr></argument>, <argument><expr><name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> &lt;= 0</expr>)</condition><then>
			<return>return <expr><name>res</name></expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Coerce two numeric types to the "larger" one.
   Increment the reference count on each argument.
   Return -1 and raise an exception if no coercion is possible
   (and then no reference count is incremented).
*/</comment>
<function><type><name>int</name></type>
<name>PyNumber_Coerce</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>PyNumber_CoerceEx</name><argument_list>(<argument><expr><name>pv</name></expr></argument>, <argument><expr><name>pw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>err</name> &lt;= 0</expr>)</condition><then>
		<return>return <expr><name>err</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"number coercion failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>


<comment type="block">/* Test whether an object can be called */</comment>

<function><type><name>int</name></type>
<name>PyCallable_Check</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>x</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>call</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>"__call__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>call</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<comment type="block">/* Could test recursively but don't, for fear of endless
		   recursion if some joker sets self.__call__ = self */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then>
	<else>else <block>{
		<return>return <expr><name><name>x</name>-&gt;<name>ob_type</name>-&gt;<name>tp_call</name></name> != <name>NULL</name></expr>;</return>
	}</block></else></if>
}</block></function>

<comment type="block">/* ------------------------- PyObject_Dir() helpers ------------------------- */</comment>

<comment type="block">/* Helper for PyObject_Dir.
   Merge the __dict__ of aclass into dict, and recursively also all
   the __dict__s of aclass's base classes.  The order of merging isn't
   defined, as it's expected that only the final set of dict keys is
   interesting.
   Return 0 on success, -1 on error.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>merge_class_dict</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>dict</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>aclass</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>classdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>bases</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>aclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Merge in the type's dict (if any). */</comment>
	<expr_stmt><expr><name>classdict</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>aclass</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>classdict</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>classdict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>classdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></else></if>

	<comment type="block">/* Recursively merge in the base types' (if any) dicts. */</comment>
	<expr_stmt><expr><name>bases</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>aclass</name></expr></argument>, <argument><expr>"__bases__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<comment type="block">/* We have no guarantee that bases is a real tuple */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* This better be right */</comment>
		<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>base</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>base</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>-1</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><name>status</name> = <call><name>merge_class_dict</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>-1</expr>;</return>
				}</block></then></if>
			}</block></for>
		}</block></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Helper for PyObject_Dir.
   If obj has an attr named attrname that's a list, merge its string
   elements into keys of dict.
   Return 0 on success, -1 on error.  Errors due to not finding the attr,
   or the attr not being a list, are suppressed.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>merge_list_attr</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>dict</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>attrname</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>list</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>

	<else>else <if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>result</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></then></if>
		}</block></for>
		<if>if <condition>(<expr><name>Py_Py3kWarningFlag</name> &amp;&amp;
		    (<call><name>strcmp</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>, <argument><expr>"__members__"</expr></argument>)</argument_list></call> == 0 ||
		     <call><name>strcmp</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>, <argument><expr>"__methods__"</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>, 
				       <argument><expr>"__members__ and __methods__ not "
				       "supported in 3.x"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></then></if></else></if>

	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for PyObject_Dir without arguments: returns the local scope. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_dir_locals</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>locals</name> <init>= <expr><call><name>PyEval_GetLocals</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>locals</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"frame does not exist"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>names</name> = <call><name>PyMapping_Keys</name><argument_list>(<argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>names</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"dir(): expected keys() of locals to be a list, "
			"not '%.200s'"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* the locals don't need to be DECREF'd */</comment>
	<return>return <expr><name>names</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for PyObject_Dir of type objects: returns __dict__ and __bases__.
   We deliberately don't suck up its __class__, as methods belonging to the 
   metaclass would probably be more confusing than helpful. 
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type> 
<name>_specialized_dir_type</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>dict</name> != <name>NULL</name> &amp;&amp; <call><name>merge_class_dict</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>PyDict_Keys</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for PyObject_Dir of module objects: returns the module's __dict__. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_specialized_dir_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>dict</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>PyDict_Keys</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"%.200s.__dict__ is not a dictionary"</expr></argument>,
				     <argument><expr><call><name>PyModule_GetName</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for PyObject_Dir of generic objects: returns __dict__, __class__,
   and recursively up the __class__.__bases__ chain.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_generic_dir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>itsclass</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/* Get __dict__ (which may or may not be a real dict...) */</comment>
	<expr_stmt><expr><name>dict</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Copy __dict__ to avoid mutating it. */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><call><name>PyDict_Copy</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dict</name> = <name>temp</name></expr>;</expr_stmt>
	}</block></else></if></else></if>

	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<comment type="block">/* Merge in __members__ and __methods__ (if any).
	 * This is removed in Python 3000. */</comment>
	<if>if <condition>(<expr><call><name>merge_list_attr</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>"__members__"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>merge_list_attr</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>"__methods__"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<comment type="block">/* Merge in attrs reachable from its class. */</comment>
	<expr_stmt><expr><name>itsclass</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>itsclass</name> == <name>NULL</name></expr>)</condition><then>
		<comment type="block">/* XXX(tomer): Perhaps fall back to obj-&gt;ob_type if no
		               __class__ exists? */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<if>if <condition>(<expr><call><name>merge_class_dict</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>itsclass</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></else></if>

	<expr_stmt><expr><name>result</name> = <call><name>PyDict_Keys</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* fall through */</comment>
<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>itsclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for PyObject_Dir: object introspection.
   This calls one of the above specialized versions if no __dir__ method
   exists. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_dir_object</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dirfunc</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name><name>obj</name>-&gt;<name>ob_type</name></name></expr></argument>,
						   <argument><expr>"__dir__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dirfunc</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* use default implementation */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyModule_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>_specialized_dir_module</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> || <call><name>PyClass_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>_specialized_dir_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>result</name> = <call><name>_generic_dir</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* use __dir__ */</comment>
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>dirfunc</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dirfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<comment type="block">/* result must be a list */</comment>
		<comment type="block">/* XXX(gbrandl): could also check if all items are strings */</comment>
		<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"__dir__() must return a list, not %.200s"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></else></if>

	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Implementation of dir() -- if obj is NULL, returns the names in the current
   (local) scope.  Otherwise, performs introspection of the object: returns a
   sorted list of attribute names (supposedly) accessible from the object
*/</comment>
<function><type><name>PyObject</name> *</type>
<name>PyObject_Dir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type> <name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then>
		<comment type="block">/* no object -- introspect the locals */</comment>
		<expr_stmt><expr><name>result</name> = <call><name>_dir_locals</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<comment type="block">/* object -- introspect the object */</comment>
		<expr_stmt><expr><name>result</name> = <call><name>_dir_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result</name> == <name>NULL</name> || <call><name>PyList_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>result</name> != <name>NULL</name> &amp;&amp; <call><name>PyList_Sort</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
		<comment type="block">/* sorting the list failed */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
NoObject is usable as a non-NULL undefined value, used by the macro None.
There is (and should be!) no way to create other objects of this type,
so there is exactly one (which is indestructible, by the way).
(XXX This type and the type of NotImplemented below should be unified.)
*/</comment>

<comment type="block">/* ARGSUSED */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>none_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"None"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ARGUSED */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>none_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>ignore</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* This should never get called, but we also don't want to SEGV if
	 * we accidently decref None out of existance.
	 */</comment>
	<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"deallocating None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyNone_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"NoneType"</expr>,
	<expr>0</expr>,
	<expr>0</expr>,
	<expr><name>none_dealloc</name></expr>,	<comment type="block">/*tp_dealloc*/</comment> <comment type="block">/*never called*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_print*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_getattr*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_setattr*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_compare*/</comment>
	<expr><name>none_repr</name></expr>,	<comment type="block">/*tp_repr*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_as_number*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_as_sequence*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_as_mapping*/</comment>
	<expr>(<name>hashfunc</name>)<name>_Py_HashPointer</name></expr>, <comment type="block">/*tp_hash */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyObject</name></type> <name>_Py_NoneStruct</name> <init>= <expr><block>{
  <expr><name>_PyObject_EXTRA_INIT</name>
  1</expr>, <expr>&amp;<name>PyNone_Type</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* NotImplemented is an object that can be used to signal that an
   operation is not implemented for the given type combination. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>NotImplemented_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"NotImplemented"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyNotImplemented_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"NotImplementedType"</expr>,
	<expr>0</expr>,
	<expr>0</expr>,
	<expr><name>none_dealloc</name></expr>,	<comment type="block">/*tp_dealloc*/</comment> <comment type="block">/*never called*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_print*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_getattr*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_setattr*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_compare*/</comment>
	<expr><name>NotImplemented_repr</name></expr>, <comment type="block">/*tp_repr*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_as_number*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_as_sequence*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_as_mapping*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_hash */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyObject</name></type> <name>_Py_NotImplementedStruct</name> <init>= <expr><block>{
	<expr><name>_PyObject_EXTRA_INIT</name>
	1</expr>, <expr>&amp;<name>PyNotImplemented_Type</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>_Py_ReadyTypes</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize 'type'"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>_PyWeakref_RefType</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize 'weakref'"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyBool_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize 'bool'"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyString_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize 'str'"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyByteArray_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize 'bytes'"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyList_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize 'list'"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyNone_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize type(None)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyNotImplemented_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize type(NotImplemented)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TRACE_REFS</name></cpp:ifdef>

<function><type><name>void</name></type>
<name>_Py_NewReference</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name>_Py_INC_REFTOTAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_refcnt</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_Py_AddToAllObjects</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_Py_INC_TPALLOCS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>_Py_ForgetReference</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SLOW_UNREF_CHECK</name></cpp:ifdef>
        <decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>p</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name><name>op</name>-&gt;<name>ob_refcnt</name></name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"UNREF negative refcnt"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>op</name> == &amp;<name>refchain</name> ||
	    <name><name>op</name>-&gt;<name>_ob_prev</name>-&gt;<name>_ob_next</name></name> != <name>op</name> || <name><name>op</name>-&gt;<name>_ob_next</name>-&gt;<name>_ob_prev</name></name> != <name>op</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"UNREF invalid object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SLOW_UNREF_CHECK</name></cpp:ifdef>
	<for>for (<init><expr><name>p</name> = <name><name>refchain</name>.<name>_ob_next</name></name></expr>;</init> <condition><expr><name>p</name> != &amp;<name>refchain</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>_ob_next</name></name></expr></incr>) <block>{
		<if>if <condition>(<expr><name>p</name> == <name>op</name></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>p</name> == &amp;<name>refchain</name></expr>)</condition><then> <comment type="block">/* Not found */</comment>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"UNREF unknown object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>_ob_next</name>-&gt;<name>_ob_prev</name></name> = <name><name>op</name>-&gt;<name>_ob_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>_ob_prev</name>-&gt;<name>_ob_next</name></name> = <name><name>op</name>-&gt;<name>_ob_next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>_ob_next</name></name> = <name><name>op</name>-&gt;<name>_ob_prev</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_Py_INC_TPFREES</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>_Py_Dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>destructor</name></type> <name>dealloc</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_dealloc</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_Py_ForgetReference</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call>(*<name>dealloc</name>)<argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Print all live objects.  Because PyObject_Print is called, the
 * interpreter must be in a healthy state.
 */</comment>
<function><type><name>void</name></type>
<name>_Py_PrintReferences</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"Remaining objects:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>op</name> = <name><name>refchain</name>.<name>_ob_next</name></name></expr>;</init> <condition><expr><name>op</name> != &amp;<name>refchain</name></expr>;</condition> <incr><expr><name>op</name> = <name><name>op</name>-&gt;<name>_ob_next</name></name></expr></incr>) <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%p [%" <name>PY_FORMAT_SIZE_T</name> "d] "</expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>op</name>-&gt;<name>ob_refcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
}</block></function>

<comment type="block">/* Print the addresses of all live objects.  Unlike _Py_PrintReferences, this
 * doesn't make any calls to the Python C API, so is always safe to call.
 */</comment>
<function><type><name>void</name></type>
<name>_Py_PrintReferenceAddresses</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"Remaining object addresses:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>op</name> = <name><name>refchain</name>.<name>_ob_next</name></name></expr>;</init> <condition><expr><name>op</name> != &amp;<name>refchain</name></expr>;</condition> <incr><expr><name>op</name> = <name><name>op</name>-&gt;<name>_ob_next</name></name></expr></incr>)
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%p [%" <name>PY_FORMAT_SIZE_T</name> "d] %s\n"</expr></argument>, <argument><expr><name>op</name></expr></argument>,
			<argument><expr><name><name>op</name>-&gt;<name>ob_refcnt</name></name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_Py_GetObjects</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>, *<decl><type ref="prev"/><name>op</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i|O"</expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>op</name> = <name><name>refchain</name>.<name>_ob_next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr>(<name>n</name> == 0 || <name>i</name> &lt; <name>n</name>) &amp;&amp; <name>op</name> != &amp;<name>refchain</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<while>while <condition>(<expr><name>op</name> == <name>self</name> || <name>op</name> == <name>args</name> || <name>op</name> == <name>res</name> || <name>op</name> == <name>t</name> ||
		       (<name>t</name> != <name>NULL</name> &amp;&amp; <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> != (<name>PyTypeObject</name> *) <name>t</name>)</expr>)</condition> <block>{
			<expr_stmt><expr><name>op</name> = <name><name>op</name>-&gt;<name>_ob_next</name></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>op</name> == &amp;<name>refchain</name></expr>)</condition><then>
				<return>return <expr><name>res</name></expr>;</return></then></if>
		}</block></while>
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>op</name> = <name><name>op</name>-&gt;<name>_ob_next</name></name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Hack to force loading of cobject.o */</comment>
<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>_Py_cobject_hack</name> <init>= <expr>&amp;<name>PyCObject_Type</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* Hack to force loading of abstract.o */</comment>
<expr_stmt><expr><call><call><name>Py_ssize_t</name> <argument_list>(<argument><expr>*<name>_Py_abstract_hack</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call> = <name>PyObject_Size</name></expr>;</expr_stmt>


<comment type="block">/* Python's malloc wrappers (see pymem.h) */</comment>

<function><type><name>void</name> *</type>
<name>PyMem_Malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name> *</type>
<name>PyMem_Realloc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyMem_REALLOC</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyMem_Free</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* These methods are used to control infinite recursion in repr, str, print,
   etc.  Container objects that may recursively contain themselves,
   e.g. builtin dictionaries and lists, should used Py_ReprEnter() and
   Py_ReprLeave() to avoid infinite recursion.

   Py_ReprEnter() returns 0 the first time it is called for a particular
   object and 1 every time thereafter.  It returns -1 if an exception
   occurred.  Py_ReprLeave() has no return value.

   See dictobject.c and listobject.c for examples of use.
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEY</name></cpp:macro> <cpp:value>"Py_Repr"</cpp:value></cpp:define>

<function><type><name>int</name></type>
<name>Py_ReprEnter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dict</name> = <call><name>PyThreadState_GetDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>list</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>KEY</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>i</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<if>if <condition>(<expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == <name>obj</name></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
	}</block></while>
	<expr_stmt><expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>Py_ReprLeave</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dict</name> = <call><name>PyThreadState_GetDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>list</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>i</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Count backwards because we always expect obj to be list[-1] */</comment>
	<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
		<if>if <condition>(<expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == <name>obj</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyList_SetSlice</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
	}</block></while>
}</block></function>

<comment type="block">/* Trashcan support. */</comment>

<comment type="block">/* Current call-stack depth of tp_dealloc calls. */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>_PyTrash_delete_nesting</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/* List of objects that still need to be cleaned up, singly linked via their
 * gc headers' gc_prev pointers.
 */</comment>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>_PyTrash_delete_later</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Add op to the _PyTrash_delete_later list.  Called when the current
 * call-stack depth gets large.  op must be a currently untracked gc'ed
 * object, with refcount 0.  Py_DECREF must already have been called on it.
 */</comment>
<function><type><name>void</name></type>
<name>_PyTrash_deposit_object</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>_Py_AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name><name>gc</name>.<name>gc_refs</name></name> == <name>_PyGC_REFS_UNTRACKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_refcnt</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_Py_AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name><name>gc</name>.<name>gc_prev</name></name> = (<name>PyGC_Head</name> *)<name>_PyTrash_delete_later</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>_PyTrash_delete_later</name> = <name>op</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Dealloccate all the objects in the _PyTrash_delete_later list.  Called when
 * the call-stack unwinds again.
 */</comment>
<function><type><name>void</name></type>
<name>_PyTrash_destroy_chain</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<while>while <condition>(<expr><name>_PyTrash_delete_later</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><name>_PyTrash_delete_later</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>destructor</name></type> <name>dealloc</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_dealloc</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>_PyTrash_delete_later</name> =
			(<name>PyObject</name>*) <call><name>_Py_AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name><name>gc</name>.<name>gc_prev</name></name></expr>;</expr_stmt>

		<comment type="block">/* Call the deallocator directly.  This used to try to
		 * fool Py_DECREF into calling it indirectly, but
		 * Py_DECREF was already called on this object, and in
		 * assorted non-release builds calling Py_DECREF again ends
		 * up distorting allocation statistics.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_refcnt</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>++<name>_PyTrash_delete_nesting</name></expr>;</expr_stmt>
		<expr_stmt><expr><call>(*<name>dealloc</name>)<argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>--<name>_PyTrash_delete_nesting</name></expr>;</expr_stmt>
	}</block></while>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
