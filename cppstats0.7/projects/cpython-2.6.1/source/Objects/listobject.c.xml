<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Objects/listobject.c"><comment type="block">/* List object implementation */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STDC_HEADERS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>		<comment type="block">/* For size_t */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Ensure ob_item has room for at least newsize elements, and set
 * ob_size to newsize.  If newsize &gt; ob_size on entry, the content
 * of the new slots at exit is undefined heap trash; it's the caller's
 * responsiblity to overwrite them with sane values.
 * The number of allocated elements may grow, shrink, or stay the same.
 * Failure is impossible if newsize &lt;= self.allocated on entry, although
 * that partly relies on an assumption that the system realloc() never
 * fails when passed a number of bytes &lt;= the number of bytes last
 * allocated (the C standard doesn't guarantee this, but it's hard to
 * imagine a realloc implementation where it wouldn't be true).
 * Note that self-&gt;ob_item may change, and even if newsize is less
 * than ob_size on entry.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_resize</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>newsize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>new_allocated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>allocated</name> <init>= <expr><name><name>self</name>-&gt;<name>allocated</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Bypass realloc() when a previous overallocation is large enough
	   to accommodate the newsize.  If the newsize falls lower than half
	   the allocated size, then proceed with the realloc() to shrink the list.
	*/</comment>
	<if>if <condition>(<expr><name>allocated</name> &gt;= <name>newsize</name> &amp;&amp; <name>newsize</name> &gt;= (<name>allocated</name> &gt;&gt; 1)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name> != <name>NULL</name> || <name>newsize</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = <name>newsize</name></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* This over-allocates proportional to the list size, making room
	 * for additional growth.  The over-allocation is mild, but is
	 * enough to give linear-time amortized behavior over a long
	 * sequence of appends() in the presence of a poorly-performing
	 * system realloc().
	 * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
	 */</comment>
	<expr_stmt><expr><name>new_allocated</name> = (<name>newsize</name> &gt;&gt; 3) + (<name>newsize</name> &lt; 9 ? 3 : 6)</expr>;</expr_stmt>

	<comment type="block">/* check for integer overflow */</comment>
	<if>if <condition>(<expr><name>new_allocated</name> &gt; <name>PY_SIZE_MAX</name> - <name>newsize</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>new_allocated</name> += <name>newsize</name></expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><name>newsize</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>new_allocated</name> = 0</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>items</name> = <name><name>self</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>new_allocated</name> &lt;= ((~(<name>size_t</name>)0) / <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof>)</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_RESIZE</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>new_allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>items</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>items</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_item</name></name> = <name>items</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = <name>newsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>allocated</name></name> = <name>new_allocated</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Debug statistic to compare allocations with reuse through the free list */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:undef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>count_alloc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>count_reuse</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_alloc</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"List allocations: %" <name>PY_FORMAT_SIZE_T</name> "d\n"</expr></argument>,
		<argument><expr><name>count_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"List reuse through freelist: %" <name>PY_FORMAT_SIZE_T</name>
		"d\n"</expr></argument>, <argument><expr><name>count_reuse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%.2f%% reuse rate\n\n"</expr></argument>,
		<argument><expr>(100.0*<name>count_reuse</name>/(<name>count_alloc</name>+<name>count_reuse</name>))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Empty list reuse scheme to save calls to malloc and free */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyList_MAXFREELIST</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyList_MAXFREELIST</name></cpp:macro> <cpp:value>80</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyListObject</name> *</type><name><name>free_list</name><index>[<expr><name>PyList_MAXFREELIST</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>numfree</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>PyList_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>op</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>numfree</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>op</name> = <name><name>free_list</name><index>[<expr>--<name>numfree</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyList_New</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:ifdef>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_AtExit</name><argument_list>(<argument><expr><name>show_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>nbytes</name> = <name>size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<comment type="block">/* Check for overflow without an actual overflow,
	 *  which can cause compiler to optimise out */</comment>
	<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SIZE_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>numfree</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>numfree</name>--</expr>;</expr_stmt>
		<expr_stmt><expr><name>op</name> = <name><name>free_list</name><index>[<expr><name>numfree</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_Py_NewReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:ifdef>
		<expr_stmt><expr><name>count_reuse</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>op</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>PyListObject</name></expr></argument>, <argument><expr>&amp;<name>PyList_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>op</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_ALLOC_COUNT</name></cpp:ifdef>
		<expr_stmt><expr><name>count_alloc</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></else></if>
	<if>if <condition>(<expr><name>size</name> &lt;= 0</expr>)</condition><then>
		<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_item</name></name> = <name>NULL</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name><name>op</name>-&gt;<name>ob_item</name></name> = (<name>PyObject</name> **) <call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>op</name>-&gt;<name>ob_item</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_item</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> = <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name>-&gt;<name>allocated</name></name> = <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *) <name>op</name></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type>
<name>PyList_Size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then>
	<else>else
		<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>indexerr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><name>PyObject</name> *</type>
<name>PyList_GetItem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>indexerr</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>indexerr</name> = <call><name>PyString_FromString</name><argument_list>(
				<argument><expr>"list index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr><name>indexerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>((<name>PyListObject</name> *)<name>op</name>) -&gt; <name><name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyList_SetItem</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl></param>,
               <param><decl><type><name>register</name> <name>PyObject</name> *</type><name>newitem</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>olditem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> **</type><name>p</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
				<argument><expr>"list assignment index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>p</name> = ((<name>PyListObject</name> *)<name>op</name>) -&gt; <name>ob_item</name> + <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>olditem</name> = *<name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>p</name> = <name>newitem</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>olditem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ins1</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>where</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>items</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>n</name> == <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"cannot add more objects to list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>list_resize</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<if>if <condition>(<expr><name>where</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>where</name> += <name>n</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>where</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>where</name> = 0</expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>where</name> &gt; <name>n</name></expr>)</condition><then>
		<expr_stmt><expr><name>where</name> = <name>n</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>items</name> = <name><name>self</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>n</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= <name>where</name></expr>;</condition> <incr/>)
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name>+1</expr>]</index></name> = <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>items</name><index>[<expr><name>where</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyList_Insert</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>where</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>newitem</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>ins1</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>op</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>app1</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>v</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> == <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"cannot add more objects to list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>list_resize</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyList_Append</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>newitem</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>newitem</name> != <name>NULL</name>)</expr>)</condition><then>
		<return>return <expr><call><name>app1</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>op</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* Methods */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>list_dealloc</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>Py_TRASHCAN_SAFE_BEGIN</name><argument_list>(<argument>op</argument>)</argument_list></macro>
	<if>if <condition>(<expr><name><name>op</name>-&gt;<name>ob_item</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Do it backwards, for Christian Tismer.
		   There's a simple test case where somehow this reduces
		   thrashing when a *very* large list is created and
		   immediately deleted. */</comment>
		<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_item</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>numfree</name> &lt; <name>PyList_MAXFREELIST</name> &amp;&amp; <call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>free_list</name><index>[<expr><name>numfree</name>++</expr>]</index></name> = <name>op</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>Py_TRASHCAN_SAFE_END</name><argument_list>(<argument>op</argument>)</argument_list></macro>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_print</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rc</name> = <call><name>Py_ReprEnter</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rc</name> != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>rc</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>rc</name></expr>;</return></then></if>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"[...]"</expr></argument>)</argument_list></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"["</expr></argument>)</argument_list></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
			<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></decl>;</decl_stmt>
			<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></for>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"]"</expr></argument>)</argument_list></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>op</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_repr</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pieces</name> <init>= <expr><name>NULL</name></expr></init>, *<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = <call><name>Py_ReprEnter</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> != 0</expr>)</condition><then> <block>{
		<return>return <expr><name>i</name> &gt; 0 ? <call><name>PyString_FromString</name><argument_list>(<argument><expr>"[...]"</expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"[]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>Done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>pieces</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pieces</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<comment type="block">/* Do repr() on each element.  Note that this may mutate the list,
	   so must refetch the list size on each iteration. */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>" while getting the repr of a list"</expr></argument>)</argument_list></call></expr>)</condition><then>
			<goto>goto <name>Done</name>;</goto></then></if>
		<expr_stmt><expr><name>s</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>Done</name>;</goto></then></if>
		<expr_stmt><expr><name>status</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* append created a new ref */</comment>
		<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
			<goto>goto <name>Done</name>;</goto></then></if>
	}</block></for>

	<comment type="block">/* Add "[]" decorations to the first and last items. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"["</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>temp</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>temp</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>temp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call> - 1</expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<comment type="block">/* Paste them all together with ", " between. */</comment>
	<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>_PyString_Join</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>Done</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>list_length</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_contains</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>el</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>cmp</name> = 0</expr> ;</init> <condition><expr><name>cmp</name> == 0 &amp;&amp; <name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
		<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<return>return <expr><name>cmp</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_item</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>indexerr</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>indexerr</name> = <call><name>PyString_FromString</name><argument_list>(
				<argument><expr>"list index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr><name>indexerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>a</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_slice</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ilow</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>np</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>src</name></decl>, **<decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>ilow</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>ilow</name> = 0</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>ilow</name> &gt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>ilow</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
	<if>if <condition>(<expr><name>ihigh</name> &lt; <name>ilow</name></expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = <name>ilow</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>ihigh</name> &gt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
	<expr_stmt><expr><name>len</name> = <name>ihigh</name> - <name>ilow</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>np</name> = (<name>PyListObject</name> *) <call><name>PyList_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>src</name> = <name><name>a</name>-&gt;<name>ob_item</name></name> + <name>ilow</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest</name> = <name><name>np</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>(<name>PyObject</name> *)<name>np</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyList_GetSlice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ilow</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>list_slice</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>a</name></expr></argument>, <argument><expr><name>ilow</name></expr></argument>, <argument><expr><name>ihigh</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_concat</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>src</name></decl>, **<decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>np</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			  <argument><expr>"can only concatenate list (not \"%.200s\") to list"</expr></argument>,
			  <argument><expr><name><name>bb</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>b</name></cpp:macro> <cpp:value>((PyListObject *)bb)</cpp:value></cpp:define>
	<expr_stmt><expr><name>size</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>np</name> = (<name>PyListObject</name> *) <call><name>PyList_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>src</name> = <name><name>a</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest</name> = <name><name>np</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name>src</name> = <name><name>b</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest</name> = <name><name>np</name>-&gt;<name>ob_item</name></name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>(<name>PyObject</name> *)<name>np</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>b</name></cpp:undef>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_repeat</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>np</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>p</name></decl>, **<decl><type ref="prev"/><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>elem</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>size</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> * <name>n</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &amp;&amp; <name>size</name>/<name>n</name> != <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
		<return>return <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>np</name> = (<name>PyListObject</name> *) <call><name>PyList_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>items</name> = <name><name>np</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>elem</name> = <name><name>a</name>-&gt;<name>ob_item</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name> = <name>elem</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<return>return <expr>(<name>PyObject</name> *) <name>np</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>p</name> = <name><name>np</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>items</name> = <name><name>a</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<expr_stmt><expr>*<name>p</name> = <name><name>items</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
		}</block></for>
	}</block></for>
	<return>return <expr>(<name>PyObject</name> *) <name>np</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_clear</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>item</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_item</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>item</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Because XDECREF can recursively invoke operations on
		   this list, we make it empty first. */</comment>
		<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name>-&gt;<name>ob_item</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name>-&gt;<name>allocated</name></name> = 0</expr>;</expr_stmt>
		<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* Never fails; the return value can be ignored.
	   Note that there is no guarantee that the list is actually empty
	   at this point, because XDECREF may have populated it again! */</comment>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* a[ilow:ihigh] = v if v != NULL.
 * del a[ilow:ihigh] if v == NULL.
 *
 * Special speed gimmick:  when v is NULL and ihigh - ilow &lt;= 8, it's
 * guaranteed the call cannot fail.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_ass_slice</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ilow</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Because [X]DECREF can recursively invoke list operations on
	   this list, we must postpone all [X]DECREF activity until
	   after the list is back in its canonical shape.  Therefore
	   we must allocate an additional array, 'recycle', into which
	   we temporarily copy the items that are deleted from the
	   list. :-( */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name><name>recycle_on_stack</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>recycle</name> <init>= <expr><name>recycle_on_stack</name></expr></init></decl>;</decl_stmt> <comment type="block">/* will allocate more if needed */</comment>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>vitem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v_as_SF</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* PySequence_Fast(v) */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt> <comment type="block">/* # of elements in replacement list */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>norig</name></decl>;</decl_stmt> <comment type="block">/* # of elements in list getting replaced */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>d</name></decl>;</decl_stmt> <comment type="block">/* Change in size */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>	<comment type="block">/* guilty until proved innocent */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>b</name></cpp:macro> <cpp:value>((PyListObject *)v)</cpp:value></cpp:define>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then>
	<else>else <block>{
		<if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then> <block>{
			<comment type="block">/* Special case "a[i:j] = a" -- copy b first */</comment>
			<expr_stmt><expr><name>v</name> = <call><name>list_slice</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>result</name></expr>;</return></then></if>
			<expr_stmt><expr><name>result</name> = <call><name>list_ass_slice</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ilow</name></expr></argument>, <argument><expr><name>ihigh</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>v_as_SF</name> = <call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"can only assign an iterable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if<condition>(<expr><name>v_as_SF</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>Error</name>;</goto></then></if>
		<expr_stmt><expr><name>n</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>v_as_SF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vitem</name> = <call><name>PySequence_Fast_ITEMS</name><argument_list>(<argument><expr><name>v_as_SF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>ilow</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>ilow</name> = 0</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>ilow</name> &gt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>ilow</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

	<if>if <condition>(<expr><name>ihigh</name> &lt; <name>ilow</name></expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = <name>ilow</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>ihigh</name> &gt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

	<expr_stmt><expr><name>norig</name> = <name>ihigh</name> - <name>ilow</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>norig</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> = <name>n</name> - <name>norig</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> + <name>d</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v_as_SF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_clear</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>item</name> = <name><name>a</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<comment type="block">/* recycle the items that we are about to remove */</comment>
	<expr_stmt><expr><name>s</name> = <name>norig</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> &gt; <sizeof>sizeof<argument_list>(<argument><expr><name>recycle_on_stack</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>recycle</name> = (<name>PyObject</name> **)<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>recycle</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Error</name>;</goto>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>recycle</name></expr></argument>, <argument><expr>&amp;<name><name>item</name><index>[<expr><name>ilow</name></expr>]</index></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>d</name> &lt; 0</expr>)</condition><then> <block>{ <comment type="block">/* Delete -d items */</comment>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr>&amp;<name><name>item</name><index>[<expr><name>ihigh</name>+<name>d</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>item</name><index>[<expr><name>ihigh</name></expr>]</index></name></expr></argument>,
			<argument><expr>(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> - <name>ihigh</name>)*<sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_resize</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> + <name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> = <name><name>a</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>d</name> &gt; 0</expr>)</condition><then> <block>{ <comment type="block">/* Insert d items */</comment>
		<expr_stmt><expr><name>k</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>list_resize</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>k</name>+<name>d</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>Error</name>;</goto></then></if>
		<expr_stmt><expr><name>item</name> = <name><name>a</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr>&amp;<name><name>item</name><index>[<expr><name>ihigh</name>+<name>d</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>item</name><index>[<expr><name>ihigh</name></expr>]</index></name></expr></argument>,
			<argument><expr>(<name>k</name> - <name>ihigh</name>)*<sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>k</name>++</expr>, <expr><name>ilow</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><name><name>vitem</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><index>[<expr><name>ilow</name></expr>]</index></name> = <name>w</name></expr>;</expr_stmt>
	}</block></for>
	<for>for (<init><expr><name>k</name> = <name>norig</name> - 1</expr>;</init> <condition><expr><name>k</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>k</name></expr></incr>)
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>recycle</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
 <label><name>Error</name>:</label>
	<if>if <condition>(<expr><name>recycle</name> != <name>recycle_on_stack</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>recycle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v_as_SF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>b</name></cpp:undef>
}</block></function>

<function><type><name>int</name></type>
<name>PyList_SetSlice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ilow</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>list_ass_slice</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>a</name></expr></argument>, <argument><expr><name>ilow</name></expr></argument>, <argument><expr><name>ihigh</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_inplace_repeat</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>


	<expr_stmt><expr><name>size</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> == 0 || <name>n</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>n</name> &lt; 1</expr>)</condition><then> <block>{
		<expr_stmt><expr>(<name>void</name>)<call><name>list_clear</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> / <name>n</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>list_resize</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>size</name>*<name>n</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>p</name> = <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>items</name> = <name><name>self</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{ <comment type="block">/* Start counting at 1, not 0 */</comment>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>p</name>++</expr>]</index></name> = <name>o</name></expr>;</expr_stmt>
		}</block></for>
	}</block></for>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_ass_item</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_value</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
				<argument><expr>"list assignment index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>list_ass_slice</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_value</name> = <name><name>a</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listinsert</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"nO:insert"</expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins1</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listappend</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>app1</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listextend</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>      <comment type="block">/* iter(v) */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>m</name></decl>;</decl_stmt>		   <comment type="block">/* size of self */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>		   <comment type="block">/* guess for size of b */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mn</name></decl>;</decl_stmt>		   <comment type="block">/* m + n */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<function_decl><type><name>PyObject</name> *</type>(*<name>iternext</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>

	<comment type="block">/* Special cases:
	   1) lists and tuples which can use PySequence_Fast ops
	   2) extending self to self requires making a copy first
	*/</comment>
	<if>if <condition>(<expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> || (<name>PyObject</name> *)<name>self</name> == <name>b</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>src</name></decl>, **<decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>b</name> = <call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>"argument must be iterable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>b</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>n</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
			<comment type="block">/* short circuit when b is empty */</comment>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>m</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>list_resize</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>m</name> + <name>n</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* note that we may still have self == b here for the
		 * situation a.extend(a), but the following code works
		 * in that case too.  Just make sure to resize self
		 * before calling PySequence_Fast_ITEMS.
		 */</comment>
		<comment type="block">/* populate the end of self with b's items */</comment>
		<expr_stmt><expr><name>src</name> = <call><name>PySequence_Fast_ITEMS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dest</name> = <name><name>self</name>-&gt;<name>ob_item</name></name> + <name>m</name></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>o</name></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>iternext</name> = *<name><name>it</name>-&gt;<name>ob_type</name>-&gt;<name>tp_iternext</name></name></expr>;</expr_stmt>

	<comment type="block">/* Guess a result list size. */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>_PyObject_LengthHint</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>m</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mn</name> = <name>m</name> + <name>n</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mn</name> &gt;= <name>m</name></expr>)</condition><then> <block>{
		<comment type="block">/* Make room. */</comment>
		<if>if <condition>(<expr><call><name>list_resize</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>mn</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<comment type="block">/* Make the list sane again. */</comment>
		<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = <name>m</name></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* Else m + n overflowed; on the chance that n lied, and there really
	 * is enough room, ignore it.  If n was telling the truth, we'll
	 * eventually run out of memory during the loop.
	 */</comment>

	<comment type="block">/* Run iterator to exhaustion. */</comment>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>iternext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<goto>goto <name>error</name>;</goto></else></if>
			}</block></then></if>
			<break>break;</break>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; <name><name>self</name>-&gt;<name>allocated</name></name></expr>)</condition><then> <block>{
			<comment type="block">/* steals ref */</comment>
			<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr>++<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>app1</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* append creates a new ref */</comment>
			<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
		}</block></else></if>
	}</block></for>

	<comment type="block">/* Cut back result list if initial guess was too large. */</comment>
	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; <name><name>self</name>-&gt;<name>allocated</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>list_resize</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>  <comment type="block">/* shrinking can't fail */</comment>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>

  <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyList_Extend</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>listextend</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_inplace_concat</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>listextend</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>result</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listpop</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|n:pop"</expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* Special-case most common failure cause */</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"pop from empty list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>i</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"pop index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = <name><name>self</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> == <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>status</name> = <call><name>list_resize</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>status</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return> <comment type="block">/* and v now owns the reference the list had */</comment>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>status</name> = <call><name>list_ass_slice</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>status</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Use status, so that in a release build compilers don't
	 * complain about the unused name.
	 */</comment>
	<expr_stmt><expr>(<name>void</name>) <name>status</name></expr>;</expr_stmt>

	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* Reverse a slice of a list in place, from lo up to (exclusive) hi. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reverse_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>lo</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>hi</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lo</name> &amp;&amp; <name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr>--<name>hi</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> &lt; <name>hi</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name> <init>= <expr>*<name>lo</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr>*<name>lo</name> = *<name>hi</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>hi</name> = <name>t</name></expr>;</expr_stmt>
		<expr_stmt><expr>++<name>lo</name></expr>;</expr_stmt>
		<expr_stmt><expr>--<name>hi</name></expr>;</expr_stmt>
	}</block></while>
}</block></function>

<comment type="block">/* Lots of code for an adaptive, stable, natural mergesort.  There are many
 * pieces to this algorithm; read listsort.txt for overviews and details.
 */</comment>

<comment type="block">/* Comparison function.  Takes care of calling a user-supplied
 * comparison function (any callable Python object), which must not be
 * NULL (use the ISLT macro if you don't know, or call PyObject_RichCompareBool
 * with Py_LT if you know it's NULL).
 * Returns -1 on error, 1 if x &lt; y, 0 if x &gt;= y.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>islt</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>x</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>y</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>compare</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>compare</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Call the user's comparison function and translate the 3-way
	 * result into true or false (or error).
	 */</comment>
	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>compare</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"comparison function must return int, not %.200s"</expr></argument>,
			     <argument><expr><name><name>res</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>i</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>i</name> &lt; 0</expr>;</return>
}</block></function>

<comment type="block">/* If COMPARE is NULL, calls PyObject_RichCompareBool with Py_LT, else calls
 * islt.  This avoids a layer of function call in the usual case, and
 * sorting does many comparisons.
 * Returns -1 on error, 1 if x &lt; y, 0 if x &gt;= y.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISLT</name><parameter_list>(<param><type><name>X</name></type></param>, <param><type><name>Y</name></type></param>, <param><type><name>COMPARE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((COMPARE) == NULL ?			\
			     PyObject_RichCompareBool(X, Y, Py_LT) :	\
			     islt(X, Y, COMPARE))</cpp:value></cpp:define>

<comment type="block">/* Compare X to Y via "&lt;".  Goto "fail" if the comparison raises an
   error.  Else "k" is set to true iff X&lt;Y, and an "if (k)" block is
   started.  It makes more sense in context &lt;wink&gt;.  X and Y are PyObject*s.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IFLT</name><parameter_list>(<param><type><name>X</name></type></param>, <param><type><name>Y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if ((k = ISLT(X, Y, compare)) &lt; 0) goto fail;  \
		   if (k)</cpp:value></cpp:define>

<comment type="block">/* binarysort is the best method for sorting small arrays: it does
   few compares, but can do data movement quadratic in the number of
   elements.
   [lo, hi) is a contiguous slice of a list, and is sorted via
   binary insertion.  This sort is stable.
   On entry, must have lo &lt;= start &lt;= hi, and that [lo, start) is already
   sorted (pass start == lo if you don't know!).
   If islt() complains return -1, else 0.
   Even in case of error, the output slice will be some permutation of
   the input (nothing is lost or duplicated).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>binarysort</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>lo</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>hi</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>start</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>compare</name></decl></param>)</parameter_list>
     <comment type="block">/* compare -- comparison function object, or NULL for default */</comment>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> **</type><name>l</name></decl>, **<decl><type ref="prev"/><name>p</name></decl>, **<decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>pivot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lo</name> &lt;= <name>start</name> &amp;&amp; <name>start</name> &lt;= <name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* assert [lo, start) is sorted */</comment>
	<if>if <condition>(<expr><name>lo</name> == <name>start</name></expr>)</condition><then>
		<expr_stmt><expr>++<name>start</name></expr>;</expr_stmt></then></if>
	<for>for (<init>;</init> <condition><expr><name>start</name> &lt; <name>hi</name></expr>;</condition> <incr><expr>++<name>start</name></expr></incr>) <block>{
		<comment type="block">/* set l to where *start belongs */</comment>
		<expr_stmt><expr><name>l</name> = <name>lo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>r</name> = <name>start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pivot</name> = *<name>r</name></expr>;</expr_stmt>
		<comment type="block">/* Invariants:
		 * pivot &gt;= all in [lo, l).
		 * pivot  &lt; all in [r, start).
		 * The second is vacuously true at the start.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>l</name> &lt; <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<do>do <block>{
			<expr_stmt><expr><name>p</name> = <name>l</name> + ((<name>r</name> - <name>l</name>) &gt;&gt; 1)</expr>;</expr_stmt>
			<macro><name>IFLT</name><argument_list>(<argument>pivot</argument>, <argument>*p</argument>)</argument_list></macro>
				<expr_stmt><expr><name>r</name> = <name>p</name></expr>;</expr_stmt>
			<else>else
				<expr_stmt><expr><name>l</name> = <name>p</name>+1</expr>;</expr_stmt></else>
		}</block> while <condition>(<expr><name>l</name> &lt; <name>r</name></expr>)</condition>;</do>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>l</name> == <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The invariants still hold, so pivot &gt;= all in [lo, l) and
		   pivot &lt; all in [l, start), so pivot belongs at l.  Note
		   that if there are elements equal to pivot, l points to the
		   first slot after them -- that's why this sort is stable.
		   Slide over to make room.
		   Caution: using memmove is much slower under MSVC 5;
		   we're not usually moving many slots. */</comment>
		<for>for (<init><expr><name>p</name> = <name>start</name></expr>;</init> <condition><expr><name>p</name> &gt; <name>l</name></expr>;</condition> <incr><expr>--<name>p</name></expr></incr>)
			<expr_stmt><expr>*<name>p</name> = *(<name>p</name>-1)</expr>;</expr_stmt></for>
		<expr_stmt><expr>*<name>l</name> = <name>pivot</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>0</expr>;</return>

 <label><name>fail</name>:</label>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/*
Return the length of the run beginning at lo, in the slice [lo, hi).  lo &lt; hi
is required on entry.  "A run" is the longest ascending sequence, with

    lo[0] &lt;= lo[1] &lt;= lo[2] &lt;= ...

or the longest descending sequence, with

    lo[0] &gt; lo[1] &gt; lo[2] &gt; ...

Boolean *descending is set to 0 in the former case, or to 1 in the latter.
For its intended use in a stable mergesort, the strictness of the defn of
"descending" is needed so that the caller can safely reverse a descending
sequence without violating stability (strict &gt; ensures there are no equal
elements to get out of order).

Returns -1 in case of error.
*/</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>count_run</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>lo</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>hi</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>compare</name></decl></param>, <param><decl><type><name>int</name> *</type><name>descending</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lo</name> &lt; <name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>descending</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr>++<name>lo</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>lo</name> == <name>hi</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<expr_stmt><expr><name>n</name> = 2</expr>;</expr_stmt>
	<macro><name>IFLT</name><argument_list>(<argument>*lo</argument>, <argument>*(lo-1)</argument>)</argument_list></macro> <block>{
		<expr_stmt><expr>*<name>descending</name> = 1</expr>;</expr_stmt>
		<for>for (<init><expr><name>lo</name> = <name>lo</name>+1</expr>;</init> <condition><expr><name>lo</name> &lt; <name>hi</name></expr>;</condition> <incr><expr>++<name>lo</name></expr>, <expr>++<name>n</name></expr></incr>) <block>{
			<expr_stmt><expr><call><name>IFLT</name><argument_list>(<argument><expr>*<name>lo</name></expr></argument>, <argument><expr>*(<name>lo</name>-1)</expr></argument>)</argument_list></call></expr>
				;</expr_stmt>
			<else>else
				<break>break;</break></else>
		}</block></for>
	}</block>
	<else>else <block>{
		<for>for (<init><expr><name>lo</name> = <name>lo</name>+1</expr>;</init> <condition><expr><name>lo</name> &lt; <name>hi</name></expr>;</condition> <incr><expr>++<name>lo</name></expr>, <expr>++<name>n</name></expr></incr>) <block>{
			<macro><name>IFLT</name><argument_list>(<argument>*lo</argument>, <argument>*(lo-1)</argument>)</argument_list></macro>
				<break>break;</break>
		}</block></for>
	}</block></else>

	<return>return <expr><name>n</name></expr>;</return>
<label><name>fail</name>:</label>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/*
Locate the proper position of key in a sorted vector; if the vector contains
an element equal to key, return the position immediately to the left of
the leftmost equal element.  [gallop_right() does the same except returns
the position to the right of the rightmost equal element (if any).]

"a" is a sorted vector with n elements, starting at a[0].  n must be &gt; 0.

"hint" is an index at which to begin the search, 0 &lt;= hint &lt; n.  The closer
hint is to the final result, the faster this runs.

The return value is the int k in 0..n such that

    a[k-1] &lt; key &lt;= a[k]

pretending that *(a-1) is minus infinity and a[n] is plus infinity.  IOW,
key belongs at index k; or, IOW, the first k elements of a should precede
key, and the last n-k should follow key.

Returns -1 on error.  See listsort.txt for info on the method.
*/</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>gallop_left</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>hint</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>compare</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ofs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lastofs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>k</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>key</name> &amp;&amp; <name>a</name> &amp;&amp; <name>n</name> &gt; 0 &amp;&amp; <name>hint</name> &gt;= 0 &amp;&amp; <name>hint</name> &lt; <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>a</name> += <name>hint</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastofs</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>ofs</name> = 1</expr>;</expr_stmt>
	<macro><name>IFLT</name><argument_list>(<argument>*a</argument>, <argument>key</argument>)</argument_list></macro> <block>{
		<comment type="block">/* a[hint] &lt; key -- gallop right, until
		 * a[hint + lastofs] &lt; key &lt;= a[hint + ofs]
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>maxofs</name> <init>= <expr><name>n</name> - <name>hint</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* &amp;a[n-1] is highest */</comment>
		<while>while <condition>(<expr><name>ofs</name> &lt; <name>maxofs</name></expr>)</condition> <block>{
			<macro><name>IFLT</name><argument_list>(<argument>a[ofs]</argument>, <argument>key</argument>)</argument_list></macro> <block>{
				<expr_stmt><expr><name>lastofs</name> = <name>ofs</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ofs</name> = (<name>ofs</name> &lt;&lt; 1) + 1</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ofs</name> &lt;= 0</expr>)</condition><then>	<comment type="block">/* int overflow */</comment>
					<expr_stmt><expr><name>ofs</name> = <name>maxofs</name></expr>;</expr_stmt></then></if>
			}</block>
 			<else>else	<comment type="block">/* key &lt;= a[hint + ofs] */</comment>
				<break>break;</break></else>
		}</block></while>
		<if>if <condition>(<expr><name>ofs</name> &gt; <name>maxofs</name></expr>)</condition><then>
			<expr_stmt><expr><name>ofs</name> = <name>maxofs</name></expr>;</expr_stmt></then></if>
		<comment type="block">/* Translate back to offsets relative to &amp;a[0]. */</comment>
		<expr_stmt><expr><name>lastofs</name> += <name>hint</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ofs</name> += <name>hint</name></expr>;</expr_stmt>
	}</block>
	<else>else <block>{
		<comment type="block">/* key &lt;= a[hint] -- gallop left, until
		 * a[hint - ofs] &lt; key &lt;= a[hint - lastofs]
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>maxofs</name> <init>= <expr><name>hint</name> + 1</expr></init></decl>;</decl_stmt>	<comment type="block">/* &amp;a[0] is lowest */</comment>
		<while>while <condition>(<expr><name>ofs</name> &lt; <name>maxofs</name></expr>)</condition> <block>{
			<macro><name>IFLT</name><argument_list>(<argument>*(a-ofs)</argument>, <argument>key</argument>)</argument_list></macro>
				<break>break;</break>
			<comment type="block">/* key &lt;= a[hint - ofs] */</comment>
			<expr_stmt><expr><name>lastofs</name> = <name>ofs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ofs</name> = (<name>ofs</name> &lt;&lt; 1) + 1</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ofs</name> &lt;= 0</expr>)</condition><then>	<comment type="block">/* int overflow */</comment>
				<expr_stmt><expr><name>ofs</name> = <name>maxofs</name></expr>;</expr_stmt></then></if>
		}</block></while>
		<if>if <condition>(<expr><name>ofs</name> &gt; <name>maxofs</name></expr>)</condition><then>
			<expr_stmt><expr><name>ofs</name> = <name>maxofs</name></expr>;</expr_stmt></then></if>
		<comment type="block">/* Translate back to positive offsets relative to &amp;a[0]. */</comment>
		<expr_stmt><expr><name>k</name> = <name>lastofs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastofs</name> = <name>hint</name> - <name>ofs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ofs</name> = <name>hint</name> - <name>k</name></expr>;</expr_stmt>
	}</block></else>
	<expr_stmt><expr><name>a</name> -= <name>hint</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>-1 &lt;= <name>lastofs</name> &amp;&amp; <name>lastofs</name> &lt; <name>ofs</name> &amp;&amp; <name>ofs</name> &lt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Now a[lastofs] &lt; key &lt;= a[ofs], so key belongs somewhere to the
	 * right of lastofs but no farther right than ofs.  Do a binary
	 * search, with invariant a[lastofs-1] &lt; key &lt;= a[ofs].
	 */</comment>
	<expr_stmt><expr>++<name>lastofs</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lastofs</name> &lt; <name>ofs</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>m</name> <init>= <expr><name>lastofs</name> + ((<name>ofs</name> - <name>lastofs</name>) &gt;&gt; 1)</expr></init></decl>;</decl_stmt>

		<macro><name>IFLT</name><argument_list>(<argument>a[m]</argument>, <argument>key</argument>)</argument_list></macro>
			<expr_stmt><expr><name>lastofs</name> = <name>m</name>+1</expr>;</expr_stmt>	<comment type="block">/* a[m] &lt; key */</comment>
		<else>else
			<expr_stmt><expr><name>ofs</name> = <name>m</name></expr>;</expr_stmt></else>	<comment type="block">/* key &lt;= a[m] */</comment>
	}</block></while>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lastofs</name> == <name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* so a[ofs-1] &lt; key &lt;= a[ofs] */</comment>
	<return>return <expr><name>ofs</name></expr>;</return>

<label><name>fail</name>:</label>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/*
Exactly like gallop_left(), except that if key already exists in a[0:n],
finds the position immediately to the right of the rightmost equal value.

The return value is the int k in 0..n such that

    a[k-1] &lt;= key &lt; a[k]

or -1 if error.

The code duplication is massive, but this is enough different given that
we're sticking to "&lt;" comparisons that it's much harder to follow if
written as one routine with yet another "left or right?" flag.
*/</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>gallop_right</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>a</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>hint</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>compare</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ofs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lastofs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>k</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>key</name> &amp;&amp; <name>a</name> &amp;&amp; <name>n</name> &gt; 0 &amp;&amp; <name>hint</name> &gt;= 0 &amp;&amp; <name>hint</name> &lt; <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>a</name> += <name>hint</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastofs</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>ofs</name> = 1</expr>;</expr_stmt>
	<macro><name>IFLT</name><argument_list>(<argument>key</argument>, <argument>*a</argument>)</argument_list></macro> <block>{
		<comment type="block">/* key &lt; a[hint] -- gallop left, until
		 * a[hint - ofs] &lt;= key &lt; a[hint - lastofs]
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>maxofs</name> <init>= <expr><name>hint</name> + 1</expr></init></decl>;</decl_stmt>	<comment type="block">/* &amp;a[0] is lowest */</comment>
		<while>while <condition>(<expr><name>ofs</name> &lt; <name>maxofs</name></expr>)</condition> <block>{
			<macro><name>IFLT</name><argument_list>(<argument>key</argument>, <argument>*(a-ofs)</argument>)</argument_list></macro> <block>{
				<expr_stmt><expr><name>lastofs</name> = <name>ofs</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ofs</name> = (<name>ofs</name> &lt;&lt; 1) + 1</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ofs</name> &lt;= 0</expr>)</condition><then>	<comment type="block">/* int overflow */</comment>
					<expr_stmt><expr><name>ofs</name> = <name>maxofs</name></expr>;</expr_stmt></then></if>
			}</block>
			<else>else	<comment type="block">/* a[hint - ofs] &lt;= key */</comment>
				<break>break;</break></else>
		}</block></while>
		<if>if <condition>(<expr><name>ofs</name> &gt; <name>maxofs</name></expr>)</condition><then>
			<expr_stmt><expr><name>ofs</name> = <name>maxofs</name></expr>;</expr_stmt></then></if>
		<comment type="block">/* Translate back to positive offsets relative to &amp;a[0]. */</comment>
		<expr_stmt><expr><name>k</name> = <name>lastofs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastofs</name> = <name>hint</name> - <name>ofs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ofs</name> = <name>hint</name> - <name>k</name></expr>;</expr_stmt>
	}</block>
	<else>else <block>{
		<comment type="block">/* a[hint] &lt;= key -- gallop right, until
		 * a[hint + lastofs] &lt;= key &lt; a[hint + ofs]
		*/</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>maxofs</name> <init>= <expr><name>n</name> - <name>hint</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* &amp;a[n-1] is highest */</comment>
		<while>while <condition>(<expr><name>ofs</name> &lt; <name>maxofs</name></expr>)</condition> <block>{
			<macro><name>IFLT</name><argument_list>(<argument>key</argument>, <argument>a[ofs]</argument>)</argument_list></macro>
				<break>break;</break>
			<comment type="block">/* a[hint + ofs] &lt;= key */</comment>
			<expr_stmt><expr><name>lastofs</name> = <name>ofs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ofs</name> = (<name>ofs</name> &lt;&lt; 1) + 1</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ofs</name> &lt;= 0</expr>)</condition><then>	<comment type="block">/* int overflow */</comment>
				<expr_stmt><expr><name>ofs</name> = <name>maxofs</name></expr>;</expr_stmt></then></if>
		}</block></while>
		<if>if <condition>(<expr><name>ofs</name> &gt; <name>maxofs</name></expr>)</condition><then>
			<expr_stmt><expr><name>ofs</name> = <name>maxofs</name></expr>;</expr_stmt></then></if>
		<comment type="block">/* Translate back to offsets relative to &amp;a[0]. */</comment>
		<expr_stmt><expr><name>lastofs</name> += <name>hint</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ofs</name> += <name>hint</name></expr>;</expr_stmt>
	}</block></else>
	<expr_stmt><expr><name>a</name> -= <name>hint</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>-1 &lt;= <name>lastofs</name> &amp;&amp; <name>lastofs</name> &lt; <name>ofs</name> &amp;&amp; <name>ofs</name> &lt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Now a[lastofs] &lt;= key &lt; a[ofs], so key belongs somewhere to the
	 * right of lastofs but no farther right than ofs.  Do a binary
	 * search, with invariant a[lastofs-1] &lt;= key &lt; a[ofs].
	 */</comment>
	<expr_stmt><expr>++<name>lastofs</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lastofs</name> &lt; <name>ofs</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>m</name> <init>= <expr><name>lastofs</name> + ((<name>ofs</name> - <name>lastofs</name>) &gt;&gt; 1)</expr></init></decl>;</decl_stmt>

		<macro><name>IFLT</name><argument_list>(<argument>key</argument>, <argument>a[m]</argument>)</argument_list></macro>
			<expr_stmt><expr><name>ofs</name> = <name>m</name></expr>;</expr_stmt>	<comment type="block">/* key &lt; a[m] */</comment>
		<else>else
			<expr_stmt><expr><name>lastofs</name> = <name>m</name>+1</expr>;</expr_stmt></else>	<comment type="block">/* a[m] &lt;= key */</comment>
	}</block></while>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lastofs</name> == <name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* so a[ofs-1] &lt;= key &lt; a[ofs] */</comment>
	<return>return <expr><name>ofs</name></expr>;</return>

<label><name>fail</name>:</label>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* The maximum number of entries in a MergeState's pending-runs stack.
 * This is enough to sort arrays of size up to about
 *     32 * phi ** MAX_MERGE_PENDING
 * where phi ~= 1.618.  85 is ridiculouslylarge enough, good for an array
 * with 2**64 elements.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MERGE_PENDING</name></cpp:macro> <cpp:value>85</cpp:value></cpp:define>

<comment type="block">/* When we get into galloping mode, we stay there until both runs win less
 * often than MIN_GALLOP consecutive times.  See listsort.txt for more info.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_GALLOP</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>

<comment type="block">/* Avoid malloc for small temp arrays. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MERGESTATE_TEMP_SIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/* One MergeState exists on the stack per invocation of mergesort.  It's just
 * a convenient way to pass state around among the helper functions.
 */</comment>
<struct>struct <name>s_slice</name> <block>{
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>s_MergeState</name> <block>{
	<comment type="block">/* The user-supplied comparison function. or NULL if none given. */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>compare</name></decl>;</decl_stmt>

	<comment type="block">/* This controls when we get *into* galloping mode.  It's initialized
	 * to MIN_GALLOP.  merge_lo and merge_hi tend to nudge it higher for
	 * random data, and lower for highly structured data.
	 */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>min_gallop</name></decl>;</decl_stmt>

	<comment type="block">/* 'a' is temp storage to help with merges.  It contains room for
	 * alloced entries.
	 */</comment>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>a</name></decl>;</decl_stmt>	<comment type="block">/* may point to temparray below */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>alloced</name></decl>;</decl_stmt>

	<comment type="block">/* A stack of n pending runs yet to be merged.  Run #i starts at
	 * address base[i] and extends for len[i] elements.  It's always
	 * true (so long as the indices are in bounds) that
	 *
	 *     pending[i].base + pending[i].len == pending[i+1].base
	 *
	 * so we could cut the storage for this, but it's a minor amount,
	 * and keeping all the info explicit simplifies the code.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>s_slice</name></type> <name><name>pending</name><index>[<expr><name>MAX_MERGE_PENDING</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* 'a' points to this when possible, rather than muck with malloc. */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name><name>temparray</name><index>[<expr><name>MERGESTATE_TEMP_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>MergeState</name>;</typedef>

<comment type="block">/* Conceptually a MergeState's constructor. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_init</name><parameter_list>(<param><decl><type><name>MergeState</name> *</type><name>ms</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>compare</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ms</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ms</name>-&gt;<name>compare</name></name> = <name>compare</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ms</name>-&gt;<name>a</name></name> = <name><name>ms</name>-&gt;<name>temparray</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ms</name>-&gt;<name>alloced</name></name> = <name>MERGESTATE_TEMP_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ms</name>-&gt;<name>n</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ms</name>-&gt;<name>min_gallop</name></name> = <name>MIN_GALLOP</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Free all the temp memory owned by the MergeState.  This must be called
 * when you're done with a MergeState, and may be called before then if
 * you want to free the temp memory early.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_freemem</name><parameter_list>(<param><decl><type><name>MergeState</name> *</type><name>ms</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ms</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>ms</name>-&gt;<name>a</name></name> != <name><name>ms</name>-&gt;<name>temparray</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>ms</name>-&gt;<name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>ms</name>-&gt;<name>a</name></name> = <name><name>ms</name>-&gt;<name>temparray</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ms</name>-&gt;<name>alloced</name></name> = <name>MERGESTATE_TEMP_SIZE</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Ensure enough temp memory for 'need' array slots is available.
 * Returns 0 on success and -1 if the memory can't be gotten.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>merge_getmem</name><parameter_list>(<param><decl><type><name>MergeState</name> *</type><name>ms</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>need</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ms</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>need</name> &lt;= <name><name>ms</name>-&gt;<name>alloced</name></name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<comment type="block">/* Don't realloc!  That can cost cycles to copy the old data, but
	 * we don't care what's in the block.
	 */</comment>
	<expr_stmt><expr><call><name>merge_freemem</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>need</name> &gt; <name>PY_SSIZE_T_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>ms</name>-&gt;<name>a</name></name> = (<name>PyObject</name> **)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>need</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>ms</name>-&gt;<name>a</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>ms</name>-&gt;<name>alloced</name></name> = <name>need</name></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>merge_freemem</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* reset to sane state */</comment>
	<return>return <expr>-1</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MERGE_GETMEM</name><parameter_list>(<param><type><name>MS</name></type></param>, <param><type><name>NEED</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((NEED) &lt;= (MS)-&gt;alloced ? 0 :	\
				merge_getmem(MS, NEED))</cpp:value></cpp:define>

<comment type="block">/* Merge the na elements starting at pa with the nb elements starting at pb
 * in a stable way, in-place.  na and nb must be &gt; 0, and pa + na == pb.
 * Must also have that *pb &lt; *pa, that pa[na-1] belongs at the end of the
 * merge, and should have na &lt;= nb.  See listsort.txt for more info.
 * Return 0 if successful, -1 if error.
 */</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>merge_lo</name><parameter_list>(<param><decl><type><name>MergeState</name> *</type><name>ms</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pa</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>na</name></decl></param>,
                         <param><decl><type><name>PyObject</name> **</type><name>pb</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>nb</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>compare</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>	<comment type="block">/* guilty until proved innocent */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>min_gallop</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ms</name> &amp;&amp; <name>pa</name> &amp;&amp; <name>pb</name> &amp;&amp; <name>na</name> &gt; 0 &amp;&amp; <name>nb</name> &gt; 0 &amp;&amp; <name>pa</name> + <name>na</name> == <name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>MERGE_GETMEM</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>na</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ms</name>-&gt;<name>a</name></name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>na</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest</name> = <name>pa</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pa</name> = <name><name>ms</name>-&gt;<name>a</name></name></expr>;</expr_stmt>

	<expr_stmt><expr>*<name>dest</name>++ = *<name>pb</name>++</expr>;</expr_stmt>
	<expr_stmt><expr>--<name>nb</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>nb</name> == 0</expr>)</condition><then>
		<goto>goto <name>Succeed</name>;</goto></then></if>
	<if>if <condition>(<expr><name>na</name> == 1</expr>)</condition><then>
		<goto>goto <name>CopyB</name>;</goto></then></if>

	<expr_stmt><expr><name>min_gallop</name> = <name><name>ms</name>-&gt;<name>min_gallop</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>compare</name> = <name><name>ms</name>-&gt;<name>compare</name></name></expr>;</expr_stmt>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>acount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* # of times A won in a row */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bcount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* # of times B won in a row */</comment>

		<comment type="block">/* Do the straightforward thing until (if ever) one run
		 * appears to win consistently.
		 */</comment>
 		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
 			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>na</name> &gt; 1 &amp;&amp; <name>nb</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 		<expr_stmt><expr><name>k</name> = <call><name>ISLT</name><argument_list>(<argument><expr>*<name>pb</name></expr></argument>, <argument><expr>*<name>pa</name></expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>k</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then>
					<goto>goto <name>Fail</name>;</goto></then></if>
				<expr_stmt><expr>*<name>dest</name>++ = *<name>pb</name>++</expr>;</expr_stmt>
				<expr_stmt><expr>++<name>bcount</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>acount</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr>--<name>nb</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>nb</name> == 0</expr>)</condition><then>
					<goto>goto <name>Succeed</name>;</goto></then></if>
				<if>if <condition>(<expr><name>bcount</name> &gt;= <name>min_gallop</name></expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr>*<name>dest</name>++ = *<name>pa</name>++</expr>;</expr_stmt>
				<expr_stmt><expr>++<name>acount</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>bcount</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr>--<name>na</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>na</name> == 1</expr>)</condition><then>
					<goto>goto <name>CopyB</name>;</goto></then></if>
				<if>if <condition>(<expr><name>acount</name> &gt;= <name>min_gallop</name></expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></else></if>
 		}</block></for>

		<comment type="block">/* One run is winning so consistently that galloping may
		 * be a huge win.  So try that, and continue galloping until
		 * (if ever) neither run appears to be winning consistently
		 * anymore.
		 */</comment>
		<expr_stmt><expr>++<name>min_gallop</name></expr>;</expr_stmt>
		<do>do <block>{
 			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>na</name> &gt; 1 &amp;&amp; <name>nb</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>min_gallop</name> -= <name>min_gallop</name> &gt; 1</expr>;</expr_stmt>
	 		<expr_stmt><expr><name><name>ms</name>-&gt;<name>min_gallop</name></name> = <name>min_gallop</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>k</name> = <call><name>gallop_right</name><argument_list>(<argument><expr>*<name>pb</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>acount</name> = <name>k</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>k</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then>
					<goto>goto <name>Fail</name>;</goto></then></if>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>k</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dest</name> += <name>k</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pa</name> += <name>k</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>na</name> -= <name>k</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>na</name> == 1</expr>)</condition><then>
					<goto>goto <name>CopyB</name>;</goto></then></if>
				<comment type="block">/* na==0 is impossible now if the comparison
				 * function is consistent, but we can't assume
				 * that it is.
				 */</comment>
				<if>if <condition>(<expr><name>na</name> == 0</expr>)</condition><then>
					<goto>goto <name>Succeed</name>;</goto></then></if>
			}</block></then></if>
			<expr_stmt><expr>*<name>dest</name>++ = *<name>pb</name>++</expr>;</expr_stmt>
			<expr_stmt><expr>--<name>nb</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>nb</name> == 0</expr>)</condition><then>
				<goto>goto <name>Succeed</name>;</goto></then></if>

 			<expr_stmt><expr><name>k</name> = <call><name>gallop_left</name><argument_list>(<argument><expr>*<name>pa</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 			<expr_stmt><expr><name>bcount</name> = <name>k</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>k</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then>
					<goto>goto <name>Fail</name>;</goto></then></if>
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>k</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dest</name> += <name>k</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pb</name> += <name>k</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nb</name> -= <name>k</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>nb</name> == 0</expr>)</condition><then>
					<goto>goto <name>Succeed</name>;</goto></then></if>
			}</block></then></if>
			<expr_stmt><expr>*<name>dest</name>++ = *<name>pa</name>++</expr>;</expr_stmt>
			<expr_stmt><expr>--<name>na</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>na</name> == 1</expr>)</condition><then>
				<goto>goto <name>CopyB</name>;</goto></then></if>
 		}</block> while <condition>(<expr><name>acount</name> &gt;= <name>MIN_GALLOP</name> || <name>bcount</name> &gt;= <name>MIN_GALLOP</name></expr>)</condition>;</do>
 		<expr_stmt><expr>++<name>min_gallop</name></expr>;</expr_stmt>	<comment type="block">/* penalize it for leaving galloping mode */</comment>
 		<expr_stmt><expr><name><name>ms</name>-&gt;<name>min_gallop</name></name> = <name>min_gallop</name></expr>;</expr_stmt>
 	}</block></for>
<label><name>Succeed</name>:</label>
	<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
<label><name>Fail</name>:</label>
	<if>if <condition>(<expr><name>na</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>na</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
<label><name>CopyB</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>na</name> == 1 &amp;&amp; <name>nb</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The last element of pa belongs at the end of the merge. */</comment>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>nb</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><index>[<expr><name>nb</name></expr>]</index></name> = *<name>pa</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Merge the na elements starting at pa with the nb elements starting at pb
 * in a stable way, in-place.  na and nb must be &gt; 0, and pa + na == pb.
 * Must also have that *pb &lt; *pa, that pa[na-1] belongs at the end of the
 * merge, and should have na &gt;= nb.  See listsort.txt for more info.
 * Return 0 if successful, -1 if error.
 */</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>merge_hi</name><parameter_list>(<param><decl><type><name>MergeState</name> *</type><name>ms</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pa</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>na</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pb</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>nb</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>compare</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>	<comment type="block">/* guilty until proved innocent */</comment>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>basea</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>baseb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>min_gallop</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ms</name> &amp;&amp; <name>pa</name> &amp;&amp; <name>pb</name> &amp;&amp; <name>na</name> &gt; 0 &amp;&amp; <name>nb</name> &gt; 0 &amp;&amp; <name>pa</name> + <name>na</name> == <name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>MERGE_GETMEM</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>dest</name> = <name>pb</name> + <name>nb</name> - 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ms</name>-&gt;<name>a</name></name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>nb</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>basea</name> = <name>pa</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>baseb</name> = <name><name>ms</name>-&gt;<name>a</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pb</name> = <name><name>ms</name>-&gt;<name>a</name></name> + <name>nb</name> - 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>pa</name> += <name>na</name> - 1</expr>;</expr_stmt>

	<expr_stmt><expr>*<name>dest</name>-- = *<name>pa</name>--</expr>;</expr_stmt>
	<expr_stmt><expr>--<name>na</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>na</name> == 0</expr>)</condition><then>
		<goto>goto <name>Succeed</name>;</goto></then></if>
	<if>if <condition>(<expr><name>nb</name> == 1</expr>)</condition><then>
		<goto>goto <name>CopyA</name>;</goto></then></if>

	<expr_stmt><expr><name>min_gallop</name> = <name><name>ms</name>-&gt;<name>min_gallop</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>compare</name> = <name><name>ms</name>-&gt;<name>compare</name></name></expr>;</expr_stmt>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>acount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* # of times A won in a row */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bcount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* # of times B won in a row */</comment>

		<comment type="block">/* Do the straightforward thing until (if ever) one run
		 * appears to win consistently.
		 */</comment>
 		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
 			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>na</name> &gt; 0 &amp;&amp; <name>nb</name> &gt; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 		<expr_stmt><expr><name>k</name> = <call><name>ISLT</name><argument_list>(<argument><expr>*<name>pb</name></expr></argument>, <argument><expr>*<name>pa</name></expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>k</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then>
					<goto>goto <name>Fail</name>;</goto></then></if>
				<expr_stmt><expr>*<name>dest</name>-- = *<name>pa</name>--</expr>;</expr_stmt>
				<expr_stmt><expr>++<name>acount</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>bcount</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr>--<name>na</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>na</name> == 0</expr>)</condition><then>
					<goto>goto <name>Succeed</name>;</goto></then></if>
				<if>if <condition>(<expr><name>acount</name> &gt;= <name>min_gallop</name></expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr>*<name>dest</name>-- = *<name>pb</name>--</expr>;</expr_stmt>
				<expr_stmt><expr>++<name>bcount</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>acount</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr>--<name>nb</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>nb</name> == 1</expr>)</condition><then>
					<goto>goto <name>CopyA</name>;</goto></then></if>
				<if>if <condition>(<expr><name>bcount</name> &gt;= <name>min_gallop</name></expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></else></if>
 		}</block></for>

		<comment type="block">/* One run is winning so consistently that galloping may
		 * be a huge win.  So try that, and continue galloping until
		 * (if ever) neither run appears to be winning consistently
		 * anymore.
		 */</comment>
		<expr_stmt><expr>++<name>min_gallop</name></expr>;</expr_stmt>
		<do>do <block>{
 			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>na</name> &gt; 0 &amp;&amp; <name>nb</name> &gt; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>min_gallop</name> -= <name>min_gallop</name> &gt; 1</expr>;</expr_stmt>
	 		<expr_stmt><expr><name><name>ms</name>-&gt;<name>min_gallop</name></name> = <name>min_gallop</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>k</name> = <call><name>gallop_right</name><argument_list>(<argument><expr>*<name>pb</name></expr></argument>, <argument><expr><name>basea</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr><name>na</name>-1</expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
			<expr_stmt><expr><name>k</name> = <name>na</name> - <name>k</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>acount</name> = <name>k</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>k</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>dest</name> -= <name>k</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pa</name> -= <name>k</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name>+1</expr></argument>, <argument><expr><name>pa</name>+1</expr></argument>, <argument><expr><name>k</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>na</name> -= <name>k</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>na</name> == 0</expr>)</condition><then>
					<goto>goto <name>Succeed</name>;</goto></then></if>
			}</block></then></if>
			<expr_stmt><expr>*<name>dest</name>-- = *<name>pb</name>--</expr>;</expr_stmt>
			<expr_stmt><expr>--<name>nb</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>nb</name> == 1</expr>)</condition><then>
				<goto>goto <name>CopyA</name>;</goto></then></if>

 			<expr_stmt><expr><name>k</name> = <call><name>gallop_left</name><argument_list>(<argument><expr>*<name>pa</name></expr></argument>, <argument><expr><name>baseb</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>, <argument><expr><name>nb</name>-1</expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
			<expr_stmt><expr><name>k</name> = <name>nb</name> - <name>k</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bcount</name> = <name>k</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>k</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>dest</name> -= <name>k</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pb</name> -= <name>k</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name>+1</expr></argument>, <argument><expr><name>pb</name>+1</expr></argument>, <argument><expr><name>k</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nb</name> -= <name>k</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>nb</name> == 1</expr>)</condition><then>
					<goto>goto <name>CopyA</name>;</goto></then></if>
				<comment type="block">/* nb==0 is impossible now if the comparison
				 * function is consistent, but we can't assume
				 * that it is.
				 */</comment>
				<if>if <condition>(<expr><name>nb</name> == 0</expr>)</condition><then>
					<goto>goto <name>Succeed</name>;</goto></then></if>
			}</block></then></if>
			<expr_stmt><expr>*<name>dest</name>-- = *<name>pa</name>--</expr>;</expr_stmt>
			<expr_stmt><expr>--<name>na</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>na</name> == 0</expr>)</condition><then>
				<goto>goto <name>Succeed</name>;</goto></then></if>
 		}</block> while <condition>(<expr><name>acount</name> &gt;= <name>MIN_GALLOP</name> || <name>bcount</name> &gt;= <name>MIN_GALLOP</name></expr>)</condition>;</do>
 		<expr_stmt><expr>++<name>min_gallop</name></expr>;</expr_stmt>	<comment type="block">/* penalize it for leaving galloping mode */</comment>
 		<expr_stmt><expr><name><name>ms</name>-&gt;<name>min_gallop</name></name> = <name>min_gallop</name></expr>;</expr_stmt>
 	}</block></for>
<label><name>Succeed</name>:</label>
	<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
<label><name>Fail</name>:</label>
	<if>if <condition>(<expr><name>nb</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name>-(<name>nb</name>-1)</expr></argument>, <argument><expr><name>baseb</name></expr></argument>, <argument><expr><name>nb</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
<label><name>CopyA</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nb</name> == 1 &amp;&amp; <name>na</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The first element of pb belongs at the front of the merge. */</comment>
	<expr_stmt><expr><name>dest</name> -= <name>na</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pa</name> -= <name>na</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name>+1</expr></argument>, <argument><expr><name>pa</name>+1</expr></argument>, <argument><expr><name>na</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>dest</name> = *<name>pb</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Merge the two runs at stack indices i and i+1.
 * Returns 0 on success, -1 on error.
 */</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>merge_at</name><parameter_list>(<param><decl><type><name>MergeState</name> *</type><name>ms</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>pa</name></decl>, **<decl><type ref="prev"/><name>pb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>na</name></decl>, <decl><type ref="prev"/><name>nb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>compare</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ms</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name>-&gt;<name>n</name></name> &gt;= 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> == <name><name>ms</name>-&gt;<name>n</name></name> - 2 || <name>i</name> == <name><name>ms</name>-&gt;<name>n</name></name> - 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pa</name> = <name><name>ms</name>-&gt;<name>pending</name><index>[<expr><name>i</name></expr>]</index></name>.<name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>na</name> = <name><name>ms</name>-&gt;<name>pending</name><index>[<expr><name>i</name></expr>]</index></name>.<name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pb</name> = <name><name>ms</name>-&gt;<name>pending</name><index>[<expr><name>i</name>+1</expr>]</index></name>.<name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nb</name> = <name><name>ms</name>-&gt;<name>pending</name><index>[<expr><name>i</name>+1</expr>]</index></name>.<name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>na</name> &gt; 0 &amp;&amp; <name>nb</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pa</name> + <name>na</name> == <name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Record the length of the combined runs; if i is the 3rd-last
	 * run now, also slide over the last run (which isn't involved
	 * in this merge).  The current run i+1 goes away in any case.
	 */</comment>
	<expr_stmt><expr><name><name>ms</name>-&gt;<name>pending</name><index>[<expr><name>i</name></expr>]</index></name>.<name>len</name> = <name>na</name> + <name>nb</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> == <name><name>ms</name>-&gt;<name>n</name></name> - 3</expr>)</condition><then>
		<expr_stmt><expr><name><name>ms</name>-&gt;<name>pending</name><index>[<expr><name>i</name>+1</expr>]</index></name> = <name><name>ms</name>-&gt;<name>pending</name><index>[<expr><name>i</name>+2</expr>]</index></name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr>--<name><name>ms</name>-&gt;<name>n</name></name></expr>;</expr_stmt>

	<comment type="block">/* Where does b start in a?  Elements in a before that can be
	 * ignored (already in place).
	 */</comment>
	<expr_stmt><expr><name>compare</name> = <name><name>ms</name>-&gt;<name>compare</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> = <call><name>gallop_right</name><argument_list>(<argument><expr>*<name>pb</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>pa</name> += <name>k</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>na</name> -= <name>k</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>na</name> == 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<comment type="block">/* Where does a end in b?  Elements in b after that can be
	 * ignored (already in place).
	 */</comment>
	<expr_stmt><expr><name>nb</name> = <call><name>gallop_left</name><argument_list>(<argument><expr><name><name>pa</name><index>[<expr><name>na</name>-1</expr>]</index></name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>, <argument><expr><name>nb</name>-1</expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>nb</name> &lt;= 0</expr>)</condition><then>
		<return>return <expr><name>nb</name></expr>;</return></then></if>

	<comment type="block">/* Merge what remains of the runs, using a temp array with
	 * min(na, nb) elements.
	 */</comment>
	<if>if <condition>(<expr><name>na</name> &lt;= <name>nb</name></expr>)</condition><then>
		<return>return <expr><call><name>merge_lo</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>merge_hi</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<comment type="block">/* Examine the stack of runs waiting to be merged, merging adjacent runs
 * until the stack invariants are re-established:
 *
 * 1. len[-3] &gt; len[-2] + len[-1]
 * 2. len[-2] &gt; len[-1]
 *
 * See listsort.txt for more info.
 *
 * Returns 0 on success, -1 on error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>merge_collapse</name><parameter_list>(<param><decl><type><name>MergeState</name> *</type><name>ms</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>s_slice</name> *</type><name>p</name> <init>= <expr><name><name>ms</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>ms</name>-&gt;<name>n</name></name> &gt; 1</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><name><name>ms</name>-&gt;<name>n</name></name> - 2</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; <name><name>p</name><index>[<expr><name>n</name>-1</expr>]</index></name>.<name>len</name> &lt;= <name><name>p</name><index>[<expr><name>n</name></expr>]</index></name>.<name>len</name> + <name><name>p</name><index>[<expr><name>n</name>+1</expr>]</index></name>.<name>len</name></expr>)</condition><then> <block>{
		    	<if>if <condition>(<expr><name><name>p</name><index>[<expr><name>n</name>-1</expr>]</index></name>.<name>len</name> &lt; <name><name>p</name><index>[<expr><name>n</name>+1</expr>]</index></name>.<name>len</name></expr>)</condition><then>
		    		<expr_stmt><expr>--<name>n</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><call><name>merge_at</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name>.<name>len</name> &lt;= <name><name>p</name><index>[<expr><name>n</name>+1</expr>]</index></name>.<name>len</name></expr>)</condition><then> <block>{
			 <if>if <condition>(<expr><call><name>merge_at</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			 	<return>return <expr>-1</expr>;</return></then></if>
		}</block></then>
		<else>else
			<break>break;</break></else></if></else></if>
	}</block></while>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Regardless of invariants, merge all runs on the stack until only one
 * remains.  This is used at the end of the mergesort.
 *
 * Returns 0 on success, -1 on error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>merge_force_collapse</name><parameter_list>(<param><decl><type><name>MergeState</name> *</type><name>ms</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>s_slice</name> *</type><name>p</name> <init>= <expr><name><name>ms</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>ms</name>-&gt;<name>n</name></name> &gt; 1</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><name><name>ms</name>-&gt;<name>n</name></name> - 2</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; <name><name>p</name><index>[<expr><name>n</name>-1</expr>]</index></name>.<name>len</name> &lt; <name><name>p</name><index>[<expr><name>n</name>+1</expr>]</index></name>.<name>len</name></expr>)</condition><then>
			<expr_stmt><expr>--<name>n</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><call><name>merge_at</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></while>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Compute a good value for the minimum run length; natural runs shorter
 * than this are boosted artificially via binary insertion.
 *
 * If n &lt; 64, return n (it's too small to bother with fancy stuff).
 * Else if n is an exact power of 2, return 32.
 * Else return an int k, 32 &lt;= k &lt;= 64, such that n/k is close to, but
 * strictly less than, an exact power of 2.
 *
 * See listsort.txt for more info.
 */</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>merge_compute_minrun</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>r</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* becomes 1 if any 1 bits are shifted off */</comment>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>n</name> &gt;= 64</expr>)</condition> <block>{
		<expr_stmt><expr><name>r</name> |= <name>n</name> &amp; 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> &gt;&gt;= 1</expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>n</name> + <name>r</name></expr>;</return>
}</block></function>

<comment type="block">/* Special wrapper to support stable sorting using the decorate-sort-undecorate
   pattern.  Holds a key which is used for comparisons and the original record
   which is returned during the undecorate phase.  By exposing only the key
   during comparisons, the underlying sort stability characteristics are left
   unchanged.  Also, if a custom comparison function is used, it will only see
   the key instead of a full record. */</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>sortwrapperobject</name>;</typedef>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sortwrapper_doc</name></expr></argument>, <argument><expr>"Object wrapper with a custom sort key."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sortwrapper_richcompare</name><parameter_list>(<param><decl><type><name>sortwrapperobject</name> *</type></decl></param>, <param><decl><type><name>sortwrapperobject</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>sortwrapper_dealloc</name><parameter_list>(<param><decl><type><name>sortwrapperobject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>sortwrapper_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"sortwrapper"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>sortwrapperobject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>sortwrapper_dealloc</name></expr>,	<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> |
	<name>Py_TPFLAGS_HAVE_RICHCOMPARE</name></expr>, 		<comment type="block">/* tp_flags */</comment>
	<expr><name>sortwrapper_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>(<name>richcmpfunc</name>)<name>sortwrapper_richcompare</name></expr>,	<comment type="block">/* tp_richcompare */</comment>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sortwrapper_richcompare</name><parameter_list>(<param><decl><type><name>sortwrapperobject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>sortwrapperobject</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>sortwrapper_type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"expected a sortwrapperobject"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyObject_RichCompare</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sortwrapper_dealloc</name><parameter_list>(<param><decl><type><name>sortwrapperobject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>so</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>so</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Returns a new reference to a sortwrapper.
   Consumes the references to the two underlying objects. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>build_sortwrapper</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>sortwrapperobject</name> *</type><name>so</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>so</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>sortwrapperobject</name></expr></argument>, <argument><expr>&amp;<name>sortwrapper_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>so</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name>-&gt;<name>value</name></name> = <name>value</name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>so</name></expr>;</return>
}</block></function>

<comment type="block">/* Returns a new reference to the value underlying the wrapper. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sortwrapper_getvalue</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>so</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr>&amp;<name>sortwrapper_type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"expected a sortwrapperobject"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>value</name> = ((<name>sortwrapperobject</name> *)<name>so</name>)-&gt;<name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>value</name></expr>;</return>
}</block></function>

<comment type="block">/* Wrapper for user specified cmp functions in combination with a
   specified key function.  Makes sure the cmp function is presented
   with the actual key instead of the sortwrapper */</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
}</block></struct></type> <name>cmpwrapperobject</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cmpwrapper_dealloc</name><parameter_list>(<param><decl><type><name>cmpwrapperobject</name> *</type><name>co</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cmpwrapper_call</name><parameter_list>(<param><decl><type><name>cmpwrapperobject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>, *<decl><type ref="prev"/><name>y</name></decl>, *<decl><type ref="prev"/><name>xx</name></decl>, *<decl><type ref="prev"/><name>yy</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>&amp;<name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>&amp;<name>sortwrapper_type</name></expr></argument>)</argument_list></call> ||
	    !<call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr>&amp;<name>sortwrapper_type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"expected a sortwrapperobject"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>xx</name> = ((<name>sortwrapperobject</name> *)<name>x</name>)-&gt;<name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>yy</name> = ((<name>sortwrapperobject</name> *)<name>y</name>)-&gt;<name>key</name></expr>;</expr_stmt>
	<return>return <expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name>xx</name></expr></argument>, <argument><expr><name>yy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>cmpwrapper_doc</name></expr></argument>, <argument><expr>"cmp() wrapper for sort with custom keys."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>cmpwrapper_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"cmpwrapper"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmpwrapperobject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>cmpwrapper_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>(<name>ternaryfunc</name>)<name>cmpwrapper_call</name></expr>,		<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,			<comment type="block">/* tp_flags */</comment>
	<expr><name>cmpwrapper_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>build_cmpwrapper</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cmpfunc</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>cmpwrapperobject</name> *</type><name>co</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>co</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>cmpwrapperobject</name></expr></argument>, <argument><expr>&amp;<name>cmpwrapper_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>cmpfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>co</name>-&gt;<name>func</name></name> = <name>cmpfunc</name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>co</name></expr>;</return>
}</block></function>

<comment type="block">/* An adaptive, stable, natural mergesort.  See listsort.txt.
 * Returns Py_None on success, NULL on error.  Even in case of error, the
 * list will be some permutation of its input state (nothing is lost or
 * duplicated).
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listsort</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>MergeState</name></type> <name>ms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>lo</name></decl>, **<decl><type ref="prev"/><name>hi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nremaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>minrun</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>saved_ob_size</name></decl>, <decl><type ref="prev"/><name>saved_allocated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>saved_ob_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>final_ob_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>compare</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* guilty until proved innocent */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>reverse</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>keyfunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>kvpair</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"cmp"</expr>, <expr>"key"</expr>, <expr>"reverse"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>self</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|OOi:sort"</expr></argument>,
			<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>compare</name></expr></argument>, <argument><expr>&amp;<name>keyfunc</name></expr></argument>, <argument><expr>&amp;<name>reverse</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>compare</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>compare</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>compare</name> != <name>NULL</name> &amp;&amp; 
	    <call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"the cmp argument is not supported in 3.x"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>keyfunc</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>keyfunc</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>compare</name> != <name>NULL</name> &amp;&amp; <name>keyfunc</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>compare</name> = <call><name>build_cmpwrapper</name><argument_list>(<argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>compare</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then> <else>else
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<comment type="block">/* The list is temporarily made empty, so that mutations performed
	 * by comparison functions can't affect the slice of memory we're
	 * sorting (allowing mutations during sorting is a core-dump
	 * factory, since ob_item may change).
	 */</comment>
	<expr_stmt><expr><name>saved_ob_size</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>saved_ob_item</name> = <name><name>self</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saved_allocated</name> = <name><name>self</name>-&gt;<name>allocated</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_item</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>allocated</name></name> = -1</expr>;</expr_stmt> <comment type="block">/* any operation will reset it to &gt;= 0 */</comment>

	<if>if <condition>(<expr><name>keyfunc</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>saved_ob_size</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>value</name> = <name><name>saved_ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>key</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>keyfunc</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<for>for (<init><expr><name>i</name>=<name>i</name>-1</expr> ;</init> <condition><expr><name>i</name>&gt;=0</expr> ;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
					<expr_stmt><expr><name>kvpair</name> = <name><name>saved_ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>value</name> = <call><name>sortwrapper_getvalue</name><argument_list>(<argument><expr><name>kvpair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saved_ob_item</name><index>[<expr><name>i</name></expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>kvpair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></for>
				<goto>goto <name>dsu_fail</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name>kvpair</name> = <call><name>build_sortwrapper</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>kvpair</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>dsu_fail</name>;</goto></then></if>
			<expr_stmt><expr><name><name>saved_ob_item</name><index>[<expr><name>i</name></expr>]</index></name> = <name>kvpair</name></expr>;</expr_stmt>
		}</block></for>
	}</block></then></if>

	<comment type="block">/* Reverse sort stability achieved by initially reversing the list,
	applying a stable forward sort, then reversing the final result. */</comment>
	<if>if <condition>(<expr><name>reverse</name> &amp;&amp; <name>saved_ob_size</name> &gt; 1</expr>)</condition><then>
		<expr_stmt><expr><call><name>reverse_slice</name><argument_list>(<argument><expr><name>saved_ob_item</name></expr></argument>, <argument><expr><name>saved_ob_item</name> + <name>saved_ob_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>merge_init</name><argument_list>(<argument><expr>&amp;<name>ms</name></expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nremaining</name> = <name>saved_ob_size</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>nremaining</name> &lt; 2</expr>)</condition><then>
		<goto>goto <name>succeed</name>;</goto></then></if>

	<comment type="block">/* March over the array once, left to right, finding natural runs,
	 * and extending short natural runs to minrun elements.
	 */</comment>
	<expr_stmt><expr><name>lo</name> = <name>saved_ob_item</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> = <name>lo</name> + <name>nremaining</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minrun</name> = <call><name>merge_compute_minrun</name><argument_list>(<argument><expr><name>nremaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<do>do <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>descending</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

		<comment type="block">/* Identify next run. */</comment>
		<expr_stmt><expr><name>n</name> = <call><name>count_run</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>compare</name></expr></argument>, <argument><expr>&amp;<name>descending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
			<goto>goto <name>fail</name>;</goto></then></if>
		<if>if <condition>(<expr><name>descending</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>reverse_slice</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>lo</name> + <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<comment type="block">/* If short, extend to min(minrun, nremaining). */</comment>
		<if>if <condition>(<expr><name>n</name> &lt; <name>minrun</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>force</name> <init>= <expr><name>nremaining</name> &lt;= <name>minrun</name> ?
	 			  	  <name>nremaining</name> : <name>minrun</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>binarysort</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>lo</name> + <name>force</name></expr></argument>, <argument><expr><name>lo</name> + <name>n</name></expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<goto>goto <name>fail</name>;</goto></then></if>
			<expr_stmt><expr><name>n</name> = <name>force</name></expr>;</expr_stmt>
		}</block></then></if>
		<comment type="block">/* Push run onto pending-runs stack, and maybe merge. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name>.<name>n</name></name> &lt; <name>MAX_MERGE_PENDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ms</name>.<name>pending</name><index>[<expr><name><name>ms</name>.<name>n</name></name></expr>]</index></name>.<name>base</name> = <name>lo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ms</name>.<name>pending</name><index>[<expr><name><name>ms</name>.<name>n</name></name></expr>]</index></name>.<name>len</name> = <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr>++<name><name>ms</name>.<name>n</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>merge_collapse</name><argument_list>(<argument><expr>&amp;<name>ms</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>fail</name>;</goto></then></if>
		<comment type="block">/* Advance to find next run. */</comment>
		<expr_stmt><expr><name>lo</name> += <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nremaining</name> -= <name>n</name></expr>;</expr_stmt>
	}</block> while <condition>(<expr><name>nremaining</name></expr>)</condition>;</do>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lo</name> == <name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>merge_force_collapse</name><argument_list>(<argument><expr>&amp;<name>ms</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name>.<name>n</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name>.<name>pending</name><index>[<expr>0</expr>]</index></name>.<name>base</name> == <name>saved_ob_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ms</name>.<name>pending</name><index>[<expr>0</expr>]</index></name>.<name>len</name> == <name>saved_ob_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>succeed</name>:</label>
	<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
<label><name>fail</name>:</label>
	<if>if <condition>(<expr><name>keyfunc</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>saved_ob_size</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>kvpair</name> = <name><name>saved_ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> = <call><name>sortwrapper_getvalue</name><argument_list>(<argument><expr><name>kvpair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>saved_ob_item</name><index>[<expr><name>i</name></expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>kvpair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>allocated</name></name> != -1 &amp;&amp; <name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* The user mucked with the list during the sort,
		 * and we don't already have another error to report.
		 */</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"list modified during sort"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>reverse</name> &amp;&amp; <name>saved_ob_size</name> &gt; 1</expr>)</condition><then>
		<expr_stmt><expr><call><name>reverse_slice</name><argument_list>(<argument><expr><name>saved_ob_item</name></expr></argument>, <argument><expr><name>saved_ob_item</name> + <name>saved_ob_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>merge_freemem</name><argument_list>(<argument><expr>&amp;<name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>dsu_fail</name>:</label>
	<expr_stmt><expr><name>final_ob_item</name> = <name><name>self</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> = <name>saved_ob_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>ob_item</name></name> = <name>saved_ob_item</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>allocated</name></name> = <name>saved_allocated</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>final_ob_item</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* we cannot use list_clear() for this because it does not
		   guarantee that the list is really empty when it returns */</comment>
		<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>final_ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>final_ob_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IFLT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ISLT</name></cpp:undef>

<function><type><name>int</name></type>
<name>PyList_Sort</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>listsort</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listreverse</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then>
		<expr_stmt><expr><call><name>reverse_slice</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type>
<name>PyList_Reverse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>self</name> <init>= <expr>(<name>PyListObject</name> *)<name>v</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then>
		<expr_stmt><expr><call><name>reverse_slice</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyList_AsTuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>p</name></decl>, **<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>n</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>p</name> = ((<name>PyTupleObject</name> *)<name>w</name>)-&gt;<name>ob_item</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> = ((<name>PyListObject</name> *)<name>v</name>)-&gt;<name>ob_item</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>--<name>n</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name> = *<name>q</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>q</name>++</expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>w</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listindex</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>start</name><init>=<expr>0</expr></init>, <name>stop</name><init>=<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:index"</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>,
	                            <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>,
	                            <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>start</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>stop</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>stop</name> += <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>stop</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>stop</name> = 0</expr>;</expr_stmt></then></if>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = <name>start</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>stop</name> &amp;&amp; <name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
			<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
	}</block></for>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"list.index(x): x not in list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listcount</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
	}</block></for>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listremove</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>list_ass_slice</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>,
					   <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
	}</block></for>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"list.remove(x): x not in list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_traverse</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>o</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>)
		<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>o</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>vl</name></decl>, *<decl><type ref="prev"/><name>wl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>vl</name> = (<name>PyListObject</name> *)<name>v</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>wl</name> = (<name>PyListObject</name> *)<name>w</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>vl</name></expr></argument>)</argument_list></call> != <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>wl</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>op</name> == <name>Py_EQ</name> || <name>op</name> == <name>Py_NE</name>)</expr>)</condition><then> <block>{
		<comment type="block">/* Shortcut: if the lengths differ, the lists differ */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name></expr>)</condition><then>
			<expr_stmt><expr><name>res</name> = <name>Py_False</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>res</name> = <name>Py_True</name></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Search for the first index where items are different */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>vl</name></expr></argument>)</argument_list></call> &amp;&amp; <name>i</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name><name>vl</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						 <argument><expr><name><name>wl</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr>!<name>k</name></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>

	<if>if <condition>(<expr><name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>vl</name></expr></argument>)</argument_list></call> || <name>i</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* No more items to compare -- compare sizes */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>vs</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>vl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ws</name> <init>= <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
		<case>case <expr><name>Py_LT</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>vs</name> &lt;  <name>ws</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_LE</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>vs</name> &lt;= <name>ws</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_EQ</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>vs</name> == <name>ws</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_NE</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>vs</name> != <name>ws</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_GT</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>vs</name> &gt;  <name>ws</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_GE</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>vs</name> &gt;= <name>ws</name></expr>;</expr_stmt> <break>break;</break>
		</case><default>default: <return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* cannot happen */</comment>
		</default>}</block></switch>
		<if>if <condition>(<expr><name>cmp</name></expr>)</condition><then>
			<expr_stmt><expr><name>res</name> = <name>Py_True</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>res</name> = <name>Py_False</name></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* We have an item that differs -- shortcuts for EQ/NE */</comment>
	<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_False</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>op</name> == <name>Py_NE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_True</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Compare the final item again using the proper operator */</comment>
	<return>return <expr><call><name>PyObject_RichCompare</name><argument_list>(<argument><expr><name><name>vl</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>wl</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_init</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"sequence"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|O:list"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<comment type="block">/* Verify list invariants established by PyType_GenericAlloc() */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt;= <name><name>self</name>-&gt;<name>allocated</name></name> || <name><name>self</name>-&gt;<name>allocated</name></name> == -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name> != <name>NULL</name> ||
	       <name><name>self</name>-&gt;<name>allocated</name></name> == 0 || <name><name>self</name>-&gt;<name>allocated</name></name> == -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Empty previous contents */</comment>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ob_item</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>(<name>void</name>)<call><name>list_clear</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>arg</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name> <init>= <expr><call><name>listextend</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>rv</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_sizeof</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>PyListObject</name></expr></argument>)</argument_list></sizeof> + <name><name>self</name>-&gt;<name>allocated</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>list_iter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>list_reversed</name><parameter_list>(<param><decl><type><name>PyListObject</name>*</type> <name>seq</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>unused</name></decl></param>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getitem_doc</name></expr></argument>,
<argument><expr>"x.__getitem__(y) &lt;==&gt; x[y]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reversed_doc</name></expr></argument>,
<argument><expr>"L.__reversed__() -- return a reverse iterator over the list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sizeof_doc</name></expr></argument>,
<argument><expr>"L.__sizeof__() -- size of L in memory, in bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>append_doc</name></expr></argument>,
<argument><expr>"L.append(object) -- append object to end"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>extend_doc</name></expr></argument>,
<argument><expr>"L.extend(iterable) -- extend list by appending elements from the iterable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>insert_doc</name></expr></argument>,
<argument><expr>"L.insert(index, object) -- insert object before index"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pop_doc</name></expr></argument>,
<argument><expr>"L.pop([index]) -&gt; item -- remove and return item at index (default last).\n"
"Raises IndexError if list is empty or index is out of range."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>remove_doc</name></expr></argument>,
<argument><expr>"L.remove(value) -- remove first occurrence of value.\n"
"Raises ValueError if the value is not present."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>index_doc</name></expr></argument>,
<argument><expr>"L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.\n"
"Raises ValueError if the value is not present."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>count_doc</name></expr></argument>,
<argument><expr>"L.count(value) -&gt; integer -- return number of occurrences of value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reverse_doc</name></expr></argument>,
<argument><expr>"L.reverse() -- reverse *IN PLACE*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sort_doc</name></expr></argument>,
<argument><expr>"L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;\n\
cmp(x, y) -&gt; -1, 0, 1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>list_subscript</name><parameter_list>(<param><decl><type><name>PyListObject</name>*</type></decl></param>, <param><decl><type><name>PyObject</name>*</type></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>list_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__getitem__"</expr>, <expr>(<name>PyCFunction</name>)<name>list_subscript</name></expr>, <expr><name>METH_O</name>|<name>METH_COEXIST</name></expr>, <expr><name>getitem_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__reversed__"</expr>,<expr>(<name>PyCFunction</name>)<name>list_reversed</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>reversed_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__sizeof__"</expr>,  <expr>(<name>PyCFunction</name>)<name>list_sizeof</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>sizeof_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"append"</expr>,	<expr>(<name>PyCFunction</name>)<name>listappend</name></expr>,  <expr><name>METH_O</name></expr>, <expr><name>append_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"insert"</expr>,	<expr>(<name>PyCFunction</name>)<name>listinsert</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>insert_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"extend"</expr>,      <expr>(<name>PyCFunction</name>)<name>listextend</name></expr>,  <expr><name>METH_O</name></expr>, <expr><name>extend_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"pop"</expr>,		<expr>(<name>PyCFunction</name>)<name>listpop</name></expr>, 	  <expr><name>METH_VARARGS</name></expr>, <expr><name>pop_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"remove"</expr>,	<expr>(<name>PyCFunction</name>)<name>listremove</name></expr>,  <expr><name>METH_O</name></expr>, <expr><name>remove_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"index"</expr>,	<expr>(<name>PyCFunction</name>)<name>listindex</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>index_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"count"</expr>,	<expr>(<name>PyCFunction</name>)<name>listcount</name></expr>,   <expr><name>METH_O</name></expr>, <expr><name>count_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"reverse"</expr>,	<expr>(<name>PyCFunction</name>)<name>listreverse</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>reverse_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"sort"</expr>,	<expr>(<name>PyCFunction</name>)<name>listsort</name></expr>, 	  <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>sort_doc</name></expr>}</block></expr>,
 	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>list_as_sequence</name> <init>= <expr><block>{
	<expr>(<name>lenfunc</name>)<name>list_length</name></expr>,			<comment type="block">/* sq_length */</comment>
	<expr>(<name>binaryfunc</name>)<name>list_concat</name></expr>,		<comment type="block">/* sq_concat */</comment>
	<expr>(<name>ssizeargfunc</name>)<name>list_repeat</name></expr>,		<comment type="block">/* sq_repeat */</comment>
	<expr>(<name>ssizeargfunc</name>)<name>list_item</name></expr>,		<comment type="block">/* sq_item */</comment>
	<expr>(<name>ssizessizeargfunc</name>)<name>list_slice</name></expr>,		<comment type="block">/* sq_slice */</comment>
	<expr>(<name>ssizeobjargproc</name>)<name>list_ass_item</name></expr>,		<comment type="block">/* sq_ass_item */</comment>
	<expr>(<name>ssizessizeobjargproc</name>)<name>list_ass_slice</name></expr>,	<comment type="block">/* sq_ass_slice */</comment>
	<expr>(<name>objobjproc</name>)<name>list_contains</name></expr>,		<comment type="block">/* sq_contains */</comment>
	<expr>(<name>binaryfunc</name>)<name>list_inplace_concat</name></expr>,	<comment type="block">/* sq_inplace_concat */</comment>
	<expr>(<name>ssizeargfunc</name>)<name>list_inplace_repeat</name></expr>,	<comment type="block">/* sq_inplace_repeat */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>list_doc</name></expr></argument>,
<argument><expr>"list() -&gt; new list\n"
"list(sequence) -&gt; new list initialized from sequence's items"</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_subscript</name><parameter_list>(<param><decl><type><name>PyListObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>item</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>i</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>i</name> += <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><call><name>list_item</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelength</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name>*</type> <name>it</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>src</name></decl>, **<decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name>*)<name>item</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelength</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>

		<if>if <condition>(<expr><name>slicelength</name> &lt;= 0</expr>)</condition><then> <block>{
			<return>return <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
			<return>return <expr><call><name>list_slice</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>

			<expr_stmt><expr><name>src</name> = <name><name>self</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dest</name> = ((<name>PyListObject</name> *)<name>result</name>)-&gt;<name>ob_item</name></expr>;</expr_stmt>
			<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelength</name></expr>;</condition>
			     <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name>it</name> = <name><name>src</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>it</name></expr>;</expr_stmt>
			}</block></for>

			<return>return <expr><name>result</name></expr>;</return>
		}</block></else></if></else></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"list indices must be integers, not %.200s"</expr></argument>,
			     <argument><expr><name><name>item</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_ass_subscript</name><parameter_list>(<param><decl><type><name>PyListObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>item</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>value</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>i</name> += <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><call><name>list_ass_item</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelength</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name>*)<name>item</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelength</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>

		<if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then>
			<return>return <expr><call><name>list_ass_slice</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

		<comment type="block">/* Make sure s[5:2] = [..] inserts at the right place:
		   before 5, not before 2. */</comment>
		<if>if <condition>(<expr>(<name>step</name> &lt; 0 &amp;&amp; <name>start</name> &lt; <name>stop</name>) ||
		    (<name>step</name> &gt; 0 &amp;&amp; <name>start</name> &gt; <name>stop</name>)</expr>)</condition><then>
			<expr_stmt><expr><name>stop</name> = <name>start</name></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* delete slice */</comment>
			<decl_stmt><decl><type><name>PyObject</name> **</type><name>garbage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>slicelength</name> &lt;= 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>

			<if>if <condition>(<expr><name>step</name> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>stop</name> = <name>start</name> + 1</expr>;</expr_stmt>
				<expr_stmt><expr><name>start</name> = <name>stop</name> + <call><name>step</name>*<argument_list>(<argument><expr><name>slicelength</name> - 1</expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
				<expr_stmt><expr><name>step</name> = -<name>step</name></expr>;</expr_stmt>
			}</block></then></if>

			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>slicelength</name> &lt;= <name>PY_SIZE_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>garbage</name> = (<name>PyObject</name>**)
				<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>slicelength</name>*<sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>garbage</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>

			<comment type="block">/* drawing pictures might help understand these for
			   loops. Basically, we memmove the parts of the
			   list that are *not* part of the slice: step-1
			   items for each item that is part of the slice,
			   and then tail end of the list that was not
			   covered by the slice */</comment>
			<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init>
			     <condition><expr><name>cur</name> &lt; <name>stop</name></expr>;</condition>
			     <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lim</name> <init>= <expr><name>step</name> - 1</expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>garbage</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>cur</name> + <name>step</name> &gt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>lim</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>cur</name> - 1</expr>;</expr_stmt>
				}</block></then></if>

				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name> + <name>cur</name> - <name>i</name></expr></argument>,
					<argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name> + <name>cur</name> + 1</expr></argument>,
					<argument><expr><name>lim</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><name>cur</name> = <name>start</name> + <name>slicelength</name>*<name>step</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cur</name> &lt; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name> + <name>cur</name> - <name>slicelength</name></expr></argument>,
					<argument><expr><name><name>self</name>-&gt;<name>ob_item</name></name> + <name>cur</name></expr></argument>,
					<argument><expr>(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>cur</name>) * 
					 <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>

			<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> -= <name>slicelength</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_resize</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>garbage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>garbage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr>0</expr>;</return>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* assign slice */</comment>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>ins</name></decl>, *<decl><type ref="prev"/><name>seq</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> **</type><name>garbage</name></decl>, **<decl><type ref="prev"/><name>seqitems</name></decl>, **<decl><type ref="prev"/><name>selfitems</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

			<comment type="block">/* protect against a[::-1] = a */</comment>
			<if>if <condition>(<expr><name>self</name> == (<name>PyListObject</name>*)<name>value</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>seq</name> = <call><name>list_slice</name><argument_list>(<argument><expr>(<name>PyListObject</name>*)<name>value</name></expr></argument>, <argument><expr>0</expr></argument>,
						   <argument><expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name>seq</name> = <call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
						      <argument><expr>"must assign iterable "
						      "to extended slice"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<if>if <condition>(<expr>!<name>seq</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>

			<if>if <condition>(<expr><call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call> != <name>slicelength</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"attempt to assign sequence of "
					"size %zd to extended slice of "
					"size %zd"</expr></argument>,
					     <argument><expr><call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>

			<if>if <condition>(<expr>!<name>slicelength</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>

			<expr_stmt><expr><name>garbage</name> = (<name>PyObject</name>**)
				<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>slicelength</name>*<sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>garbage</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>

			<expr_stmt><expr><name>selfitems</name> = <name><name>self</name>-&gt;<name>ob_item</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>seqitems</name> = <call><name>PySequence_Fast_ITEMS</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelength</name></expr>;</condition>
			     <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name><name>garbage</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>selfitems</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ins</name> = <name><name>seqitems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>selfitems</name><index>[<expr><name>cur</name></expr>]</index></name> = <name>ins</name></expr>;</expr_stmt>
			}</block></for>

			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>garbage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>

			<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>garbage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr>0</expr>;</return>
		}</block></else></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"list indices must be integers, not %.200s"</expr></argument>,
			     <argument><expr><name><name>item</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></else></if></else></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>list_as_mapping</name> <init>= <expr><block>{
	<expr>(<name>lenfunc</name>)<name>list_length</name></expr>,
	<expr>(<name>binaryfunc</name>)<name>list_subscript</name></expr>,
	<expr>(<name>objobjargproc</name>)<name>list_ass_subscript</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyList_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"list"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyListObject</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr>0</expr>,
	<expr>(<name>destructor</name>)<name>list_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>(<name>printfunc</name>)<name>list_print</name></expr>,			<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>list_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>list_as_sequence</name></expr>,			<comment type="block">/* tp_as_sequence */</comment>
	<expr>&amp;<name>list_as_mapping</name></expr>,			<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>PyObject_HashNotImplemented</name></expr>,	<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
		<name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_LIST_SUBCLASS</name></expr>,	<comment type="block">/* tp_flags */</comment>
 	<expr><name>list_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
 	<expr>(<name>traverseproc</name>)<name>list_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
 	<expr>(<name>inquiry</name>)<name>list_clear</name></expr>,			<comment type="block">/* tp_clear */</comment>
	<expr><name>list_richcompare</name></expr>,			<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr><name>list_iter</name></expr>,				<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>list_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>(<name>initproc</name>)<name>list_init</name></expr>,			<comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,			<comment type="block">/* tp_alloc */</comment>
	<expr><name>PyType_GenericNew</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_GC_Del</name></expr>,			<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*********************** List Iterator **************************/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>long</name></type> <name>it_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>it_seq</name></decl>;</decl_stmt> <comment type="block">/* Set to NULL when iterator is exhausted */</comment>
}</block></struct></type> <name>listiterobject</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>list_iter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>listiter_dealloc</name><parameter_list>(<param><decl><type><name>listiterobject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>listiter_traverse</name><parameter_list>(<param><decl><type><name>listiterobject</name> *</type></decl></param>, <param><decl><type><name>visitproc</name></type></decl></param>, <param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>listiter_next</name><parameter_list>(<param><decl><type><name>listiterobject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>listiter_len</name><parameter_list>(<param><decl><type><name>listiterobject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>length_hint_doc</name></expr></argument>, <argument><expr>"Private method returning an estimate of len(list(it))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>listiter_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__length_hint__"</expr>, <expr>(<name>PyCFunction</name>)<name>listiter_len</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>length_hint_doc</name></expr>}</block></expr>,
 	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyListIter_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"listiterator"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>listiterobject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>listiter_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,<comment type="block">/* tp_flags */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>listiter_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr><name>PyObject_SelfIter</name></expr>,			<comment type="block">/* tp_iter */</comment>
	<expr>(<name>iternextfunc</name>)<name>listiter_next</name></expr>,		<comment type="block">/* tp_iternext */</comment>
	<expr><name>listiter_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_iter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>listiterobject</name> *</type><name>it</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>listiterobject</name></expr></argument>, <argument><expr>&amp;<name>PyListIter_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>it_index</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>it_seq</name></name> = (<name>PyListObject</name> *)<name>seq</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>it</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>listiter_dealloc</name><parameter_list>(<param><decl><type><name>listiterobject</name> *</type><name>it</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>listiter_traverse</name><parameter_list>(<param><decl><type><name>listiterobject</name> *</type><name>it</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listiter_next</name><parameter_list>(<param><decl><type><name>listiterobject</name> *</type><name>it</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>it</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>seq</name> = <name><name>it</name>-&gt;<name>it_seq</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>seq</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>it</name>-&gt;<name>it_index</name></name> &lt; <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>item</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name><name>it</name>-&gt;<name>it_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>++<name><name>it</name>-&gt;<name>it_index</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>item</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>it_seq</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listiter_len</name><parameter_list>(<param><decl><type><name>listiterobject</name> *</type><name>it</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>len</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call> - <name><name>it</name>-&gt;<name>it_index</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>len</name> &gt;= 0</expr>)</condition><then>
			<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<comment type="block">/*********************** List Reverse Iterator **************************/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>Py_ssize_t</name></type> <name>it_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>it_seq</name></decl>;</decl_stmt> <comment type="block">/* Set to NULL when iterator is exhausted */</comment>
}</block></struct></type> <name>listreviterobject</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>list_reversed</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>listreviter_dealloc</name><parameter_list>(<param><decl><type><name>listreviterobject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>listreviter_traverse</name><parameter_list>(<param><decl><type><name>listreviterobject</name> *</type></decl></param>, <param><decl><type><name>visitproc</name></type></decl></param>, <param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>listreviter_next</name><parameter_list>(<param><decl><type><name>listreviterobject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Py_ssize_t</name></type> <name>listreviter_len</name><parameter_list>(<param><decl><type><name>listreviterobject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>listreviter_as_sequence</name> <init>= <expr><block>{
	<expr>(<name>lenfunc</name>)<name>listreviter_len</name></expr>,	<comment type="block">/* sq_length */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_concat */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyListRevIter_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"listreverseiterator"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>listreviterobject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>listreviter_dealloc</name></expr>,	<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>listreviter_as_sequence</name></expr>,		<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,<comment type="block">/* tp_flags */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>listreviter_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr><name>PyObject_SelfIter</name></expr>,			<comment type="block">/* tp_iter */</comment>
	<expr>(<name>iternextfunc</name>)<name>listreviter_next</name></expr>,		<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_reversed</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>seq</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>listreviterobject</name> *</type><name>it</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>listreviterobject</name></expr></argument>, <argument><expr>&amp;<name>PyListRevIter_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>it_index</name></name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>it_seq</name></name> = <name>seq</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>it</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>listreviter_dealloc</name><parameter_list>(<param><decl><type><name>listreviterobject</name> *</type><name>it</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>listreviter_traverse</name><parameter_list>(<param><decl><type><name>listreviterobject</name> *</type><name>it</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>listreviter_next</name><parameter_list>(<param><decl><type><name>listreviterobject</name> *</type><name>it</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>index</name> <init>= <expr><name><name>it</name>-&gt;<name>it_index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>seq</name> <init>= <expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>index</name>&gt;=0 &amp;&amp; <name>index</name> &lt; <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>item</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>it</name>-&gt;<name>it_index</name></name>--</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>item</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>it_index</name></name> = -1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>seq</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>it</name>-&gt;<name>it_seq</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>listreviter_len</name><parameter_list>(<param><decl><type><name>listreviterobject</name> *</type><name>it</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>it</name>-&gt;<name>it_index</name></name> + 1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>it</name>-&gt;<name>it_seq</name></name> == <name>NULL</name> || <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>it_seq</name></name></expr></argument>)</argument_list></call> &lt; <name>len</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><name>len</name></expr>;</return>
}</block></function>
</unit>
