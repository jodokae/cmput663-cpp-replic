<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/peephole.c"><comment type="block">/* Peephole optimizations for bytecode compiler. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"symtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"opcode.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETARG</name><parameter_list>(<param><type><name>arr</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((int)((arr[i+2]&lt;&lt;8) + arr[i+1]))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNCONDITIONAL_JUMP</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(op==JUMP_ABSOLUTE || op==JUMP_FORWARD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSOLUTE_JUMP</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(op==JUMP_ABSOLUTE || op==CONTINUE_LOOP)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETJUMPTGT</name><parameter_list>(<param><type><name>arr</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(GETARG(arr,i) + (ABSOLUTE_JUMP(arr[i]) ? 0 : i+3))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETARG</name><parameter_list>(<param><type><name>arr</name></type></param>, <param><type><name>i</name></type></param>, <param><type><name>val</name></type></param>)</parameter_list></cpp:macro> <cpp:value>arr[i+2] = val&gt;&gt;8; arr[i+1] = val &amp; 255</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODESIZE</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>(HAS_ARG(op) ? 3 : 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISBASICBLOCK</name><parameter_list>(<param><type><name>blocks</name></type></param>, <param><type><name>start</name></type></param>, <param><type><name>bytes</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>(blocks[start]==blocks[start+bytes-1])</cpp:value></cpp:define>

<comment type="block">/* Replace LOAD_CONST c1. LOAD_CONST c2 ... LOAD_CONST cn BUILD_TUPLE n
   with	   LOAD_CONST (c1, c2, ... cn).
   The consts table must still be in list form so that the
   new constant (c1, c2, ... cn) can be appended.
   Called with codestr pointing to the first LOAD_CONST.
   Bails out with no change if one or more of the LOAD_CONSTs is missing. 
   Also works for BUILD_LIST when followed by an "in" or "not in" test.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tuple_of_constants</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>codestr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>consts</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newconst</name></decl>, *<decl><type ref="prev"/><name>constant</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>arg</name></decl>, <decl><type ref="prev"/><name>len_consts</name></decl>;</decl_stmt>

	<comment type="block">/* Pre-conditions */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr><name>n</name>*3</expr>]</index></name> == <name>BUILD_TUPLE</name> || <name><name>codestr</name><index>[<expr><name>n</name>*3</expr>]</index></name> == <name>BUILD_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr>(<name>n</name>*3)</expr></argument>)</argument_list></call> == <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr><name>i</name>*3</expr>]</index></name> == <name>LOAD_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

	<comment type="block">/* Buildup new tuple of constants */</comment>
	<expr_stmt><expr><name>newconst</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newconst</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>len_consts</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>arg</name> = <call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr>(<name>i</name>*3)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arg</name> &lt; <name>len_consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constant</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>constant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>newconst</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>constant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* Append folded constant onto consts */</comment>
	<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write NOPs over old LOAD_CONSTS and
	   add a new LOAD_CONST newconst on top of the BUILD_TUPLE n */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>NOP</name></expr></argument>, <argument><expr><name>n</name>*3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>n</name>*3</expr>]</index></name> = <name>LOAD_CONST</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr>(<name>n</name>*3)</expr></argument>, <argument><expr><name>len_consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Replace LOAD_CONST c1. LOAD_CONST c2 BINOP
   with	   LOAD_CONST binop(c1,c2)
   The consts table must still be in list form so that the
   new constant can be appended.
   Called with codestr pointing to the first LOAD_CONST. 
   Abandons the transformation if the folding fails (i.e.  1+'a').  
   If the new constant is a sequence, only folds when the size
   is below a threshold value.	That keeps pyc files from
   becoming large in the presence of code like:	 (None,)*1000.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>fold_binops_on_constants</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>codestr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>consts</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newconst</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len_consts</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>opcode</name></decl>;</decl_stmt>

	<comment type="block">/* Pre-conditions */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr>0</expr>]</index></name> == <name>LOAD_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr>3</expr>]</index></name> == <name>LOAD_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create new constant */</comment>
	<expr_stmt><expr><name>v</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opcode</name> = <name><name>codestr</name><index>[<expr>6</expr>]</index></name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{
		<case>case <expr><name>BINARY_POWER</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Power</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_MULTIPLY</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Multiply</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_DIVIDE</name></expr>:
			<comment type="block">/* Cannot fold this operation statically since
                           the result can depend on the run-time presence
                           of the -Qnew flag */</comment>
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>BINARY_TRUE_DIVIDE</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_TrueDivide</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_FLOOR_DIVIDE</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_FloorDivide</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_MODULO</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Remainder</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_ADD</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_SUBTRACT</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Subtract</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_SUBSCR</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_LSHIFT</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Lshift</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_RSHIFT</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Rshift</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_AND</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_And</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_XOR</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Xor</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>BINARY_OR</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Or</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<comment type="block">/* Called with an unknown opcode */</comment>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			     <argument><expr>"unexpected binary operation %d on a constant"</expr></argument>,
				     <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
	</default>}</block></switch>
	<if>if <condition>(<expr><name>newconst</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>size</name> = <call><name>PyObject_Size</name><argument_list>(<argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> == -1</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>size</name> &gt; 20</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if></else></if>

	<comment type="block">/* Append folded constant into consts table */</comment>
	<expr_stmt><expr><name>len_consts</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write NOP NOP NOP NOP LOAD_CONST newconst */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>NOP</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>codestr</name><index>[<expr>4</expr>]</index></name> = <name>LOAD_CONST</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name>len_consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>fold_unaryops_on_constants</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>codestr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>consts</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newconst</name><init>=<expr><name>NULL</name></expr></init>, *<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len_consts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>opcode</name></decl>;</decl_stmt>

	<comment type="block">/* Pre-conditions */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr>0</expr>]</index></name> == <name>LOAD_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create new constant */</comment>
	<expr_stmt><expr><name>v</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opcode</name> = <name><name>codestr</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{
		<case>case <expr><name>UNARY_NEGATIVE</name></expr>:
			<comment type="block">/* Preserve the sign of -0.0 */</comment>
			<if>if <condition>(<expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
				<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Negative</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<break>break;</break>
		</case><case>case <expr><name>UNARY_CONVERT</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>UNARY_INVERT</name></expr>:
			<expr_stmt><expr><name>newconst</name> = <call><name>PyNumber_Invert</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<comment type="block">/* Called with an unknown opcode */</comment>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			     <argument><expr>"unexpected unary operation %d on a constant"</expr></argument>,
				     <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
	</default>}</block></switch>
	<if>if <condition>(<expr><name>newconst</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* Append folded constant into consts table */</comment>
	<expr_stmt><expr><name>len_consts</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newconst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write NOP LOAD_CONST newconst */</comment>
	<expr_stmt><expr><name><name>codestr</name><index>[<expr>0</expr>]</index></name> = <name>NOP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>codestr</name><index>[<expr>1</expr>]</index></name> = <name>LOAD_CONST</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>len_consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name> *</type>
<name>markblocks</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>code</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name> *</type><name>blocks</name> <init>= <expr>(<name>unsigned</name> <name>int</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>len</name>*<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>opcode</name></decl>, <decl><type ref="prev"/><name>blockcnt</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>blocks</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name>*<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark labels in the first pass */</comment>
	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr> ;</condition> <incr><expr><name>i</name>+=<call><name>CODESIZE</name><argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
		<expr_stmt><expr><name>opcode</name> = <name><name>code</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{
			<case>case <expr><name>FOR_ITER</name></expr>:
			</case><case>case <expr><name>JUMP_FORWARD</name></expr>:
			</case><case>case <expr><name>JUMP_IF_FALSE</name></expr>:
			</case><case>case <expr><name>JUMP_IF_TRUE</name></expr>:
			</case><case>case <expr><name>JUMP_ABSOLUTE</name></expr>:
			</case><case>case <expr><name>CONTINUE_LOOP</name></expr>:
			</case><case>case <expr><name>SETUP_LOOP</name></expr>:
			</case><case>case <expr><name>SETUP_EXCEPT</name></expr>:
			</case><case>case <expr><name>SETUP_FINALLY</name></expr>:
				<expr_stmt><expr><name>j</name> = <call><name>GETJUMPTGT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>j</name></expr>]</index></name> = 1</expr>;</expr_stmt>
				<break>break;</break>
		</case>}</block></switch>
	}</block></for>
	<comment type="block">/* Build block numbers in the second pass */</comment>
	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>blockcnt</name> += <name><name>blocks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>	<comment type="block">/* increment blockcnt over labels */</comment>
		<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>i</name></expr>]</index></name> = <name>blockcnt</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>blocks</name></expr>;</return>
}</block></function>

<comment type="block">/* Perform basic peephole optimizations to components of a code object.
   The consts object should still be in list form to allow new constants 
   to be appended.

   To keep the optimizer simple, it bails out (does nothing) for code
   containing extended arguments or that has a length over 32,700.  That 
   allows us to avoid overflow and sign issues.	 Likewise, it bails when
   the lineno table has complex encoding for gaps &gt;= 255.

   Optimizations are restricted to simple transformations occuring within a
   single basic block.	All transformations keep the code size the same or 
   smaller.  For those that reduce size, the gaps are initially filled with 
   NOPs.  Later those NOPs are removed and the jump addresses retargeted in 
   a single pass.  Line numbering is adjusted accordingly. */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyCode_Optimize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>code</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>consts</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>names</name></decl></param>,
                <param><decl><type><name>PyObject</name> *</type><name>lineno_obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>codelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nops</name></decl>, <decl><type ref="prev"/><name>h</name></decl>, <decl><type ref="prev"/><name>adj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tgt</name></decl>, <decl><type ref="prev"/><name>tgttgt</name></decl>, <decl><type ref="prev"/><name>opcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>codestr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> *</type><name>addrmap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>new_line</name></decl>, <decl><type ref="prev"/><name>cum_orig_line</name></decl>, <decl><type ref="prev"/><name>last_line</name></decl>, <decl><type ref="prev"/><name>tabsiz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cumlc</name><init>=<expr>0</expr></init>, <name>lastlc</name><init>=<expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* Count runs of consecutive LOAD_CONSTs */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name> *</type><name>blocks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>

	<comment type="block">/* Bail out if an exception is set */</comment>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<goto>goto <name>exitUnchanged</name>;</goto></then></if>

	<comment type="block">/* Bypass optimization when the lineno table is too complex */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>lineno_obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lineno</name> = (<name>unsigned</name> <name>char</name>*)<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>lineno_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tabsiz</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>lineno_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr>255</expr></argument>, <argument><expr><name>tabsiz</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>exitUnchanged</name>;</goto></then></if>

	<comment type="block">/* Avoid situations where jump retargeting could overflow */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>codelen</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>codelen</name> &gt; 32700</expr>)</condition><then>
		<goto>goto <name>exitUnchanged</name>;</goto></then></if>

	<comment type="block">/* Make a modifiable copy of the code string */</comment>
	<expr_stmt><expr><name>codestr</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>codelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>codestr</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>exitUnchanged</name>;</goto></then></if>
	<expr_stmt><expr><name>codestr</name> = (<name>unsigned</name> <name>char</name> *)<call><name>memcpy</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, 
					  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>codelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify that RETURN_VALUE terminates the codestring.	This allows
	   the various transformation patterns to look ahead several
	   instructions without additional checks to make sure they are not
	   looking beyond the end of the code string.
	*/</comment>
	<if>if <condition>(<expr><name><name>codestr</name><index>[<expr><name>codelen</name>-1</expr>]</index></name> != <name>RETURN_VALUE</name></expr>)</condition><then>
		<goto>goto <name>exitUnchanged</name>;</goto></then></if>

	<comment type="block">/* Mapping to new jump targets after NOPs are removed */</comment>
	<expr_stmt><expr><name>addrmap</name> = (<name>int</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>codelen</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>addrmap</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>exitUnchanged</name>;</goto></then></if>

	<expr_stmt><expr><name>blocks</name> = <call><name>markblocks</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>codelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>blocks</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>exitUnchanged</name>;</goto></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>codelen</name></expr> ;</condition> <incr><expr><name>i</name> += <call><name>CODESIZE</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></incr>) <block>{
		<expr_stmt><expr><name>opcode</name> = <name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>lastlc</name> = <name>cumlc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cumlc</name> = 0</expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{

			<comment type="block">/* Replace UNARY_NOT JUMP_IF_FALSE POP_TOP with 
			   with	   JUMP_IF_TRUE POP_TOP */</comment>
			<case>case <expr><name>UNARY_NOT</name></expr>:
				<if>if <condition>(<expr><name><name>codestr</name><index>[<expr><name>i</name>+1</expr>]</index></name> != <name>JUMP_IF_FALSE</name>  ||
				    <name><name>codestr</name><index>[<expr><name>i</name>+4</expr>]</index></name> != <name>POP_TOP</name>  ||
				    !<call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<expr_stmt><expr><name>tgt</name> = <call><name>GETJUMPTGT</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr>(<name>i</name>+1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>codestr</name><index>[<expr><name>tgt</name></expr>]</index></name> != <name>POP_TOP</name></expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<expr_stmt><expr><name>j</name> = <call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
				<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> = <name>JUMP_IF_TRUE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name>+3</expr>]</index></name> = <name>POP_TOP</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name>+4</expr>]</index></name> = <name>NOP</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* not a is b --&gt;  a is not b
				   not a in b --&gt;  a not in b
				   not a is not b --&gt;  a is b
				   not a not in b --&gt;  a in b
				*/</comment>
			</case><case>case <expr><name>COMPARE_OP</name></expr>:
				<expr_stmt><expr><name>j</name> = <call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>j</name> &lt; 6  ||  <name>j</name> &gt; 9  ||
				    <name><name>codestr</name><index>[<expr><name>i</name>+3</expr>]</index></name> != <name>UNARY_NOT</name>  || 
				    !<call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>(<name>j</name>^1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name>+3</expr>]</index></name> = <name>NOP</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* Replace LOAD_GLOBAL/LOAD_NAME None
                                   with LOAD_CONST None */</comment>
			</case><case>case <expr><name>LOAD_NAME</name></expr>:
			</case><case>case <expr><name>LOAD_GLOBAL</name></expr>:
				<expr_stmt><expr><name>j</name> = <call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>name</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>name</name> == <name>NULL</name>  ||  <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"None"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<for>for (<init><expr><name>j</name>=0</expr> ;</init> <condition><expr><name>j</name> &lt; <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
					<if>if <condition>(<expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> == <name>Py_None</name></expr>)</condition><then>
						<break>break;</break></then></if>
				}</block></for>
				<if>if <condition>(<expr><name>j</name> == <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
					        <goto>goto <name>exitUnchanged</name>;</goto></then></if>                                        
				}</block></then></if>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> == <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> = <name>LOAD_CONST</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cumlc</name> = <name>lastlc</name> + 1</expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* Skip over LOAD_CONST trueconst
                                   JUMP_IF_FALSE xx  POP_TOP */</comment>
			</case><case>case <expr><name>LOAD_CONST</name></expr>:
				<expr_stmt><expr><name>cumlc</name> = <name>lastlc</name> + 1</expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name> = <call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>codestr</name><index>[<expr><name>i</name>+3</expr>]</index></name> != <name>JUMP_IF_FALSE</name>  ||
				    <name><name>codestr</name><index>[<expr><name>i</name>+6</expr>]</index></name> != <name>POP_TOP</name>  ||
				    !<call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr>7</expr></argument>)</argument_list></call>  ||
				    !<call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>codestr</name>+<name>i</name></expr></argument>, <argument><expr><name>NOP</name></expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cumlc</name> = 0</expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* Try to fold tuples of constants (includes a case for lists
				   which are only used for "in" and "not in" tests).
				   Skip over BUILD_SEQN 1 UNPACK_SEQN 1.
				   Replace BUILD_SEQN 2 UNPACK_SEQN 2 with ROT2.
				   Replace BUILD_SEQN 3 UNPACK_SEQN 3 with ROT3 ROT2. */</comment>
			</case><case>case <expr><name>BUILD_TUPLE</name></expr>:
			</case><case>case <expr><name>BUILD_LIST</name></expr>:
				<expr_stmt><expr><name>j</name> = <call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>h</name> = <name>i</name> - 3 * <name>j</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>h</name> &gt;= 0  &amp;&amp;
				    <name>j</name> &lt;= <name>lastlc</name>	 &amp;&amp;
				    ((<name>opcode</name> == <name>BUILD_TUPLE</name> &amp;&amp; 
				      <call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr>3*(<name>j</name>+1)</expr></argument>)</argument_list></call>) ||
				     (<name>opcode</name> == <name>BUILD_LIST</name> &amp;&amp; 
				      <name><name>codestr</name><index>[<expr><name>i</name>+3</expr>]</index></name>==<name>COMPARE_OP</name> &amp;&amp; 
				      <call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr>3*(<name>j</name>+2)</expr></argument>)</argument_list></call> &amp;&amp;
				      (<call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>,<argument><expr><name>i</name>+3</expr></argument>)</argument_list></call>==6 ||
				       <call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>,<argument><expr><name>i</name>+3</expr></argument>)</argument_list></call>==7))) &amp;&amp;
				    <call><name>tuple_of_constants</name><argument_list>(<argument><expr>&amp;<name><name>codestr</name><index>[<expr><name>h</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> == <name>LOAD_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cumlc</name> = 1</expr>;</expr_stmt>
					<break>break;</break>
				}</block></then></if>
				<if>if <condition>(<expr><name><name>codestr</name><index>[<expr><name>i</name>+3</expr>]</index></name> != <name>UNPACK_SEQUENCE</name>  ||
				    !<call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr>6</expr></argument>)</argument_list></call> ||
				    <name>j</name> != <call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name>+3</expr></argument>)</argument_list></call></expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<if>if <condition>(<expr><name>j</name> == 1</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>codestr</name>+<name>i</name></expr></argument>, <argument><expr><name>NOP</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then> <else>else <if>if <condition>(<expr><name>j</name> == 2</expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> = <name>ROT_TWO</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>codestr</name>+<name>i</name>+1</expr></argument>, <argument><expr><name>NOP</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then> <else>else <if>if <condition>(<expr><name>j</name> == 3</expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> = <name>ROT_THREE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name>+1</expr>]</index></name> = <name>ROT_TWO</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>codestr</name>+<name>i</name>+2</expr></argument>, <argument><expr><name>NOP</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if></else></if></else></if>
				<break>break;</break>

				<comment type="block">/* Fold binary ops on constants.
				   LOAD_CONST c1 LOAD_CONST c2 BINOP --&gt;  LOAD_CONST binop(c1,c2) */</comment>
			</case><case>case <expr><name>BINARY_POWER</name></expr>:
			</case><case>case <expr><name>BINARY_MULTIPLY</name></expr>:
			</case><case>case <expr><name>BINARY_TRUE_DIVIDE</name></expr>:
			</case><case>case <expr><name>BINARY_FLOOR_DIVIDE</name></expr>:
			</case><case>case <expr><name>BINARY_MODULO</name></expr>:
			</case><case>case <expr><name>BINARY_ADD</name></expr>:
			</case><case>case <expr><name>BINARY_SUBTRACT</name></expr>:
			</case><case>case <expr><name>BINARY_SUBSCR</name></expr>:
			</case><case>case <expr><name>BINARY_LSHIFT</name></expr>:
			</case><case>case <expr><name>BINARY_RSHIFT</name></expr>:
			</case><case>case <expr><name>BINARY_AND</name></expr>:
			</case><case>case <expr><name>BINARY_XOR</name></expr>:
			</case><case>case <expr><name>BINARY_OR</name></expr>:
				<if>if <condition>(<expr><name>lastlc</name> &gt;= 2	 &amp;&amp;
				    <call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>i</name>-6</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call>  &amp;&amp;
				    <call><name>fold_binops_on_constants</name><argument_list>(<argument><expr>&amp;<name><name>codestr</name><index>[<expr><name>i</name>-6</expr>]</index></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>i</name> -= 2</expr>;</expr_stmt>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> == <name>LOAD_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cumlc</name> = 1</expr>;</expr_stmt>
				}</block></then></if>
				<break>break;</break>

				<comment type="block">/* Fold unary ops on constants.
				   LOAD_CONST c1  UNARY_OP --&gt;	LOAD_CONST unary_op(c) */</comment>
			</case><case>case <expr><name>UNARY_NEGATIVE</name></expr>:
			</case><case>case <expr><name>UNARY_CONVERT</name></expr>:
			</case><case>case <expr><name>UNARY_INVERT</name></expr>:
				<if>if <condition>(<expr><name>lastlc</name> &gt;= 1	 &amp;&amp;
				    <call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>i</name>-3</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call>  &amp;&amp;
				    <call><name>fold_unaryops_on_constants</name><argument_list>(<argument><expr>&amp;<name><name>codestr</name><index>[<expr><name>i</name>-3</expr>]</index></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>)</condition><then>	<block>{
					<expr_stmt><expr><name>i</name> -= 2</expr>;</expr_stmt>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> == <name>LOAD_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cumlc</name> = 1</expr>;</expr_stmt>
				}</block></then></if>
				<break>break;</break>

				<comment type="block">/* Simplify conditional jump to conditional jump where the
				   result of the first test implies the success of a similar
				   test or the failure of the opposite test.
				   Arises in code like:
				   "if a and b:"
				   "if a or b:"
				   "a and b or c"
				   "(a and b) and c"
				   x:JUMP_IF_FALSE y   y:JUMP_IF_FALSE z  --&gt;  x:JUMP_IF_FALSE z
				   x:JUMP_IF_FALSE y   y:JUMP_IF_TRUE z	 --&gt;  x:JUMP_IF_FALSE y+3
				   where y+3 is the instruction following the second test.
				*/</comment>
			</case><case>case <expr><name>JUMP_IF_FALSE</name></expr>:
			</case><case>case <expr><name>JUMP_IF_TRUE</name></expr>:
				<expr_stmt><expr><name>tgt</name> = <call><name>GETJUMPTGT</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name> = <name><name>codestr</name><index>[<expr><name>tgt</name></expr>]</index></name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>j</name> == <name>JUMP_IF_FALSE</name>	||  <name>j</name> == <name>JUMP_IF_TRUE</name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>j</name> == <name>opcode</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>tgttgt</name> = <call><name>GETJUMPTGT</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>tgt</name></expr></argument>)</argument_list></call> - <name>i</name> - 3</expr>;</expr_stmt>
						<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tgttgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then> <else>else <block>{
						<expr_stmt><expr><name>tgt</name> -= <name>i</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></else></if>
					<break>break;</break>
				}</block></then></if>
				<comment type="block">/* Intentional fallthrough */</comment>  

				<comment type="block">/* Replace jumps to unconditional jumps */</comment>
			</case><case>case <expr><name>FOR_ITER</name></expr>:
			</case><case>case <expr><name>JUMP_FORWARD</name></expr>:
			</case><case>case <expr><name>JUMP_ABSOLUTE</name></expr>:
			</case><case>case <expr><name>CONTINUE_LOOP</name></expr>:
			</case><case>case <expr><name>SETUP_LOOP</name></expr>:
			</case><case>case <expr><name>SETUP_EXCEPT</name></expr>:
			</case><case>case <expr><name>SETUP_FINALLY</name></expr>:
				<expr_stmt><expr><name>tgt</name> = <call><name>GETJUMPTGT</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Replace JUMP_* to a RETURN into just a RETURN */</comment>
				<if>if <condition>(<expr><call><name>UNCONDITIONAL_JUMP</name><argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call> &amp;&amp;
				    <name><name>codestr</name><index>[<expr><name>tgt</name></expr>]</index></name> == <name>RETURN_VALUE</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> = <name>RETURN_VALUE</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>codestr</name>+<name>i</name>+1</expr></argument>, <argument><expr><name>NOP</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				}</block></then></if>
				<if>if <condition>(<expr>!<call><name>UNCONDITIONAL_JUMP</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr><name>tgt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<expr_stmt><expr><name>tgttgt</name> = <call><name>GETJUMPTGT</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>opcode</name> == <name>JUMP_FORWARD</name></expr>)</condition><then> <comment type="block">/* JMP_ABS can go backwards */</comment>
					<expr_stmt><expr><name>opcode</name> = <name>JUMP_ABSOLUTE</name></expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr>!<call><name>ABSOLUTE_JUMP</name><argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><name>tgttgt</name> -= <name>i</name> + 3</expr>;</expr_stmt></then></if>     <comment type="block">/* Calc relative jump addr */</comment>
				<if>if <condition>(<expr><name>tgttgt</name> &lt; 0</expr>)</condition><then>		  <comment type="block">/* No backward relative jumps */</comment>
					<continue>continue;</continue></then></if>
				<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> = <name>opcode</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tgttgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			</case><case>case <expr><name>EXTENDED_ARG</name></expr>:
				<goto>goto <name>exitUnchanged</name>;</goto>

				<comment type="block">/* Replace RETURN LOAD_CONST None RETURN with just RETURN */</comment>
				<comment type="block">/* Remove unreachable JUMPs after RETURN */</comment>
			</case><case>case <expr><name>RETURN_VALUE</name></expr>:
				<if>if <condition>(<expr><name>i</name>+4 &gt;= <name>codelen</name></expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<if>if <condition>(<expr><name><name>codestr</name><index>[<expr><name>i</name>+4</expr>]</index></name> == <name>RETURN_VALUE</name> &amp;&amp;
				    <call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>codestr</name>+<name>i</name>+1</expr></argument>, <argument><expr><name>NOP</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><call><name>UNCONDITIONAL_JUMP</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp;
				         <call><name>ISBASICBLOCK</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>codestr</name>+<name>i</name>+1</expr></argument>, <argument><expr><name>NOP</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
				<break>break;</break>
		</case>}</block></switch>
	}</block></for>

	<comment type="block">/* Fixup linenotab */</comment>
	<for>for (<init><expr><name>i</name>=0</expr>, <expr><name>nops</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>codelen</name></expr> ;</condition> <incr><expr><name>i</name> += <call><name>CODESIZE</name><argument_list>(<argument><expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></incr>) <block>{
		<expr_stmt><expr><name><name>addrmap</name><index>[<expr><name>i</name></expr>]</index></name> = <name>i</name> - <name>nops</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name> == <name>NOP</name></expr>)</condition><then>
			<expr_stmt><expr><name>nops</name>++</expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr><name>cum_orig_line</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>last_line</name> = 0</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>tabsiz</name></expr> ;</condition> <incr><expr><name>i</name>+=2</expr></incr>) <block>{
		<expr_stmt><expr><name>cum_orig_line</name> += <name><name>lineno</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_line</name> = <name><name>addrmap</name><index>[<expr><name>cum_orig_line</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>new_line</name> - <name>last_line</name> &lt; 255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lineno</name><index>[<expr><name>i</name></expr>]</index></name> =(<call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name>new_line</name> - <name>last_line</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>last_line</name> = <name>new_line</name></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* Remove NOPs and fixup jump targets */</comment>
	<for>for (<init><expr><name>i</name>=0</expr>, <expr><name>h</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>codelen</name></expr> ;</condition> <incr/>) <block>{
		<expr_stmt><expr><name>opcode</name> = <name><name>codestr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{
			<case>case <expr><name>NOP</name></expr>:
				<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
				<continue>continue;</continue>

			</case><case>case <expr><name>JUMP_ABSOLUTE</name></expr>:
			</case><case>case <expr><name>CONTINUE_LOOP</name></expr>:
				<expr_stmt><expr><name>j</name> = <name><name>addrmap</name><index>[<expr><call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			</case><case>case <expr><name>FOR_ITER</name></expr>:
			</case><case>case <expr><name>JUMP_FORWARD</name></expr>:
			</case><case>case <expr><name>JUMP_IF_FALSE</name></expr>:
			</case><case>case <expr><name>JUMP_IF_TRUE</name></expr>:
			</case><case>case <expr><name>SETUP_LOOP</name></expr>:
			</case><case>case <expr><name>SETUP_EXCEPT</name></expr>:
			</case><case>case <expr><name>SETUP_FINALLY</name></expr>:
				<expr_stmt><expr><name>j</name> = <name><name>addrmap</name><index>[<expr><call><name>GETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> + <name>i</name> + 3</expr>]</index></name> - <name><name>addrmap</name><index>[<expr><name>i</name></expr>]</index></name> - 3</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SETARG</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</case>}</block></switch>
		<expr_stmt><expr><name>adj</name> = <call><name>CODESIZE</name><argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>adj</name>--</expr>)</condition>
			<expr_stmt><expr><name><name>codestr</name><index>[<expr><name>h</name>++</expr>]</index></name> = <name><name>codestr</name><index>[<expr><name>i</name>++</expr>]</index></name></expr>;</expr_stmt></while>
	}</block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>h</name> + <name>nops</name> == <name>codelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>code</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>codestr</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>addrmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>code</name></expr>;</return>

 <label><name>exitUnchanged</name>:</label>
	<if>if <condition>(<expr><name>blocks</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>addrmap</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>addrmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>codestr</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>codestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>code</name></expr>;</return>
}</block></function>
</unit>
