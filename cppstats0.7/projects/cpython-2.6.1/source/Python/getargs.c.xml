<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/getargs.c">
<comment type="block">/* New getargs implementation */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{ 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>int</name></type> <name>PyArg_Parse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>PyArg_ParseTuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>PyArg_VaParse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>va_list</name></type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>PyArg_ParseTupleAndKeywords</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
				<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>PyArg_VaParseTupleAndKeywords</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
				<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>va_list</name></type></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DECLSPEC_DLL</name></cpp:ifdef>
<comment type="block">/* Export functions */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyArg_Parse_SizeT</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>char</name> *</expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyArg_ParseTuple_SizeT</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>char</name> *</expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyArg_ParseTupleAndKeywords_SizeT</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>,
                                                  <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>char</name> **</expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_Py_BuildValue_SizeT</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyArg_VaParse_SizeT</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>va_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyArg_VaParseTupleAndKeywords_SizeT</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>,
                                              <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>char</name> **</expr></argument>, <argument><expr><name>va_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAG_COMPAT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAG_SIZE_T</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>


<comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>vgetargs1</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>seterror</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> *</type><name>convertitem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> **</decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>, 
                         <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><name>PyObject</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> *</type><name>converttuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> **</decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>,
			  <param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> *</type><name>convertsimple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> **</decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>,
			   <param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><name>PyObject</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Py_ssize_t</name></type> <name>convertbuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>void</name> **</type><name>p</name></decl></param>, <param><decl><type><name>char</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>getbuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_buffer</name> *</type></decl></param>, <param><decl><type><name>char</name>**</type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>vgetargskeywords</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
			    <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> *</type><name>skipitem</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> **</decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

<function><type><name>int</name></type>
<name>PyArg_Parse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>vgetargs1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr>&amp;<name>va</name></expr></argument>, <argument><expr><name>FLAG_COMPAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyArg_Parse_SizeT</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>vgetargs1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr>&amp;<name>va</name></expr></argument>, <argument><expr><name>FLAG_COMPAT</name>|<name>FLAG_SIZE_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>


<function><type><name>int</name></type>
<name>PyArg_ParseTuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>vgetargs1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr>&amp;<name>va</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyArg_ParseTuple_SizeT</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>vgetargs1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr>&amp;<name>va</name></expr></argument>, <argument><expr><name>FLAG_SIZE_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>


<function><type><name>int</name></type>
<name>PyArg_VaParse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>va</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>lva</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VA_LIST_IS_ARRAY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>va_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__va_copy</name></cpp:ifdef>
	<expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>lva</name> = <name>va</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>vgetargs1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr>&amp;<name>lva</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyArg_VaParse_SizeT</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>va</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>lva</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VA_LIST_IS_ARRAY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>va_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__va_copy</name></cpp:ifdef>
	<expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>lva</name> = <name>va</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>vgetargs1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr>&amp;<name>lva</name></expr></argument>, <argument><expr><name>FLAG_SIZE_T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Handle cleanup of allocated memory in case of exception */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_ptr</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_buffer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>(<name>Py_buffer</name> *) <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>addcleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>freelist</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>destr</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>cobj</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!*<name>freelist</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>freelist</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!*<name>freelist</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>destr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>cobj</name> = <call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>destr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>cobj</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>destr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr>*<name>freelist</name></expr></argument>, <argument><expr><name>cobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cleanreturn</name><parameter_list>(<param><decl><type><name>int</name></type> <name>retval</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>freelist</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>freelist</name> &amp;&amp; <name>retval</name> != 0</expr>)</condition><then> <block>{
		<comment type="block">/* We were successful, reset the destructors so that they
		   don't get called. */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr></init>, <name>i</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<expr_stmt><expr>((<name>PyCObject</name> *) <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>freelist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>)
				-&gt;<name>destructor</name> = <name>NULL</name></expr>;</expr_stmt></for>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>vgetargs1</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>msgbuf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>levels</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>endfmt</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>formatsave</name> <init>= <expr><name>format</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>freelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>compat</name> <init>= <expr><name>flags</name> &amp; <name>FLAG_COMPAT</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>compat</name> || (<name>args</name> != (<name>PyObject</name>*)<name>NULL</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flags</name> = <name>flags</name> &amp; ~<name>FLAG_COMPAT</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>endfmt</name> == 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr>*<name>format</name>++</expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
		<case>case <expr>'('</expr>:
			<if>if <condition>(<expr><name>level</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>max</name>++</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>level</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>level</name> &gt;= 30</expr>)</condition><then>
				<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"too many tuple nesting levels "
					      "in argument format string"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<break>break;</break>
		</case><case>case <expr>')'</expr>:
			<if>if <condition>(<expr><name>level</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"excess ')' in getargs format"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>level</name>--</expr>;</expr_stmt></else></if>
			<break>break;</break>
		</case><case>case <expr>'\0'</expr>:
			<expr_stmt><expr><name>endfmt</name> = 1</expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>':'</expr>:
			<expr_stmt><expr><name>fname</name> = <name>format</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>endfmt</name> = 1</expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>';'</expr>:
			<expr_stmt><expr><name>message</name> = <name>format</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>endfmt</name> = 1</expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<if>if <condition>(<expr><name>level</name> == 0</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>c</name> == 'O'</expr>)</condition><then>
					<expr_stmt><expr><name>max</name>++</expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>c</name> != 'e'</expr>)</condition><then> <comment type="block">/* skip encoded */</comment>
						<expr_stmt><expr><name>max</name>++</expr>;</expr_stmt></then></if>
				}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == '|'</expr>)</condition><then>
					<expr_stmt><expr><name>min</name> = <name>max</name></expr>;</expr_stmt></then></if></else></if></else></if>
			}</block></then></if>
			<break>break;</break>
		</default>}</block></switch>
	}</block></while>
	
	<if>if <condition>(<expr><name>level</name> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<comment type="block">/* '(' */</comment> <argument><expr>"missing ')' in getargs format"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	
	<if>if <condition>(<expr><name>min</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>min</name> = <name>max</name></expr>;</expr_stmt></then></if>
	
	<expr_stmt><expr><name>format</name> = <name>formatsave</name></expr>;</expr_stmt>
	
	<if>if <condition>(<expr><name>compat</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>max</name> == 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>1</expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				      <argument><expr>"%.200s%s takes no arguments"</expr></argument>,
				      <argument><expr><name>fname</name>==<name>NULL</name> ? "function" : <name>fname</name></expr></argument>,
				      <argument><expr><name>fname</name>==<name>NULL</name> ? "" : "()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>min</name> == 1 &amp;&amp; <name>max</name> == 1</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				      <argument><expr>"%.200s%s takes at least one argument"</expr></argument>,
					      <argument><expr><name>fname</name>==<name>NULL</name> ? "function" : <name>fname</name></expr></argument>,
					      <argument><expr><name>fname</name>==<name>NULL</name> ? "" : "()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>msg</name> = <call><name>convertitem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>, 
					  <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>freelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>msg</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
			<expr_stmt><expr><call><name>seterror</name><argument_list>(<argument><expr><name><name>levels</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>levels</name>+1</expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			    <argument><expr>"old style getargs format uses new features"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></else></if></else></if>
	}</block></then></if>
	
	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
		    <argument><expr>"new style getargs format but argument is not a tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	
	<expr_stmt><expr><name>len</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if>if <condition>(<expr><name>len</name> &lt; <name>min</name> || <name>max</name> &lt; <name>len</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>message</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				      <argument><expr>"%.150s%s takes %s %d argument%s "
				      "(%ld given)"</expr></argument>,
				      <argument><expr><name>fname</name>==<name>NULL</name> ? "function" : <name>fname</name></expr></argument>,
				      <argument><expr><name>fname</name>==<name>NULL</name> ? "" : "()"</expr></argument>,
				      <argument><expr><name>min</name>==<name>max</name> ? "exactly"
				      : <name>len</name> &lt; <name>min</name> ? "at least" : "at most"</expr></argument>,
				      <argument><expr><name>len</name> &lt; <name>min</name> ? <name>min</name> : <name>max</name></expr></argument>,
				      <argument><expr>(<name>len</name> &lt; <name>min</name> ? <name>min</name> : <name>max</name>) == 1 ? "" : "s"</expr></argument>,
				      <argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>message</name> = <name>msgbuf</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>format</name> == '|'</expr>)</condition><then>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>msg</name> = <call><name>convertitem</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>,
				  <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, 
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>freelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>msg</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>seterror</name><argument_list>(<argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
	}</block></for>

	<if>if <condition>(<expr>*<name>format</name> != '\0' &amp;&amp; !<call><name>isalpha</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>format</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
	    *<name>format</name> != '(' &amp;&amp;
	    *<name>format</name> != '|' &amp;&amp; *<name>format</name> != ':' &amp;&amp; *<name>format</name> != ';'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			     <argument><expr>"bad format string: %.200s"</expr></argument>, <argument><expr><name>formatsave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	
	<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>seterror</name><parameter_list>(<param><decl><type><name>int</name></type> <name>iarg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>levels</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return;</return></then>
	<else>else <if>if <condition>(<expr><name>message</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>fname</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%.200s() "</expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>iarg</name> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - (<name>p</name> - <name>buf</name>)</expr></argument>,
				      <argument><expr>"argument %d"</expr></argument>, <argument><expr><name>iarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name><name>levels</name><index>[<expr><name>i</name></expr>]</index></name> &gt; 0 &amp;&amp; <name>i</name> &lt; 32 &amp;&amp; <call>(<name>int</name>)<argument_list>(<argument><expr><name>p</name>-<name>buf</name></expr></argument>)</argument_list></call> &lt; 220</expr>)</condition> <block>{
				<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - (<name>p</name> - <name>buf</name>)</expr></argument>,
					      <argument><expr>", item %d"</expr></argument>, <argument><expr><name><name>levels</name><index>[<expr><name>i</name></expr>]</index></name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
			}</block></while>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - (<name>p</name> - <name>buf</name>)</expr></argument>, <argument><expr>"argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - (<name>p</name> - <name>buf</name>)</expr></argument>, <argument><expr>" %.256s"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>message</name> = <name>buf</name></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Convert a tuple argument.
   On entry, *p_format points to the character _after_ the opening '('.
   On successful exit, *p_format points to the closing ')'.
   If successful:
      *p_format and *p_va are updated,
      *levels and *msgbuf are untouched,
      and NULL is returned.
   If the argument is invalid:
      *p_format is unchanged,
      *p_va is undefined,
      *levels is a 0-terminated list of item numbers,
      *msgbuf contains an error message, whose format is:
         "must be &lt;typename1&gt;, not &lt;typename2&gt;", where:
            &lt;typename1&gt; is the name of the expected type, and
            &lt;typename2&gt; is the name of the actual type,
      and msgbuf is returned.
*/</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>converttuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>p_format</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
             <param><decl><type><name>int</name> *</type><name>levels</name></decl></param>, <param><decl><type><name>char</name> *</type><name>msgbuf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bufsize</name></decl></param>, <param><decl><type><name>int</name></type> <name>toplevel</name></decl></param>, 
             <param><decl><type><name>PyObject</name> **</type><name>freelist</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name> <init>= <expr>*<name>p_format</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr>*<name>format</name>++</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>c</name> == '('</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>level</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>level</name>++</expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>c</name> == ')'</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>level</name> == 0</expr>)</condition><then>
				<break>break;</break></then></if>
			<expr_stmt><expr><name>level</name>--</expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>c</name> == ':' || <name>c</name> == ';' || <name>c</name> == '\0'</expr>)</condition><then>
			<break>break;</break></then>
		<else>else <if>if <condition>(<expr><name>level</name> == 0 &amp;&amp; <call><name>isalpha</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if></else></if></else></if></else></if>
	}</block></for>
	
	<if>if <condition>(<expr>!<call><name>PySequence_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> || <call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>levels</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
			      <argument><expr><name>toplevel</name> ? "expected %d arguments, not %.50s" :
			              "must be %d-item sequence, not %.50s"</expr></argument>,
			      <argument><expr><name>n</name></expr></argument>, 
			      <argument><expr><name>arg</name> == <name>Py_None</name> ? "None" : <name><name>arg</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>msgbuf</name></expr>;</return>
	}</block></then></if>
	
	<if>if <condition>(<expr>(<name>i</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>) != <name>n</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>levels</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
			      <argument><expr><name>toplevel</name> ? "expected %d arguments, not %d" :
			             "must be sequence of length %d, not %d"</expr></argument>,
			      <argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>msgbuf</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>format</name> = *<name>p_format</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>msg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>item</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>levels</name><index>[<expr>0</expr>]</index></name> = <name>i</name>+1</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>levels</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr>"is not retrievable"</expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>msgbuf</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>msg</name> = <call><name>convertitem</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>levels</name>+1</expr></argument>, 
				  <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* PySequence_GetItem calls tp-&gt;sq_item, which INCREFs */</comment>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>msg</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>levels</name><index>[<expr>0</expr>]</index></name> = <name>i</name>+1</expr>;</expr_stmt>
			<return>return <expr><name>msg</name></expr>;</return>
		}</block></then></if>
	}</block></for>

	<expr_stmt><expr>*<name>p_format</name> = <name>format</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<comment type="block">/* Convert a single item. */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>convertitem</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>p_format</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
            <param><decl><type><name>int</name> *</type><name>levels</name></decl></param>, <param><decl><type><name>char</name> *</type><name>msgbuf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bufsize</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>freelist</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name> <init>= <expr>*<name>p_format</name></expr></init></decl>;</decl_stmt>
	
	<if>if <condition>(<expr>*<name>format</name> == '('</expr> <comment type="block">/* ')' */</comment>)</condition><then> <block>{
		<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>msg</name> = <call><name>converttuple</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, 
				   <argument><expr><name>bufsize</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>msg</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>msg</name> = <call><name>convertsimple</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, 
				    <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>msg</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>levels</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt></then></if>
	}</block></else></if>
	<if>if <condition>(<expr><name>msg</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>p_format</name> = <name>format</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>msg</name></expr>;</return>
}</block></function>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNICODE_DEFAULT_ENCODING</name><parameter_list>(<param><type><name>arg</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>_PyUnicode_AsDefaultEncodedString(arg, NULL)</cpp:value></cpp:define>

<comment type="block">/* Format an error message generated by convertsimple(). */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>converterr</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expected</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>char</name> *</type><name>msgbuf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bufsize</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>expected</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arg</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
		      <argument><expr>"must be %.50s, not %.50s"</expr></argument>, <argument><expr><name>expected</name></expr></argument>,
		      <argument><expr><name>arg</name> == <name>Py_None</name> ? "None" : <name><name>arg</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>msgbuf</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_UNICODE</name></cpp:macro> <cpp:value>"(unicode conversion error)"</cpp:value></cpp:define>

<comment type="block">/* explicitly check for float arguments when integers are expected.  For now
 * signal a warning.  Returns true if an exception was raised. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>float_argument_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> &amp;&amp;
	    <call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
		       <argument><expr>"integer argument expected, got float"</expr></argument> )</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then>
	<else>else
		<return>return <expr>0</expr>;</return></else></if>
}</block></function>

<comment type="block">/* Convert a non-tuple argument.  Return NULL if conversion went OK,
   or a string with a message describing the failure.  The message is
   formatted as "must be &lt;desired type&gt;, not &lt;actual type&gt;".
   When failing, an exception may or may not have been raised.
   Don't call if a tuple is expected.

   When you add new format codes, please don't forget poor skipitem() below.
*/</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>convertsimple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>p_format</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
              <param><decl><type><name>char</name> *</type><name>msgbuf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bufsize</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>freelist</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* For # codes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FETCH_SIZE</name></cpp:macro>	<cpp:value>int *q=NULL;Py_ssize_t *q2=NULL;\
	if (flags &amp; FLAG_SIZE_T) q2=va_arg(*p_va, Py_ssize_t*); \
	else q=va_arg(*p_va, int*);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE_SIZE</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>if (flags &amp; FLAG_SIZE_T) *q2=s; else *q=s;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFFER_LEN</name></cpp:macro>      <cpp:value>((flags &amp; FLAG_SIZE_T) ? *q2:*q)</cpp:value></cpp:define>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name> <init>= <expr>*<name>p_format</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>*<name>format</name>++</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>uarg</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	
	<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
	
	<case>case <expr>'b'</expr>: <block>{ <comment type="block">/* unsigned byte -- very short int */</comment>
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>float_argument_error</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;b&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>ival</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ival</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;b&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else <if>if <condition>(<expr><name>ival</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"unsigned byte integer is less than minimum"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;b&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>ival</name> &gt; <name>UCHAR_MAX</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"unsigned byte integer is greater than maximum"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;b&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = (<name>unsigned</name> <name>char</name>) <name>ival</name></expr>;</expr_stmt></else></if></else></if></else></if>
		<break>break;</break>
	}</block>
	
	</case><case>case <expr>'B'</expr>: <block>{<comment type="block">/* byte sized bitfield - both signed and unsigned
		      values allowed */</comment>  
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>float_argument_error</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;B&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>ival</name> = <call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ival</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;B&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = (<name>unsigned</name> <name>char</name>) <name>ival</name></expr>;</expr_stmt></else></if>
		<break>break;</break>
	}</block>
	
	</case><case>case <expr>'h'</expr>: <block>{<comment type="block">/* signed short int */</comment>
		<decl_stmt><decl><type><name>short</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>short</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>float_argument_error</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;h&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>ival</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ival</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;h&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else <if>if <condition>(<expr><name>ival</name> &lt; <name>SHRT_MIN</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"signed short integer is less than minimum"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;h&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>ival</name> &gt; <name>SHRT_MAX</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"signed short integer is greater than maximum"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;h&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = (<name>short</name>) <name>ival</name></expr>;</expr_stmt></else></if></else></if></else></if>
		<break>break;</break>
	}</block>
	
	</case><case>case <expr>'H'</expr>: <block>{ <comment type="block">/* short int sized bitfield, both signed and
		       unsigned allowed */</comment> 
		<decl_stmt><decl><type><name>unsigned</name> <name>short</name> *</type><name>p</name> <init>= <macro><name>va_arg</name><argument_list>(<argument>*p_va</argument>, <argument>unsigned short *</argument>)</argument_list></macro></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>float_argument_error</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;H&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>ival</name> = <call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ival</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;H&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = (<name>unsigned</name> <name>short</name>) <name>ival</name></expr>;</expr_stmt></else></if>
		<break>break;</break>
	}</block>

	</case><case>case <expr>'i'</expr>: <block>{<comment type="block">/* signed int */</comment>
		<decl_stmt><decl><type><name>int</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>int</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>float_argument_error</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;i&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>ival</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ival</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;i&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else <if>if <condition>(<expr><name>ival</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"signed integer is greater than maximum"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;i&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>ival</name> &lt; <name>INT_MIN</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"signed integer is less than minimum"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;i&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = <name>ival</name></expr>;</expr_stmt></else></if></else></if></else></if>
		<break>break;</break>
	}</block>

	</case><case>case <expr>'I'</expr>: <block>{ <comment type="block">/* int sized bitfield, both signed and
		       unsigned allowed */</comment> 
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name> *</type><name>p</name> <init>= <macro><name>va_arg</name><argument_list>(<argument>*p_va</argument>, <argument>unsigned int *</argument>)</argument_list></macro></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>float_argument_error</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;I&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>ival</name> = (<name>unsigned</name> <name>int</name>)<call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ival</name> == (<name>unsigned</name> <name>int</name>)-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;I&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = <name>ival</name></expr>;</expr_stmt></else></if>
		<break>break;</break>
	}</block>
	
	</case><case>case <expr>'n'</expr>: <comment type="block">/* Py_ssize_t */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> != <name>SIZEOF_LONG</name></expr></cpp:if>
	<block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_ssize_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>float_argument_error</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;n&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>ival</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ival</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;n&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr>*<name>p</name> = <name>ival</name></expr>;</expr_stmt>
		<break>break;</break>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Fall through from 'n' to 'l' if Py_ssize_t is int */</comment>
	</case><case>case <expr>'l'</expr>: <block>{<comment type="block">/* long int */</comment>
		<decl_stmt><decl><type><name>long</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>long</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>float_argument_error</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;l&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>ival</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ival</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;l&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = <name>ival</name></expr>;</expr_stmt></else></if>
		<break>break;</break>
	}</block>

	</case><case>case <expr>'k'</expr>: <block>{ <comment type="block">/* long sized bitfield */</comment>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name> *</type><name>p</name> <init>= <macro><name>va_arg</name><argument_list>(<argument>*p_va</argument>, <argument>unsigned long *</argument>)</argument_list></macro></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>ival</name> = <call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>ival</name> = <call><name>PyLong_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;k&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
		<expr_stmt><expr>*<name>p</name> = <name>ival</name></expr>;</expr_stmt>
		<break>break;</break>
	}</block>
	
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
	</case><case>case <expr>'L'</expr>: <block>{<comment type="block">/* PY_LONG_LONG */</comment>
		<decl_stmt><decl><type><name>PY_LONG_LONG</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>( <argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PY_LONG_LONG</name> *</expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>ival</name> <init>= <expr><call><name>PyLong_AsLongLong</name><argument_list>( <argument><expr><name>arg</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>ival</name> == (<name>PY_LONG_LONG</name>)-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr> )</condition><then> <block>{
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"long&lt;L&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then> <else>else <block>{
			<expr_stmt><expr>*<name>p</name> = <name>ival</name></expr>;</expr_stmt>
		}</block></else></if>
		<break>break;</break>
	}</block>

	</case><case>case <expr>'K'</expr>: <block>{ <comment type="block">/* long long sized bitfield */</comment>
		<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name> *</type><name>p</name> <init>= <macro><name>va_arg</name><argument_list>(<argument>*p_va</argument>, <argument>unsigned PY_LONG_LONG *</argument>)</argument_list></macro></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>ival</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>ival</name> = <call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>ival</name> = <call><name>PyLong_AsUnsignedLongLongMask</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"integer&lt;K&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
		<expr_stmt><expr>*<name>p</name> = <name>ival</name></expr>;</expr_stmt>
		<break>break;</break>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	
	</case><case>case <expr>'f'</expr>: <block>{<comment type="block">/* float */</comment>
		<decl_stmt><decl><type><name>float</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>float</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>dval</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"float&lt;f&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = (<name>float</name>) <name>dval</name></expr>;</expr_stmt></else></if>
		<break>break;</break>
	}</block>
	
	</case><case>case <expr>'d'</expr>: <block>{<comment type="block">/* double */</comment>
		<decl_stmt><decl><type><name>double</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>double</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>dval</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"float&lt;d&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = <name>dval</name></expr>;</expr_stmt></else></if>
		<break>break;</break>
	}</block>
	
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITHOUT_COMPLEX</name></cpp:ifndef>
	</case><case>case <expr>'D'</expr>: <block>{<comment type="block">/* complex double */</comment>
		<decl_stmt><decl><type><name>Py_complex</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_complex</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_complex</name></type> <name>cval</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>cval</name> = <call><name>PyComplex_AsCComplex</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"complex&lt;D&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<expr_stmt><expr>*<name>p</name> = <name>cval</name></expr>;</expr_stmt></else></if>
		<break>break;</break>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WITHOUT_COMPLEX */</comment>
	
	</case><case>case <expr>'c'</expr>: <block>{<comment type="block">/* char */</comment>
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyString_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
			<expr_stmt><expr>*<name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</expr_stmt></then>
		<else>else
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"char"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
		<break>break;</break>
	}</block>
	
	</case><case>case <expr>'s'</expr>: <block>{<comment type="block">/* string */</comment>
		<if>if <condition>(<expr>*<name>format</name> == '*'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_buffer</name> *</type><name>p</name> <init>= <expr>(<name>Py_buffer</name> *)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_buffer</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyBuffer_FillInfo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>,
						  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>uarg</name> = <call><name>UNICODE_DEFAULT_ENCODING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>uarg</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>CONV_UNICODE</name></expr></argument>,
							  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr><call><name>PyBuffer_FillInfo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>,
						  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else <block>{ <comment type="block">/* any buffer-like object */</comment>
				<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
				<if>if <condition>(<expr><call><name>getbuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
			}</block></else></if></else></if>
			<if>if <condition>(<expr><call><name>addcleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>freelist</name></expr></argument>, <argument><expr><name>cleanup_buffer</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<return>return <expr><call><name>converterr</name><argument_list>(
					<argument><expr>"(cleanup problem)"</expr></argument>,
					<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr>*<name>format</name> == '#'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>void</name> **</type><name>p</name> <init>= <expr>(<name>void</name> **)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>FETCH_SIZE</name></expr>;</expr_stmt>
			
			<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>uarg</name> = <call><name>UNICODE_DEFAULT_ENCODING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>uarg</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>CONV_UNICODE</name></expr></argument>,
							  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr>*<name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else <block>{ <comment type="block">/* any buffer-like object */</comment>
				<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name> <init>= <expr><call><name>convertbuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>count</name> &lt; 0</expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if></else></if>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<decl_stmt><decl><type><name>char</name> **</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			
			<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr>*<name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>uarg</name> = <call><name>UNICODE_DEFAULT_ENCODING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>uarg</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>CONV_UNICODE</name></expr></argument>,
							  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr>*<name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"string"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
			<if>if <condition>(<expr>(<name>Py_ssize_t</name>)<call><name>strlen</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != <call><name>PyString_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"string without null bytes"</expr></argument>,
						  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		}</block></else></if></else></if>
		<break>break;</break>
	}</block>

	</case><case>case <expr>'z'</expr>: <block>{<comment type="block">/* string, may be NULL (None) */</comment>
		<if>if <condition>(<expr>*<name>format</name> == '*'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_buffer</name> *</type><name>p</name> <init>= <expr>(<name>Py_buffer</name> *)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_buffer</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyBuffer_FillInfo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyBuffer_FillInfo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>,
						  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>uarg</name> = <call><name>UNICODE_DEFAULT_ENCODING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>uarg</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>CONV_UNICODE</name></expr></argument>,
							  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr><call><name>PyBuffer_FillInfo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>,
						  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else <block>{ <comment type="block">/* any buffer-like object */</comment>
				<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
				<if>if <condition>(<expr><call><name>getbuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
			}</block></else></if></else></if></else></if>
			<if>if <condition>(<expr><call><name>addcleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>freelist</name></expr></argument>, <argument><expr><name>cleanup_buffer</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<return>return <expr><call><name>converterr</name><argument_list>(
					<argument><expr>"(cleanup problem)"</expr></argument>,
					<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr>*<name>format</name> == '#'</expr>)</condition><then> <block>{ <comment type="block">/* any buffer-like object */</comment>
			<decl_stmt><decl><type><name>void</name> **</type><name>p</name> <init>= <expr>(<name>void</name> **)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>FETCH_SIZE</name></expr>;</expr_stmt>
			
			<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>p</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>uarg</name> = <call><name>UNICODE_DEFAULT_ENCODING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>uarg</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>CONV_UNICODE</name></expr></argument>,
							  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr>*<name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else <block>{ <comment type="block">/* any buffer-like object */</comment>
				<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name> <init>= <expr><call><name>convertbuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>count</name> &lt; 0</expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if></else></if></else></if>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<decl_stmt><decl><type><name>char</name> **</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			
			<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then>
				<expr_stmt><expr>*<name>p</name> = 0</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr>*<name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>uarg</name> = <call><name>UNICODE_DEFAULT_ENCODING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>uarg</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name>CONV_UNICODE</name></expr></argument>,
							  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr>*<name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"string or None"</expr></argument>, 
						  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if></else></if>
			<if>if <condition>(<expr>*<name>format</name> == '#'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>FETCH_SIZE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* XXX redundant with if-case */</comment>
				<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then>
					<expr_stmt><expr>*<name>q</name> = 0</expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr>*<name>q</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
				<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr>*<name>p</name> != <name>NULL</name> &amp;&amp;
				 (<name>Py_ssize_t</name>)<call><name>strlen</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != <call><name>PyString_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><call><name>converterr</name><argument_list>(
					<argument><expr>"string without null bytes or None"</expr></argument>, 
					<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
		}</block></else></if></else></if>
		<break>break;</break>
	}</block>
	
	</case><case>case <expr>'e'</expr>: <block>{<comment type="block">/* encoded string */</comment>
		<decl_stmt><decl><type><name>char</name> **</type><name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>recode_strings</name></decl>;</decl_stmt>

		<comment type="block">/* Get 'e' parameter: the encoding name */</comment>
		<expr_stmt><expr><name>encoding</name> = (const <name>char</name> *)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			
		<comment type="block">/* Get output buffer parameter:
		   's' (recode all objects via Unicode) or
		   't' (only recode non-string objects) 
		*/</comment>
		<if>if <condition>(<expr>*<name>format</name> == 's'</expr>)</condition><then>
			<expr_stmt><expr><name>recode_strings</name> = 1</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr>*<name>format</name> == 't'</expr>)</condition><then>
			<expr_stmt><expr><name>recode_strings</name> = 0</expr>;</expr_stmt></then>
		<else>else
			<return>return <expr><call><name>converterr</name><argument_list>(
				<argument><expr>"(unknown parser marker combination)"</expr></argument>,
				<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
		<expr_stmt><expr><name>buffer</name> = (<name>char</name> **)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> **</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"(buffer is NULL)"</expr></argument>, 
					  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
			
		<comment type="block">/* Encode object */</comment>
		<if>if <condition>(<expr>!<name>recode_strings</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>s</name> = <name>arg</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		    	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>;</decl_stmt>

			<comment type="block">/* Convert object to Unicode */</comment>
			<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call><name>converterr</name><argument_list>(
					<argument><expr>"string or unicode or text buffer"</expr></argument>, 
					<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
			
			<comment type="block">/* Encode object; use default error handling */</comment>
			<expr_stmt><expr><name>s</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>u</name></expr></argument>,
						      <argument><expr><name>encoding</name></expr></argument>,
						      <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"(encoding failed)"</expr></argument>,
						  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
			<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>converterr</name><argument_list>(
					<argument><expr>"(encoder failed to return a string)"</expr></argument>,
					<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"string&lt;e&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<expr_stmt><expr><name>size</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Write output; output is guaranteed to be 0-terminated */</comment>
		<if>if <condition>(<expr>*<name>format</name> == '#'</expr>)</condition><then> <block>{ 
			<comment type="block">/* Using buffer length parameter '#':
				   
			   - if *buffer is NULL, a new buffer of the
			   needed size is allocated and the data
			   copied into it; *buffer is updated to point
			   to the new buffer; the caller is
			   responsible for PyMem_Free()ing it after
			   usage 

			   - if *buffer is not NULL, the data is
			   copied to *buffer; *buffer_len has to be
			   set to the size of the buffer on input;
			   buffer overflow is signalled with an error;
			   buffer has to provide enough room for the
			   encoded string plus the trailing 0-byte
			   
			   - in both cases, *buffer_len is updated to
			   the size of the buffer /excluding/ the
			   trailing 0-byte 
			   
			*/</comment>
			<expr_stmt><expr><name>FETCH_SIZE</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>q</name> == <name>NULL</name> &amp;&amp; <name>q2</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>converterr</name><argument_list>(
					<argument><expr>"(buffer_len is NULL)"</expr></argument>,
					<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr>*<name>buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>buffer</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>size</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>*<name>buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><call><name>converterr</name><argument_list>(
						<argument><expr>"(memory error)"</expr></argument>,
						<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
				}</block></then></if>
				<if>if <condition>(<expr><call><name>addcleanup</name><argument_list>(<argument><expr>*<name>buffer</name></expr></argument>, <argument><expr><name>freelist</name></expr></argument>, <argument><expr><name>cleanup_ptr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><call><name>converterr</name><argument_list>(
						<argument><expr>"(cleanup problem)"</expr></argument>,
						<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
				}</block></then></if>
			}</block></then> <else>else <block>{
				<if>if <condition>(<expr><name>size</name> + 1 &gt; <name>BUFFER_LEN</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><call><name>converterr</name><argument_list>(
						<argument><expr>"(buffer overflow)"</expr></argument>, 
						<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
				}</block></then></if>
			}</block></else></if>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>*<name>buffer</name></expr></argument>,
			       <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><name>size</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<comment type="block">/* Using a 0-terminated buffer:
				   
			   - the encoded string has to be 0-terminated
			   for this variant to work; if it is not, an
			   error raised 

			   - a new buffer of the needed size is
			   allocated and the data copied into it;
			   *buffer is updated to point to the new
			   buffer; the caller is responsible for
			   PyMem_Free()ing it after usage

			*/</comment>
			<if>if <condition>(<expr>(<name>Py_ssize_t</name>)<call><name>strlen</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
								!= <name>size</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>converterr</name><argument_list>(
					<argument><expr>"(encoded string without NULL bytes)"</expr></argument>,
					<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr>*<name>buffer</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>size</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"(memory error)"</expr></argument>,
						  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>addcleanup</name><argument_list>(<argument><expr>*<name>buffer</name></expr></argument>, <argument><expr><name>freelist</name></expr></argument>, <argument><expr><name>cleanup_ptr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"(cleanup problem)"</expr></argument>,
						<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>*<name>buffer</name></expr></argument>,
			       <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><name>size</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	</case><case>case <expr>'u'</expr>: <block>{<comment type="block">/* raw unicode buffer (Py_UNICODE *) */</comment>
		<if>if <condition>(<expr>*<name>format</name> == '#'</expr>)</condition><then> <block>{ <comment type="block">/* any buffer-like object */</comment>
			<decl_stmt><decl><type><name>void</name> **</type><name>p</name> <init>= <expr>(<name>void</name> **)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>FETCH_SIZE</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    	<expr_stmt><expr>*<name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"cannot convert raw buffers"</expr></argument>,
						  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></else></if>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<decl_stmt><decl><type><name>Py_UNICODE</name> **</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_UNICODE</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr>*<name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"unicode"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
		}</block></else></if>
		<break>break;</break>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</case><case>case <expr>'S'</expr>: <block>{ <comment type="block">/* string object */</comment>
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyObject</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr>*<name>p</name> = <name>arg</name></expr>;</expr_stmt></then>
		<else>else
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"string"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
		<break>break;</break>
	}</block>
	
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	</case><case>case <expr>'U'</expr>: <block>{ <comment type="block">/* Unicode object */</comment>
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyObject</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr>*<name>p</name> = <name>arg</name></expr>;</expr_stmt></then>
		<else>else
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"unicode"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
		<break>break;</break>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	
	</case><case>case <expr>'O'</expr>: <block>{ <comment type="block">/* object */</comment>
		<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>p</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>*<name>format</name> == '!'</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>type</name> = <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyTypeObject</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> = <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyObject</name> **</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name><name>arg</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr>*<name>p</name> = <name>arg</name></expr>;</expr_stmt></then>
			<else>else
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>tp_name</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if>

		}</block></then>
		<else>else <if>if <condition>(<expr>*<name>format</name> == '?'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>inquiry</name></type> <name>pred</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>inquiry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>p</name> = <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyObject</name> **</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><call>(*<name>pred</name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
				<expr_stmt><expr>*<name>p</name> = <name>arg</name></expr>;</expr_stmt></then>
			<else>else
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"(unspecified)"</expr></argument>, 
						  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
				
		}</block></then>
		<else>else <if>if <condition>(<expr>*<name>format</name> == '&amp;'</expr>)</condition><then> <block>{
			<typedef>typedef <function_decl><type><name>int</name></type> (*<name>converter</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl></typedef>
			<decl_stmt><decl><type><name>converter</name></type> <name>convert</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>converter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>void</name> *</type><name>addr</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr>! <call>(*<name>convert</name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"(unspecified)"</expr></argument>, 
						  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>p</name> = <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyObject</name> **</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>p</name> = <name>arg</name></expr>;</expr_stmt>
		}</block></else></if></else></if></else></if>
		<break>break;</break>
	}</block>
		
		
	</case><case>case <expr>'w'</expr>: <block>{ <comment type="block">/* memory buffer, read-write access */</comment>
		<decl_stmt><decl><type><name>void</name> **</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>void</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> *</type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyBufferProcs</name> *</type><name>pb</name> <init>= <expr><name><name>arg</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_buffer</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>pb</name> &amp;&amp; <name><name>pb</name>-&gt;<name>bf_releasebuffer</name></name> &amp;&amp; *<name>format</name> != '*'</expr>)</condition><then>
			<comment type="block">/* Buffer must be released, yet caller does not use
			   the Py_buffer protocol. */</comment>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"pinned buffer"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

		<if>if <condition>(<expr><name>pb</name> &amp;&amp; <name><name>pb</name>-&gt;<name>bf_getbuffer</name></name> &amp;&amp; *<name>format</name> == '*'</expr>)</condition><then> <block>{
			<comment type="block">/* Caller is interested in Py_buffer, and the object
			   supports it directly. */</comment>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name><name>pb</name>-&gt;<name>bf_getbuffer</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>(<name>Py_buffer</name>*)<name>p</name></expr></argument>, <argument><expr><name>PyBUF_WRITABLE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"read-write buffer"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>addcleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>freelist</name></expr></argument>, <argument><expr><name>cleanup_buffer</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<return>return <expr><call><name>converterr</name><argument_list>(
					<argument><expr>"(cleanup problem)"</expr></argument>,
					<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr>!<call><name>PyBuffer_IsContiguous</name><argument_list>(<argument><expr>(<name>Py_buffer</name>*)<name>p</name></expr></argument>, <argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"contiguous buffer"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
			<break>break;</break>
		}</block></then></if>

		<if>if <condition>(<expr><name>pb</name> == <name>NULL</name> ||
		    <name><name>pb</name>-&gt;<name>bf_getwritebuffer</name></name> == <name>NULL</name> ||
		    <name><name>pb</name>-&gt;<name>bf_getsegcount</name></name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"read-write buffer"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr><call>(*<name><name>pb</name>-&gt;<name>bf_getsegcount</name></name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"single-segment read-write buffer"</expr></argument>, 
					  <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>count</name> = <call><name><name>pb</name>-&gt;<name>bf_getwritebuffer</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"(unspecified)"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr>*<name>format</name> == '*'</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyBuffer_FillInfo</name><argument_list>(<argument><expr>(<name>Py_buffer</name>*)<name>p</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr>*<name>p</name> = <name>res</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>format</name> == '#'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>FETCH_SIZE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			}</block></then></if>
		}</block></else></if>
		<break>break;</break>
	}</block>
		
	</case><case>case <expr>'t'</expr>: <block>{ <comment type="block">/* 8-bit character buffer, read-only access */</comment>
		<decl_stmt><decl><type><name>char</name> **</type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> **</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyBufferProcs</name> *</type><name>pb</name> <init>= <expr><name><name>arg</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_buffer</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>
		
		<if>if <condition>(<expr>*<name>format</name>++ != '#'</expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(
				<argument><expr>"invalid use of 't' format character"</expr></argument>, 
				<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr>!<call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name><name>arg</name>-&gt;<name>ob_type</name></name></expr></argument>,
				       <argument><expr><name>Py_TPFLAGS_HAVE_GETCHARBUFFER</name></expr></argument>)</argument_list></call> ||
		    <name>pb</name> == <name>NULL</name> || <name><name>pb</name>-&gt;<name>bf_getcharbuffer</name></name> == <name>NULL</name> ||
		    <name><name>pb</name>-&gt;<name>bf_getsegcount</name></name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(
				<argument><expr>"string or read-only character buffer"</expr></argument>,
				<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

		<if>if <condition>(<expr><call><name><name>pb</name>-&gt;<name>bf_getsegcount</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(
				<argument><expr>"string or single-segment read-only buffer"</expr></argument>,
				<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

		<if>if <condition>(<expr><name><name>pb</name>-&gt;<name>bf_releasebuffer</name></name></expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(
				<argument><expr>"string or pinned buffer"</expr></argument>,
				<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

		<expr_stmt><expr><name>count</name> = <call><name><name>pb</name>-&gt;<name>bf_getcharbuffer</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>count</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"(unspecified)"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<block>{
			<expr_stmt><expr><name>FETCH_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STORE_SIZE</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block>
		<break>break;</break>
	}</block>

	</case><default>default:
		<return>return <expr><call><name>converterr</name><argument_list>(<argument><expr>"impossible&lt;bad format char&gt;"</expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return>
	
	</default>}</block></switch>
	
	<expr_stmt><expr>*<name>p_format</name> = <name>format</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>convertbuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>void</name> **</type><name>p</name></decl></param>, <param><decl><type><name>char</name> **</type><name>errmsg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyBufferProcs</name> *</type><name>pb</name> <init>= <expr><name><name>arg</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_buffer</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>pb</name> == <name>NULL</name> ||
	    <name><name>pb</name>-&gt;<name>bf_getreadbuffer</name></name> == <name>NULL</name> ||
	    <name><name>pb</name>-&gt;<name>bf_getsegcount</name></name> == <name>NULL</name> ||
	    <name><name>pb</name>-&gt;<name>bf_releasebuffer</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>errmsg</name> = "string or read-only buffer"</expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call>(*<name><name>pb</name>-&gt;<name>bf_getsegcount</name></name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>errmsg</name> = "string or single-segment read-only buffer"</expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>count</name> = <call>(*<name><name>pb</name>-&gt;<name>bf_getreadbuffer</name></name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>errmsg</name> = "(unspecified)"</expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>count</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>getbuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>char</name> **</type><name>errmsg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>void</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyBufferProcs</name> *</type><name>pb</name> <init>= <expr><name><name>arg</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_buffer</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>pb</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>errmsg</name> = "string or buffer"</expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>pb</name>-&gt;<name>bf_getbuffer</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name><name>pb</name>-&gt;<name>bf_getbuffer</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>view</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>errmsg</name> = "convertible to a buffer"</expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>PyBuffer_IsContiguous</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>errmsg</name> = "contiguous buffer"</expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>count</name> = <call><name>convertbuffer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>count</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>errmsg</name> = "convertible to a buffer"</expr>;</expr_stmt>
		<return>return <expr><name>count</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyBuffer_FillInfo</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Support for keyword arguments donated by
   Geoff Philbrick &lt;philbric@delphi.hks.com&gt; */</comment>

<comment type="block">/* Return false (0) for error, else true. */</comment>
<function><type><name>int</name></type>
<name>PyArg_ParseTupleAndKeywords</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
			    <param><decl><type><name>PyObject</name> *</type><name>keywords</name></decl></param>,
			    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, 
			    <param><decl><type><name>char</name> **</type><name>kwlist</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>args</name> == <name>NULL</name> || !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>) ||
	    (<name>keywords</name> != <name>NULL</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call>) ||
	    <name>format</name> == <name>NULL</name> ||
	    <name>kwlist</name> == <name>NULL</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>kwlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>vgetargskeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>va</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyArg_ParseTupleAndKeywords_SizeT</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
				  <param><decl><type><name>PyObject</name> *</type><name>keywords</name></decl></param>,
				  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, 
				  <param><decl><type><name>char</name> **</type><name>kwlist</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>args</name> == <name>NULL</name> || !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>) ||
	    (<name>keywords</name> != <name>NULL</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call>) ||
	    <name>format</name> == <name>NULL</name> ||
	    <name>kwlist</name> == <name>NULL</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>kwlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>vgetargskeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, 
				  <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>va</name></expr></argument>, <argument><expr><name>FLAG_SIZE_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>


<function><type><name>int</name></type>
<name>PyArg_VaParseTupleAndKeywords</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
                              <param><decl><type><name>PyObject</name> *</type><name>keywords</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, 
                              <param><decl><type><name>char</name> **</type><name>kwlist</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>va</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>lva</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>args</name> == <name>NULL</name> || !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>) ||
	    (<name>keywords</name> != <name>NULL</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call>) ||
	    <name>format</name> == <name>NULL</name> ||
	    <name>kwlist</name> == <name>NULL</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VA_LIST_IS_ARRAY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>va_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__va_copy</name></cpp:ifdef>
	<expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>lva</name> = <name>va</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>retval</name> = <call><name>vgetargskeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>lva</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>_PyArg_VaParseTupleAndKeywords_SizeT</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
				    <param><decl><type><name>PyObject</name> *</type><name>keywords</name></decl></param>,
				    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, 
				    <param><decl><type><name>char</name> **</type><name>kwlist</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>va</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>lva</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>args</name> == <name>NULL</name> || !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>) ||
	    (<name>keywords</name> != <name>NULL</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call>) ||
	    <name>format</name> == <name>NULL</name> ||
	    <name>kwlist</name> == <name>NULL</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VA_LIST_IS_ARRAY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>va_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__va_copy</name></cpp:ifdef>
	<expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>lva</name> = <name>va</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>retval</name> = <call><name>vgetargskeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, 
				  <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>lva</name></expr></argument>, <argument><expr><name>FLAG_SIZE_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_END_OF_FORMAT</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(c == '\0' || c == ';' || c == ':')</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>vgetargskeywords</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>keywords</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>,
	         <param><decl><type><name>char</name> **</type><name>kwlist</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>msgbuf</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>levels</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl>, *<decl><type ref="prev"/><name>msg</name></decl>, *<decl><type ref="prev"/><name>custom_msg</name></decl>, *<decl><type ref="prev"/><name>keyword</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>nargs</name></decl>, <decl><type ref="prev"/><name>nkeywords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>freelist</name> <init>= <expr><name>NULL</name></expr></init>, *<name>current_arg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>args</name> != <name>NULL</name> &amp;&amp; <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>keywords</name> == <name>NULL</name> || <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>format</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>kwlist</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p_va</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* grab the function name or custom error msg first (mutually exclusive) */</comment>
	<expr_stmt><expr><name>fname</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fname</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>fname</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>custom_msg</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>custom_msg</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>format</name></expr></argument>,<argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>custom_msg</name></expr>)</condition><then>
			<expr_stmt><expr><name>custom_msg</name>++</expr>;</expr_stmt></then></if>
	}</block></else></if>

	<comment type="block">/* scan kwlist and get greatest possible nbr of args */</comment>
	<for>for (<init><expr><name>len</name>=0</expr>;</init> <condition><expr><name><name>kwlist</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>)
		<continue>continue;</continue></for>

	<expr_stmt><expr><name>nargs</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nkeywords</name> = (<name>keywords</name> == <name>NULL</name>) ? 0 : <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>nargs</name> + <name>nkeywords</name> &gt; <name>len</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"%s%s takes at most %d "
			     "argument%s (%d given)"</expr></argument>,
			     <argument><expr>(<name>fname</name> == <name>NULL</name>) ? "function" : <name>fname</name></expr></argument>,
			     <argument><expr>(<name>fname</name> == <name>NULL</name>) ? "" : "()"</expr></argument>,
			     <argument><expr><name>len</name></expr></argument>,
			     <argument><expr>(<name>len</name> == 1) ? "" : "s"</expr></argument>,
			     <argument><expr><name>nargs</name> + <name>nkeywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* convert tuple args and keyword args in same loop, using kwlist to drive process */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>keyword</name> = <name><name>kwlist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>format</name> == '|'</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>min</name> = <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>IS_END_OF_FORMAT</name><argument_list>(<argument><expr>*<name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				     <argument><expr>"More keyword list entries (%d) than "
				     "format specifiers (%d)"</expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>current_arg</name> = <name>NULL</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>nkeywords</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>current_arg</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>current_arg</name></expr>)</condition><then> <block>{
			<expr_stmt><expr>--<name>nkeywords</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>i</name> &lt; <name>nargs</name></expr>)</condition><then> <block>{
				<comment type="block">/* arg present in tuple and in dict */</comment>
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					     <argument><expr>"Argument given by name ('%s') "
					     "and position (%d)"</expr></argument>,
					     <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>nkeywords</name> &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else <if>if <condition>(<expr><name>i</name> &lt; <name>nargs</name></expr>)</condition><then>
			<expr_stmt><expr><name>current_arg</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
			
		<if>if <condition>(<expr><name>current_arg</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>msg</name> = <call><name>convertitem</name><argument_list>(<argument><expr><name>current_arg</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
				<argument><expr><name>levels</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>freelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>msg</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>seterror</name><argument_list>(<argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>custom_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<continue>continue;</continue>
		}</block></then></if>

		<if>if <condition>(<expr><name>i</name> &lt; <name>min</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"Required argument "
				     "'%s' (pos %d) not found"</expr></argument>,
				     <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<comment type="block">/* current code reports success when all required args
		 * fulfilled and no keyword args left, with no further
		 * validation. XXX Maybe skip this in debug build ?
		 */</comment>
		<if>if <condition>(<expr>!<name>nkeywords</name></expr>)</condition><then>
			<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

		<comment type="block">/* We are into optional args, skip thru to any remaining
		 * keyword args */</comment>
		<expr_stmt><expr><name>msg</name> = <call><name>skipitem</name><argument_list>(<argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>msg</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"%s: '%s'"</expr></argument>, <argument><expr><name>msg</name></expr></argument>,
				     <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
	}</block></for>

	<if>if <condition>(<expr>!<call><name>IS_END_OF_FORMAT</name><argument_list>(<argument><expr>*<name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
			<argument><expr>"more argument specifiers than keyword list entries "
			"(remaining format:'%s')"</expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* make sure there are no extraneous keyword arguments */</comment>
	<if>if <condition>(<expr><name>nkeywords</name> &gt; 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>ks</name></decl>;</decl_stmt>
			<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, 
					        <argument><expr>"keywords must be strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>ks</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>ks</name></expr></argument>, <argument><expr><name><name>kwlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>match</name> = 1</expr>;</expr_stmt>
					<break>break;</break>
				}</block></then></if>
			}</block></for>
			<if>if <condition>(<expr>!<name>match</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					     <argument><expr>"'%s' is an invalid keyword "
					     "argument for this function"</expr></argument>,
					     <argument><expr><name>ks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
		}</block></while>
	}</block></then></if>

	<return>return <expr><call><name>cleanreturn</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>skipitem</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>p_format</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name> <init>= <expr>*<name>p_format</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>*<name>format</name>++</expr></init></decl>;</decl_stmt>
	
	<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{

	<comment type="block">/* simple codes
	 * The individual types (second arg of va_arg) are irrelevant */</comment>

	<case>case <expr>'b'</expr>: <comment type="block">/* byte -- very short int */</comment>
	</case><case>case <expr>'B'</expr>: <comment type="block">/* byte as bitfield */</comment>
	</case><case>case <expr>'h'</expr>: <comment type="block">/* short int */</comment>
	</case><case>case <expr>'H'</expr>: <comment type="block">/* short int as bitfield */</comment>
	</case><case>case <expr>'i'</expr>: <comment type="block">/* int */</comment>
	</case><case>case <expr>'I'</expr>: <comment type="block">/* int sized bitfield */</comment>
	</case><case>case <expr>'l'</expr>: <comment type="block">/* long int */</comment>
	</case><case>case <expr>'k'</expr>: <comment type="block">/* long int sized bitfield */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
	</case><case>case <expr>'L'</expr>: <comment type="block">/* PY_LONG_LONG */</comment>
	</case><case>case <expr>'K'</expr>: <comment type="block">/* PY_LONG_LONG sized bitfield */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>'f'</expr>: <comment type="block">/* float */</comment>
	</case><case>case <expr>'d'</expr>: <comment type="block">/* double */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITHOUT_COMPLEX</name></cpp:ifndef>
	</case><case>case <expr>'D'</expr>: <comment type="block">/* complex double */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>'c'</expr>: <comment type="block">/* char */</comment>
		<block>{
			<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block>

	</case><case>case <expr>'n'</expr>: <comment type="block">/* Py_ssize_t */</comment>
		<block>{
			<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_ssize_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block>
	
	<comment type="block">/* string codes */</comment>
		
	</case><case>case <expr>'e'</expr>: <comment type="block">/* string with encoding */</comment>
		<block>{
			<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!(*<name>format</name> == 's' || *<name>format</name> == 't')</expr>)</condition><then>
				<comment type="block">/* after 'e', only 's' and 't' is allowed */</comment>
				<goto>goto <name>err</name>;</goto></then></if>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			<comment type="block">/* explicit fallthrough to string cases */</comment>
		}</block>
	
	</case><case>case <expr>'s'</expr>: <comment type="block">/* string */</comment>
	</case><case>case <expr>'z'</expr>: <comment type="block">/* string or None */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	</case><case>case <expr>'u'</expr>: <comment type="block">/* unicode string */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>'t'</expr>: <comment type="block">/* buffer, read-only */</comment>
	</case><case>case <expr>'w'</expr>: <comment type="block">/* buffer, read-write */</comment>
		<block>{
			<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> **</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>format</name> == '#'</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>flags</name> &amp; <name>FLAG_SIZE_T</name></expr>)</condition><then>
					<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_ssize_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>int</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
				<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr>(<name>c</name> == 's' || <name>c</name> == 'z') &amp;&amp; *<name>format</name> == '*'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			}</block></then></if></else></if>
			<break>break;</break>
		}</block>

	<comment type="block">/* object codes */</comment>

	</case><case>case <expr>'S'</expr>: <comment type="block">/* string object */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	</case><case>case <expr>'U'</expr>: <comment type="block">/* unicode string object */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{
			<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyObject</name> **</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block>
	
	</case><case>case <expr>'O'</expr>: <comment type="block">/* object */</comment>
		<block>{
			<if>if <condition>(<expr>*<name>format</name> == '!'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyTypeObject</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyObject</name> **</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="block">/* I don't know what this is for */</comment>
			else if (*format == '?') {
				inquiry pred = va_arg(*p_va, inquiry);
				format++;
				if ((*pred)(arg)) {
					(void) va_arg(*p_va, PyObject **);
				}
			}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else <if>if <condition>(<expr>*<name>format</name> == '&amp;'</expr>)</condition><then> <block>{
				<typedef>typedef <function_decl><type><name>int</name></type> (*<name>converter</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl></typedef>
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>converter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyObject</name> **</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if></else></if>
			<break>break;</break>
		}</block>

	</case><case>case <expr>'('</expr>:	<comment type="block">/* bypass tuple, not handled at all previously */</comment>
		<block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>msg</name></decl>;</decl_stmt>
			<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
				<if>if <condition>(<expr>*<name>format</name>==')'</expr>)</condition><then>
					<break>break;</break></then></if>
				<if>if <condition>(<expr><call><name>IS_END_OF_FORMAT</name><argument_list>(<argument><expr>*<name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<return>return <expr>"Unmatched left paren in format "
					       "string"</expr>;</return></then></if>
				<expr_stmt><expr><name>msg</name> = <call><name>skipitem</name><argument_list>(<argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>msg</name></expr>)</condition><then>
					<return>return <expr><name>msg</name></expr>;</return></then></if>
			}</block></for>
			<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
			<break>break;</break>
		}</block>

	</case><case>case <expr>')'</expr>:
		<return>return <expr>"Unmatched right paren in format string"</expr>;</return>

	</case><default>default:
<label><name>err</name>:</label>
		<return>return <expr>"impossible&lt;bad format char&gt;"</expr>;</return>
	
	</default>}</block></switch>

	<expr_stmt><expr>*<name>p_format</name> = <name>format</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><name>int</name></type>
<name>PyArg_UnpackTuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>min</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>max</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>o</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STDARG_PROTOTYPES</name></cpp:ifdef>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>min</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>min</name> &lt;= <name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
		    <argument><expr>"PyArg_UnpackTuple() argument list is not a tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>	
	<expr_stmt><expr><name>l</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>l</name> &lt; <name>min</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>name</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
			    <argument><expr><name>PyExc_TypeError</name></expr></argument>,
			    <argument><expr>"%s expected %s%zd arguments, got %zd"</expr></argument>, 
			    <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>min</name> == <name>max</name> ? "" : "at least ")</expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
			    <argument><expr><name>PyExc_TypeError</name></expr></argument>,
			    <argument><expr>"unpacked tuple should have %s%zd elements,"
			    " but has %zd"</expr></argument>, 
			    <argument><expr>(<name>min</name> == <name>max</name> ? "" : "at least ")</expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>l</name> &gt; <name>max</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>name</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
			    <argument><expr><name>PyExc_TypeError</name></expr></argument>,
			    <argument><expr>"%s expected %s%zd arguments, got %zd"</expr></argument>, 
			    <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>min</name> == <name>max</name> ? "" : "at most ")</expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
			    <argument><expr><name>PyExc_TypeError</name></expr></argument>,
			    <argument><expr>"unpacked tuple should have %s%zd elements,"
			    " but has %zd"</expr></argument>, 
			    <argument><expr>(<name>min</name> == <name>max</name> ? "" : "at most ")</expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>l</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>o</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>PyObject</name> **</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>o</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>


<comment type="block">/* For type constructors that don't take keyword args
 *
 * Sets a TypeError and returns 0 if the kwds dict is 
 * not empty, returns 1 otherwise
 */</comment>
<function><type><name>int</name></type>
<name>_PyArg_NoKeywords</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>funcname</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>kw</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"%s does not take keyword arguments"</expr></argument>, 
			<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
