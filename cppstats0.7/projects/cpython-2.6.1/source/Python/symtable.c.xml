<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/symtable.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"symtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<comment type="block">/* error strings used for warnings */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOBAL_AFTER_ASSIGN</name></cpp:macro> \
<cpp:value>"name '%.400s' is assigned to before global declaration"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOBAL_AFTER_USE</name></cpp:macro> \
<cpp:value>"name '%.400s' is used prior to global declaration"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPORT_STAR_WARNING</name></cpp:macro> <cpp:value>"import * only allowed at module level"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_VAL_IN_GENERATOR</name></cpp:macro> \
    <cpp:value>"'return' with argument inside generator"</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>PySTEntryObject</name> *</type>
<name>ste_new</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>name</name></decl></param>, <param><decl><type><name>_Py_block_ty</name></type> <name>block</name></decl></param>,
	      <param><decl><type><name>void</name> *</type><name>key</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySTEntryObject</name> *</type><name>ste</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>k</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>k</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><name>ste</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>PySTEntryObject</name></expr></argument>, <argument><expr>&amp;<name>PySTEntry_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ste</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_table</name></name> = <name>st</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_id</name></name> = <name>k</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_tmpname</name></name> = 0</expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_name</name></name> = <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_symbols</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_varnames</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_children</name></name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_symbols</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_symbols</name></name> == <name>NULL</name></expr>)</condition><then>
	    <goto>goto <name>fail</name>;</goto></then></if>

	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_varnames</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_varnames</name></name> == <name>NULL</name></expr>)</condition><then>
	    <goto>goto <name>fail</name>;</goto></then></if>

	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_children</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_children</name></name> == <name>NULL</name></expr>)</condition><then>
	    <goto>goto <name>fail</name>;</goto></then></if>

	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_type</name></name> = <name>block</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_unoptimized</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_nested</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_free</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_varargs</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_varkeywords</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_opt_lineno</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_tmpname</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_lineno</name></name> = <name>lineno</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_cur</name></name> != <name>NULL</name> &amp;&amp;
	    (<name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_nested</name></name> ||
	     <name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_type</name></name> == <name>FunctionBlock</name>)</expr>)</condition><then>
		<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_nested</name></name> = 1</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_child_free</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_generator</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_returns_value</name></name> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_symbols</name></name></expr></argument>, <argument><expr><name><name>ste</name>-&gt;<name>ste_id</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>ste</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <goto>goto <name>fail</name>;</goto></then></if>
	
	<return>return <expr><name>ste</name></expr>;</return>
 <label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ste</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ste_repr</name><parameter_list>(<param><decl><type><name>PySTEntryObject</name> *</type><name>ste</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		      <argument><expr>"&lt;symtable entry %.100s(%ld), line %d&gt;"</expr></argument>,
		      <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_id</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ste</name>-&gt;<name>ste_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ste_dealloc</name><parameter_list>(<param><decl><type><name>PySTEntryObject</name> *</type><name>ste</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_table</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_varnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>ste</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(PySTEntryObject, x)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>ste_memberlist</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"id"</expr>,       <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>ste_id</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"name"</expr>,     <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>ste_name</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"symbols"</expr>,  <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>ste_symbols</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"varnames"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>ste_varnames</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"children"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>ste_children</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
        <expr><block>{<expr>"optimized"</expr>,<expr><name>T_INT</name></expr>,    <expr><call><name>OFF</name><argument_list>(<argument><expr><name>ste_unoptimized</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"nested"</expr>,   <expr><name>T_INT</name></expr>,    <expr><call><name>OFF</name><argument_list>(<argument><expr><name>ste_nested</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"type"</expr>,     <expr><name>T_INT</name></expr>,    <expr><call><name>OFF</name><argument_list>(<argument><expr><name>ste_type</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr>"lineno"</expr>,   <expr><name>T_INT</name></expr>,    <expr><call><name>OFF</name><argument_list>(<argument><expr><name>ste_lineno</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PySTEntry_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"symtable entry"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PySTEntryObject</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr>0</expr>,
	<expr>(<name>destructor</name>)<name>ste_dealloc</name></expr>,                <comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_print */</comment>
	<expr>0</expr>,			               <comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,			                <comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>ste_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,			                <comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,	                <comment type="block">/* tp_flags */</comment>
 	<expr>0</expr>,					<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr><name>ste_memberlist</name></expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_analyze</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_warn</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_enter_block</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>name</name></decl></param>, 
				<param><decl><type><name>_Py_block_ty</name></type> <name>block</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ast</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_exit_block</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ast</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_stmt</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_expr</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>s</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_genexp</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>s</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_arguments</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>arguments_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_excepthandler</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>excepthandler_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_alias</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>alias_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_comprehension</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>comprehension_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_keyword</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>keyword_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_slice</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>slice_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_params</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>asdl_seq</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>top</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_visit_params_nested</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>asdl_seq</name> *</type><name>args</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>symtable_implicit_arg</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>int</name></type> <name>pos</name></decl></param>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>static</specifier> <name>identifier</name></type> <name>top</name> <init>= <expr><name>NULL</name></expr></init>, <name>lambda</name> <init>= <expr><name>NULL</name></expr></init>, <name>genexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_IDENTIFIER</name><parameter_list>(<param><type><name>VAR</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>((VAR) ? (VAR) : ((VAR) = PyString_InternFromString(# VAR)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUPLICATE_ARGUMENT</name></cpp:macro> \
<cpp:value>"duplicate argument '%s' in function definition"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> struct <name>symtable</name> *</type>
<name>symtable_new</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>symtable</name> *</type><name>st</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>st</name> = (struct <name>symtable</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>symtable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>st</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_filename</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_symbols</name></name> = <name>NULL</name></expr>;</expr_stmt>

	<if>if <condition>(<expr>(<name><name>st</name>-&gt;<name>st_stack</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<if>if <condition>(<expr>(<name><name>st</name>-&gt;<name>st_symbols</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if> 
	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_tmpname</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_private</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>st</name></expr>;</return>
 <label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>PySymtable_Free</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type>struct <name>symtable</name> *</type>
<name>PySymtable_Build</name><parameter_list>(<param><decl><type><name>mod_ty</name></type> <name>mod</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>PyFutureFeatures</name> *</type><name>future</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>symtable</name> *</type><name>st</name> <init>= <expr><call><name>symtable_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>st</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>st</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_filename</name></name> = <name>filename</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_future</name></name> = <name>future</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>GET_IDENTIFIER</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call> ||
	    !<call><name>symtable_enter_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>ModuleBlock</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>mod</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PySymtable_Free</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_top</name></name> = <name><name>st</name>-&gt;<name>st_cur</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_unoptimized</name></name> = <name>OPT_TOPLEVEL</name></expr>;</expr_stmt>
	<comment type="block">/* Any other top-level initialization? */</comment>
	<switch>switch <condition>(<expr><name><name>mod</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
	<case>case <expr><name>Module_kind</name></expr>:
		<expr_stmt><expr><name>seq</name> = <name><name>mod</name>-&gt;<name>v</name>.<name>Module</name>.<name>body</name></name></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<if>if <condition>(<expr>!<call><name>symtable_visit_stmt</name><argument_list>(<argument><expr><name>st</name></expr></argument>, 
                                    <argument><expr>(<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if></for>
		<break>break;</break>
	</case><case>case <expr><name>Expression_kind</name></expr>:
		<if>if <condition>(<expr>!<call><name>symtable_visit_expr</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>mod</name>-&gt;<name>v</name>.<name>Expression</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<break>break;</break>
	</case><case>case <expr><name>Interactive_kind</name></expr>:
		<expr_stmt><expr><name>seq</name> = <name><name>mod</name>-&gt;<name>v</name>.<name>Interactive</name>.<name>body</name></name></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<if>if <condition>(<expr>!<call><name>symtable_visit_stmt</name><argument_list>(<argument><expr><name>st</name></expr></argument>, 
                                    <argument><expr>(<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if></for>
		<break>break;</break>
	</case><case>case <expr><name>Suite_kind</name></expr>:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"this compiler does not handle Suites"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</case>}</block></switch>
	<if>if <condition>(<expr>!<call><name>symtable_exit_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PySymtable_Free</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>symtable_analyze</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>st</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PySymtable_Free</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
 <label><name>error</name>:</label>
	<expr_stmt><expr>(<name>void</name>) <call><name>symtable_exit_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PySymtable_Free</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PySymtable_Free</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_symbols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr>(<name>void</name> *)<name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PySTEntryObject</name> *</type>
<name>PySymtable_Lookup</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>k</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>k</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_symbols</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySTEntry_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>,
				<argument><expr>"unknown symbol table entry"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PySTEntryObject</name> *)<name>v</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> 
<name>PyST_GetScope</name><parameter_list>(<param><decl><type><name>PySTEntryObject</name> *</type><name>ste</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &gt;&gt; <name>SCOPE_OFF</name>) &amp; <name>SCOPE_MASK</name></expr>;</return>
}</block></function>


<comment type="block">/* Analyze raw symbol information to determine scope of each name.

   The next several functions are helpers for PySymtable_Analyze(),
   which determines whether a name is local, global, or free.  In addition, 
   it determines which local variables are cell variables; they provide
   bindings that are used for free variables in enclosed blocks.  

   There are also two kinds of free variables, implicit and explicit.  An 
   explicit global is declared with the global statement.  An implicit
   global is a free variable for which the compiler has found no binding
   in an enclosing function scope.  The implicit global is either a global
   or a builtin.  Python's module and class blocks use the xxx_NAME opcodes
   to handle these names to implement slightly odd semantics.  In such a
   block, the name is treated as global until it is assigned to; then it
   is treated as a local.

   The symbol table requires two passes to determine the scope of each name.
   The first pass collects raw facts from the AST: the name is a parameter 
   here, the name is used by not defined here, etc.  The second pass analyzes
   these facts during a pass over the PySTEntryObjects created during pass 1.

   When a function is entered during the second pass, the parent passes
   the set of all name bindings visible to its children.  These bindings 
   are used to determine if the variable is free or an implicit global.
   After doing the local analysis, it analyzes each of its child blocks
   using an updated set of name bindings.  

   The children update the free variable set.  If a local variable is free 
   in a child, the variable is marked as a cell.  The current function must 
   provide runtime storage for the variable that may outlive the function's 
   frame.  Cell variables are removed from the free set before the analyze
   function returns to its parent.
   
   The sets of bound and free variables are implemented as dictionaries
   mapping strings to None.
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_SCOPE</name><parameter_list>(<param><type><name>DICT</name></type></param>, <param><type><name>NAME</name></type></param>, <param><type><name>I</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	PyObject *o = PyInt_FromLong(I); \
	if (!o) \
		return 0; \
	if (PyDict_SetItem((DICT), (NAME), o) &lt; 0) { \
		Py_DECREF(o); \
		return 0; \
	} \
	Py_DECREF(o); \
}</cpp:value></cpp:define>

<comment type="block">/* Decide on scope of name, given flags.

   The dicts passed in as arguments are modified as necessary.
   ste is passed so that flags can be updated.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>analyze_name</name><parameter_list>(<param><decl><type><name>PySTEntryObject</name> *</type><name>ste</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>long</name></type> <name>flags</name></decl></param>,
	     <param><decl><type><name>PyObject</name> *</type><name>bound</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>local</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>free</name></decl></param>, 
	     <param><decl><type><name>PyObject</name> *</type><name>global</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>flags</name> &amp; <name>DEF_GLOBAL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>flags</name> &amp; <name>DEF_PARAM</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>,
				     <argument><expr>"name '%s' is local and global"</expr></argument>,
				     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SyntaxLocation</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_table</name>-&gt;<name>st_filename</name></name></expr></argument>,
					     <argument><expr><name><name>ste</name>-&gt;<name>ste_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>SET_SCOPE</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GLOBAL_EXPLICIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>global</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<if>if <condition>(<expr><name>bound</name> &amp;&amp; <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>bound</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>bound</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
		}</block></then></if>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>flags</name> &amp; <name>DEF_BOUND</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>SET_SCOPE</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>global</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>global</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
		}</block></then></if>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<comment type="block">/* If an enclosing block has a binding for this name, it
	   is a free variable rather than a global variable.
	   Note that having a non-NULL bound implies that the block
	   is nested.
	*/</comment>
	<if>if <condition>(<expr><name>bound</name> &amp;&amp; <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>bound</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>SET_SCOPE</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_free</name></name> = 1</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>free</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<return>return <expr>1</expr>;</return>
	}</block></then>
	<comment type="block">/* If a parent has a global statement, then call it global
	   explicit?  It could also be global implicit.
	 */</comment>
	<else>else <if>if <condition>(<expr><name>global</name> &amp;&amp; <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>global</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>SET_SCOPE</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GLOBAL_EXPLICIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_nested</name></name></expr>)</condition><then>
			<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_free</name></name> = 1</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>SET_SCOPE</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GLOBAL_IMPLICIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></else></if></else></if>
	<return>return <expr>0</expr>;</return> <comment type="block">/* Can't get here */</comment>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_SCOPE</name></cpp:undef>

<comment type="block">/* If a name is defined in free and also in locals, then this block
   provides the binding for the free variable.  The name should be
   marked CELL in this block and removed from the free list.

   Note that the current block's free variables are included in free.
   That's safe because no name can be free and local in the same scope.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>analyze_cells</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>scope</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>free</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>w</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>CELL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>w</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>long</name></type> <name>flags</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>flags</name> != <name>LOCAL</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr>!<call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>free</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<comment type="block">/* Replace LOCAL with CELL for this name, and remove
		   from free. It is safe to replace the value of name 
		   in the dict, because it will not cause a resize.
		 */</comment>
		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<if>if <condition>(<expr>!<call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>free</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></while>
	<expr_stmt><expr><name>success</name> = 1</expr>;</expr_stmt>
 <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>success</name></expr>;</return>
}</block></function>

<comment type="block">/* Check for illegal statements in unoptimized namespaces */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_unoptimized</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PySTEntryObject</name>*</type> <name>ste</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>300</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>trailer</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_type</name></name> != <name>FunctionBlock</name> || !<name><name>ste</name>-&gt;<name>ste_unoptimized</name></name>
	    || !(<name><name>ste</name>-&gt;<name>ste_free</name></name> || <name><name>ste</name>-&gt;<name>ste_child_free</name></name>)</expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<expr_stmt><expr><name>trailer</name> = (<name><name>ste</name>-&gt;<name>ste_child_free</name></name> ? 
		       "contains a nested function with free variables" :
			       "is a nested function")</expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>ste</name>-&gt;<name>ste_unoptimized</name></name></expr>)</condition> <block>{
	<case>case <expr><name>OPT_TOPLEVEL</name></expr>: <comment type="block">/* exec / import * at top-level is fine */</comment>
	</case><case>case <expr><name>OPT_EXEC</name></expr>: <comment type="block">/* qualified exec is fine */</comment>
		<return>return <expr>1</expr>;</return>
	</case><case>case <expr><name>OPT_IMPORT_STAR</name></expr>:
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
			      <argument><expr>"import * is not allowed in function '%.100s' "
			      "because it is %s"</expr></argument>,
			      <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trailer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>OPT_BARE_EXEC</name></expr>:
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"unqualified exec is not allowed in function "
			      "'%.100s' it %s"</expr></argument>,
			      <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trailer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><default>default:
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
			      <argument><expr>"function '%.100s' uses import * and bare exec, "
			      "which are illegal because it %s"</expr></argument>,
			      <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trailer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</default>}</block></switch>

	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_SyntaxLocation</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_table</name>-&gt;<name>st_filename</name></name></expr></argument>, 
			     <argument><expr><name><name>ste</name>-&gt;<name>ste_opt_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Enter the final scope information into the st_symbols dict. 
 * 
 * All arguments are dicts.  Modifies symbols, others are read-only.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>update_symbols</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>symbols</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>scope</name></decl></param>, 
               <param><decl><type><name>PyObject</name> *</type><name>bound</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>free</name></decl></param>, <param><decl><type><name>int</name></type> <name>classflag</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>u</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>, *<decl><type ref="prev"/><name>free_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>symbols</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>w</name> &amp;&amp; <call><name>PyInt_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> |= (<name>i</name> &lt;&lt; <name>SCOPE_OFF</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>u</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>symbols</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

        <expr_stmt><expr><name>free_value</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>FREE</name> &lt;&lt; <name>SCOPE_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>free_value</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

        <comment type="block">/* add a free variable when it's only use is for creating a closure */</comment>
        <expr_stmt><expr><name>pos</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>free</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>symbols</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>o</name></expr>)</condition><then> <block>{
			<comment type="block">/* It could be a free variable in a method of
			   the class that has the same name as a local
			   or global in the class scope.
			*/</comment>
			<if>if  <condition>(<expr><name>classflag</name> &amp;&amp; 
			     <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> &amp; (<name>DEF_BOUND</name> | <name>DEF_GLOBAL</name>)</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> | <name>DEF_FREE_CLASS</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>o</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!<name>o</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>free_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>0</expr>;</return>
				}</block></then></if>
				<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>symbols</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>free_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>0</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<comment type="block">/* else it's not free, probably a cell */</comment>
			<continue>continue;</continue>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>bound</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if>       <comment type="block">/* it's a global */</comment>

		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>symbols</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>free_value</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>free_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
        }</block></while>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>free_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>   

<comment type="block">/* Make final symbol table decisions for block of ste.
   Arguments:
   ste -- current symtable entry (input/output)
   bound -- set of variables bound in enclosing scopes (input)
   free -- set of free variables in enclosed scopes (output)
   globals -- set of declared global variables in enclosing scopes (input)
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>analyze_block</name><parameter_list>(<param><decl><type><name>PySTEntryObject</name> *</type><name>ste</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>bound</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>free</name></decl></param>, 
	      <param><decl><type><name>PyObject</name> *</type><name>global</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>local</name> <init>= <expr><name>NULL</name></expr></init>, *<name>scope</name> <init>= <expr><name>NULL</name></expr></init>, *<name>newbound</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newglobal</name> <init>= <expr><name>NULL</name></expr></init>, *<name>newfree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>success</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>local</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>local</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>scope</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>scope</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>newglobal</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>newglobal</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>newfree</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>newfree</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>newbound</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>newbound</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_type</name></name> == <name>ClassBlock</name></expr>)</condition><then> <block>{
		<comment type="block">/* make a copy of globals before calling analyze_name(),
		   because global statements in the class have no effect
		   on nested functions.
		*/</comment>
		<if>if <condition>(<expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>newglobal</name></expr></argument>, <argument><expr><name>global</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<if>if <condition>(<expr><name>bound</name></expr>)</condition><then>
			<if>if <condition>(<expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>newbound</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if></then></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PySTEntry_Check</name><argument_list>(<argument><expr><name>ste</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>long</name></type> <name>flags</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>analyze_name</name><argument_list>(<argument><expr><name>ste</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>, <argument><expr><name>local</name></expr></argument>, <argument><expr><name>free</name></expr></argument>,
				  <argument><expr><name>global</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></while>

	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_type</name></name> != <name>ClassBlock</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_type</name></name> == <name>FunctionBlock</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>newbound</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
		}</block></then></if>
		<if>if <condition>(<expr><name>bound</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>newbound</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>newglobal</name></expr></argument>, <argument><expr><name>global</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></then></if>

	<comment type="block">/* Recursively call analyze_block() on each child block */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_children</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_children</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PySTEntryObject</name>*</type> <name>entry</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> &amp;&amp; <call><name>PySTEntry_Check</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>entry</name> = (<name>PySTEntryObject</name>*)<name>c</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>analyze_block</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>newbound</name></expr></argument>, <argument><expr><name>newfree</name></expr></argument>, <argument><expr><name>newglobal</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>ste_free</name></name> || <name><name>entry</name>-&gt;<name>ste_child_free</name></name></expr>)</condition><then>
			<expr_stmt><expr><name><name>ste</name>-&gt;<name>ste_child_free</name></name> = 1</expr>;</expr_stmt></then></if>
	}</block></for>

	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_type</name></name> == <name>FunctionBlock</name> &amp;&amp; !<call><name>analyze_cells</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>newfree</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<if>if <condition>(<expr>!<call><name>update_symbols</name><argument_list>(<argument><expr><name><name>ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>, <argument><expr><name>newfree</name></expr></argument>,
			    <argument><expr><name><name>ste</name>-&gt;<name>ste_type</name></name> == <name>ClassBlock</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<if>if <condition>(<expr>!<call><name>check_unoptimized</name><argument_list>(<argument><expr><name>ste</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<if>if <condition>(<expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>free</name></expr></argument>, <argument><expr><name>newfree</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>success</name> = 1</expr>;</expr_stmt>
 <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>newbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>newglobal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>newfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>success</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>success</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>symtable_analyze</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>free</name></decl>, *<decl><type ref="prev"/><name>global</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>free</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>free</name></expr>)</condition><then>
	    <return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>global</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>global</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>r</name> = <call><name>analyze_block</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_top</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>free</name></expr></argument>, <argument><expr><name>global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>symtable_warn</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyErr_WarnExplicit</name><argument_list>(<argument><expr><name>PyExc_SyntaxWarning</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>st_filename</name></name></expr></argument>,
			       <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>	<block>{
		<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_SyntaxWarning</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SyntaxLocation</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_filename</name></name></expr></argument>, 
					     <argument><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* symtable_enter_block() gets a reference via ste_new.
   This reference is released when the block is exited, via the DECREF
   in symtable_exit_block().
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>symtable_exit_block</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ast</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_stack</name></name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>end</name> &gt;= 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name></name> = (<name>PySTEntryObject</name> *)<call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_stack</name></name></expr></argument>, 
								<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_cur</name></name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PySequence_DelItem</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_stack</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>symtable_enter_block</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>name</name></decl></param>, <param><decl><type><name>_Py_block_ty</name></type> <name>block</name></decl></param>, 
		     <param><decl><type><name>void</name> *</type><name>ast</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySTEntryObject</name> *</type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_cur</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>prev</name> = <name><name>st</name>-&gt;<name>st_cur</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_stack</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name><name>st</name>-&gt;<name>st_cur</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name></name> = <call><name>ste_new</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>ast</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_cur</name></name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name>name</name> == <call><name>GET_IDENTIFIER</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>st</name>-&gt;<name>st_global</name></name> = <name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_symbols</name></name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>prev</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>prev</name>-&gt;<name>ste_children</name></name></expr></argument>, 
				  <argument><expr>(<name>PyObject</name> *)<name><name>st</name>-&gt;<name>st_cur</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>symtable_lookup</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mangled</name> <init>= <expr><call><name>_Py_Mangle</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_private</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>mangled</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>o</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_symbols</name></name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>o</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>symtable_add_def</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>int</name></type> <name>flag</name></decl></param>)</parameter_list> 
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mangled</name> <init>= <expr><call><name>_Py_Mangle</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_private</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>mangled</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>dict</name> = <name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_symbols</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>o</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>val</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>flag</name> &amp; <name>DEF_PARAM</name>) &amp;&amp; (<name>val</name> &amp; <name>DEF_PARAM</name>)</expr>)</condition><then> <block>{
		    <comment type="block">/* Is it better to use 'mangled' or 'name' here? */</comment>
		    <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>, <argument><expr><name>DUPLICATE_ARGUMENT</name></expr></argument>,
				 <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>PyErr_SyntaxLocation</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_filename</name></name></expr></argument>,
				       <argument><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <goto>goto <name>error</name>;</goto>
	    }</block></then></if>
	    <expr_stmt><expr><name>val</name> |= <name>flag</name></expr>;</expr_stmt>
	}</block></then> <else>else
	    <expr_stmt><expr><name>val</name> = <name>flag</name></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>o</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
	    <goto>goto <name>error</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>flag</name> &amp; <name>DEF_PARAM</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_varnames</name></name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></then> <else>else	<if>if <condition>(<expr><name>flag</name> &amp; <name>DEF_GLOBAL</name></expr>)</condition><then> <block>{
		<comment type="block">/* XXX need to update DEF_GLOBAL for other flags too;
		   perhaps only DEF_FREE_GLOBAL */</comment>
		<expr_stmt><expr><name>val</name> = <name>flag</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>o</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_global</name></name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>val</name> |= <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>o</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_global</name></name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* VISIT, VISIT_SEQ and VIST_SEQ_TAIL take an ASDL type as their second argument.
   They use the ASDL name to synthesize the name of the C type and the visit
   function. 
   
   VISIT_SEQ_TAIL permits the start of an ASDL sequence to be skipped, which is
   useful if the first node in the sequence requires special treatment.
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT</name><parameter_list>(<param><type><name>ST</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>V</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>if (!symtable_visit_ ## TYPE((ST), (V))) \
		return 0;</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_IN_BLOCK</name><parameter_list>(<param><type><name>ST</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>V</name></type></param>, <param><type><name>S</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>if (!symtable_visit_ ## TYPE((ST), (V))) { \
		symtable_exit_block((ST), (S)); \
		return 0; \
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SEQ</name><parameter_list>(<param><type><name>ST</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>SEQ</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	int i; \
	asdl_seq *seq = (SEQ); <comment type="block">/* avoid variable capture */</comment> \
	for (i = 0; i &lt; asdl_seq_LEN(seq); i++) { \
		TYPE ## _ty elt = (TYPE ## _ty)asdl_seq_GET(seq, i); \
		if (!symtable_visit_ ## TYPE((ST), elt)) \
			return 0; \
	} \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SEQ_IN_BLOCK</name><parameter_list>(<param><type><name>ST</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>SEQ</name></type></param>, <param><type><name>S</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	int i; \
	asdl_seq *seq = (SEQ); <comment type="block">/* avoid variable capture */</comment> \
	for (i = 0; i &lt; asdl_seq_LEN(seq); i++) { \
		TYPE ## _ty elt = (TYPE ## _ty)asdl_seq_GET(seq, i); \
		if (!symtable_visit_ ## TYPE((ST), elt)) { \
			symtable_exit_block((ST), (S)); \
			return 0; \
		} \
	} \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SEQ_TAIL</name><parameter_list>(<param><type><name>ST</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>SEQ</name></type></param>, <param><type><name>START</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	int i; \
	asdl_seq *seq = (SEQ); <comment type="block">/* avoid variable capture */</comment> \
	for (i = (START); i &lt; asdl_seq_LEN(seq); i++) { \
		TYPE ## _ty elt = (TYPE ## _ty)asdl_seq_GET(seq, i); \
		if (!symtable_visit_ ## TYPE((ST), elt)) \
			return 0; \
	} \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SEQ_TAIL_IN_BLOCK</name><parameter_list>(<param><type><name>ST</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>SEQ</name></type></param>, <param><type><name>START</name></type></param>, <param><type><name>S</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	int i; \
	asdl_seq *seq = (SEQ); <comment type="block">/* avoid variable capture */</comment> \
	for (i = (START); i &lt; asdl_seq_LEN(seq); i++) { \
		TYPE ## _ty elt = (TYPE ## _ty)asdl_seq_GET(seq, i); \
		if (!symtable_visit_ ## TYPE((ST), elt)) { \
			symtable_exit_block((ST), (S)); \
			return 0; \
		} \
	} \
}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>symtable_new_tmpname</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>tmpname</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>identifier</name></type> <name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"_[%d]"</expr></argument>,
		      <argument><expr>++<name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_tmpname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>DEF_LOCAL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>symtable_visit_stmt</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
        <case>case <expr><name>FunctionDef_kind</name></expr>:
		<if>if <condition>(<expr>!<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>name</name></name></expr></argument>, <argument><expr><name>DEF_LOCAL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>args</name>-&gt;<name>defaults</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>decorator_list</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>decorator_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>!<call><name>symtable_enter_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>name</name></name></expr></argument>, 
					  <argument><expr><name>FunctionBlock</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>VISIT_IN_BLOCK</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>args</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ_IN_BLOCK</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>body</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>symtable_exit_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<break>break;</break>
        </case><case>case <expr><name>ClassDef_kind</name></expr>: <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr></argument>, <argument><expr><name>DEF_LOCAL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>decorator_list</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>decorator_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>!<call><name>symtable_enter_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr></argument>, <argument><expr><name>ClassBlock</name></expr></argument>, 
					  <argument><expr>(<name>void</name> *)<name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name>tmp</name> = <name><name>st</name>-&gt;<name>st_private</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>st</name>-&gt;<name>st_private</name></name> = <name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ_IN_BLOCK</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>body</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>st</name>-&gt;<name>st_private</name></name> = <name>tmp</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>symtable_exit_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<break>break;</break>
	}</block>
        </case><case>case <expr><name>Return_kind</name></expr>:
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Return</name>.<name>value</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Return</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_returns_value</name></name> = 1</expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_generator</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>,
					<argument><expr><name>RETURN_VAL_IN_GENERATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			        <expr_stmt><expr><call><name>PyErr_SyntaxLocation</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_filename</name></name></expr></argument>,
				             <argument><expr><name><name>s</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
		}</block></then></if>
		<break>break;</break>
        </case><case>case <expr><name>Delete_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Delete</name>.<name>targets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Assign_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assign</name>.<name>targets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>AugAssign_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Print_kind</name></expr>:
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>dest</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>For_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>orelse</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<break>break;</break>
        </case><case>case <expr><name>While_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<break>break;</break>
        </case><case>case <expr><name>If_kind</name></expr>:
		<comment type="block">/* XXX if 0: and lookup_yield() hacks */</comment>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<break>break;</break>
        </case><case>case <expr><name>Raise_kind</name></expr>:
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>type</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>inst</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>inst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>tback</name></name></expr>)</condition><then>
					<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>tback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then></if>
		<break>break;</break>
        </case><case>case <expr><name>TryExcept_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>excepthandler</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>handlers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>TryFinally_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryFinally</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryFinally</name>.<name>finalbody</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Assert_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>msg</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<break>break;</break>
        </case><case>case <expr><name>Import_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Import</name>.<name>names</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* XXX Don't have the lineno available inside
		   visit_alias */</comment>
		<if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_unoptimized</name></name> &amp;&amp; !<name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_opt_lineno</name></name></expr>)</condition><then>
			<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_opt_lineno</name></name> = <name><name>s</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt></then></if>
		<break>break;</break>
        </case><case>case <expr><name>ImportFrom_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>names</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* XXX Don't have the lineno available inside
		   visit_alias */</comment>
		<if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_unoptimized</name></name> &amp;&amp; !<name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_opt_lineno</name></name></expr>)</condition><then>
			<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_opt_lineno</name></name> = <name><name>s</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt></then></if>
		<break>break;</break>
        </case><case>case <expr><name>Exec_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_opt_lineno</name></name></expr>)</condition><then>
			<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_opt_lineno</name></name> = <name><name>s</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>globals</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_unoptimized</name></name> |= <name>OPT_EXEC</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>locals</name></name></expr>)</condition><then> 
				<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>locals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_unoptimized</name></name> |= <name>OPT_BARE_EXEC</name></expr>;</expr_stmt>
		}</block></else></if>
		<break>break;</break>
        </case><case>case <expr><name>Global_kind</name></expr>: <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>seq</name> <init>= <expr><name><name>s</name>-&gt;<name>v</name>.<name>Global</name>.<name>names</name></name></expr></init></decl>;</decl_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>identifier</name></type> <name>name</name> <init>= <expr>(<name>identifier</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>c_name</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name></type> <name>cur</name> <init>= <expr><call><name>symtable_lookup</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>cur</name> &lt; 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
			<if>if <condition>(<expr><name>cur</name> &amp; (<name>DEF_LOCAL</name> | <name>USE</name>)</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>cur</name> &amp; <name>DEF_LOCAL</name></expr>)</condition><then> 
					<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						      <argument><expr><name>GLOBAL_AFTER_ASSIGN</name></expr></argument>,
						      <argument><expr><name>c_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						      <argument><expr><name>GLOBAL_AFTER_USE</name></expr></argument>,
						      <argument><expr><name>c_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
				<if>if <condition>(<expr>!<call><name>symtable_warn</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                                    <return>return <expr>0</expr>;</return></then></if>
			}</block></then></if>
			<if>if <condition>(<expr>!<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>DEF_GLOBAL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
		}</block></for>
		<break>break;</break>
	}</block>
        </case><case>case <expr><name>Expr_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Pass_kind</name></expr>:
        </case><case>case <expr><name>Break_kind</name></expr>:
        </case><case>case <expr><name>Continue_kind</name></expr>:
		<comment type="block">/* nothing to do here */</comment>
		<break>break;</break>
        </case><case>case <expr><name>With_kind</name></expr>:
		<if>if <condition>(<expr>!<call><name>symtable_new_tmpname</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
                <expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>context_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>symtable_new_tmpname</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
                        <expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
	</case>}</block></switch>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>symtable_visit_expr</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
        <case>case <expr><name>BoolOp_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>BoolOp</name>.<name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>BinOp_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>BinOp</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>BinOp</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>UnaryOp_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>UnaryOp</name>.<name>operand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Lambda_kind</name></expr>: <block>{
		<if>if <condition>(<expr>!<call><name>GET_IDENTIFIER</name><argument_list>(<argument><expr><name>lambda</name></expr></argument>)</argument_list></call> ||
		    !<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>lambda</name></expr></argument>, <argument><expr><name>DEF_LOCAL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Lambda</name>.<name>args</name>-&gt;<name>defaults</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Lambda</name>.<name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<comment type="block">/* XXX how to get line numbers for expressions */</comment>
		<if>if <condition>(<expr>!<call><name>symtable_enter_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>lambda</name></expr></argument>,
                                          <argument><expr><name>FunctionBlock</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>e</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>VISIT_IN_BLOCK</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Lambda</name>.<name>args</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_IN_BLOCK</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Lambda</name>.<name>body</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>symtable_exit_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<break>break;</break>
	}</block>
	</case><case>case <expr><name>IfExp_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>IfExp</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>IfExp</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>IfExp</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Dict_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Dict</name>.<name>keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Dict</name>.<name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>ListComp_kind</name></expr>:
		<if>if <condition>(<expr>!<call><name>symtable_new_tmpname</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>ListComp</name>.<name>elt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>comprehension</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>ListComp</name>.<name>generators</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>GeneratorExp_kind</name></expr>:
		<if>if <condition>(<expr>!<call><name>symtable_visit_genexp</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<break>break;</break>
        </case><case>case <expr><name>Yield_kind</name></expr>:
		<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Yield</name>.<name>value</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Yield</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_generator</name></name> = 1</expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_returns_value</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>,
				<argument><expr><name>RETURN_VAL_IN_GENERATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		        <expr_stmt><expr><call><name>PyErr_SyntaxLocation</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_filename</name></name></expr></argument>,
			             <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<break>break;</break>
        </case><case>case <expr><name>Compare_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>comparators</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Call_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>keywords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>starargs</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>starargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>kwargs</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>kwargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<break>break;</break>
        </case><case>case <expr><name>Repr_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Repr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Num_kind</name></expr>:
        </case><case>case <expr><name>Str_kind</name></expr>:
		<comment type="block">/* Nothing to do here. */</comment>
		<break>break;</break>
	<comment type="block">/* The following exprs can be assignment targets. */</comment>
        </case><case>case <expr><name>Attribute_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Subscript_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Name_kind</name></expr>:
		<if>if <condition>(<expr>!<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>, 
				      <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>ctx</name></name> == <name>Load</name> ? <name>USE</name> : <name>DEF_LOCAL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<break>break;</break>
	<comment type="block">/* child nodes of List and Tuple will have expr_context set */</comment>
        </case><case>case <expr><name>List_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
        </case><case>case <expr><name>Tuple_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case>}</block></switch>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>symtable_implicit_arg</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>int</name></type> <name>pos</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>id</name> <init>= <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>".%d"</expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>id</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>DEF_PARAM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>symtable_visit_params</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>asdl_seq</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>toplevel</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	
        <comment type="block">/* go through all the toplevel arguments first */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>expr_ty</name></type> <name>arg</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>arg</name>-&gt;<name>kind</name></name> == <name>Name_kind</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>arg</name>-&gt;<name>v</name>.<name>Name</name>.<name>ctx</name></name> == <name>Param</name> ||
                               (<name><name>arg</name>-&gt;<name>v</name>.<name>Name</name>.<name>ctx</name></name> == <name>Store</name> &amp;&amp; !<name>toplevel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>arg</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>, <argument><expr><name>DEF_PARAM</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>arg</name>-&gt;<name>kind</name></name> == <name>Tuple_kind</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>arg</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>ctx</name></name> == <name>Store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>toplevel</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>!<call><name>symtable_implicit_arg</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<return>return <expr>0</expr>;</return></then></if>
			}</block></then></if>
		}</block></then>
		<else>else <block>{
		        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>,
					<argument><expr>"invalid expression in parameter list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		        <expr_stmt><expr><call><name>PyErr_SyntaxLocation</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_filename</name></name></expr></argument>,
				             <argument><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></else></if></else></if>
	}</block></for>

	<if>if <condition>(<expr>!<name>toplevel</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>symtable_visit_params_nested</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>

	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>symtable_visit_params_nested</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>asdl_seq</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>expr_ty</name></type> <name>arg</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>arg</name>-&gt;<name>kind</name></name> == <name>Tuple_kind</name> &amp;&amp;
		    !<call><name>symtable_visit_params</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>arg</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></for>
	
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>symtable_visit_arguments</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>arguments_ty</name></type> <name>a</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* skip default arguments inside function block
	   XXX should ast be different?
	*/</comment>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>args</name></name> &amp;&amp; !<call><name>symtable_visit_params</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>vararg</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>vararg</name></name></expr></argument>, <argument><expr><name>DEF_PARAM</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_varargs</name></name> = 1</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>kwarg</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>kwarg</name></name></expr></argument>, <argument><expr><name>DEF_PARAM</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_varkeywords</name></name> = 1</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>args</name></name> &amp;&amp; !<call><name>symtable_visit_params_nested</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> 
<name>symtable_visit_excepthandler</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>excepthandler_ty</name></type> <name>eh</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>eh</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>eh</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>eh</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>name</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>eh</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>eh</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> 
<name>symtable_visit_alias</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>alias_ty</name></type> <name>a</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Compute store_name, the name actually bound by the import
	   operation.  It is diferent than a-&gt;name when a-&gt;name is a
	   dotted package name (e.g. spam.eggs) 
	*/</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>store_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr>(<name><name>a</name>-&gt;<name>asname</name></name> == <name>NULL</name>) ? <name><name>a</name>-&gt;<name>name</name></name> : <name><name>a</name>-&gt;<name>asname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>dot</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>store_name</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>dot</name> - <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>store_name</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>store_name</name> = <name>name</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>store_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>symtable_add_def</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>store_name</name></expr></argument>, <argument><expr><name>DEF_IMPORT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>store_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>r</name></expr>;</return>
	}</block></then>
	<else>else <block>{
            <if>if <condition>(<expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_type</name></name> != <name>ModuleBlock</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_lineno</name></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name>symtable_warn</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>IMPORT_STAR_WARNING</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>store_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr>0</expr>;</return>
		}</block></then></if>
            }</block></then></if>
	    <expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_unoptimized</name></name> |= <name>OPT_IMPORT_STAR</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>store_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>1</expr>;</return>
	}</block></else></if>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> 
<name>symtable_visit_comprehension</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>comprehension_ty</name></type> <name>lc</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>lc</name>-&gt;<name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>lc</name>-&gt;<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>lc</name>-&gt;<name>ifs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> 
<name>symtable_visit_keyword</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>keyword_ty</name></type> <name>k</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>k</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> 
<name>symtable_visit_slice</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>slice_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
	<case>case <expr><name>Slice_kind</name></expr>:
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>lower</name></name></expr>)</condition><then>
			<macro><name>VISIT</name><argument_list>(<argument>st</argument>, <argument>expr</argument>, <argument>s-&gt;v.Slice.lower</argument>)</argument_list></macro>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>upper</name></name></expr>)</condition><then>
			<macro><name>VISIT</name><argument_list>(<argument>st</argument>, <argument>expr</argument>, <argument>s-&gt;v.Slice.upper</argument>)</argument_list></macro>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>step</name></name></expr>)</condition><then>
			<macro><name>VISIT</name><argument_list>(<argument>st</argument>, <argument>expr</argument>, <argument>s-&gt;v.Slice.step</argument>)</argument_list></macro>
		<break>break;</break></then></if></then></if></then></if>
	</case><case>case <expr><name>ExtSlice_kind</name></expr>:
		<macro><name>VISIT_SEQ</name><argument_list>(<argument>st</argument>, <argument>slice</argument>, <argument>s-&gt;v.ExtSlice.dims</argument>)</argument_list></macro>
		<break>break;</break>
	</case><case>case <expr><name>Index_kind</name></expr>:
		<macro><name>VISIT</name><argument_list>(<argument>st</argument>, <argument>expr</argument>, <argument>s-&gt;v.Index.value</argument>)</argument_list></macro>
		<break>break;</break>
	</case><case>case <expr><name>Ellipsis_kind</name></expr>:
		<break>break;</break>
	</case>}</block></switch>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>symtable_visit_genexp</name><parameter_list>(<param><decl><type>struct <name>symtable</name> *</type><name>st</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>comprehension_ty</name></type> <name>outermost</name> <init>= <expr>(<call>(<name>comprehension_ty</name>)
			 <argument_list>(<argument><expr><call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>GeneratorExp</name>.<name>generators</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
	<comment type="block">/* Outermost iterator is evaluated in current scope */</comment>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>outermost</name>-&gt;<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Create generator scope for the rest */</comment>
	<if>if <condition>(<expr>!<call><name>GET_IDENTIFIER</name><argument_list>(<argument><expr><name>genexpr</name></expr></argument>)</argument_list></call> ||
	    !<call><name>symtable_enter_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>genexpr</name></expr></argument>, <argument><expr><name>FunctionBlock</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>e</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>st</name>-&gt;<name>st_cur</name>-&gt;<name>ste_generator</name></name> = 1</expr>;</expr_stmt>
	<comment type="block">/* Outermost iter is received as an argument */</comment>
	<if>if <condition>(<expr>!<call><name>symtable_implicit_arg</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>symtable_exit_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>VISIT_IN_BLOCK</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>outermost</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT_SEQ_IN_BLOCK</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>outermost</name>-&gt;<name>ifs</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT_SEQ_TAIL_IN_BLOCK</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>comprehension</name></expr></argument>,
				<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>GeneratorExp</name>.<name>generators</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>(<name>void</name>*)<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT_IN_BLOCK</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>GeneratorExp</name>.<name>elt</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>symtable_exit_block</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>e</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
