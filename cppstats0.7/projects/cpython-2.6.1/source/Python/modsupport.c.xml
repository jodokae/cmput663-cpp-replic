<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/modsupport.c">
<comment type="block">/* Module support implementation */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAG_SIZE_T</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<typedef>typedef <type><name>double</name></type> <name>va_double</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>va_build_value</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>va_list</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Package context -- the full module name for package imports */</comment>
<decl_stmt><decl><type><name>char</name> *</type><name>_Py_PackageContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Py_InitModule4() parameters:
   - name is the module name
   - methods is the list of top-level functions
   - doc is the documentation string
   - passthrough is passed as self to functions defined in the module
   - api_version is the value of PYTHON_API_VERSION at the time the
     module was compiled

   Return value is a borrowed reference to the module object; or NULL
   if an error occurred (in Python 1.4 and before, errors were fatal).
   Errors may still leak memory.
*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>api_version_warning</name><index>[]</index></name> <init>=
<expr>"Python C API version mismatch for module %.100s:\
 This Python has API version %d, module %.100s has version %d."</expr></init></decl>;</decl_stmt>

<function><type><name>PyObject</name> *</type>
<name>Py_InitModule4</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyMethodDef</name> *</type><name>methods</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>doc</name></decl></param>,
	       <param><decl><type><name>PyObject</name> *</type><name>passthrough</name></decl></param>, <param><decl><type><name>int</name></type> <name>module_api_version</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyMethodDef</name> *</type><name>ml</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>Py_IsInitialized</name><argument_list>()</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Interpreter not initialized (version mismatch?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>module_api_version</name> != <name>PYTHON_API_VERSION</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name></type> <name><name>message</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
			      <argument><expr><name>api_version_warning</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, 
			      <argument><expr><name>PYTHON_API_VERSION</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, 
			      <argument><expr><name>module_api_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<comment type="block">/* Make sure name is fully qualified.

	   This is a bit of a hack: when the shared library is loaded,
	   the module name is "package.module", but the module calls
	   Py_InitModule*() with just "module" for the name.  The shared
	   library loader squirrels away the true name of the module in
	   _Py_PackageContext, and Py_InitModule*() will substitute this
	   (if the name actually matches).
	*/</comment>
	<if>if <condition>(<expr><name>_Py_PackageContext</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>_Py_PackageContext</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>p</name> != <name>NULL</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>p</name>+1</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>name</name> = <name>_Py_PackageContext</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>_Py_PackageContext</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>methods</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>n</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<for>for (<init><expr><name>ml</name> = <name>methods</name></expr>;</init> <condition><expr><name><name>ml</name>-&gt;<name>ml_name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>ml</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr>(<name><name>ml</name>-&gt;<name>ml_flags</name></name> &amp; <name>METH_CLASS</name>) ||
			    (<name><name>ml</name>-&gt;<name>ml_flags</name></name> &amp; <name>METH_STATIC</name>)</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"module functions cannot set"
						" METH_CLASS or METH_STATIC"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>v</name> = <call><name>PyCFunction_NewEx</name><argument_list>(<argument><expr><name>ml</name></expr></argument>, <argument><expr><name>passthrough</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>ml</name>-&gt;<name>ml_name</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>doc</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__doc__"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>m</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper for mkvalue() to scan the length of a format */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>countformat</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>int</name></type> <name>endchar</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>level</name> &gt; 0 || *<name>format</name> != <name>endchar</name></expr>)</condition> <block>{
		<switch>switch <condition>(<expr>*<name>format</name></expr>)</condition> <block>{
		<case>case <expr>'\0'</expr>:
			<comment type="block">/* Premature end */</comment>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"unmatched paren in format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr>'('</expr>:
		</case><case>case <expr>'['</expr>:
		</case><case>case <expr>'{'</expr>:
			<if>if <condition>(<expr><name>level</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>level</name>++</expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>')'</expr>:
		</case><case>case <expr>']'</expr>:
		</case><case>case <expr>'}'</expr>:
			<expr_stmt><expr><name>level</name>--</expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>'#'</expr>:
		</case><case>case <expr>'&amp;'</expr>:
		</case><case>case <expr>','</expr>:
		</case><case>case <expr>':'</expr>:
		</case><case>case <expr>' '</expr>:
		</case><case>case <expr>'\t'</expr>:
			<break>break;</break>
		</case><default>default:
			<if>if <condition>(<expr><name>level</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then></if>
		</default>}</block></switch>
		<expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>count</name></expr>;</return>
}</block></function>


<comment type="block">/* Generic function to create a value -- the inverse of getargs() */</comment>
<comment type="block">/* After an original idea and first implementation by Steven Miale */</comment>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>do_mktuple</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name>**</decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>do_mklist</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name>**</decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>do_mkdict</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name>**</decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>do_mkvalue</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name>**</decl></param>, <param><decl><type><name>va_list</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_mkdict</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>p_format</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>endchar</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>itemfailed</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>(<name>d</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* Note that we can't bail immediately on error as this will leak
	   refcounts on any 'N' arguments. */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>+= 2</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>k</name> = <call><name>do_mkvalue</name><argument_list>(<argument><expr><name>p_format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>k</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>itemfailed</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>k</name> = <name>Py_None</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>v</name> = <call><name>do_mkvalue</name><argument_list>(<argument><expr><name>p_format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>itemfailed</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <name>Py_None</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>err</name> &lt; 0 || <name>itemfailed</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>d</name> != <name>NULL</name> &amp;&amp; **<name>p_format</name> != <name>endchar</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"Unmatched paren in format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>endchar</name></expr>)</condition><then>
		<expr_stmt><expr>++*<name>p_format</name></expr>;</expr_stmt></then></if></else></if>
	<return>return <expr><name>d</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_mklist</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>p_format</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>endchar</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>itemfailed</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* Note that we can't bail immediately on error as this will leak
	   refcounts on any 'N' arguments. */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>do_mkvalue</name><argument_list>(<argument><expr><name>p_format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>itemfailed</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> = <name>Py_None</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<if>if <condition>(<expr><name>itemfailed</name></expr>)</condition><then> <block>{
		<comment type="block">/* do_mkvalue() should have already set an error */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>**<name>p_format</name> != <name>endchar</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"Unmatched paren in format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>endchar</name></expr>)</condition><then>
		<expr_stmt><expr>++*<name>p_format</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_ustrlen</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>u</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>v</name> <init>= <expr><name>u</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr>*<name>v</name> != 0</expr>)</condition> <block>{ <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt> <expr_stmt><expr><name>v</name>++</expr>;</expr_stmt> }</block></while> 
	<return>return <expr><name>i</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_mktuple</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>p_format</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>endchar</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>itemfailed</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>(<name>v</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* Note that we can't bail immediately on error as this will leak
	   refcounts on any 'N' arguments. */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>do_mkvalue</name><argument_list>(<argument><expr><name>p_format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>itemfailed</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> = <name>Py_None</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr><name>itemfailed</name></expr>)</condition><then> <block>{
		<comment type="block">/* do_mkvalue() should have already set an error */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>**<name>p_format</name> != <name>endchar</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"Unmatched paren in format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>endchar</name></expr>)</condition><then>
		<expr_stmt><expr>++*<name>p_format</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_mkvalue</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>p_format</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>p_va</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<switch>switch <condition>(<expr>*(*<name>p_format</name>)++</expr>)</condition> <block>{
		<case>case <expr>'('</expr>:
			<return>return <expr><call><name>do_mktuple</name><argument_list>(<argument><expr><name>p_format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr>')'</expr></argument>,
					  <argument><expr><call><name>countformat</name><argument_list>(<argument><expr>*<name>p_format</name></expr></argument>, <argument><expr>')'</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

		</case><case>case <expr>'['</expr>:
			<return>return <expr><call><name>do_mklist</name><argument_list>(<argument><expr><name>p_format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr>']'</expr></argument>,
					 <argument><expr><call><name>countformat</name><argument_list>(<argument><expr>*<name>p_format</name></expr></argument>, <argument><expr>']'</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

		</case><case>case <expr>'{'</expr>:
			<return>return <expr><call><name>do_mkdict</name><argument_list>(<argument><expr><name>p_format</name></expr></argument>, <argument><expr><name>p_va</name></expr></argument>, <argument><expr>'}'</expr></argument>,
					 <argument><expr><call><name>countformat</name><argument_list>(<argument><expr>*<name>p_format</name></expr></argument>, <argument><expr>'}'</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

		</case><case>case <expr>'b'</expr>:
		</case><case>case <expr>'B'</expr>:
		</case><case>case <expr>'h'</expr>:
		</case><case>case <expr>'i'</expr>:
			<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			
		</case><case>case <expr>'H'</expr>:
			<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<macro><name>va_arg</name><argument_list>(<argument>*p_va</argument>, <argument>unsigned int</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</return>

		</case><case>case <expr>'I'</expr>:
		<block>{
			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>n</name> = <macro><name>va_arg</name><argument_list>(<argument>*p_va</argument>, <argument>unsigned int</argument>)</argument_list></macro></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>n</name> &gt; (<name>unsigned</name> <name>long</name>)<call><name>PyInt_GetMax</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</return></then>
			<else>else
				<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
		}</block>
		
		</case><case>case <expr>'n'</expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name>!=<name>SIZEOF_LONG</name></expr></cpp:if>
			<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* Fall through from 'n' to 'l' if Py_ssize_t is long */</comment>
		</case><case>case <expr>'l'</expr>:
			<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

		</case><case>case <expr>'k'</expr>:
		<block>{
			<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>n</name> = <macro><name>va_arg</name><argument_list>(<argument>*p_va</argument>, <argument>unsigned long</argument>)</argument_list></macro></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>n</name> &gt; (<name>unsigned</name> <name>long</name>)<call><name>PyInt_GetMax</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then>
			<else>else
				<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
		}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
		</case><case>case <expr>'L'</expr>:
			<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PY_LONG_LONG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

		</case><case>case <expr>'K'</expr>:
			<return>return <expr><call><name>PyLong_FromUnsignedLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<macro><name>va_arg</name><argument_list>(<argument>*p_va</argument>, <argument>unsigned PY_LONG_LONG</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		</case><case>case <expr>'u'</expr>:
		<block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>u</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_UNICODE</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>	
			<if>if <condition>(<expr>**<name>p_format</name> == '#'</expr>)</condition><then> <block>{
				<expr_stmt><expr>++*<name>p_format</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>flags</name> &amp; <name>FLAG_SIZE_T</name></expr>)</condition><then>
					<expr_stmt><expr><name>n</name> = <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>n</name> = <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			}</block></then>
			<else>else
				<expr_stmt><expr><name>n</name> = -1</expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>v</name> = <name>Py_None</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
					<expr_stmt><expr><name>n</name> = <call><name>_ustrlen</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<return>return <expr><name>v</name></expr>;</return>
		}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</case><case>case <expr>'f'</expr>:
		</case><case>case <expr>'d'</expr>:
			<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(
				<argument><expr>(<name>double</name>)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>va_double</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITHOUT_COMPLEX</name></cpp:ifndef>
		</case><case>case <expr>'D'</expr>:
			<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(
				<argument><expr>*((<name>Py_complex</name> *)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_complex</name> *</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WITHOUT_COMPLEX */</comment>

		</case><case>case <expr>'c'</expr>:
		<block>{
			<decl_stmt><decl><type><name>char</name></type> <name><name>p</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>p</name><index>[<expr>0</expr>]</index></name> = (<name>char</name>)<call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
		}</block>

		</case><case>case <expr>'s'</expr>:
		</case><case>case <expr>'z'</expr>:
		<block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>str</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
			<if>if <condition>(<expr>**<name>p_format</name> == '#'</expr>)</condition><then> <block>{
				<expr_stmt><expr>++*<name>p_format</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>flags</name> &amp; <name>FLAG_SIZE_T</name></expr>)</condition><then>
					<expr_stmt><expr><name>n</name> = <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>n</name> = <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			}</block></then>
			<else>else
				<expr_stmt><expr><name>n</name> = -1</expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>v</name> = <name>Py_None</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>size_t</name></type> <name>m</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if>if <condition>(<expr><name>m</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
							<argument><expr>"string too long for Python string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>NULL</name></expr>;</return>
					}</block></then></if>
					<expr_stmt><expr><name>n</name> = (<name>Py_ssize_t</name>)<name>m</name></expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<return>return <expr><name>v</name></expr>;</return>
		}</block>

		</case><case>case <expr>'N'</expr>:
		</case><case>case <expr>'S'</expr>:
		</case><case>case <expr>'O'</expr>:
		<if>if <condition>(<expr>**<name>p_format</name> == '&amp;'</expr>)</condition><then> <block>{
			<typedef>typedef <function_decl><type><name>PyObject</name> *</type>(*<name>converter</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl></typedef>
			<decl_stmt><decl><type><name>converter</name></type> <name>func</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>converter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>void</name> *</type><name>arg</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr>++*<name>p_format</name></expr>;</expr_stmt>
			<return>return <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>va_arg</name><argument_list>(<argument><expr>*<name>p_va</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>*(*<name>p_format</name> - 1) != 'N'</expr>)</condition><then>
					<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			}</block></then>
			<else>else <if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<comment type="block">/* If a NULL was passed
				 * because a call that should
				 * have constructed a value
				 * failed, that's OK, and we
				 * pass the error on; but if
				 * no error occurred it's not
				 * clear that the caller knew
				 * what she was doing. */</comment>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"NULL object passed to Py_BuildValue"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
			<return>return <expr><name>v</name></expr>;</return>
		}</block></else></if>

		</case><case>case <expr>':'</expr>:
		</case><case>case <expr>','</expr>:
		</case><case>case <expr>' '</expr>:
		</case><case>case <expr>'\t'</expr>:
			<break>break;</break>

		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"bad format char passed to Py_BuildValue"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>

		</default>}</block></switch>
	}</block></for>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>Py_BuildValue</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>retval</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>va_build_value</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_Py_BuildValue_SizeT</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>retval</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> = <call><name>va_build_value</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><name>FLAG_SIZE_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>Py_VaBuildValue</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>va</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>va_build_value</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_Py_VaBuildValue_SizeT</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>va</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>va_build_value</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><name>FLAG_SIZE_T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>va_build_value</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>va</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>f</name> <init>= <expr><name>format</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>countformat</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>lva</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VA_LIST_IS_ARRAY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>va_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__va_copy</name></cpp:ifdef>
	<expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>lva</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>lva</name> = <name>va</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>n</name> == 1</expr>)</condition><then>
		<return>return <expr><call><name>do_mkvalue</name><argument_list>(<argument><expr>&amp;<name>f</name></expr></argument>, <argument><expr>&amp;<name>lva</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>do_mktuple</name><argument_list>(<argument><expr>&amp;<name>f</name></expr></argument>, <argument><expr>&amp;<name>lva</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>PyEval_CallFunction</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>args</name> = <call><name>Py_VaBuildValue</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>PyEval_CallMethod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>methodname</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>meth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>meth</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>methodname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>meth</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>args</name> = <call><name>Py_VaBuildValue</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>meth</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyModule_AddObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>m</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyModule_Check</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			    <argument><expr>"PyModule_AddObject() needs module as first arg"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<name>o</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"PyModule_AddObject() needs non-NULL value"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Internal error -- modules must have a dict! */</comment>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"module '%s' has no __dict__"</expr></argument>,
			     <argument><expr><call><name>PyModule_GetName</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type> 
<name>PyModule_AddIntConstant</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>m</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>long</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>o</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>int</name></type> 
<name>PyModule_AddStringConstant</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>m</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>o</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>
</unit>
