<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/pymath.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_HYPOT</name></cpp:ifndef>
<function><type><name>double</name></type> <name>hypot</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>, <param><decl><type><name>double</name></type> <name>y</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>yx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> = <call><name>fabs</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> &lt; <name>y</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>double</name></type> <name>temp</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>x</name> = <name>y</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> = <name>temp</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>x</name> == 0.</expr>)</condition><then>
		<return>return <expr>0.</expr>;</return></then>
	<else>else <block>{
		<expr_stmt><expr><name>yx</name> = <name>y</name>/<name>x</name></expr>;</expr_stmt>
		<return>return <expr><name>x</name>*<call><name>sqrt</name><argument_list>(<argument><expr>1.+<name>yx</name>*<name>yx</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_HYPOT */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_COPYSIGN</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>copysign</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>, <param><decl><type><name>double</name></type> <name>y</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* use atan2 to distinguish -0. from 0. */</comment>
	<if>if <condition>(<expr><name>y</name> &gt; 0. || (<name>y</name> == 0. &amp;&amp; <call><name>atan2</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr>-1.</expr></argument>)</argument_list></call> &gt; 0.)</expr>)</condition><then> <block>{
		<return>return <expr><call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<return>return <expr>-<call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_COPYSIGN */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LOG1P</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>

<function><type><name>double</name></type>
<name>log1p</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* For x small, we use the following approach.  Let y be the nearest
	   float to 1+x, then

	     1+x = y * (1 - (y-1-x)/y)

	   so log(1+x) = log(y) + log(1-(y-1-x)/y).  Since (y-1-x)/y is tiny,
	   the second term is well approximated by (y-1-x)/y.  If abs(x) &gt;=
	   DBL_EPSILON/2 or the rounding-mode is some form of round-to-nearest
	   then y-1-x will be exactly representable, and is computed exactly
	   by (y-1)-x.

	   If abs(x) &lt; DBL_EPSILON/2 and the rounding mode is not known to be
	   round-to-nearest then this method is slightly dangerous: 1+x could
	   be rounded up to 1+DBL_EPSILON instead of down to 1, and in that
	   case y-1-x will not be exactly representable any more and the
	   result can be off by many ulps.  But this is easily fixed: for a
	   floating-point number |x| &lt; DBL_EPSILON/2., the closest
	   floating-point number to log(1+x) is exactly x.
	*/</comment>

	<decl_stmt><decl><type><name>double</name></type> <name>y</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; <name>DBL_EPSILON</name>/2.</expr>)</condition><then> <block>{
		<return>return <expr><name>x</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr>-0.5 &lt;= <name>x</name> &amp;&amp; <name>x</name> &lt;= 1.</expr>)</condition><then> <block>{
		<comment type="block">/* WARNING: it's possible than an overeager compiler
		   will incorrectly optimize the following two lines
		   to the equivalent of "return log(1.+x)". If this
		   happens, then results from log1p will be inaccurate
		   for small x. */</comment>
		<expr_stmt><expr><name>y</name> = 1.+<name>x</name></expr>;</expr_stmt>
		<return>return <expr><call><name>log</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call>-((<name>y</name>-1.)-<name>x</name>)/<name>y</name></expr>;</return>
	}</block></then> <else>else <block>{
		<comment type="block">/* NaNs and infinities should end up here */</comment>
		<return>return <expr><call><name>log</name><argument_list>(<argument><expr>1.+<name>x</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LOG1P */</comment>

<comment type="block">/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>ln2</name> <init>= <expr>6.93147180559945286227E-01</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>two_pow_m28</name> <init>= <expr>3.7252902984619141E-09</expr></init></decl>;</decl_stmt> <comment type="block">/* 2**-28 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>two_pow_p28</name> <init>= <expr>268435456.0</expr></init></decl>;</decl_stmt> <comment type="block">/* 2**28 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>zero</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>

<comment type="block">/* asinh(x)
 * Method :
 *	Based on 
 *		asinh(x) = sign(x) * log [ |x| + sqrt(x*x+1) ]
 *	we have
 *	asinh(x) := x  if  1+x*x=1,
 *		 := sign(x)*(log(x)+ln2)) for large |x|, else
 *		 := sign(x)*log(2|x|+1/(|x|+sqrt(x*x+1))) if|x|&gt;2, else
 *		 := sign(x)*log1p(|x| + x^2/(1 + sqrt(1+x^2)))  
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_ASINH</name></cpp:ifndef>
<function><type><name>double</name></type>
<name>asinh</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list>
<block>{	
	<decl_stmt><decl><type><name>double</name></type> <name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>absx</name> <init>= <expr><call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> || <call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>x</name>+<name>x</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>absx</name> &lt; <name>two_pow_m28</name></expr>)</condition><then> <block>{	<comment type="block">/* |x| &lt; 2**-28 */</comment>
		<return>return <expr><name>x</name></expr>;</return>	<comment type="block">/* return x inexact except 0 */</comment>
	}</block></then></if> 
	<if>if <condition>(<expr><name>absx</name> &gt; <name>two_pow_p28</name></expr>)</condition><then> <block>{	<comment type="block">/* |x| &gt; 2**28 */</comment>
		<expr_stmt><expr><name>w</name> = <call><name>log</name><argument_list>(<argument><expr><name>absx</name></expr></argument>)</argument_list></call>+<name>ln2</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>absx</name> &gt; 2.0</expr>)</condition><then> <block>{		<comment type="block">/* 2 &lt; |x| &lt; 2**28 */</comment>
		<expr_stmt><expr><name>w</name> = <call><name>log</name><argument_list>(<argument><expr>2.0*<name>absx</name> + 1.0 / (<call><name>sqrt</name><argument_list>(<argument><expr><name>x</name>*<name>x</name> + 1.0</expr></argument>)</argument_list></call> + <name>absx</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{				<comment type="block">/* 2**-28 &lt;= |x| &lt; 2= */</comment>
		<decl_stmt><decl><type><name>double</name></type> <name>t</name> <init>= <expr><name>x</name>*<name>x</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>w</name> = <call><name>log1p</name><argument_list>(<argument><expr><name>absx</name> + <name>t</name> / (1.0 + <call><name>sqrt</name><argument_list>(<argument><expr>1.0 + <name>t</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
	
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_ASINH */</comment>

<comment type="block">/* acosh(x)
 * Method :
 *      Based on
 *	      acosh(x) = log [ x + sqrt(x*x-1) ]
 *      we have
 *	      acosh(x) := log(x)+ln2, if x is large; else
 *	      acosh(x) := log(2x-1/(sqrt(x*x-1)+x)) if x&gt;2; else
 *	      acosh(x) := log1p(t+sqrt(2.0*t+t*t)); where t=x-1.
 *
 * Special cases:
 *      acosh(x) is NaN with signal if x&lt;1.
 *      acosh(NaN) is NaN without signal.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_ACOSH</name></cpp:ifndef>
<function><type><name>double</name></type>
<name>acosh</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>x</name>+<name>x</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>x</name> &lt; 1.</expr>)</condition><then> <block>{			<comment type="block">/* x &lt; 1;  return a signaling NaN */</comment>
		<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_NAN</name></cpp:ifdef>
		<return>return <expr><name>Py_NAN</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<return>return <expr>(<name>x</name>-<name>x</name>)/(<name>x</name>-<name>x</name>)</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>x</name> &gt;= <name>two_pow_p28</name></expr>)</condition><then> <block>{	<comment type="block">/* x &gt; 2**28 */</comment>
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<return>return <expr><name>x</name>+<name>x</name></expr>;</return>
		}</block></then> <else>else <block>{
			<return>return <expr><call><name>log</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call>+<name>ln2</name></expr>;</return>	<comment type="block">/* acosh(huge)=log(2x) */</comment>
		}</block></else></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>x</name> == 1.</expr>)</condition><then> <block>{
		<return>return <expr>0.0</expr>;</return>			<comment type="block">/* acosh(1) = 0 */</comment>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>x</name> &gt; 2.</expr>)</condition><then> <block>{			<comment type="block">/* 2 &lt; x &lt; 2**28 */</comment>
		<decl_stmt><decl><type><name>double</name></type> <name>t</name> <init>= <expr><name>x</name>*<name>x</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>log</name><argument_list>(<argument><expr>2.0*<name>x</name> - 1.0 / (<name>x</name> + <call><name>sqrt</name><argument_list>(<argument><expr><name>t</name> - 1.0</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <block>{				<comment type="block">/* 1 &lt; x &lt;= 2 */</comment>
		<decl_stmt><decl><type><name>double</name></type> <name>t</name> <init>= <expr><name>x</name> - 1.0</expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>log1p</name><argument_list>(<argument><expr><name>t</name> + <call><name>sqrt</name><argument_list>(<argument><expr>2.0*<name>t</name> + <name>t</name>*<name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if></else></if></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_ACOSH */</comment>

<comment type="block">/* atanh(x)
 * Method :
 *    1.Reduced x to positive by atanh(-x) = -atanh(x)
 *    2.For x&gt;=0.5
 *		  1	      2x			  x
 *      atanh(x) = --- * log(1 + -------) = 0.5 * log1p(2 * --------)
 *		  2	     1 - x		      1 - x
 *
 *      For x&lt;0.5
 *      atanh(x) = 0.5*log1p(2x+2x*x/(1-x))
 *
 * Special cases:
 *      atanh(x) is NaN if |x| &gt;= 1 with signal;
 *      atanh(NaN) is that NaN with no signal;
 *
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_ATANH</name></cpp:ifndef>
<function><type><name>double</name></type>
<name>atanh</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>absx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>t</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>x</name>+<name>x</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>absx</name> = <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>absx</name> &gt;= 1.</expr>)</condition><then> <block>{		<comment type="block">/* |x| &gt;= 1 */</comment>
		<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_NAN</name></cpp:ifdef>
		<return>return <expr><name>Py_NAN</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<return>return <expr><name>x</name>/<name>zero</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
	<if>if <condition>(<expr><name>absx</name> &lt; <name>two_pow_m28</name></expr>)</condition><then> <block>{	<comment type="block">/* |x| &lt; 2**-28 */</comment>
		<return>return <expr><name>x</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>absx</name> &lt; 0.5</expr>)</condition><then> <block>{		<comment type="block">/* |x| &lt; 0.5 */</comment>
		<expr_stmt><expr><name>t</name> = <name>absx</name>+<name>absx</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> = 0.5 * <call><name>log1p</name><argument_list>(<argument><expr><name>t</name> + <name>t</name>*<name>absx</name> / (1.0 - <name>absx</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> 
	<else>else <block>{				<comment type="block">/* 0.5 &lt;= |x| &lt;= 1.0 */</comment>
		<expr_stmt><expr><name>t</name> = 0.5 * <call><name>log1p</name><argument_list>(<argument><expr>(<name>absx</name> + <name>absx</name>) / (1.0 - <name>absx</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_ATANH */</comment>
</unit>
