<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/mysnprintf.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="block">/* snprintf() wrappers.  If the platform has vsnprintf, we use it, else we
   emulate it in a half-hearted way.  Even if the platform has it, we wrap
   it because platforms differ in what vsnprintf does in case the buffer
   is too small:  C99 behavior is to return the number of characters that
   would have been written had the buffer not been too small, and to set
   the last byte of the buffer to \0.  At least MS _vsnprintf returns a
   negative value instead, and fills the entire buffer with non-\0 data.

   The wrappers ensure that str[size-1] is always \0 upon return.

   PyOS_snprintf and PyOS_vsnprintf never write more than size bytes
   (including the trailing '\0') into str.

   If the platform doesn't have vsnprintf, and the buffer size needed to
   avoid truncation exceeds size by more than 512, Python aborts with a
   Py_FatalError.

   Return value (rv):

	When 0 &lt;= rv &lt; size, the output conversion was unexceptional, and
	rv characters were written to str (excluding a trailing \0 byte at
	str[rv]).

	When rv &gt;= size, output conversion was truncated, and a buffer of
	size rv+1 would have been needed to avoid truncation.  str[size-1]
	is \0 in this case.

	When rv &lt; 0, "something bad happened".  str[size-1] is \0 in this
	case too, but the rest of str is unreliable.  It could be that
	an error in format codes was detected by libc, or on platforms
	with a non-C99 vsnprintf simply that the buffer wasn't big enough
	to avoid truncation, or on platforms without any vsnprintf that
	PyMem_Malloc couldn't obtain space for a temp buffer.

   CAUTION:  Unlike C99, str != NULL and size &gt; 0 are required.
*/</comment>

<function><type><name>int</name></type>
<name>PyOS_snprintf</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>size</name></decl></param>, <param><decl><type><specifier>const</specifier>  <name>char</name>  *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> = <call><name>PyOS_vsnprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyOS_vsnprintf</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>size</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>  *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>va</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>  <comment type="block">/* # bytes written, excluding \0 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SNPRINTF</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyOS_vsnprintf_EXTRA_SPACE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyOS_vsnprintf_EXTRA_SPACE</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>str</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>format</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We take a size_t as input but return an int.  Sanity check
	 * our input so that it won't cause an overflow in the
         * vsnprintf return value or the buffer malloc size.  */</comment>
	<if>if <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name> - <name>_PyOS_vsnprintf_EXTRA_SPACE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>len</name> = -666</expr>;</expr_stmt>
		<goto>goto <name>Done</name>;</goto>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SNPRINTF</name></cpp:ifdef>
	<expr_stmt><expr><name>len</name> = <call><name>vsnprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Emulate it. */</comment>
	<expr_stmt><expr><name>buffer</name> = <call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>size</name> + <name>_PyOS_vsnprintf_EXTRA_SPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>len</name> = -666</expr>;</expr_stmt>
		<goto>goto <name>Done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>len</name> = <call><name>vsprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
		<comment type="block">/* ignore the error */</comment><empty_stmt>;</empty_stmt></then>

	<else>else <if>if <condition>(<expr>(<name>size_t</name>)<name>len</name> &gt;= <name>size</name> + <name>_PyOS_vsnprintf_EXTRA_SPACE</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Buffer overflow in PyOS_snprintf/PyOS_vsnprintf"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

	<else>else <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>to_copy</name> <init>= <expr>(<name>size_t</name>)<name>len</name> &lt; <name>size</name> ?
					(<name>size_t</name>)<name>len</name> : <name>size</name> - 1</expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>to_copy</name> &lt; <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>to_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>str</name><index>[<expr><name>to_copy</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	}</block></else></if></else></if>
	<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>Done</name>:</label>
	<if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then>
		<expr_stmt><expr><name><name>str</name><index>[<expr><name>size</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>
	<return>return <expr><name>len</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_PyOS_vsnprintf_EXTRA_SPACE</name></cpp:undef>
}</block></function>
</unit>
