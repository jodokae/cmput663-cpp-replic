<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/ceval.c">
<comment type="block">/* Execute compiled code */</comment>

<comment type="block">/* XXX TO DO:
   XXX speed up searching for keywords by using a dictionary
   XXX document it!
   */</comment>

<comment type="block">/* enable more aggressive intra-module optimizations, where available */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LOCAL_AGGRESSIVE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"frameobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"opcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITH_TSC</name></cpp:ifndef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_TIMESTAMP</name><parameter_list>(<param><type><name>var</name></type></param>)</parameter_list></cpp:macro></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<typedef>typedef <type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>uint64</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="block">/* &lt;- Don't know if this is the correct symbol; this
			   section should work for GCC on any PowerPC
			   platform, irrespective of OS.
			   POWER?  Who knows :-) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_TIMESTAMP</name><parameter_list>(<param><type><name>var</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ppc_getcounter(&amp;var)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ppc_getcounter</name><parameter_list>(<param><decl><type><name>uint64</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>long</name></type> <name>tbu</name></decl>, <decl><type ref="prev"/><name>tb</name></decl>, <decl><type ref="prev"/><name>tbu2</name></decl>;</decl_stmt>

  <label><name>loop</name>:</label>
	<asm>asm <specifier>volatile</specifier> ("mftbu %0" : "=r" (tbu) );</asm>
	<asm>asm <specifier>volatile</specifier> ("mftb  %0" : "=r" (tb)  );</asm>
	<asm>asm <specifier>volatile</specifier> ("mftbu %0" : "=r" (tbu2));</asm>
	<if>if <condition>(<expr><call><name>__builtin_expect</name><argument_list>(<argument><expr><name>tbu</name> != <name>tbu2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <goto>goto <name>loop</name>;</goto></then></if>

	<comment type="block">/* The slightly peculiar way of writing the next lines is
	   compiled better by GCC than any other way I tried. */</comment>
	<expr_stmt><expr>(<call>(<name>long</name>*)<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)<index>[<expr>0</expr>]</index> = <name>tbu</name></expr>;</expr_stmt>
	<expr_stmt><expr>(<call>(<name>long</name>*)<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)<index>[<expr>1</expr>]</index> = <name>tb</name></expr>;</expr_stmt>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* this is for linux/x86 (and probably any other GCC/x86 combo) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_TIMESTAMP</name><parameter_list>(<param><type><name>val</name></type></param>)</parameter_list></cpp:macro> \
     <cpp:value>__asm__ __volatile__("rdtsc" : "=A" (val))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>dump_tsc</name><parameter_list>(<param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>int</name></type> <name>ticked</name></decl></param>, <param><decl><type><name>uint64</name></type> <name>inst0</name></decl></param>, <param><decl><type><name>uint64</name></type> <name>inst1</name></decl></param>,
	      <param><decl><type><name>uint64</name></type> <name>loop0</name></decl></param>, <param><decl><type><name>uint64</name></type> <name>loop1</name></decl></param>, <param><decl><type><name>uint64</name></type> <name>intr0</name></decl></param>, <param><decl><type><name>uint64</name></type> <name>intr1</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>uint64</name></type> <name>intr</name></decl>, <decl><type ref="prev"/><name>inst</name></decl>, <decl><type ref="prev"/><name>loop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_Get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name><name>tstate</name>-&gt;<name>interp</name>-&gt;<name>tscdump</name></name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>intr</name> = <name>intr1</name> - <name>intr0</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>inst</name> = <name>inst1</name> - <name>inst0</name> - <name>intr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>loop</name> = <name>loop1</name> - <name>loop0</name> - <name>intr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"opcode=%03d t=%d inst=%06lld loop=%06lld\n"</expr></argument>,
		<argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>ticked</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Turn this on if your compiler chokes on the big switch: */</comment>
<comment type="block">/* #define CASE_TOO_BIG 1 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
<comment type="block">/* For debugging the interpreter: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLTRACE</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* Low-level trace feature */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKEXC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* Double-check exception checking */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <function_decl><type><name>PyObject</name> *</type>(*<name>callproc</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Forward declarations */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_TSC</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>call_function</name><parameter_list>(<param><decl><type><name>PyObject</name> ***</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>uint64</name>*</type></decl></param>, <param><decl><type><name>uint64</name>*</type></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>call_function</name><parameter_list>(<param><decl><type><name>PyObject</name> ***</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>fast_function</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> ***</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>do_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> ***</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>ext_do_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> ***</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>update_keyword_args</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> ***</type></decl></param>,
				      <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>update_star_args</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> ***</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>load_args</name><parameter_list>(<param><decl><type><name>PyObject</name> ***</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_FLAG_VAR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_FLAG_KW</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LLTRACE</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>lltrace</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>prtrace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>call_trace</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type></decl></param>,
		      <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>call_trace_protected</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
				 <param><decl><type><name>PyFrameObject</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>call_exc_trace</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>maybe_call_line_trace</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
				  <param><decl><type><name>PyFrameObject</name> *</type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>apply_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>assign_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
			<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>cmp_outcome</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>import_from</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>import_all_from</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>build_class</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>exec_statement</name><parameter_list>(<param><decl><type><name>PyFrameObject</name> *</type></decl></param>,
			  <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_exc_info</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reset_exc_info</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>format_exc_check_arg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>string_concatenate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
				    <param><decl><type><name>PyFrameObject</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAME_ERROR_MSG</name></cpp:macro> \
	<cpp:value>"name '%.200s' is not defined"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOBAL_NAME_ERROR_MSG</name></cpp:macro> \
	<cpp:value>"global name '%.200s' is not defined"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNBOUNDLOCAL_ERROR_MSG</name></cpp:macro> \
	<cpp:value>"local variable '%.200s' referenced before assignment"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNBOUNDFREE_ERROR_MSG</name></cpp:macro> \
	<cpp:value>"free variable '%.200s' referenced before assignment" \
        " in enclosing scope"</cpp:value></cpp:define>

<comment type="block">/* Dynamic execution profile */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DYNAMIC_EXECUTION_PROFILE</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DXPAIRS</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name><name>dxpairs</name><index>[<expr>257</expr>]</index><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dxp</name></cpp:macro> <cpp:value>dxpairs[256]</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name><name>dxp</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Function call profile */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CALL_PROFILE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_NUM</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>pcall</name><index>[<expr><name>PCALL_NUM</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_ALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_FUNCTION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_FAST_FUNCTION</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_FASTER_FUNCTION</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_METHOD</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_BOUND_METHOD</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_CFUNCTION</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_TYPE</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_GENERATOR</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_OTHER</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL_POP</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/* Notes about the statistics

   PCALL_FAST stats

   FAST_FUNCTION means no argument tuple needs to be created.
   FASTER_FUNCTION means that the fast-path frame setup code is used.

   If there is a method call where the call can be optimized by changing
   the argument tuple and calling the function directly, it gets recorded
   twice.

   As a result, the relationship among the statistics appears to be
   PCALL_ALL == PCALL_FUNCTION + PCALL_METHOD - PCALL_BOUND_METHOD +
                PCALL_CFUNCTION + PCALL_TYPE + PCALL_GENERATOR + PCALL_OTHER
   PCALL_FUNCTION &gt; PCALL_FAST_FUNCTION &gt; PCALL_FASTER_FUNCTION
   PCALL_METHOD &gt; PCALL_BOUND_METHOD
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL</name><parameter_list>(<param><type><name>POS</name></type></param>)</parameter_list></cpp:macro> <cpp:value>pcall[POS]++</cpp:value></cpp:define>

<function><type><name>PyObject</name> *</type>
<name>PyEval_GetCallStats</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiiiiiiiiii"</expr></argument>,
			     <argument><expr><name><name>pcall</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>pcall</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>pcall</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name><name>pcall</name><index>[<expr>3</expr>]</index></name></expr></argument>,
			     <argument><expr><name><name>pcall</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr><name><name>pcall</name><index>[<expr>5</expr>]</index></name></expr></argument>, <argument><expr><name><name>pcall</name><index>[<expr>6</expr>]</index></name></expr></argument>, <argument><expr><name><name>pcall</name><index>[<expr>7</expr>]</index></name></expr></argument>,
			     <argument><expr><name><name>pcall</name><index>[<expr>8</expr>]</index></name></expr></argument>, <argument><expr><name><name>pcall</name><index>[<expr>9</expr>]</index></name></expr></argument>, <argument><expr><name><name>pcall</name><index>[<expr>10</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCALL</name><parameter_list>(<param><type><name>O</name></type></param>)</parameter_list></cpp:macro></cpp:define>

<function><type><name>PyObject</name> *</type>
<name>PyEval_GetCallStats</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ERRNO_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyThread_type_lock</name></type> <name>interpreter_lock</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* This is the GIL */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>main_thread</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>PyEval_ThreadsInitialized</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>interpreter_lock</name> != 0</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyEval_InitThreads</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>interpreter_lock</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>interpreter_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>main_thread</name> = <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyEval_AcquireLock</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyEval_ReleaseLock</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyEval_AcquireThread</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>tstate</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyEval_AcquireThread: NULL new thread state"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<comment type="block">/* Check someone has called PyEval_InitThreads() to create the lock */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
			<argument><expr>"PyEval_AcquireThread: non-NULL old thread state"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>PyEval_ReleaseThread</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>tstate</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyEval_ReleaseThread: NULL thread state"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != <name>tstate</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyEval_ReleaseThread: wrong thread state"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* This function is called from PyOS_AfterFork to ensure that newly
   created child processes don't hold locks referring to threads which
   are not running in the child process.  (This could also be done using
   pthread_atfork mechanism, at least for the pthreads implementation.) */</comment>

<function><type><name>void</name></type>
<name>PyEval_ReInitThreads</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>threading</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>interpreter_lock</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<comment type="block">/*XXX Can't use PyThread_free_lock here because it does too
	  much error-checking.  Doing this cleanly would require
	  adding a new function to each thread_*.h.  Instead, just
	  create a new lock and waste a little bit of memory */</comment>
	<expr_stmt><expr><name>interpreter_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>main_thread</name> = <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the threading module with the new state.
	 */</comment>
	<expr_stmt><expr><name>tstate</name> = <call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>threading</name> = <call><name>PyMapping_GetItemString</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>interp</name>-&gt;<name>modules</name></name></expr></argument>,
					    <argument><expr>"threading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>threading</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* threading not imported */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>threading</name></expr></argument>, <argument><expr>"_after_fork"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>threading</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>threading</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Functions save_thread and restore_thread are always defined so
   dynamically loaded modules needn't be compiled separately for use
   with and without threads: */</comment>

<function><type><name>PyThreadState</name> *</type>
<name>PyEval_SaveThread</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>tstate</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyEval_SaveThread: NULL tstate"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name>interpreter_lock</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>tstate</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyEval_RestoreThread</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>tstate</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyEval_RestoreThread: NULL tstate"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name>interpreter_lock</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> = <name>err</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Mechanism whereby asynchronously executing callbacks (e.g. UNIX
   signal handlers or Mac I/O completion routines) can schedule calls
   to a function to be called synchronously.
   The synchronous function is called with one void* argument.
   It should return 0 for success or -1 for failure -- failure should
   be accompanied by an exception.

   If registry succeeds, the registry function returns 0; if it fails
   (e.g. due to too many pending calls) it returns -1 (without setting
   an exception condition).

   Note that because registry may occur from within signal handlers,
   or other asynchronous events, calling malloc() is unsafe!

#ifdef WITH_THREAD
   Any thread can schedule pending calls, but only the main thread
   will execute them.
#endif

   XXX WARNING!  ASYNCHRONOUSLY EXECUTING CODE!
   There are two possible race conditions:
   (1) nested asynchronous registry calls;
   (2) registry calls made while pending calls are being processed.
   While (1) is very unlikely, (2) is a real possibility.
   The current code is safe against (2), but not against (1).
   The safety against (2) is derived from the fact that only one
   thread (the main thread) ever takes things out of the queue.

   XXX Darn!  With the advent of thread state, we should have an array
   of pending calls per thread in the thread state!  Later...
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NPENDINGCALLS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<struct><specifier>static</specifier> struct <block>{
	<function_decl><type><name>int</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>void</name> *</type><name>arg</name></decl>;</decl_stmt>
}</block> <decl><name><name>pendingcalls</name><index>[<expr><name>NPENDINGCALLS</name></expr>]</index></name></decl>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>pendingfirst</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>pendinglast</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>things_to_do</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>Py_AddPendingCall</name><parameter_list>(<param><function_decl><type><name>int</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>busy</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<comment type="block">/* XXX Begin critical section */</comment>
	<comment type="block">/* XXX If you want this to be safe against nested
	   XXX asynchronous calls, you'll have to work harder! */</comment>
	<if>if <condition>(<expr><name>busy</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>busy</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = <name>pendinglast</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> = (<name>i</name> + 1) % <name>NPENDINGCALLS</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>j</name> == <name>pendingfirst</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>busy</name> = 0</expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return> <comment type="block">/* Queue full */</comment>
	}</block></then></if>
	<expr_stmt><expr><name><name>pendingcalls</name><index>[<expr><name>i</name></expr>]</index></name>.<name>func</name> = <name>func</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pendingcalls</name><index>[<expr><name>i</name></expr>]</index></name>.<name>arg</name> = <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pendinglast</name> = <name>j</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>_Py_Ticker</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>things_to_do</name> = 1</expr>;</expr_stmt> <comment type="block">/* Signal main loop */</comment>
	<expr_stmt><expr><name>busy</name> = 0</expr>;</expr_stmt>
	<comment type="block">/* XXX End critical section */</comment>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>Py_MakePendingCalls</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>busy</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name>main_thread</name> &amp;&amp; <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call> != <name>main_thread</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>busy</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>busy</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>things_to_do</name> = 0</expr>;</expr_stmt>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<function_decl><type><name>int</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl>
		<decl_stmt><decl><type><name>void</name> *</type><name>arg</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>i</name> = <name>pendingfirst</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> == <name>pendinglast</name></expr>)</condition><then>
			<break>break;</break></then></if> <comment type="block">/* Queue empty */</comment>
		<expr_stmt><expr><name>func</name> = <name><name>pendingcalls</name><index>[<expr><name>i</name></expr>]</index></name>.<name>func</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>arg</name> = <name><name>pendingcalls</name><index>[<expr><name>i</name></expr>]</index></name>.<name>arg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pendingfirst</name> = (<name>i</name> + 1) % <name>NPENDINGCALLS</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>func</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>busy</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>things_to_do</name> = 1</expr>;</expr_stmt> <comment type="block">/* We're not done yet */</comment>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><name>busy</name> = 0</expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* The interpreter's recursion limit */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_DEFAULT_RECURSION_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_DEFAULT_RECURSION_LIMIT</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recursion_limit</name> <init>= <expr><name>Py_DEFAULT_RECURSION_LIMIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>_Py_CheckRecursionLimit</name> <init>= <expr><name>Py_DEFAULT_RECURSION_LIMIT</name></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>Py_GetRecursionLimit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>recursion_limit</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>Py_SetRecursionLimit</name><parameter_list>(<param><decl><type><name>int</name></type> <name>new_limit</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name>recursion_limit</name> = <name>new_limit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>_Py_CheckRecursionLimit</name> = <name>recursion_limit</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* the macro Py_EnterRecursiveCall() only calls _Py_CheckRecursiveCall()
   if the recursion_depth reaches _Py_CheckRecursionLimit.
   If USE_STACKCHECK, the macro decrements _Py_CheckRecursionLimit
   to guarantee that _Py_CheckRecursiveCall() is regularly called.
   Without USE_STACKCHECK, there is no need for this. */</comment>
<function><type><name>int</name></type>
<name>_Py_CheckRecursiveCall</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>where</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_STACKCHECK</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyOS_CheckStack</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>--<name><name>tstate</name>-&gt;<name>recursion_depth</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"Stack overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>recursion_depth</name></name> &gt; <name>recursion_limit</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>--<name><name>tstate</name>-&gt;<name>recursion_depth</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
			     <argument><expr>"maximum recursion depth exceeded%s"</expr></argument>,
			     <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>_Py_CheckRecursionLimit</name> = <name>recursion_limit</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Status code for main loop (reason for stack unwind) */</comment>
<enum>enum <name>why_code</name> <block>{
		<decl><name>WHY_NOT</name> <init>=	<expr>0x0001</expr></init></decl>,	<comment type="block">/* No error */</comment>
		<decl><name>WHY_EXCEPTION</name> <init>= <expr>0x0002</expr></init></decl>,	<comment type="block">/* Exception occurred */</comment>
		<decl><name>WHY_RERAISE</name> <init>=	<expr>0x0004</expr></init></decl>,	<comment type="block">/* Exception re-raised by 'finally' */</comment>
		<decl><name>WHY_RETURN</name> <init>=	<expr>0x0008</expr></init></decl>,	<comment type="block">/* 'return' statement */</comment>
		<decl><name>WHY_BREAK</name> <init>=	<expr>0x0010</expr></init></decl>,	<comment type="block">/* 'break' statement */</comment>
		<decl><name>WHY_CONTINUE</name> <init>=	<expr>0x0020</expr></init></decl>,	<comment type="block">/* 'continue' statement */</comment>
		<decl><name>WHY_YIELD</name> <init>=	<expr>0x0040</expr></init></decl>	<comment type="block">/* 'yield' operator */</comment>
}</block>;</enum>

<enum><specifier>static</specifier> enum <name>why_code</name> <name>do_raise</name><expr_stmt><expr>(<name>PyObject</name> *, <name>PyObject</name> *, <name>PyObject</name> *)</expr>;</expr_stmt></enum>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>unpack_iterable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> **</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* for manipulating the thread switch and periodic "stuff" - used to be
   per thread, now just a pair o' globals */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>_Py_CheckInterval</name> <init>= <expr>100</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>_Py_Ticker</name> <init>= <expr>100</expr></init></decl>;</decl_stmt>

<function><type><name>PyObject</name> *</type>
<name>PyEval_EvalCode</name><parameter_list>(<param><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyEval_EvalCodeEx</name><argument_list>(<argument><expr><name>co</name></expr></argument>,
			  <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>,
			  <argument><expr>(<name>PyObject</name> **)<name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
			  <argument><expr>(<name>PyObject</name> **)<name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
			  <argument><expr>(<name>PyObject</name> **)<name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
			  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Interpreter main loop */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyEval_EvalFrame</name><parameter_list>(<param><decl><type><name>PyFrameObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
	<comment type="block">/* This is for backward compatibility with extension modules that
           used this API; core interpreter code should call
           PyEval_EvalFrameEx() */</comment>
	<return>return <expr><call><name>PyEval_EvalFrameEx</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyEval_EvalFrameEx</name><parameter_list>(<param><decl><type><name>PyFrameObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>throwflag</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DXPAIRS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>lastopcode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> **</type><name>stack_pointer</name></decl>;</decl_stmt>  <comment type="block">/* Next free slot in value stack */</comment>
	<decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>char</name> *</type><name>next_instr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>opcode</name></decl>;</decl_stmt>	<comment type="block">/* Current opcode */</comment>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>oparg</name></decl>;</decl_stmt>	<comment type="block">/* Current opcode argument, if any */</comment>
	<expr_stmt><expr><name>register</name> enum <name>why_code</name> <name>why</name></expr>;</expr_stmt> <comment type="block">/* Reason for block stack unwind */</comment>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>err</name></decl>;</decl_stmt>	<comment type="block">/* Error status -- nonzero if error */</comment>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>	<comment type="block">/* Result object -- NULL if error */</comment>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>	<comment type="block">/* Temporary objects popped off stack */</comment>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>stream</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* for PRINT opcodes */</comment>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> **</type><name>fastlocals</name></decl>, **<decl><type ref="prev"/><name>freevars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* Return value */</comment>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>

	<comment type="block">/* when tracing we set things up so that

               not (instr_lb &lt;= current_bytecode_offset &lt; instr_ub)

	   is true when the line being executed has changed.  The
           initial values are such as to make this false the first
           time it is tested. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>instr_ub</name> <init>= <expr>-1</expr></init>, <name>instr_lb</name> <init>= <expr>0</expr></init>, <name>instr_prev</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>first_instr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>consts</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>LLTRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* Make it easier to find out where we are with a debugger */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Tuple access macros */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_DEBUG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETITEM</name><parameter_list>(<param><type><name>v</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyTuple_GET_ITEM((PyTupleObject *)(v), (i))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETITEM</name><parameter_list>(<param><type><name>v</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyTuple_GetItem((v), (i))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_TSC</name></cpp:ifdef>
<comment type="block">/* Use Pentium timestamp counter to mark certain events:
   inst0 -- beginning of switch statement for opcode dispatch
   inst1 -- end of switch statement (may be skipped)
   loop0 -- the top of the mainloop
   loop1 -- place where control returns again to top of mainloop
            (may be skipped)
   intr1 -- beginning of long interruption
   intr2 -- end of long interruption

   Many opcodes call out to helper C functions.  In some cases, the
   time in those functions should be counted towards the time for the
   opcode, but not in all cases.  For example, a CALL_FUNCTION opcode
   calls another Python function; there's no point in charge all the
   bytecode executed by the called function to the caller.

   It's hard to make a useful judgement statically.  In the presence
   of operator overloading, it's impossible to tell if a call will
   execute new Python code or not.

   It's a case-by-case judgement.  I'll use intr1 for the following
   cases:

   EXEC_STMT
   IMPORT_STAR
   IMPORT_FROM
   CALL_FUNCTION (and friends)

 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>inst0</name></decl>, <decl><type ref="prev"/><name>inst1</name></decl>, <decl><type ref="prev"/><name>loop0</name></decl>, <decl><type ref="prev"/><name>loop1</name></decl>, <decl><type ref="prev"/><name>intr0</name> <init>= <expr>0</expr></init>, <name>intr1</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ticked</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>inst0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>inst1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>loop0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>loop1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* shut up the compiler */</comment>
	<expr_stmt><expr><name>opcode</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Code access macros */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSTR_OFFSET</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>((int)(next_instr - first_instr))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXTOP</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>(*next_instr++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXTARG</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>(next_instr += 2, (next_instr[-1]&lt;&lt;8) + next_instr[-2])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEEKARG</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>((next_instr[2]&lt;&lt;8) + next_instr[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUMPTO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(next_instr = first_instr + (x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUMPBY</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(next_instr += (x))</cpp:value></cpp:define>

<comment type="block">/* OpCode prediction macros
	Some opcodes tend to come in pairs thus making it possible to
	predict the second code when the first is run.  For example,
	COMPARE_OP is often followed by JUMP_IF_FALSE or JUMP_IF_TRUE.  And,
	those opcodes are often followed by a POP_TOP.

	Verifying the prediction costs a single high-speed test of a register
	variable against a constant.  If the pairing was good, then the
	processor's own internal branch predication has a high likelihood of
	success, resulting in a nearly zero-overhead transition to the
	next opcode.  A successful prediction saves a trip through the eval-loop
	including its two unpredictable branches, the HAS_ARG test and the
	switch-case.  Combined with the processor's internal branch prediction,
	a successful PREDICT has the effect of making the two opcodes run as if
	they were a single new opcode with the bodies combined.

    If collecting opcode statistics, your choices are to either keep the
	predictions turned-on and interpret the results as if some opcodes
	had been combined or turn-off predictions so that the opcode frequency
	counter updates for both opcodes.
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DYNAMIC_EXECUTION_PROFILE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREDICT</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>if (0) goto PRED_##op</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREDICT</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>if (*next_instr == op) goto PRED_##op</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREDICTED</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>PRED_##op: next_instr++</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREDICTED_WITH_ARG</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>PRED_##op: oparg = PEEKARG(); next_instr += 3</cpp:value></cpp:define>

<comment type="block">/* Stack manipulation macros */</comment>

<comment type="block">/* The stack can grow at most MAXINT deep, as co_nlocals and
   co_stacksize are ints. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_LEVEL</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>((int)(stack_pointer - f-&gt;f_valuestack))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>(STACK_LEVEL() == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOP</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>(stack_pointer[-1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECOND</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>(stack_pointer[-2])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THIRD</name><parameter_list>()</parameter_list></cpp:macro> 	<cpp:value>(stack_pointer[-3])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOURTH</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>(stack_pointer[-4])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_TOP</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(stack_pointer[-1] = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_SECOND</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(stack_pointer[-2] = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_THIRD</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(stack_pointer[-3] = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_FOURTH</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(stack_pointer[-4] = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BASIC_STACKADJ</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(stack_pointer += n)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BASIC_PUSH</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(*stack_pointer++ = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BASIC_POP</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>(*--stack_pointer)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LLTRACE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>{ (void)(BASIC_PUSH(v), \
                               lltrace &amp;&amp; prtrace(TOP(), "push")); \
                               assert(STACK_LEVEL() &lt;= co-&gt;co_stacksize); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POP</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>((void)(lltrace &amp;&amp; prtrace(TOP(), "pop")), \
			 BASIC_POP())</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACKADJ</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>{ (void)(BASIC_STACKADJ(n), \
                               lltrace &amp;&amp; prtrace(TOP(), "stackadj")); \
                               assert(STACK_LEVEL() &lt;= co-&gt;co_stacksize); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXT_POP</name><parameter_list>(<param><type><name>STACK_POINTER</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)(lltrace &amp;&amp; \
				prtrace((STACK_POINTER)[-1], "ext_pop")), \
				*--(STACK_POINTER))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>BASIC_PUSH(v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POP</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>BASIC_POP()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACKADJ</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>BASIC_STACKADJ(n)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXT_POP</name><parameter_list>(<param><type><name>STACK_POINTER</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(*--(STACK_POINTER))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Local variable macros */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETLOCAL</name><parameter_list>(<param><type><name>i</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(fastlocals[i])</cpp:value></cpp:define>

<comment type="block">/* The SETLOCAL() macro must not DECREF the local variable in-place and
   then store the new value; it must copy the old value to a temporary
   value, then store the new value, and then DECREF the temporary value.
   This is because it is possible that during the DECREF the frame is
   accessed by other code (e.g. a __del__ method or gc.collect()) and the
   variable would be pointing to already-freed memory. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETLOCAL</name><parameter_list>(<param><type><name>i</name></type></param>, <param><type><name>value</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>do { PyObject *tmp = GETLOCAL(i); \
				     GETLOCAL(i) = value; \
                                     Py_XDECREF(tmp); } while (0)</cpp:value></cpp:define>

<comment type="block">/* Start of code */</comment>

	<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* push frame */</comment>
	<if>if <condition>(<expr><call><name>Py_EnterRecursiveCall</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>frame</name></name> = <name>f</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* tstate-&gt;c_tracefunc, if defined, is a
			   function that will be called on *every* entry
			   to a code block.  Its return value, if not
			   None, is a function that will be called at
			   the start of each executed line of code.
			   (Actually, the function must return itself
			   in order to continue tracing.)  The trace
			   functions are called with three arguments:
			   a pointer to the current frame, a string
			   indicating why the function is called, and
			   an argument which depends on the situation.
			   The global trace function is also called
			   whenever an exception is detected. */</comment>
			<if>if <condition>(<expr><call><name>call_trace_protected</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name></expr></argument>,
						 <argument><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name></expr></argument>,
						 <argument><expr><name>f</name></expr></argument>, <argument><expr><name>PyTrace_CALL</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* Trace function raised an error */</comment>
				<goto>goto <name>exit_eval_frame</name>;</goto>
			}</block></then></if>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* Similar for c_profilefunc, except it needn't
			   return itself and isn't called for "line" events */</comment>
			<if>if <condition>(<expr><call><name>call_trace_protected</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name></expr></argument>,
						 <argument><expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name></expr></argument>,
						 <argument><expr><name>f</name></expr></argument>, <argument><expr><name>PyTrace_CALL</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* Profile function raised an error */</comment>
				<goto>goto <name>exit_eval_frame</name>;</goto>
			}</block></then></if>
		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>co</name> = <name><name>f</name>-&gt;<name>f_code</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>names</name> = <name><name>co</name>-&gt;<name>co_names</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>consts</name> = <name><name>co</name>-&gt;<name>co_consts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fastlocals</name> = <name><name>f</name>-&gt;<name>f_localsplus</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>freevars</name> = <name><name>f</name>-&gt;<name>f_localsplus</name></name> + <name><name>co</name>-&gt;<name>co_nlocals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>first_instr</name> = (<name>unsigned</name> <name>char</name>*) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* An explanation is in order for the next line.

	   f-&gt;f_lasti now refers to the index of the last instruction
	   executed.  You might think this was obvious from the name, but
	   this wasn't always true before 2.3!  PyFrame_New now sets
	   f-&gt;f_lasti to -1 (i.e. the index *before* the first instruction)
	   and YIELD_VALUE doesn't fiddle with f_lasti any more.  So this
	   does work.  Promise.

	   When the PREDICT() macros are enabled, some opcode pairs follow in
           direct succession without updating f-&gt;f_lasti.  A successful
           prediction effectively links the two codes together as if they
           were a single new opcode; accordingly,f-&gt;f_lasti will point to
           the first code in the pair (for instance, GET_ITER followed by
           FOR_ITER is effectively a single opcode and f-&gt;f_lasti will point
           at to the beginning of the combined pair.)
	*/</comment>
	<expr_stmt><expr><name>next_instr</name> = <name>first_instr</name> + <name><name>f</name>-&gt;<name>f_lasti</name></name> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>stack_pointer</name> = <name><name>f</name>-&gt;<name>f_stacktop</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stack_pointer</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name>-&gt;<name>f_stacktop</name></name> = <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* remains NULL unless yield suspends frame */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LLTRACE</name></cpp:ifdef>
	<expr_stmt><expr><name>lltrace</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>, <argument><expr>"__lltrace__"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>LLTRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>filename</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>why</name> = <name>WHY_NOT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>err</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <name>Py_None</name></expr>;</expr_stmt>	<comment type="block">/* Not a reference, just anything non-NULL */</comment>
	<expr_stmt><expr><name>w</name> = <name>NULL</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>throwflag</name></expr>)</condition><then> <block>{ <comment type="block">/* support for generator.throw() */</comment>
		<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
		<goto>goto <name>on_error</name>;</goto>
	}</block></then></if>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_TSC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>inst1</name> == 0</expr>)</condition><then> <block>{
			<comment type="block">/* Almost surely, the opcode executed a break
			   or a continue, preventing inst1 from being set
			   on the way out of the loop.
			*/</comment>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>inst1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>loop1</name> = <name>inst1</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>dump_tsc</name><argument_list>(<argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>ticked</name></expr></argument>, <argument><expr><name>inst0</name></expr></argument>, <argument><expr><name>inst1</name></expr></argument>, <argument><expr><name>loop0</name></expr></argument>, <argument><expr><name>loop1</name></expr></argument>,
			 <argument><expr><name>intr0</name></expr></argument>, <argument><expr><name>intr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ticked</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>inst1</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>intr0</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>intr1</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>loop0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stack_pointer</name> &gt;= <name><name>f</name>-&gt;<name>f_valuestack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* else underflow */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>STACK_LEVEL</name><argument_list>()</argument_list></call> &lt;= <name><name>co</name>-&gt;<name>co_stacksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* else overflow */</comment>

		<comment type="block">/* Do periodic things.  Doing this every time through
		   the loop would add too much overhead, so we do it
		   only every Nth instruction.  We also do it if
		   ``things_to_do'' is set, i.e. when an asynchronous
		   event needs attention (e.g. a signal handler or
		   async I/O handler); see Py_AddPendingCall() and
		   Py_MakePendingCalls() above. */</comment>

		<if>if <condition>(<expr>--<name>_Py_Ticker</name> &lt; 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr>*<name>next_instr</name> == <name>SETUP_FINALLY</name></expr>)</condition><then> <block>{
				<comment type="block">/* Make the last opcode before
				   a try: finally: block uninterruptable. */</comment>
				<goto>goto <name>fast_next_opcode</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name>_Py_Ticker</name> = <name>_Py_CheckInterval</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tick_counter</name></name>++</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_TSC</name></cpp:ifdef>
			<expr_stmt><expr><name>ticked</name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if>if <condition>(<expr><name>things_to_do</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>Py_MakePendingCalls</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
					<goto>goto <name>on_error</name>;</goto>
				}</block></then></if>
				<if>if <condition>(<expr><name>things_to_do</name></expr>)</condition><then>
					<comment type="block">/* MakePendingCalls() didn't succeed.
					   Force early re-execution of this
					   "periodic" code, possibly after
					   a thread switch */</comment>
					<expr_stmt><expr><name>_Py_Ticker</name> = 0</expr>;</expr_stmt></then></if>
			}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
			<if>if <condition>(<expr><name>interpreter_lock</name></expr>)</condition><then> <block>{
				<comment type="block">/* Give another thread a chance */</comment>

				<if>if <condition>(<expr><call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != <name>tstate</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"ceval: tstate mix-up"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Other threads may run now */</comment>

				<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>interpreter_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>PyThreadState_Swap</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"ceval: orphan tstate"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

				<comment type="block">/* Check for thread interrupts */</comment>

				<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>async_exc</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>x</name> = <name><name>tstate</name>-&gt;<name>async_exc</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tstate</name>-&gt;<name>async_exc</name></name> = <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PyErr_SetNone</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
					<goto>goto <name>on_error</name>;</goto>
				}</block></then></if>
			}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></then></if>

	<label><name>fast_next_opcode</name>:</label>
		<expr_stmt><expr><name><name>f</name>-&gt;<name>f_lasti</name></name> = <call><name>INSTR_OFFSET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* line-by-line tracing support */</comment>

		<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name> &amp;&amp; !<name><name>tstate</name>-&gt;<name>tracing</name></name></expr>)</condition><then> <block>{
			<comment type="block">/* see maybe_call_line_trace
			   for expository comments */</comment>
			<expr_stmt><expr><name><name>f</name>-&gt;<name>f_stacktop</name></name> = <name>stack_pointer</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>err</name> = <call><name>maybe_call_line_trace</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name></expr></argument>,
						    <argument><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name></expr></argument>,
						    <argument><expr><name>f</name></expr></argument>, <argument><expr>&amp;<name>instr_lb</name></expr></argument>, <argument><expr>&amp;<name>instr_ub</name></expr></argument>,
						    <argument><expr>&amp;<name>instr_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Reload possibly changed frame fields */</comment>
			<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_lasti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_stacktop</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>stack_pointer</name> = <name><name>f</name>-&gt;<name>f_stacktop</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>f</name>-&gt;<name>f_stacktop</name></name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
				<comment type="block">/* trace function raised an exception */</comment>
				<goto>goto <name>on_error</name>;</goto>
			}</block></then></if>
		}</block></then></if>

		<comment type="block">/* Extract opcode and argument */</comment>

		<expr_stmt><expr><name>opcode</name> = <call><name>NEXTOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oparg</name> = 0</expr>;</expr_stmt>   <comment type="block">/* allows oparg to be stored in a register because
			it doesn't have to be remembered across a full loop */</comment>
		<if>if <condition>(<expr><call><name>HAS_ARG</name><argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>oparg</name> = <call><name>NEXTARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	  <label><name>dispatch_opcode</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DYNAMIC_EXECUTION_PROFILE</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DXPAIRS</name></cpp:ifdef>
		<expr_stmt><expr><name><name>dxpairs</name><index>[<expr><name>lastopcode</name></expr>]</index><index>[<expr><name>opcode</name></expr>]</index></name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>lastopcode</name> = <name>opcode</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>dxp</name><index>[<expr><name>opcode</name></expr>]</index></name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LLTRACE</name></cpp:ifdef>
		<comment type="block">/* Instruction tracing */</comment>

		<if>if <condition>(<expr><name>lltrace</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>HAS_ARG</name><argument_list>(<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%d: %d, %d\n"</expr></argument>,
				       <argument><expr><name><name>f</name>-&gt;<name>f_lasti</name></name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%d: %d\n"</expr></argument>,
				       <argument><expr><name><name>f</name>-&gt;<name>f_lasti</name></name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Main switch on opcode */</comment>
		<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>inst0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{

		<comment type="block">/* BEWARE!
		   It is essential that any operation that fails sets either
		   x to NULL, err to nonzero, or why to anything but WHY_NOT,
		   and that no operation that succeeds does this! */</comment>

		<comment type="block">/* case STOP_CODE: this is an error! */</comment>

		<case>case <expr><name>NOP</name></expr>:
			<goto>goto <name>fast_next_opcode</name>;</goto>

		</case><case>case <expr><name>LOAD_FAST</name></expr>:
			<expr_stmt><expr><name>x</name> = <call><name>GETLOCAL</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fast_next_opcode</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><call><name>format_exc_check_arg</name><argument_list>(<argument><expr><name>PyExc_UnboundLocalError</name></expr></argument>,
				<argument><expr><name>UNBOUNDLOCAL_ERROR_MSG</name></expr></argument>,
				<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_varnames</name></name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>LOAD_CONST</name></expr>:
			<expr_stmt><expr><name>x</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>consts</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fast_next_opcode</name>;</goto>

		<expr_stmt><expr><call><name>PREDICTED_WITH_ARG</name><argument_list>(<argument><expr><name>STORE_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</case><case>case <expr><name>STORE_FAST</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SETLOCAL</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fast_next_opcode</name>;</goto>

		<expr_stmt><expr><call><name>PREDICTED</name><argument_list>(<argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</case><case>case <expr><name>POP_TOP</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fast_next_opcode</name>;</goto>

		</case><case>case <expr><name>ROT_TWO</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_SECOND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fast_next_opcode</name>;</goto>

		</case><case>case <expr><name>ROT_THREE</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>THIRD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_SECOND</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_THIRD</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fast_next_opcode</name>;</goto>

		</case><case>case <expr><name>ROT_FOUR</name></expr>:
			<expr_stmt><expr><name>u</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> = <call><name>THIRD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>FOURTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_SECOND</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_THIRD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_FOURTH</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fast_next_opcode</name>;</goto>

		</case><case>case <expr><name>DUP_TOP</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fast_next_opcode</name>;</goto>

		</case><case>case <expr><name>DUP_TOPX</name></expr>:
			<if>if <condition>(<expr><name>oparg</name> == 2</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>x</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>w</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_SECOND</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fast_next_opcode</name>;</goto>
			}</block></then> <else>else <if>if <condition>(<expr><name>oparg</name> == 3</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>x</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>w</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>v</name> = <call><name>THIRD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_SECOND</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_THIRD</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fast_next_opcode</name>;</goto>
			}</block></then></if></else></if>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"invalid argument to DUP_TOPX"
				      " (bytecode corruption?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>UNARY_POSITIVE</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Positive</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>UNARY_NEGATIVE</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Negative</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>UNARY_NOT</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>err</name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>Py_False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>err</name> = 0</expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if></else></if>
			<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>UNARY_CONVERT</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>UNARY_INVERT</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Invert</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_POWER</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Power</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_MULTIPLY</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Multiply</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_DIVIDE</name></expr>:
			<if>if <condition>(<expr>!<name>_Py_QnewFlag</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Divide</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
				<break>break;</break>
			}</block></then></if>
			<comment type="block">/* -Qnew is in effect:	fall through to
			   BINARY_TRUE_DIVIDE */</comment>
		</case><case>case <expr><name>BINARY_TRUE_DIVIDE</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_TrueDivide</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_FLOOR_DIVIDE</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_FloorDivide</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_MODULO</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Remainder</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_ADD</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* INLINE: int + int */</comment>
				<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>a</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>b</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> = <name>a</name> + <name>b</name></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>i</name>^<name>a</name>) &lt; 0 &amp;&amp; (<name>i</name>^<name>b</name>) &lt; 0</expr>)</condition><then>
					<goto>goto <name>slow_add</name>;</goto></then></if>
				<expr_stmt><expr><name>x</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp;
				 <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>x</name> = <call><name>string_concatenate</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>next_instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* string_concatenate consumed the ref to v */</comment>
				<goto>goto <name>skip_decref_vx</name>;</goto>
			}</block></then>
			<else>else <block>{
			  <label><name>slow_add</name>:</label>
				<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <label><name>skip_decref_vx</name>:</label>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_SUBTRACT</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* INLINE: int - int */</comment>
				<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>a</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>b</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> = <name>a</name> - <name>b</name></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>i</name>^<name>a</name>) &lt; 0 &amp;&amp; (<name>i</name>^~<name>b</name>) &lt; 0</expr>)</condition><then>
					<goto>goto <name>slow_sub</name>;</goto></then></if>
				<expr_stmt><expr><name>x</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
			  <label><name>slow_sub</name>:</label>
				<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Subtract</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_SUBSCR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* INLINE: list[int] */</comment>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
					<expr_stmt><expr><name>i</name> += <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; <name>i</name> &lt; <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>x</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then>
				<else>else
					<goto>goto <name>slow_get</name>;</goto></else></if>
			}</block></then>
			<else>else
			  <label><name>slow_get</name>:</label>
				<expr_stmt><expr><name>x</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_LSHIFT</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Lshift</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_RSHIFT</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Rshift</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_AND</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_And</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_XOR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Xor</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BINARY_OR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_Or</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>LIST_APPEND</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PREDICT</name><argument_list>(<argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_POWER</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlacePower</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_MULTIPLY</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceMultiply</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_DIVIDE</name></expr>:
			<if>if <condition>(<expr>!<name>_Py_QnewFlag</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceDivide</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
				<break>break;</break>
			}</block></then></if>
			<comment type="block">/* -Qnew is in effect:	fall through to
			   INPLACE_TRUE_DIVIDE */</comment>
		</case><case>case <expr><name>INPLACE_TRUE_DIVIDE</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceTrueDivide</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_FLOOR_DIVIDE</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceFloorDivide</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_MODULO</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceRemainder</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_ADD</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* INLINE: int + int */</comment>
				<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>a</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>b</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> = <name>a</name> + <name>b</name></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>i</name>^<name>a</name>) &lt; 0 &amp;&amp; (<name>i</name>^<name>b</name>) &lt; 0</expr>)</condition><then>
					<goto>goto <name>slow_iadd</name>;</goto></then></if>
				<expr_stmt><expr><name>x</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp;
				 <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>x</name> = <call><name>string_concatenate</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>next_instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* string_concatenate consumed the ref to v */</comment>
				<goto>goto <name>skip_decref_v</name>;</goto>
			}</block></then>
			<else>else <block>{
			  <label><name>slow_iadd</name>:</label>
				<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceAdd</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <label><name>skip_decref_v</name>:</label>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_SUBTRACT</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* INLINE: int - int */</comment>
				<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>a</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>b</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> = <name>a</name> - <name>b</name></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>i</name>^<name>a</name>) &lt; 0 &amp;&amp; (<name>i</name>^~<name>b</name>) &lt; 0</expr>)</condition><then>
					<goto>goto <name>slow_isub</name>;</goto></then></if>
				<expr_stmt><expr><name>x</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
			  <label><name>slow_isub</name>:</label>
				<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceSubtract</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_LSHIFT</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceLshift</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_RSHIFT</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceRshift</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_AND</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceAnd</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_XOR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceXor</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>INPLACE_OR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_InPlaceOr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>SLICE</name>+0</expr>:
		</case><case>case <expr><name>SLICE</name>+1</expr>:
		</case><case>case <expr><name>SLICE</name>+2</expr>:
		</case><case>case <expr><name>SLICE</name>+3</expr>:
			<if>if <condition>(<expr>(<name>opcode</name>-<name>SLICE</name>) &amp; 2</expr>)</condition><then>
				<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>w</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr>(<name>opcode</name>-<name>SLICE</name>) &amp; 1</expr>)</condition><then>
				<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><name>u</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>apply_slice</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>STORE_SLICE</name>+0</expr>:
		</case><case>case <expr><name>STORE_SLICE</name>+1</expr>:
		</case><case>case <expr><name>STORE_SLICE</name>+2</expr>:
		</case><case>case <expr><name>STORE_SLICE</name>+3</expr>:
			<if>if <condition>(<expr>(<name>opcode</name>-<name>STORE_SLICE</name>) &amp; 2</expr>)</condition><then>
				<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>w</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr>(<name>opcode</name>-<name>STORE_SLICE</name>) &amp; 1</expr>)</condition><then>
				<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><name>u</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>assign_slice</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* u[v:w] = t */</comment>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>DELETE_SLICE</name>+0</expr>:
		</case><case>case <expr><name>DELETE_SLICE</name>+1</expr>:
		</case><case>case <expr><name>DELETE_SLICE</name>+2</expr>:
		</case><case>case <expr><name>DELETE_SLICE</name>+3</expr>:
			<if>if <condition>(<expr>(<name>opcode</name>-<name>DELETE_SLICE</name>) &amp; 2</expr>)</condition><then>
				<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>w</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr>(<name>opcode</name>-<name>DELETE_SLICE</name>) &amp; 1</expr>)</condition><then>
				<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><name>u</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>assign_slice</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<comment type="block">/* del u[v:w] */</comment>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>STORE_SUBSCR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>u</name> = <call><name>THIRD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>-3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* v[w] = u */</comment>
			<expr_stmt><expr><name>err</name> = <call><name>PyObject_SetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>DELETE_SUBSCR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* del v[w] */</comment>
			<expr_stmt><expr><name>err</name> = <call><name>PyObject_DelItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>PRINT_EXPR</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"displayhook"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
						<argument><expr>"lost sys.displayhook"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt>
				<expr_stmt><expr><name>x</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>x</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt></then></if>
			}</block></then></if>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>w</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt></then></if>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>PRINT_ITEM_TO</name></expr>:
			<expr_stmt><expr><name>w</name> = <name>stream</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* fall through to PRINT_ITEM */</comment>

		</case><case>case <expr><name>PRINT_ITEM</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>stream</name> == <name>NULL</name> || <name>stream</name> == <name>Py_None</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>w</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
							<argument><expr>"lost sys.stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt>
				}</block></then></if>
			}</block></then></if>
			<comment type="block">/* PyFile_SoftSpace() can exececute arbitrary code
			   if sys.stdout is an instance with a __getattr__.
			   If __getattr__ raises an exception, w will
			   be freed, so we need to prevent that temporarily. */</comment>
			<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>w</name> != <name>NULL</name> &amp;&amp; <call><name>PyFile_SoftSpace</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteString</name><argument_list>(<argument><expr>" "</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>Py_PRINT_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
			    <comment type="block">/* XXX move into writeobject() ? */</comment>
			    <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>len</name> == 0 ||
				    !<call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> ||
				    <name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name> == ' '</expr>)</condition><then>
					<expr_stmt><expr><call><name>PyFile_SoftSpace</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			    }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
			    <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>len</name> == 0 ||
				    !<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name></expr></argument>)</argument_list></call> ||
				    <name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name> == ' '</expr>)</condition><then>
				    <expr_stmt><expr><call><name>PyFile_SoftSpace</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			    <else>else
			    	<expr_stmt><expr><call><name>PyFile_SoftSpace</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stream</name> = <name>NULL</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
				<continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>PRINT_NEWLINE_TO</name></expr>:
			<expr_stmt><expr><name>w</name> = <name>stream</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* fall through to PRINT_NEWLINE */</comment>

		</case><case>case <expr><name>PRINT_NEWLINE</name></expr>:
			<if>if <condition>(<expr><name>stream</name> == <name>NULL</name> || <name>stream</name> == <name>Py_None</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>w</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
							<argument><expr>"lost sys.stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			}</block></then></if>
			<if>if <condition>(<expr><name>w</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<comment type="block">/* w.write() may replace sys.stdout, so we
				 * have to keep our reference to it */</comment>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
					<expr_stmt><expr><call><name>PyFile_SoftSpace</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stream</name> = <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASE_TOO_BIG</name></cpp:ifdef>
		</case><default>default: <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<case>case <expr><name>RAISE_VARARGS</name></expr>:
			<expr_stmt><expr><name>u</name> = <name>v</name> = <name>w</name> = <name>NULL</name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>oparg</name></expr>)</condition> <block>{
			<case>case <expr>3</expr>:
				<expr_stmt><expr><name>u</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* traceback */</comment>
				<comment type="block">/* Fallthrough */</comment>
			</case><case>case <expr>2</expr>:
				<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* value */</comment>
				<comment type="block">/* Fallthrough */</comment>
			</case><case>case <expr>1</expr>:
				<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* exc */</comment>
			</case><case>case <expr>0</expr>: <comment type="block">/* Fallthrough */</comment>
				<expr_stmt><expr><name>why</name> = <call><name>do_raise</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><default>default:
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					   <argument><expr>"bad RAISE_VARARGS oparg"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
				<break>break;</break>
			</default>}</block></switch>
			<break>break;</break>

		</case><case>case <expr><name>LOAD_LOCALS</name></expr>:
			<if>if <condition>(<expr>(<name>x</name> = <name><name>f</name>-&gt;<name>f_locals</name></name>) != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"no locals"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>RETURN_VALUE</name></expr>:
			<expr_stmt><expr><name>retval</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>why</name> = <name>WHY_RETURN</name></expr>;</expr_stmt>
			<goto>goto <name>fast_block_end</name>;</goto>

		</case><case>case <expr><name>YIELD_VALUE</name></expr>:
			<expr_stmt><expr><name>retval</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>f</name>-&gt;<name>f_stacktop</name></name> = <name>stack_pointer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>why</name> = <name>WHY_YIELD</name></expr>;</expr_stmt>
			<goto>goto <name>fast_yield</name>;</goto>

		</case><case>case <expr><name>EXEC_STMT</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>u</name> = <call><name>THIRD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>-3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>exec_statement</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>POP_BLOCK</name></expr>:
			<block>{
				<decl_stmt><decl><type><name>PyTryBlock</name> *</type><name>b</name> <init>= <expr><call><name>PyFrame_BlockPop</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<while>while <condition>(<expr><call><name>STACK_LEVEL</name><argument_list>()</argument_list></call> &gt; <name><name>b</name>-&gt;<name>b_level</name></name></expr>)</condition> <block>{
					<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></while>
			}</block>
			<continue>continue;</continue>

		<expr_stmt><expr><call><name>PREDICTED</name><argument_list>(<argument><expr><name>END_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</case><case>case <expr><name>END_FINALLY</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>why</name> = (enum <name>why_code</name>) <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>why</name> != <name>WHY_YIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>why</name> == <name>WHY_RETURN</name> ||
				    <name>why</name> == <name>WHY_CONTINUE</name></expr>)</condition><then>
					<expr_stmt><expr><name>retval</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
			}</block></then>
			<else>else <if>if <condition>(<expr><call><name>PyExceptionClass_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> ||
			         <call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>u</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>why</name> = <name>WHY_RERAISE</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>v</name> != <name>Py_None</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"'finally' pops bad exception"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
			}</block></then></if></else></if></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>BUILD_CLASS</name></expr>:
			<expr_stmt><expr><name>u</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> = <call><name>THIRD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>build_class</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>STORE_NAME</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>x</name> = <name><name>f</name>-&gt;<name>f_locals</name></name>) != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>err</name> = <call><name>PyObject_SetItem</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				     <argument><expr>"no locals found when storing %s"</expr></argument>,
				     <argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>DELETE_NAME</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>x</name> = <name><name>f</name>-&gt;<name>f_locals</name></name>) != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>(<name>err</name> = <call><name>PyObject_DelItem</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<expr_stmt><expr><call><name>format_exc_check_arg</name><argument_list>(<argument><expr><name>PyExc_NameError</name></expr></argument>,
							     <argument><expr><name>NAME_ERROR_MSG</name></expr></argument>,
							     <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				     <argument><expr>"no locals when deleting %s"</expr></argument>,
				     <argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<expr_stmt><expr><call><name>PREDICTED_WITH_ARG</name><argument_list>(<argument><expr><name>UNPACK_SEQUENCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</case><case>case <expr><name>UNPACK_SEQUENCE</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp;
			    <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == <name>oparg</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>PyObject</name> **</type><name>items</name> <init>= \
					<expr>((<name>PyTupleObject</name> *)<name>v</name>)-&gt;<name>ob_item</name></expr></init></decl>;</decl_stmt>
				<while>while <condition>(<expr><name>oparg</name>--</expr>)</condition> <block>{
					<expr_stmt><expr><name>w</name> = <name><name>items</name><index>[<expr><name>oparg</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></while>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then> <else>else <if>if <condition>(<expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp;
				   <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == <name>oparg</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>PyObject</name> **</type><name>items</name> <init>= \
					<expr>((<name>PyListObject</name> *)<name>v</name>)-&gt;<name>ob_item</name></expr></init></decl>;</decl_stmt>
				<while>while <condition>(<expr><name>oparg</name>--</expr>)</condition> <block>{
					<expr_stmt><expr><name>w</name> = <name><name>items</name><index>[<expr><name>oparg</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></while>
			}</block></then> <else>else <if>if <condition>(<expr><call><name>unpack_iterable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>,
						   <argument><expr><name>stack_pointer</name> + <name>oparg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>stack_pointer</name> += <name>oparg</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<comment type="block">/* unpack_iterable() raised an exception */</comment>
				<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
			}</block></else></if></else></if></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>STORE_ATTR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>u</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>PyObject_SetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* v.w = u */</comment>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>DELETE_ATTR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>PyObject_SetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<comment type="block">/* del v.w */</comment>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>STORE_GLOBAL</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>DELETE_GLOBAL</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>err</name> = <call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>format_exc_check_arg</name><argument_list>(
				    <argument><expr><name>PyExc_NameError</name></expr></argument>, <argument><expr><name>GLOBAL_NAME_ERROR_MSG</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<break>break;</break>

		</case><case>case <expr><name>LOAD_NAME</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>v</name> = <name><name>f</name>-&gt;<name>f_locals</name></name>) == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					     <argument><expr>"no locals when loading %s"</expr></argument>,
					     <argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>x</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name>x</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>x</name> == <name>NULL</name> &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
					<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(
							<argument><expr><name>PyExc_KeyError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
						<break>break;</break></then></if>
					<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></else></if>
			<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>x</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>x</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_builtins</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>format_exc_check_arg</name><argument_list>(
							    <argument><expr><name>PyExc_NameError</name></expr></argument>,
							    <argument><expr><name>NAME_ERROR_MSG</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					}</block></then></if>
				}</block></then></if>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>

		</case><case>case <expr><name>LOAD_GLOBAL</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* Inline the PyDict_GetItem() calls.
				   WARNING: this is an extreme speed hack.
				   Do not try this at home. */</comment>
				<decl_stmt><decl><type><name>long</name></type> <name>hash</name> <init>= <expr>((<name>PyStringObject</name> *)<name>w</name>)-&gt;<name>ob_shash</name></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>hash</name> != -1</expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>PyDictObject</name> *</type><name>d</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>e</name></decl>;</decl_stmt>
					<expr_stmt><expr><name>d</name> = <call>(<name>PyDictObject</name> *)<argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>e</name> = <call><name><name>d</name>-&gt;<name>ma_lookup</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>e</name> == <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>x</name> = <name>NULL</name></expr>;</expr_stmt>
						<break>break;</break>
					}</block></then></if>
					<expr_stmt><expr><name>x</name> = <name><name>e</name>-&gt;<name>me_value</name></name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					}</block></then></if>
					<expr_stmt><expr><name>d</name> = <call>(<name>PyDictObject</name> *)<argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_builtins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>e</name> = <call><name><name>d</name>-&gt;<name>ma_lookup</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>e</name> == <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>x</name> = <name>NULL</name></expr>;</expr_stmt>
						<break>break;</break>
					}</block></then></if>
					<expr_stmt><expr><name>x</name> = <name><name>e</name>-&gt;<name>me_value</name></name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					}</block></then></if>
					<goto>goto <name>load_global_error</name>;</goto>
				}</block></then></if>
			}</block></then></if>
			<comment type="block">/* This is the un-inlined version of the code above */</comment>
			<expr_stmt><expr><name>x</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>x</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_builtins</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
				  <label><name>load_global_error</name>:</label>
					<expr_stmt><expr><call><name>format_exc_check_arg</name><argument_list>(
						    <argument><expr><name>PyExc_NameError</name></expr></argument>,
						    <argument><expr><name>GLOBAL_NAME_ERROR_MSG</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				}</block></then></if>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>

		</case><case>case <expr><name>DELETE_FAST</name></expr>:
			<expr_stmt><expr><name>x</name> = <call><name>GETLOCAL</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>SETLOCAL</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<expr_stmt><expr><call><name>format_exc_check_arg</name><argument_list>(
				<argument><expr><name>PyExc_UnboundLocalError</name></expr></argument>,
				<argument><expr><name>UNBOUNDLOCAL_ERROR_MSG</name></expr></argument>,
				<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_varnames</name></name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>LOAD_CLOSURE</name></expr>:
			<expr_stmt><expr><name>x</name> = <name><name>freevars</name><index>[<expr><name>oparg</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>LOAD_DEREF</name></expr>:
			<expr_stmt><expr><name>x</name> = <name><name>freevars</name><index>[<expr><name>oparg</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> = <call><name>PyCell_Get</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>w</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt>
			<comment type="block">/* Don't stomp existing exception */</comment>
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<break>break;</break></then></if>
			<if>if <condition>(<expr><name>oparg</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_cellvars</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_cellvars</name></name></expr></argument>,
						       <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			       <expr_stmt><expr><call><name>format_exc_check_arg</name><argument_list>(
				       <argument><expr><name>PyExc_UnboundLocalError</name></expr></argument>,
				       <argument><expr><name>UNBOUNDLOCAL_ERROR_MSG</name></expr></argument>,
				       <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_freevars</name></name></expr></argument>, <argument><expr><name>oparg</name> -
					<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_cellvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>format_exc_check_arg</name><argument_list>(<argument><expr><name>PyExc_NameError</name></expr></argument>,
						     <argument><expr><name>UNBOUNDFREE_ERROR_MSG</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<break>break;</break>

		</case><case>case <expr><name>STORE_DEREF</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <name><name>freevars</name><index>[<expr><name>oparg</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyCell_Set</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>

		</case><case>case <expr><name>BUILD_TUPLE</name></expr>:
			<expr_stmt><expr><name>x</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<for>for (<init>;</init> <condition><expr>--<name>oparg</name> &gt;= 0</expr>;</condition><incr/>) <block>{
					<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></for>
				<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BUILD_LIST</name></expr>:
			<expr_stmt><expr><name>x</name> =  <call><name>PyList_New</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<for>for (<init>;</init> <condition><expr>--<name>oparg</name> &gt;= 0</expr>;</condition><incr/>) <block>{
					<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></for>
				<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<break>break;</break>

		</case><case>case <expr><name>BUILD_MAP</name></expr>:
			<expr_stmt><expr><name>x</name> = <call><name>_PyDict_NewPresized</name><argument_list>(<argument><expr>(<name>Py_ssize_t</name>)<name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>STORE_MAP</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* key */</comment>
			<expr_stmt><expr><name>u</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* value */</comment>
			<expr_stmt><expr><name>v</name> = <call><name>THIRD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* dict */</comment>
			<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* v[w] = u */</comment>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>LOAD_ATTR</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>COMPARE_OP</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* INLINE: cmp(int, int) */</comment>
				<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>res</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>a</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>b</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name>oparg</name></expr>)</condition> <block>{
				<case>case <expr><name>PyCmp_LT</name></expr>: <expr_stmt><expr><name>res</name> = <name>a</name> &lt;  <name>b</name></expr>;</expr_stmt> <break>break;</break>
				</case><case>case <expr><name>PyCmp_LE</name></expr>: <expr_stmt><expr><name>res</name> = <name>a</name> &lt;= <name>b</name></expr>;</expr_stmt> <break>break;</break>
				</case><case>case <expr><name>PyCmp_EQ</name></expr>: <expr_stmt><expr><name>res</name> = <name>a</name> == <name>b</name></expr>;</expr_stmt> <break>break;</break>
				</case><case>case <expr><name>PyCmp_NE</name></expr>: <expr_stmt><expr><name>res</name> = <name>a</name> != <name>b</name></expr>;</expr_stmt> <break>break;</break>
				</case><case>case <expr><name>PyCmp_GT</name></expr>: <expr_stmt><expr><name>res</name> = <name>a</name> &gt;  <name>b</name></expr>;</expr_stmt> <break>break;</break>
				</case><case>case <expr><name>PyCmp_GE</name></expr>: <expr_stmt><expr><name>res</name> = <name>a</name> &gt;= <name>b</name></expr>;</expr_stmt> <break>break;</break>
				</case><case>case <expr><name>PyCmp_IS</name></expr>: <expr_stmt><expr><name>res</name> = <name>v</name> == <name>w</name></expr>;</expr_stmt> <break>break;</break>
				</case><case>case <expr><name>PyCmp_IS_NOT</name></expr>: <expr_stmt><expr><name>res</name> = <name>v</name> != <name>w</name></expr>;</expr_stmt> <break>break;</break>
				</case><default>default: <goto>goto <name>slow_compare</name>;</goto>
				</default>}</block></switch>
				<expr_stmt><expr><name>x</name> = <name>res</name> ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
			  <label><name>slow_compare</name>:</label>
				<expr_stmt><expr><name>x</name> = <call><name>cmp_outcome</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <break>break;</break></then></if>
			<expr_stmt><expr><call><name>PREDICT</name><argument_list>(<argument><expr><name>JUMP_IF_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PREDICT</name><argument_list>(<argument><expr><name>JUMP_IF_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>

		</case><case>case <expr><name>IMPORT_NAME</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_builtins</name></name></expr></argument>, <argument><expr>"__import__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
						<argument><expr>"__import__ not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>u</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> != -1 || <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>w</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>5</expr></argument>,
					    <argument><expr><name>w</name></expr></argument>,
					    <argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>,
					    <argument><expr><name><name>f</name>-&gt;<name>f_locals</name></name> == <name>NULL</name> ?
						  <name>Py_None</name> : <name><name>f</name>-&gt;<name>f_locals</name></name></expr></argument>,
					    <argument><expr><name>v</name></expr></argument>,
					    <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>w</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>4</expr></argument>,
					    <argument><expr><name>w</name></expr></argument>,
					    <argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>,
					    <argument><expr><name><name>f</name>-&gt;<name>f_locals</name></name> == <name>NULL</name> ?
						  <name>Py_None</name> : <name><name>f</name>-&gt;<name>f_locals</name></name></expr></argument>,
					    <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>u</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>x</name> = <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <name>x</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>IMPORT_STAR</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyFrame_FastToLocals</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>x</name> = <name><name>f</name>-&gt;<name>f_locals</name></name>) == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"no locals found during 'import *'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>import_all_from</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyFrame_LocalsToFast</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>IMPORT_FROM</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>import_from</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>JUMP_FORWARD</name></expr>:
			<expr_stmt><expr><call><name>JUMPBY</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fast_next_opcode</name>;</goto>

		<expr_stmt><expr><call><name>PREDICTED_WITH_ARG</name><argument_list>(<argument><expr><name>JUMP_IF_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</case><case>case <expr><name>JUMP_IF_FALSE</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>w</name> == <name>Py_True</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PREDICT</name><argument_list>(<argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fast_next_opcode</name>;</goto>
			}</block></then></if>
			<if>if <condition>(<expr><name>w</name> == <name>Py_False</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>JUMPBY</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fast_next_opcode</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name>err</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> &gt; 0</expr>)</condition><then>
				<expr_stmt><expr><name>err</name> = 0</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>JUMPBY</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<break>break;</break></else></if></else></if>
			<continue>continue;</continue>

		<expr_stmt><expr><call><name>PREDICTED_WITH_ARG</name><argument_list>(<argument><expr><name>JUMP_IF_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</case><case>case <expr><name>JUMP_IF_TRUE</name></expr>:
			<expr_stmt><expr><name>w</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>w</name> == <name>Py_False</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PREDICT</name><argument_list>(<argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fast_next_opcode</name>;</goto>
			}</block></then></if>
			<if>if <condition>(<expr><name>w</name> == <name>Py_True</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>JUMPBY</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fast_next_opcode</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name>err</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>err</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JUMPBY</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
				<empty_stmt>;</empty_stmt></then>
			<else>else
				<break>break;</break></else></if></else></if>
			<continue>continue;</continue>

		<expr_stmt><expr><call><name>PREDICTED_WITH_ARG</name><argument_list>(<argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</case><case>case <expr><name>JUMP_ABSOLUTE</name></expr>:
			<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FAST_LOOPS</name></expr></cpp:if>
			<comment type="block">/* Enabling this path speeds-up all while and for-loops by bypassing
                           the per-loop checks for signals.  By default, this should be turned-off
                           because it prevents detection of a control-break in tight loops like
                           "while 1: pass".  Compile with this option turned-on when you need
                           the speed-up and do not need break checking inside tight loops (ones
                           that contain only instructions ending with goto fast_next_opcode).
                        */</comment>
			<goto>goto <name>fast_next_opcode</name>;</goto>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		</case><case>case <expr><name>GET_ITER</name></expr>:
			<comment type="block">/* before: [obj]; after [getiter(obj)] */</comment>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PREDICT</name><argument_list>(<argument><expr><name>FOR_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<expr_stmt><expr><call><name>PREDICTED_WITH_ARG</name><argument_list>(<argument><expr><name>FOR_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</case><case>case <expr><name>FOR_ITER</name></expr>:
			<comment type="block">/* before: [iter]; after: [iter, iter()] *or* [] */</comment>
			<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call>(*<name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_iternext</name></name>)<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PREDICT</name><argument_list>(<argument><expr><name>STORE_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PREDICT</name><argument_list>(<argument><expr><name>UNPACK_SEQUENCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(
						<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<break>break;</break></then></if>
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<comment type="block">/* iterator ended normally */</comment>
 			<expr_stmt><expr><name>x</name> = <name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>JUMPBY</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>

		</case><case>case <expr><name>BREAK_LOOP</name></expr>:
			<expr_stmt><expr><name>why</name> = <name>WHY_BREAK</name></expr>;</expr_stmt>
			<goto>goto <name>fast_block_end</name>;</goto>

		</case><case>case <expr><name>CONTINUE_LOOP</name></expr>:
			<expr_stmt><expr><name>retval</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>retval</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>x</name> = <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><name>why</name> = <name>WHY_CONTINUE</name></expr>;</expr_stmt>
			<goto>goto <name>fast_block_end</name>;</goto>

		</case><case>case <expr><name>SETUP_LOOP</name></expr>:
		</case><case>case <expr><name>SETUP_EXCEPT</name></expr>:
		</case><case>case <expr><name>SETUP_FINALLY</name></expr>:
			<comment type="block">/* NOTE: If you add any new block-setup opcodes that
		           are not try/except/finally handlers, you may need
		           to update the PyGen_NeedsFinalizing() function.
		           */</comment>

			<expr_stmt><expr><call><name>PyFrame_BlockSetup</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><call><name>INSTR_OFFSET</name><argument_list>()</argument_list></call> + <name>oparg</name></expr></argument>,
					   <argument><expr><call><name>STACK_LEVEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>

		</case><case>case <expr><name>WITH_CLEANUP</name></expr>:
		<block>{
			<comment type="block">/* At the top of the stack are 1-3 values indicating
			   how/why we entered the finally clause:
			   - TOP = None
			   - (TOP, SECOND) = (WHY_{RETURN,CONTINUE}), retval
			   - TOP = WHY_*; no retval below it
			   - (TOP, SECOND, THIRD) = exc_info()
			   Below them is EXIT, the context.__exit__ bound method.
			   In the last case, we must call
			     EXIT(TOP, SECOND, THIRD)
			   otherwise we must call
			     EXIT(None, None, None)

			   In all cases, we remove EXIT from the stack, leaving
			   the rest in the same order.

			   In addition, if the stack represents an exception,
			   *and* the function call returns a 'true' value, we
			   "zap" this information, to prevent END_FINALLY from
			   re-raising the exception.  (But non-local gotos
			   should still be resumed.)
			*/</comment>

			<decl_stmt><decl><type><name>PyObject</name> *</type><name>exit_func</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>u</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>u</name> == <name>Py_None</name></expr>)</condition><then> <block>{
			       	<expr_stmt><expr><name>exit_func</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>v</name> = <name>w</name> = <name>Py_None</name></expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<switch>switch<condition>(<expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
				<case>case <expr><name>WHY_RETURN</name></expr>:
				</case><case>case <expr><name>WHY_CONTINUE</name></expr>:
					<comment type="block">/* Retval in TOP. */</comment>
					<expr_stmt><expr><name>exit_func</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SET_SECOND</name><argument_list>(<argument><expr><call><name>TOP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</case><default>default:
					<expr_stmt><expr><name>exit_func</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</default>}</block></switch>
				<expr_stmt><expr><name>u</name> = <name>v</name> = <name>w</name> = <name>Py_None</name></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name>v</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>w</name> = <call><name>SECOND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>exit_func</name> = <call><name>THIRD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_SECOND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_THIRD</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if></else></if>
			<comment type="block">/* XXX Not the fastest way to call it... */</comment>
			<expr_stmt><expr><name>x</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>exit_func</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>exit_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break> <comment type="block">/* Go to error exit */</comment>
			}</block></then></if>
			<if>if <condition>(<expr><name>u</name> != <name>Py_None</name> &amp;&amp; <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* There was an exception and a true return */</comment>
				<expr_stmt><expr><call><name>STACKADJ</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<comment type="block">/* The stack was rearranged to remove EXIT
				   above. Let END_FINALLY do its thing */</comment>
			}</block></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>exit_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PREDICT</name><argument_list>(<argument><expr><name>END_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block>

		</case><case>case <expr><name>CALL_FUNCTION</name></expr>:
		<block>{
			<decl_stmt><decl><type><name>PyObject</name> **</type><name>sp</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sp</name> = <name>stack_pointer</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_TSC</name></cpp:ifdef>
			<expr_stmt><expr><name>x</name> = <call><name>call_function</name><argument_list>(<argument><expr>&amp;<name>sp</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>, <argument><expr>&amp;<name>intr0</name></expr></argument>, <argument><expr>&amp;<name>intr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>x</name> = <call><name>call_function</name><argument_list>(<argument><expr>&amp;<name>sp</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>stack_pointer</name> = <name>sp</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then>
				<continue>continue;</continue></then></if>
			<break>break;</break>
		}</block>

		</case><case>case <expr><name>CALL_FUNCTION_VAR</name></expr>:
		</case><case>case <expr><name>CALL_FUNCTION_KW</name></expr>:
		</case><case>case <expr><name>CALL_FUNCTION_VAR_KW</name></expr>:
		<block>{
		    <decl_stmt><decl><type><name>int</name></type> <name>na</name> <init>= <expr><name>oparg</name> &amp; 0xff</expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>int</name></type> <name>nk</name> <init>= <expr>(<name>oparg</name>&gt;&gt;8) &amp; 0xff</expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr>(<name>opcode</name> - <name>CALL_FUNCTION</name>) &amp; 3</expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>na</name> + 2 * <name>nk</name></expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>PyObject</name> **</type><name>pfunc</name></decl>, *<decl><type ref="prev"/><name>func</name></decl>, **<decl><type ref="prev"/><name>sp</name></decl>;</decl_stmt>
		    <expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>flags</name> &amp; <name>CALL_FLAG_VAR</name></expr>)</condition><then>
			    <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if>
		    <if>if <condition>(<expr><name>flags</name> &amp; <name>CALL_FLAG_KW</name></expr>)</condition><then>
			    <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if>
		    <expr_stmt><expr><name>pfunc</name> = <name>stack_pointer</name> - <name>n</name> - 1</expr>;</expr_stmt>
		    <expr_stmt><expr><name>func</name> = *<name>pfunc</name></expr>;</expr_stmt>

		    <if>if <condition>(<expr><call><name>PyMethod_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call>
			&amp;&amp; <call><name>PyMethod_GET_SELF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
			    <decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><call><name>PyMethod_GET_SELF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><name>func</name> = <call><name>PyMethod_GET_FUNCTION</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>pfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr>*<name>pfunc</name> = <name>self</name></expr>;</expr_stmt>
			    <expr_stmt><expr><name>na</name>++</expr>;</expr_stmt>
			    <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
		    }</block></then> <else>else
			    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		    <expr_stmt><expr><name>sp</name> = <name>stack_pointer</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>x</name> = <call><name>ext_do_call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>&amp;<name>sp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>intr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>stack_pointer</name> = <name>sp</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <while>while <condition>(<expr><name>stack_pointer</name> &gt; <name>pfunc</name></expr>)</condition> <block>{
			    <expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></while>
		    <expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then>
			    <continue>continue;</continue></then></if>
		    <break>break;</break>
		}</block>

		</case><case>case <expr><name>MAKE_FUNCTION</name></expr>:
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* code object */</comment>
			<expr_stmt><expr><name>x</name> = <call><name>PyFunction_New</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* XXX Maybe this should be a separate opcode? */</comment>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name> &amp;&amp; <name>oparg</name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>v</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>x</name> = <name>NULL</name></expr>;</expr_stmt>
					<break>break;</break>
				}</block></then></if>
				<while>while <condition>(<expr>--<name>oparg</name> &gt;= 0</expr>)</condition> <block>{
					<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></while>
				<expr_stmt><expr><name>err</name> = <call><name>PyFunction_SetDefaults</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>MAKE_CLOSURE</name></expr>:
		<block>{
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* code object */</comment>
			<expr_stmt><expr><name>x</name> = <call><name>PyFunction_New</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>err</name> = <call><name>PyFunction_SetClosure</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name> &amp;&amp; <name>oparg</name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>v</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>x</name> = <name>NULL</name></expr>;</expr_stmt>
					<break>break;</break>
				}</block></then></if>
				<while>while <condition>(<expr>--<name>oparg</name> &gt;= 0</expr>)</condition> <block>{
					<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>oparg</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></while>
				<expr_stmt><expr><name>err</name> = <call><name>PyFunction_SetDefaults</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block>

		</case><case>case <expr><name>BUILD_SLICE</name></expr>:
			<if>if <condition>(<expr><name>oparg</name> == 3</expr>)</condition><then>
				<expr_stmt><expr><name>w</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>w</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>u</name> = <call><name>TOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <call><name>PySlice_New</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_TOP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<break>break;</break>

		</case><case>case <expr><name>EXTENDED_ARG</name></expr>:
			<expr_stmt><expr><name>opcode</name> = <call><name>NEXTOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oparg</name> = <name>oparg</name>&lt;&lt;16 | <call><name>NEXTARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>dispatch_opcode</name>;</goto>

		</case><default>default:
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr>"XXX lineno: %d, opcode: %d\n"</expr></argument>,
				<argument><expr><call><name>PyCode_Addr2Line</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_code</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_lasti</name></name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"unknown opcode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
			<break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASE_TOO_BIG</name></cpp:ifdef>
		</default>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		</default>}</block></switch> <comment type="block">/* switch */</comment>

	    <label><name>on_error</name>:</label>

		<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>inst1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Quickly continue if no error occurred */</comment>

		<if>if <condition>(<expr><name>why</name> == <name>WHY_NOT</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>err</name> == 0 &amp;&amp; <name>x</name> != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECKEXC</name></cpp:ifdef>
				<comment type="block">/* This check is expensive! */</comment>
				<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr>"XXX undetected error\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>loop1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue> <comment type="block">/* Normal, fast path */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECKEXC</name></cpp:ifdef>
				}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			}</block></then></if>
			<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> = <name>Py_None</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = 0</expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* Double-check exception status */</comment>

		<if>if <condition>(<expr><name>why</name> == <name>WHY_EXCEPTION</name> || <name>why</name> == <name>WHY_RERAISE</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"error return without exception set"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECKEXC</name></cpp:ifdef>
		<else>else <block>{
			<comment type="block">/* This check is expensive! */</comment>
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"Stack unwind with exception "
					"set and why=%d"</expr></argument>, <argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Log traceback info if this is a real exception */</comment>

		<if>if <condition>(<expr><name>why</name> == <name>WHY_EXCEPTION</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyTraceBack_Here</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>call_exc_trace</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name></expr></argument>,
					       <argument><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>

		<comment type="block">/* For the rest, treat WHY_RERAISE as WHY_EXCEPTION */</comment>

		<if>if <condition>(<expr><name>why</name> == <name>WHY_RERAISE</name></expr>)</condition><then>
			<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt></then></if>

		<comment type="block">/* Unwind stacks if a (pseudo) exception occurred */</comment>

<label><name>fast_block_end</name>:</label>
		<while>while <condition>(<expr><name>why</name> != <name>WHY_NOT</name> &amp;&amp; <name><name>f</name>-&gt;<name>f_iblock</name></name> &gt; 0</expr>)</condition> <block>{
			<decl_stmt><decl><type><name>PyTryBlock</name> *</type><name>b</name> <init>= <expr><call><name>PyFrame_BlockPop</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>why</name> != <name>WHY_YIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_type</name></name> == <name>SETUP_LOOP</name> &amp;&amp; <name>why</name> == <name>WHY_CONTINUE</name></expr>)</condition><then> <block>{
				<comment type="block">/* For a continue inside a try block,
				   don't pop the block for the loop. */</comment>
				<expr_stmt><expr><call><name>PyFrame_BlockSetup</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>b_type</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>b_handler</name></name></expr></argument>,
						   <argument><expr><name><name>b</name>-&gt;<name>b_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>why</name> = <name>WHY_NOT</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>

			<while>while <condition>(<expr><call><name>STACK_LEVEL</name><argument_list>()</argument_list></call> &gt; <name><name>b</name>-&gt;<name>b_level</name></name></expr>)</condition> <block>{
				<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></while>
			<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_type</name></name> == <name>SETUP_LOOP</name> &amp;&amp; <name>why</name> == <name>WHY_BREAK</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>why</name> = <name>WHY_NOT</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>b_handler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_type</name></name> == <name>SETUP_FINALLY</name> ||
			    (<name><name>b</name>-&gt;<name>b_type</name></name> == <name>SETUP_EXCEPT</name> &amp;&amp;
			     <name>why</name> == <name>WHY_EXCEPTION</name>)</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>why</name> == <name>WHY_EXCEPTION</name></expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>val</name> = <name>Py_None</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then></if>
					<comment type="block">/* Make the raw exception data
					   available to the handler,
					   so a program can emulate the
					   Python main loop.  Don't do
					   this for 'finally'. */</comment>
					<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_type</name></name> == <name>SETUP_EXCEPT</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>PyErr_NormalizeException</name><argument_list>(
							<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_exc_info</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>,
							     <argument><expr><name>exc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then></if>
					<if>if <condition>(<expr><name>tb</name> == <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then> <else>else
						<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
					<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then>
				<else>else <block>{
					<if>if <condition>(<expr><name>why</name> &amp; (<name>WHY_RETURN</name> | <name>WHY_CONTINUE</name>)</expr>)</condition><then>
						<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
					<expr_stmt><expr><name>v</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>why</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></else></if>
				<expr_stmt><expr><name>why</name> = <name>WHY_NOT</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>b_handler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
		}</block></while> <comment type="block">/* unwind stack */</comment>

		<comment type="block">/* End the loop if we still have an error (or return) */</comment>

		<if>if <condition>(<expr><name>why</name> != <name>WHY_NOT</name></expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr><name>loop1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	}</block></for> <comment type="block">/* main loop */</comment>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>why</name> != <name>WHY_YIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Pop remaining stack entries. */</comment>
	<while>while <condition>(<expr>!<call><name>EMPTY</name><argument_list>()</argument_list></call></expr>)</condition> <block>{
		<expr_stmt><expr><name>v</name> = <call><name>POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

	<if>if <condition>(<expr><name>why</name> != <name>WHY_RETURN</name></expr>)</condition><then>
		<expr_stmt><expr><name>retval</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

<label><name>fast_yield</name>:</label>
	<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>why</name> == <name>WHY_RETURN</name> || <name>why</name> == <name>WHY_YIELD</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>call_trace</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name></expr></argument>,
					       <argument><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>,
					       <argument><expr><name>PyTrace_RETURN</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>retval</name> = <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
				}</block></then></if>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>why</name> == <name>WHY_EXCEPTION</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>call_trace_protected</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name></expr></argument>,
						     <argument><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>,
						     <argument><expr><name>PyTrace_RETURN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if></else></if>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>why</name> == <name>WHY_EXCEPTION</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>call_trace_protected</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name></expr></argument>,
						     <argument><expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>,
						     <argument><expr><name>PyTrace_RETURN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>call_trace</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name></expr></argument>,
					    <argument><expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>,
					    <argument><expr><name>PyTrace_RETURN</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>retval</name> = <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>why</name> = <name>WHY_EXCEPTION</name></expr>;</expr_stmt>
			}</block></then></if></else></if>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>frame</name>-&gt;<name>f_exc_type</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>reset_exc_info</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>frame</name>-&gt;<name>f_exc_value</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>frame</name>-&gt;<name>f_exc_traceback</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* pop frame */</comment>
<label><name>exit_eval_frame</name>:</label>
	<expr_stmt><expr><call><name>Py_LeaveRecursiveCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>frame</name></name> = <name><name>f</name>-&gt;<name>f_back</name></name></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<comment type="block">/* This is gonna seem *real weird*, but if you put some other code between
   PyEval_EvalFrame() and PyEval_EvalCodeEx() you will need to adjust
   the test in the if statements in Misc/gdbinit (pystack and pystackv). */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyEval_EvalCodeEx</name><parameter_list>(<param><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>,
	   <param><decl><type><name>PyObject</name> **</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>argcount</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>kws</name></decl></param>, <param><decl><type><name>int</name></type> <name>kwcount</name></decl></param>,
	   <param><decl><type><name>PyObject</name> **</type><name>defs</name></decl></param>, <param><decl><type><name>int</name></type> <name>defcount</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyFrameObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>PyObject</name> **</type><name>fastlocals</name></decl>, **<decl><type ref="prev"/><name>freevars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>, *<decl><type ref="prev"/><name>u</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>globals</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"PyEval_EvalCodeEx: NULL globals"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tstate</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>globals</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> = <call><name>PyFrame_New</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>fastlocals</name> = <name><name>f</name>-&gt;<name>f_localsplus</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>freevars</name> = <name><name>f</name>-&gt;<name>f_localsplus</name></name> + <name><name>co</name>-&gt;<name>co_nlocals</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>co</name>-&gt;<name>co_argcount</name></name> &gt; 0 ||
	    <name><name>co</name>-&gt;<name>co_flags</name></name> &amp; (<name>CO_VARARGS</name> | <name>CO_VARKEYWORDS</name>)</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>argcount</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>kwdict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>co</name>-&gt;<name>co_flags</name></name> &amp; <name>CO_VARKEYWORDS</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>kwdict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>kwdict</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>fail</name>;</goto></then></if>
			<expr_stmt><expr><name>i</name> = <name><name>co</name>-&gt;<name>co_argcount</name></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>co</name>-&gt;<name>co_flags</name></name> &amp; <name>CO_VARARGS</name></expr>)</condition><then>
				<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>SETLOCAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>argcount</name> &gt; <name><name>co</name>-&gt;<name>co_argcount</name></name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!(<name><name>co</name>-&gt;<name>co_flags</name></name> &amp; <name>CO_VARARGS</name>)</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				    <argument><expr>"%.200s() takes %s %d "
				    "%sargument%s (%d given)"</expr></argument>,
				    <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><name>defcount</name> ? "at most" : "exactly"</expr></argument>,
				    <argument><expr><name><name>co</name>-&gt;<name>co_argcount</name></name></expr></argument>,
				    <argument><expr><name>kwcount</name> ? "non-keyword " : ""</expr></argument>,
				    <argument><expr><name><name>co</name>-&gt;<name>co_argcount</name></name> == 1 ? "" : "s"</expr></argument>,
				    <argument><expr><name>argcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fail</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name>n</name> = <name><name>co</name>-&gt;<name>co_argcount</name></name></expr>;</expr_stmt>
		}</block></then></if>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>x</name> = <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SETLOCAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<if>if <condition>(<expr><name><name>co</name>-&gt;<name>co_flags</name></name> &amp; <name>CO_VARARGS</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>u</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>argcount</name> - <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>fail</name>;</goto></then></if>
			<expr_stmt><expr><call><name>SETLOCAL</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_argcount</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>i</name> = <name>n</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>argcount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name>x</name> = <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>i</name>-<name>n</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>
		}</block></then></if>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>kwcount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> **</type><name>co_varnames</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>keyword</name> <init>= <expr><name><name>kws</name><index>[<expr>2*<name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><name><name>kws</name><index>[<expr>2*<name>i</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>keyword</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				    <argument><expr>"%.200s() keywords must be strings"</expr></argument>,
				    <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fail</name>;</goto>
			}</block></then></if>
			<comment type="block">/* Speed hack: do raw pointer compares. As names are
			   normally interned this should almost always hit. */</comment>
			<expr_stmt><expr><name>co_varnames</name> = <call><name>PySequence_Fast_ITEMS</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_varnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>co</name>-&gt;<name>co_argcount</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>nm</name> <init>= <expr><name><name>co_varnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>nm</name> == <name>keyword</name></expr>)</condition><then>
					<goto>goto <name>kw_found</name>;</goto></then></if>
			}</block></for>
			<comment type="block">/* Slow fallback, just in case */</comment>
			<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>co</name>-&gt;<name>co_argcount</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>nm</name> <init>= <expr><name><name>co_varnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(
					<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>nm</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
					<goto>goto <name>kw_found</name>;</goto></then>
				<else>else <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
					<goto>goto <name>fail</name>;</goto></then></if></else></if>
			}</block></for>
			<comment type="block">/* Check errors from Compare */</comment>
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<goto>goto <name>fail</name>;</goto></then></if>
			<if>if <condition>(<expr><name>j</name> &gt;= <name><name>co</name>-&gt;<name>co_argcount</name></name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>kwdict</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					    <argument><expr>"%.200s() got an unexpected "
					    "keyword argument '%.400s'"</expr></argument>,
					    <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>fail</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
<label><name>kw_found</name>:</label>
			<if>if <condition>(<expr><call><name>GETLOCAL</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
						<argument><expr>"%.200s() got multiple "
						"values for keyword "
						"argument '%.400s'"</expr></argument>,
						<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fail</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SETLOCAL</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<if>if <condition>(<expr><name>argcount</name> &lt; <name><name>co</name>-&gt;<name>co_argcount</name></name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><name><name>co</name>-&gt;<name>co_argcount</name></name> - <name>defcount</name></expr></init></decl>;</decl_stmt>
			<for>for (<init><expr><name>i</name> = <name>argcount</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>m</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<if>if <condition>(<expr><call><name>GETLOCAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					    <argument><expr>"%.200s() takes %s %d "
					    "%sargument%s (%d given)"</expr></argument>,
					    <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr>((<name><name>co</name>-&gt;<name>co_flags</name></name> &amp; <name>CO_VARARGS</name>) ||
					     <name>defcount</name>) ? "at least"
						       : "exactly"</expr></argument>,
					    <argument><expr><name>m</name></expr></argument>, <argument><expr><name>kwcount</name> ? "non-keyword " : ""</expr></argument>,
					    <argument><expr><name>m</name> == 1 ? "" : "s"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>fail</name>;</goto>
				}</block></then></if>
			}</block></for>
			<if>if <condition>(<expr><name>n</name> &gt; <name>m</name></expr>)</condition><then>
				<expr_stmt><expr><name>i</name> = <name>n</name> - <name>m</name></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt></else></if>
			<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>defcount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<if>if <condition>(<expr><call><name>GETLOCAL</name><argument_list>(<argument><expr><name>m</name>+<name>i</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>PyObject</name> *</type><name>def</name> <init>= <expr><name><name>defs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SETLOCAL</name><argument_list>(<argument><expr><name>m</name>+<name>i</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></for>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><name>argcount</name> &gt; 0 || <name>kwcount</name> &gt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"%.200s() takes no arguments (%d given)"</expr></argument>,
				     <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><name>argcount</name> + <name>kwcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		}</block></then></if>
	}</block></else></if>
	<comment type="block">/* Allocate and initialize storage for cell vars, and copy free
	   vars into frame.  This isn't too efficient right now. */</comment>
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_cellvars</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nargs</name></decl>, <decl><type ref="prev"/><name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>cellname</name></decl>, *<decl><type ref="prev"/><name>argname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nargs</name> = <name><name>co</name>-&gt;<name>co_argcount</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>co</name>-&gt;<name>co_flags</name></name> &amp; <name>CO_VARARGS</name></expr>)</condition><then>
			<expr_stmt><expr><name>nargs</name>++</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>co</name>-&gt;<name>co_flags</name></name> &amp; <name>CO_VARKEYWORDS</name></expr>)</condition><then>
			<expr_stmt><expr><name>nargs</name>++</expr>;</expr_stmt></then></if>

		<comment type="block">/* Initialize each cell var, taking into account
		   cell vars that are initialized from arguments.

		   Should arrange for the compiler to put cellvars
		   that are arguments at the beginning of the cellvars
		   list so that we can march over it more efficiently?
		*/</comment>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_cellvars</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<expr_stmt><expr><name>cellname</name> = <call><name>PyString_AS_STRING</name><argument_list>(
				<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_cellvars</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> = 0</expr>;</expr_stmt>
			<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>nargs</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name>argname</name> = <call><name>PyString_AS_STRING</name><argument_list>(
					<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_varnames</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cellname</name></expr></argument>, <argument><expr><name>argname</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>c</name> = <call><name>PyCell_New</name><argument_list>(<argument><expr><call><name>GETLOCAL</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>c</name> == <name>NULL</name></expr>)</condition><then>
						<goto>goto <name>fail</name>;</goto></then></if>
					<expr_stmt><expr><call><name>GETLOCAL</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_nlocals</name></name> + <name>i</name></expr></argument>)</argument_list></call> = <name>c</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>found</name> = 1</expr>;</expr_stmt>
					<break>break;</break>
				}</block></then></if>
			}</block></for>
			<if>if <condition>(<expr><name>found</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>c</name> = <call><name>PyCell_New</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>c</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>fail</name>;</goto></then></if>
				<expr_stmt><expr><call><name>SETLOCAL</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_nlocals</name></name> + <name>i</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_freevars</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_freevars</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>closure</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>freevars</name><index>[<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_cellvars</name></name></expr></argument>)</argument_list></call> + <name>i</name></expr>]</index></name> = <name>o</name></expr>;</expr_stmt>
		}</block></for>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>co</name>-&gt;<name>co_flags</name></name> &amp; <name>CO_GENERATOR</name></expr>)</condition><then> <block>{
		<comment type="block">/* Don't need to keep the reference to f_back, it will be set
		 * when the generator is resumed. */</comment>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_back</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name>-&gt;<name>f_back</name></name> = <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_GENERATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create a new generator that owns the ready to run frame
		 * and return that as the value. */</comment>
		<return>return <expr><call><name>PyGen_New</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>retval</name> = <call><name>PyEval_EvalFrameEx</name><argument_list>(<argument><expr><name>f</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>fail</name>:</label> <comment type="block">/* Jump here from prelude on failure */</comment>

	<comment type="block">/* decref'ing the frame can cause __del__ methods to get invoked,
	   which can call back into Python.  While we're done with the
	   current Python frame (f), the associated C stack is still in use,
	   so recursion_depth must be boosted for the duration.
	*/</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tstate</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>++<name><name>tstate</name>-&gt;<name>recursion_depth</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>--<name><name>tstate</name>-&gt;<name>recursion_depth</name></name></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
}</block></function>


<comment type="block">/* Implementation notes for set_exc_info() and reset_exc_info():

- Below, 'exc_ZZZ' stands for 'exc_type', 'exc_value' and
  'exc_traceback'.  These always travel together.

- tstate-&gt;curexc_ZZZ is the "hot" exception that is set by
  PyErr_SetString(), cleared by PyErr_Clear(), and so on.

- Once an exception is caught by an except clause, it is transferred
  from tstate-&gt;curexc_ZZZ to tstate-&gt;exc_ZZZ, from which sys.exc_info()
  can pick it up.  This is the primary task of set_exc_info().
  XXX That can't be right:  set_exc_info() doesn't look at tstate-&gt;curexc_ZZZ.

- Now let me explain the complicated dance with frame-&gt;f_exc_ZZZ.

  Long ago, when none of this existed, there were just a few globals:
  one set corresponding to the "hot" exception, and one set
  corresponding to sys.exc_ZZZ.  (Actually, the latter weren't C
  globals; they were simply stored as sys.exc_ZZZ.  For backwards
  compatibility, they still are!)  The problem was that in code like
  this:

     try:
	"something that may fail"
     except "some exception":
	"do something else first"
	"print the exception from sys.exc_ZZZ."

  if "do something else first" invoked something that raised and caught
  an exception, sys.exc_ZZZ were overwritten.  That was a frequent
  cause of subtle bugs.  I fixed this by changing the semantics as
  follows:

    - Within one frame, sys.exc_ZZZ will hold the last exception caught
      *in that frame*.

    - But initially, and as long as no exception is caught in a given
      frame, sys.exc_ZZZ will hold the last exception caught in the
      previous frame (or the frame before that, etc.).

  The first bullet fixed the bug in the above example.  The second
  bullet was for backwards compatibility: it was (and is) common to
  have a function that is called when an exception is caught, and to
  have that function access the caught exception via sys.exc_ZZZ.
  (Example: traceback.print_exc()).

  At the same time I fixed the problem that sys.exc_ZZZ weren't
  thread-safe, by introducing sys.exc_info() which gets it from tstate;
  but that's really a separate improvement.

  The reset_exc_info() function in ceval.c restores the tstate-&gt;exc_ZZZ
  variables to what they were before the current frame was called.  The
  set_exc_info() function saves them on the frame so that
  reset_exc_info() can restore them.  The invariant is that
  frame-&gt;f_exc_ZZZ is NULL iff the current frame never caught an
  exception (where "catching" an exception applies only to successful
  except clauses); and if the current frame ever caught an exception,
  frame-&gt;f_exc_ZZZ is the exception that was stored in tstate-&gt;exc_ZZZ
  at the start of the current frame.

*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_exc_info</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>,
	     <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tb</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>frame</name> <init>= <expr><name><name>tstate</name>-&gt;<name>frame</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp_type</name></decl>, *<decl><type ref="prev"/><name>tmp_value</name></decl>, *<decl><type ref="prev"/><name>tmp_tb</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>frame</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>frame</name>-&gt;<name>f_exc_type</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>frame</name>-&gt;<name>f_exc_value</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>frame</name>-&gt;<name>f_exc_traceback</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* This frame didn't catch an exception before. */</comment>
		<comment type="block">/* Save previous exception of this thread in this frame. */</comment>
		<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>exc_type</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* XXX Why is this set to Py_None? */</comment>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_type</name></name> = <name>Py_None</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>exc_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>exc_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>exc_traceback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_exc_type</name></name> = <name><name>tstate</name>-&gt;<name>exc_type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_exc_value</name></name> = <name><name>tstate</name>-&gt;<name>exc_value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_exc_traceback</name></name> = <name><name>tstate</name>-&gt;<name>exc_traceback</name></name></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* Set new exception for this thread. */</comment>
	<expr_stmt><expr><name>tmp_type</name> = <name><name>tstate</name>-&gt;<name>exc_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_value</name> = <name><name>tstate</name>-&gt;<name>exc_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_tb</name> = <name><name>tstate</name>-&gt;<name>exc_traceback</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_type</name></name> = <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_value</name></name> = <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_traceback</name></name> = <name>tb</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* For b/w compatibility */</comment>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exc_type"</expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exc_value"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exc_traceback"</expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>reset_exc_info</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp_type</name></decl>, *<decl><type ref="prev"/><name>tmp_value</name></decl>, *<decl><type ref="prev"/><name>tmp_tb</name></decl>;</decl_stmt>

	<comment type="block">/* It's a precondition that the thread state's frame caught an
	 * exception -- verify in a debug build.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tstate</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>frame</name> = <name><name>tstate</name>-&gt;<name>frame</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>frame</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>frame</name>-&gt;<name>f_exc_type</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the frame's exception info back to the thread state. */</comment>
	<expr_stmt><expr><name>tmp_type</name> = <name><name>tstate</name>-&gt;<name>exc_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_value</name> = <name><name>tstate</name>-&gt;<name>exc_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_tb</name> = <name><name>tstate</name>-&gt;<name>exc_traceback</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>frame</name>-&gt;<name>f_exc_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>frame</name>-&gt;<name>f_exc_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>frame</name>-&gt;<name>f_exc_traceback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_type</name></name> = <name><name>frame</name>-&gt;<name>f_exc_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_value</name></name> = <name><name>frame</name>-&gt;<name>f_exc_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_traceback</name></name> = <name><name>frame</name>-&gt;<name>f_exc_traceback</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For b/w compatibility */</comment>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exc_type"</expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>f_exc_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exc_value"</expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>f_exc_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exc_traceback"</expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>f_exc_traceback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear the frame's exception info. */</comment>
	<expr_stmt><expr><name>tmp_type</name> = <name><name>frame</name>-&gt;<name>f_exc_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_value</name> = <name><name>frame</name>-&gt;<name>f_exc_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_tb</name> = <name><name>frame</name>-&gt;<name>f_exc_traceback</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_exc_type</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_exc_value</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_exc_traceback</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Logic for the raise statement (too complicated for inlining).
   This *consumes* a reference count to each of its arguments. */</comment>
<enum><specifier>static</specifier> enum <name>why_code</name>
<name>do_raise</name><expr_stmt><expr>(<name>PyObject</name> *<name>type</name>, <name>PyObject</name> *<name>value</name>, <name>PyObject</name> *<name>tb</name>)
<block>{
	<if>if <condition>(<expr><name>type</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Reraise */</comment>
		<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>type</name> = <name><name>tstate</name>-&gt;<name>exc_type</name></name> == <name>NULL</name> ? <name>Py_None</name> : <name><name>tstate</name>-&gt;<name>exc_type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> = <name><name>tstate</name>-&gt;<name>exc_value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tb</name> = <name><name>tstate</name>-&gt;<name>exc_traceback</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt/></block></then></if>}</block></expr></expr_stmt></enum>

	<comment type="block">/* We support the following forms of raise:
	   raise &lt;class&gt;, &lt;classinstance&gt;
	   raise &lt;class&gt;, &lt;argument tuple&gt;
	   raise &lt;class&gt;, None
	   raise &lt;class&gt;, &lt;argument&gt;
	   raise &lt;classinstance&gt;, None
	   raise &lt;string&gt;, &lt;object&gt;
	   raise &lt;string&gt;, None

	   An omitted second argument is the same as None.

	   In addition, raise &lt;tuple&gt;, &lt;anything&gt; is the same as
	   raising the tuple's first item (and it better have one!);
	   this rule is applied recursively.

	   Finally, an optional third argument can be supplied, which
	   gives the traceback to be substituted (useful when
	   re-raising an exception after examining it).  */</comment>

	<comment type="block">/* First, check the traceback argument, replacing None with
	   NULL. */</comment>
	<if>if <condition>(<expr><name>tb</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tb</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>tb</name> != <name>NULL</name> &amp;&amp; !<call><name>PyTraceBack_Check</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			   <argument><expr>"raise: arg 3 must be a traceback or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>raise_error</name>;</goto>
	}</block></then></if></else></if>

	<comment type="block">/* Next, replace a missing value with None */</comment>
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Next, repeatedly, replace a tuple exception with its first item */</comment>
	<while>while <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>type</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>type</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

	<if>if <condition>(<expr><call><name>PyExceptionClass_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_NormalizeException</name><argument_list>(<argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

	<else>else <if>if <condition>(<expr><call><name>PyExceptionInstance_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Raising an instance.  The value should be a dummy. */</comment>
		<if>if <condition>(<expr><name>value</name> != <name>Py_None</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			  <argument><expr>"instance exception may not have a separate value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>raise_error</name>;</goto>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* Normalize to raise &lt;class&gt;, &lt;instance&gt; */</comment>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> = <name>type</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>type</name> = <call><name>PyExceptionInstance_Class</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Not something you can raise.  You get an exception
		   anyway, just not what you specified :-) */</comment>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"exceptions must be classes or instances, not %s"</expr></argument>,
			<argument><expr><name><name>type</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>raise_error</name>;</goto>
	}</block></else></if></else></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyExceptionClass_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>Py_Py3kWarningFlag</name> &amp;&amp; <call><name>PyClass_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
				<argument><expr>"exceptions must derive from BaseException "
				"in 3.x"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<goto>goto <name>raise_error</name>;</goto></then></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tb</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>WHY_EXCEPTION</name></expr>;</return></then>
	<else>else
		<return>return <expr><name>WHY_RERAISE</name></expr>;</return></else></if>
 <label><name>raise_error</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>WHY_EXCEPTION</name></expr>;</return>
}

<comment type="block">/* Iterate v argcnt times and store the results on the stack (via decreasing
   sp).  Return 1 for success, 0 if error. */</comment>

static <function><type><name>int</name></type>
<name>unpack_iterable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>int</name></type> <name>argcnt</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>sp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>  <comment type="block">/* iter(v) */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Error</name>;</goto></then></if>

	<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>argcnt</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>w</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* Iterator done, via error or exhaustion. */</comment>
			<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"need more than %d value%s to unpack"</expr></argument>,
					<argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> == 1 ? "" : "s"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<goto>goto <name>Error</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr>*--<name>sp</name> = <name>w</name></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* We better have exhausted the iterator now. */</comment>
	<expr_stmt><expr><name>w</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<goto>goto <name>Error</name>;</goto></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"too many values to unpack"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* fall through */</comment>
<label><name>Error</name>:</label>
	<for>for (<init>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>sp</name>++</expr></incr>)
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LLTRACE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>prtrace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s "</expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if> <comment type="block">/* Don't know what else to do */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>call_exc_trace</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type> <name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>traceback</name></decl>, *<decl><type ref="prev"/><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><name>err</name> = <call><name>call_trace</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>PyTrace_EXCEPTION</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>call_trace_protected</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type> <name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl></param>,
		     <param><decl><type><name>int</name></type> <name>what</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>traceback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>err</name> = <call><name>call_trace</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>call_trace</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type> <name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl></param>,
	   <param><decl><type><name>int</name></type> <name>what</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><name><name>frame</name>-&gt;<name>f_tstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>tracing</name></name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tracing</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>func</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = ((<name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name>)
			       || (<name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> != <name>NULL</name>))</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tracing</name></name>--</expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyEval_CallTracing</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>frame</name> <init>= <expr><call><name>PyEval_GetFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><name><name>frame</name>-&gt;<name>f_tstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>save_tracing</name> <init>= <expr><name><name>tstate</name>-&gt;<name>tracing</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>save_use_tracing</name> <init>= <expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tracing</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = ((<name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name>)
			       || (<name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> != <name>NULL</name>))</expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tracing</name></name> = <name>save_tracing</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = <name>save_use_tracing</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>maybe_call_line_trace</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type> <name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
		      <param><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl></param>, <param><decl><type><name>int</name> *</type><name>instr_lb</name></decl></param>, <param><decl><type><name>int</name> *</type><name>instr_ub</name></decl></param>,
		      <param><decl><type><name>int</name> *</type><name>instr_prev</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <comment type="block">/* If the last instruction executed isn't in the current
           instruction window, reset the window.  If the last
           instruction happens to fall at the start of a line or if it
           represents a jump backwards, call the trace function.
        */</comment>
	<if>if <condition>(<expr>(<name><name>frame</name>-&gt;<name>f_lasti</name></name> &lt; *<name>instr_lb</name> || <name><name>frame</name>-&gt;<name>f_lasti</name></name> &gt;= *<name>instr_ub</name>)</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyAddrPair</name></type> <name>bounds</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>line</name> = <call><name>PyCode_CheckLineNumber</name><argument_list>(<argument><expr><name><name>frame</name>-&gt;<name>f_code</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>f_lasti</name></name></expr></argument>,
					      <argument><expr>&amp;<name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>line</name> &gt;= 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_lineno</name></name> = <name>line</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> = <call><name>call_trace</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>,
					    <argument><expr><name>PyTrace_LINE</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr>*<name>instr_lb</name> = <name><name>bounds</name>.<name>ap_lower</name></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>instr_ub</name> = <name><name>bounds</name>.<name>ap_upper</name></name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name><name>frame</name>-&gt;<name>f_lasti</name></name> &lt;= *<name>instr_prev</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>call_trace</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>PyTrace_LINE</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<expr_stmt><expr>*<name>instr_prev</name> = <name><name>frame</name>-&gt;<name>f_lasti</name></name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyEval_SetProfile</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type> <name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* Must make sure that tracing is not ignored if 'temp' is freed */</comment>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = <name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> = <name>func</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name> = <name>arg</name></expr>;</expr_stmt>
	<comment type="block">/* Flag that tracing or profiling is turned on */</comment>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = (<name>func</name> != <name>NULL</name>) || (<name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name>)</expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyEval_SetTrace</name><parameter_list>(<param><decl><type><name>Py_tracefunc</name></type> <name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* Must make sure that profiling is not ignored if 'temp' is freed */</comment>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = <name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> != <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> = <name>func</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name> = <name>arg</name></expr>;</expr_stmt>
	<comment type="block">/* Flag that tracing or profiling is turned on */</comment>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = ((<name>func</name> != <name>NULL</name>)
			       || (<name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> != <name>NULL</name>))</expr>;</expr_stmt>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyEval_GetBuiltins</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>current_frame</name> <init>= <expr><call><name>PyEval_GetFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>current_frame</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name><name>interp</name>-&gt;<name>builtins</name></name></expr>;</return></then>
	<else>else
		<return>return <expr><name><name>current_frame</name>-&gt;<name>f_builtins</name></name></expr>;</return></else></if>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyEval_GetLocals</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>current_frame</name> <init>= <expr><call><name>PyEval_GetFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>current_frame</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyFrame_FastToLocals</name><argument_list>(<argument><expr><name>current_frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>current_frame</name>-&gt;<name>f_locals</name></name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyEval_GetGlobals</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>current_frame</name> <init>= <expr><call><name>PyEval_GetFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>current_frame</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then>
	<else>else
		<return>return <expr><name><name>current_frame</name>-&gt;<name>f_globals</name></name></expr>;</return></else></if>
}</block></function>

<function><type><name>PyFrameObject</name> *</type>
<name>PyEval_GetFrame</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>_PyThreadState_GetFrame</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyEval_GetRestricted</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>current_frame</name> <init>= <expr><call><name>PyEval_GetFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>current_frame</name> == <name>NULL</name> ? 0 : <call><name>PyFrame_IsRestricted</name><argument_list>(<argument><expr><name>current_frame</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyEval_MergeCompilerFlags</name><parameter_list>(<param><decl><type><name>PyCompilerFlags</name> *</type><name>cf</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>current_frame</name> <init>= <expr><call><name>PyEval_GetFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><name><name>cf</name>-&gt;<name>cf_flags</name></name> != 0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>current_frame</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>codeflags</name> <init>= <expr><name><name>current_frame</name>-&gt;<name>f_code</name>-&gt;<name>co_flags</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>compilerflags</name> <init>= <expr><name>codeflags</name> &amp; <name>PyCF_MASK</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>compilerflags</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>result</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cf</name>-&gt;<name>cf_flags</name></name> |= <name>compilerflags</name></expr>;</expr_stmt>
		}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if> <comment type="block">/* future keyword */</comment>
		if (codeflags &amp; CO_GENERATOR_ALLOWED) {
			result = 1;
			cf-&gt;cf_flags |= CO_GENERATOR_ALLOWED;
		}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>Py_FlushLine</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdout"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyFile_SoftSpace</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* External interface to call any callable object.
   The arg must be a tuple or NULL. */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyEval_CallObject</name></cpp:undef>
<comment type="block">/* for backward compatibility: export this interface */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyEval_CallObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyEval_CallObjectWithKeywords</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyEval_CallObject</name><parameter_list>(<param><type><name>func</name></type></param>,<param><type><name>arg</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)</cpp:value></cpp:define>

<function><type><name>PyObject</name> *</type>
<name>PyEval_CallObjectWithKeywords</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>arg</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"argument list must be a tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

	<if>if <condition>(<expr><name>kw</name> != <name>NULL</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"keyword list must be a dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>PyEval_GetFuncName</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyMethod_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyEval_GetFuncName</name><argument_list>(<argument><expr><call><name>PyMethod_GET_FUNCTION</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr>((<name>PyFunctionObject</name>*)<name>func</name>)-&gt;<name>func_name</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyCFunction_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>((<name>PyCFunctionObject</name>*)<name>func</name>)-&gt;<name><name>m_ml</name>-&gt;<name>ml_name</name></name></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr>((<name>PyClassObject</name>*)<name>func</name>)-&gt;<name>cl_name</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><call><name>PyString_AsString</name><argument_list>(
			<argument><expr>((<name>PyInstanceObject</name>*)<name>func</name>)-&gt;<name><name>in_class</name>-&gt;<name>cl_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<return>return <expr><name><name>func</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr>;</return>
	}</block></else></if></else></if></else></if></else></if></else></if>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>PyEval_GetFuncDesc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyMethod_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>"()"</expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>"()"</expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyCFunction_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>"()"</expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyClass_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>" constructor"</expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr>" instance"</expr>;</return>
	}</block></then> <else>else <block>{
		<return>return <expr>" object"</expr>;</return>
	}</block></else></if></else></if></else></if></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>err_args</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>, <param><decl><type><name>int</name></type> <name>nargs</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>flags</name> &amp; <name>METH_NOARGS</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"%.200s() takes no arguments (%d given)"</expr></argument>,
			     <argument><expr>((<name>PyCFunctionObject</name> *)<name>func</name>)-&gt;<name><name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>,
			     <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"%.200s() takes exactly one argument (%d given)"</expr></argument>,
			     <argument><expr>((<name>PyCFunctionObject</name> *)<name>func</name>)-&gt;<name><name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>,
			     <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C_TRACE</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>call</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>if (tstate-&gt;use_tracing &amp;&amp; tstate-&gt;c_profilefunc) { \
	if (call_trace(tstate-&gt;c_profilefunc, \
		tstate-&gt;c_profileobj, \
		tstate-&gt;frame, PyTrace_C_CALL, \
		func)) { \
		x = NULL; \
	} \
	else { \
		x = call; \
		if (tstate-&gt;c_profilefunc != NULL) { \
			if (x == NULL) { \
				call_trace_protected(tstate-&gt;c_profilefunc, \
					tstate-&gt;c_profileobj, \
					tstate-&gt;frame, PyTrace_C_EXCEPTION, \
					func); \
				<comment type="block">/* XXX should pass (type, value, tb) */</comment> \
			} else { \
				if (call_trace(tstate-&gt;c_profilefunc, \
					tstate-&gt;c_profileobj, \
					tstate-&gt;frame, PyTrace_C_RETURN, \
					func)) { \
					Py_DECREF(x); \
					x = NULL; \
				} \
			} \
		} \
	} \
} else { \
	x = call; \
	}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_function</name><parameter_list>(<param><decl><type><name>PyObject</name> ***</type><name>pp_stack</name></decl></param>, <param><decl><type><name>int</name></type> <name>oparg</name></decl></param>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_TSC</name></cpp:ifdef>
		, <param><decl><type><name>uint64</name>*</type> <name>pintr0</name></decl></param>, <param><decl><type><name>uint64</name>*</type> <name>pintr1</name></decl></param>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>na</name> <init>= <expr><name>oparg</name> &amp; 0xff</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nk</name> <init>= <expr>(<name>oparg</name>&gt;&gt;8) &amp; 0xff</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>na</name> + 2 * <name>nk</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>pfunc</name> <init>= <expr>(*<name>pp_stack</name>) - <name>n</name> - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr>*<name>pfunc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>

	<comment type="block">/* Always dispatch PyCFunction first, because these are
	   presumed to be the most frequent callable object.
	*/</comment>
	<if>if <condition>(<expr><call><name>PyCFunction_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call> &amp;&amp; <name>nk</name> == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>PyCFunction_GET_FLAGS</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_CFUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>flags</name> &amp; (<name>METH_NOARGS</name> | <name>METH_O</name>)</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyCFunction</name></type> <name>meth</name> <init>= <expr><call><name>PyCFunction_GET_FUNCTION</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><call><name>PyCFunction_GET_SELF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>flags</name> &amp; <name>METH_NOARGS</name> &amp;&amp; <name>na</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>C_TRACE</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call>(*<name>meth</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>flags</name> &amp; <name>METH_O</name> &amp;&amp; <name>na</name> == 1</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><call><name>EXT_POP</name><argument_list>(<argument><expr>*<name>pp_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>C_TRACE</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call>(*<name>meth</name>)<argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><call><name>err_args</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>na</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>x</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></else></if></else></if>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>callargs</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>callargs</name> = <call><name>load_args</name><argument_list>(<argument><expr><name>pp_stack</name></expr></argument>, <argument><expr><name>na</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr>*<name>pintr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>C_TRACE</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call><name>PyCFunction_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>,<argument><expr><name>callargs</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr>*<name>pintr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then> <else>else <block>{
		<if>if <condition>(<expr><call><name>PyMethod_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyMethod_GET_SELF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* optimize access to bound methods */</comment>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><call><name>PyMethod_GET_SELF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_METHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_BOUND_METHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>func</name> = <call><name>PyMethod_GET_FUNCTION</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>pfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>pfunc</name> = <name>self</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>na</name>++</expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr>*<name>pintr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>x</name> = <call><name>fast_function</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>pp_stack</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>x</name> = <call><name>do_call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>pp_stack</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>READ_TIMESTAMP</name><argument_list>(<argument><expr>*<name>pintr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* Clear the stack of the function object.  Also removes
           the arguments in case they weren't consumed already
           (fast_function() and err_args() leave them on the stack).
	 */</comment>
	<while>while <condition>(<expr>(*<name>pp_stack</name>) &gt; <name>pfunc</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>w</name> = <call><name>EXT_POP</name><argument_list>(<argument><expr>*<name>pp_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_POP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<comment type="block">/* The fast_function() function optimize calls for which no argument
   tuple is necessary; the objects are passed directly from the stack.
   For the simplest case -- a function that takes only positional
   arguments and is called with only positional arguments -- it
   inlines the most primitive frame setup code from
   PyEval_EvalCodeEx(), which vastly reduces the checks that must be
   done before evaluating the frame.
*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fast_function</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> ***</type><name>pp_stack</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>na</name></decl></param>, <param><decl><type><name>int</name></type> <name>nk</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr>(<name>PyCodeObject</name> *)<call><name>PyFunction_GET_CODE</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name> <init>= <expr><call><name>PyFunction_GET_GLOBALS</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argdefs</name> <init>= <expr><call><name>PyFunction_GET_DEFAULTS</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nd</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_FAST_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>argdefs</name> == <name>NULL</name> &amp;&amp; <name><name>co</name>-&gt;<name>co_argcount</name></name> == <name>n</name> &amp;&amp; <name>nk</name>==0 &amp;&amp;
	    <name><name>co</name>-&gt;<name>co_flags</name></name> == (<name>CO_OPTIMIZED</name> | <name>CO_NEWLOCALS</name> | <name>CO_NOFREE</name>)</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>f</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>fastlocals</name></decl>, **<decl><type ref="prev"/><name>stack</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_FASTER_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>globals</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* XXX Perhaps we should create a specialized
		   PyFrame_New() that doesn't take locals, but does
		   take builtins without sanity checking them.
		*/</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tstate</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>f</name> = <call><name>PyFrame_New</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<expr_stmt><expr><name>fastlocals</name> = <name><name>f</name>-&gt;<name>f_localsplus</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stack</name> = (*<name>pp_stack</name>) - <name>n</name></expr>;</expr_stmt>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fastlocals</name><index>[<expr><name>i</name></expr>]</index></name> = *<name>stack</name>++</expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><name>retval</name> = <call><name>PyEval_EvalFrameEx</name><argument_list>(<argument><expr><name>f</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>++<name><name>tstate</name>-&gt;<name>recursion_depth</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>--<name><name>tstate</name>-&gt;<name>recursion_depth</name></name></expr>;</expr_stmt>
		<return>return <expr><name>retval</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>argdefs</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>d</name> = &amp;<call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>argdefs</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nd</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>argdefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><call><name>PyEval_EvalCodeEx</name><argument_list>(<argument><expr><name>co</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>,
				 <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>, <argument><expr>(*<name>pp_stack</name>)-<name>n</name></expr></argument>, <argument><expr><name>na</name></expr></argument>,
				 <argument><expr>(*<name>pp_stack</name>)-2*<name>nk</name></expr></argument>, <argument><expr><name>nk</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>nd</name></expr></argument>,
				 <argument><expr><call><name>PyFunction_GET_CLOSURE</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>update_keyword_args</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>orig_kwdict</name></decl></param>, <param><decl><type><name>int</name></type> <name>nk</name></decl></param>, <param><decl><type><name>PyObject</name> ***</type><name>pp_stack</name></decl></param>,
                    <param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>kwdict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>orig_kwdict</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>kwdict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name>kwdict</name> = <call><name>PyDict_Copy</name><argument_list>(<argument><expr><name>orig_kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>orig_kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>kwdict</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<while>while <condition>(<expr>--<name>nk</name> &gt;= 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><call><name>EXT_POP</name><argument_list>(<argument><expr>*<name>pp_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name> <init>= <expr><call><name>EXT_POP</name><argument_list>(<argument><expr>*<name>pp_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"%.200s%s got multiple values "
				     "for keyword argument '%.200s'"</expr></argument>,
				     <argument><expr><call><name>PyEval_GetFuncName</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><call><name>PyEval_GetFuncDesc</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></while>
	<return>return <expr><name>kwdict</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>update_star_args</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nstack</name></decl></param>, <param><decl><type><name>int</name></type> <name>nstar</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>stararg</name></decl></param>,
		 <param><decl><type><name>PyObject</name> ***</type><name>pp_stack</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>callargs</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>callargs</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>nstack</name> + <name>nstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>callargs</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>nstar</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nstar</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>a</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>stararg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>nstack</name> + <name>i</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></then></if>
	<while>while <condition>(<expr>--<name>nstack</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>w</name> = <call><name>EXT_POP</name><argument_list>(<argument><expr>*<name>pp_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>nstack</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>callargs</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_args</name><parameter_list>(<param><decl><type><name>PyObject</name> ***</type><name>pp_stack</name></decl></param>, <param><decl><type><name>int</name></type> <name>na</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr><name>na</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<while>while <condition>(<expr>--<name>na</name> &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>w</name> = <call><name>EXT_POP</name><argument_list>(<argument><expr>*<name>pp_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>args</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> ***</type><name>pp_stack</name></decl></param>, <param><decl><type><name>int</name></type> <name>na</name></decl></param>, <param><decl><type><name>int</name></type> <name>nk</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>callargs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>kwdict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>nk</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>kwdict</name> = <call><name>update_keyword_args</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nk</name></expr></argument>, <argument><expr><name>pp_stack</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>kwdict</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>call_fail</name>;</goto></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>callargs</name> = <call><name>load_args</name><argument_list>(<argument><expr><name>pp_stack</name></expr></argument>, <argument><expr><name>na</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>callargs</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>call_fail</name>;</goto></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CALL_PROFILE</name></cpp:ifdef>
	<comment type="block">/* At this point, we have to look at the type of func to
	   update the call stats properly.  Do it here so as to avoid
	   exposing the call stats machinery outside ceval.c
	*/</comment>
	<if>if <condition>(<expr><call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyMethod_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_METHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 <label><name>call_fail</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ext_do_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> ***</type><name>pp_stack</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>, <param><decl><type><name>int</name></type> <name>na</name></decl></param>, <param><decl><type><name>int</name></type> <name>nk</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>nstar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>callargs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>stararg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>kwdict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>flags</name> &amp; <name>CALL_FLAG_KW</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>kwdict</name> = <call><name>EXT_POP</name><argument_list>(<argument><expr>*<name>pp_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>d</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>ext_call_fail</name>;</goto></then></if>
			<if>if <condition>(<expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>kwdict</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* PyDict_Update raises attribute
				 * error (percolated from an attempt
				 * to get 'keys' attribute) instead of
				 * a type error if its second argument
				 * is not a mapping.
				 */</comment>
				<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
						     <argument><expr>"%.200s%.200s argument after ** "
						     "must be a mapping, not %.200s"</expr></argument>,
						     <argument><expr><call><name>PyEval_GetFuncName</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>,
						     <argument><expr><call><name>PyEval_GetFuncDesc</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>,
						     <argument><expr><name><name>kwdict</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<goto>goto <name>ext_call_fail</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>kwdict</name> = <name>d</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>flags</name> &amp; <name>CALL_FLAG_VAR</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>stararg</name> = <call><name>EXT_POP</name><argument_list>(<argument><expr>*<name>pp_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>stararg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>t</name> = <call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>stararg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>t</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
						     <argument><expr>"%.200s%.200s argument after * "
						     "must be a sequence, not %200s"</expr></argument>,
						     <argument><expr><call><name>PyEval_GetFuncName</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>,
						     <argument><expr><call><name>PyEval_GetFuncDesc</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>,
						     <argument><expr><name><name>stararg</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<goto>goto <name>ext_call_fail</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>stararg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stararg</name> = <name>t</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>nstar</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>stararg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>nk</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>kwdict</name> = <call><name>update_keyword_args</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>, <argument><expr><name>nk</name></expr></argument>, <argument><expr><name>pp_stack</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>kwdict</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>ext_call_fail</name>;</goto></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>callargs</name> = <call><name>update_star_args</name><argument_list>(<argument><expr><name>na</name></expr></argument>, <argument><expr><name>nstar</name></expr></argument>, <argument><expr><name>stararg</name></expr></argument>, <argument><expr><name>pp_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>callargs</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>ext_call_fail</name>;</goto></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CALL_PROFILE</name></cpp:ifdef>
	<comment type="block">/* At this point, we have to look at the type of func to
	   update the call stats properly.  Do it here so as to avoid
	   exposing the call stats machinery outside ceval.c
	*/</comment>
	<if>if <condition>(<expr><call><name>PyFunction_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyMethod_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_METHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PCALL</name><argument_list>(<argument><expr><name>PCALL_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>ext_call_fail</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>kwdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>stararg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Extract a slice index from a PyInt or PyLong or an object with the
   nb_index slot defined, and store in *pi.
   Silently reduce values larger than PY_SSIZE_T_MAX to PY_SSIZE_T_MAX,
   and silently boost values less than -PY_SSIZE_T_MAX-1 to -PY_SSIZE_T_MAX-1.
   Return 0 on error, 1 on success.
*/</comment>
<comment type="block">/* Note:  If v is NULL, return success without storing into *pi.  This
   is because_PyEval_SliceIndex() is called by apply_slice(), which can be
   called by the SLICE opcode with v and/or w equal to NULL.
*/</comment>
<function><type><name>int</name></type>
<name>_PyEval_SliceIndex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>pi</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>x</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* XXX(nnorwitz): I think PyInt_AS_LONG is correct,
			   however, it looks like it should be AsSsize_t.
			   There should be a comment here explaining why.
			*/</comment>
			<expr_stmt><expr><name>x</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>x</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"slice indices must be integers or "
					"None or have an __index__ method"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></else></if></else></if>
		<expr_stmt><expr>*<name>pi</name> = <name>x</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ISINDEX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISINDEX</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) == NULL || \
		    PyInt_Check(x) || PyLong_Check(x) || PyIndex_Check(x))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>apply_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>u</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <comment type="block">/* return u[v:w] */</comment>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><name><name>u</name>-&gt;<name>ob_type</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>sq</name> <init>= <expr><name><name>tp</name>-&gt;<name>tp_as_sequence</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>sq</name> &amp;&amp; <name><name>sq</name>-&gt;<name>sq_slice</name></name> &amp;&amp; <call><name>ISINDEX</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>ISINDEX</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ilow</name> <init>= <expr>0</expr></init>, <name>ihigh</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>ilow</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr>!<call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>ihigh</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<return>return <expr><call><name>PySequence_GetSlice</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>ilow</name></expr></argument>, <argument><expr><name>ihigh</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>slice</name> <init>= <expr><call><name>PySlice_New</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>slice</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		}</block></then>
		<else>else
			<return>return <expr><name>NULL</name></expr>;</return></else></if>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>assign_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>u</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>x</name></decl></param>)</parameter_list>
	<comment type="block">/* u[v:w] = x */</comment>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>tp</name> <init>= <expr><name><name>u</name>-&gt;<name>ob_type</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PySequenceMethods</name> *</type><name>sq</name> <init>= <expr><name><name>tp</name>-&gt;<name>tp_as_sequence</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>sq</name> &amp;&amp; <name><name>sq</name>-&gt;<name>sq_ass_slice</name></name> &amp;&amp; <call><name>ISINDEX</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>ISINDEX</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ilow</name> <init>= <expr>0</expr></init>, <name>ihigh</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>ilow</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr>!<call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>ihigh</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>PySequence_DelSlice</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>ilow</name></expr></argument>, <argument><expr><name>ihigh</name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<return>return <expr><call><name>PySequence_SetSlice</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>ilow</name></expr></argument>, <argument><expr><name>ihigh</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>slice</name> <init>= <expr><call><name>PySlice_New</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>slice</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>x</name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>res</name> = <call><name>PyObject_SetItem</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>res</name> = <call><name>PyObject_DelItem</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		}</block></then>
		<else>else
			<return>return <expr>-1</expr>;</return></else></if>
	}</block></else></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py3kExceptionClass_Check</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>     \
    <cpp:value>(PyType_Check((x)) &amp;&amp;               \
     PyType_FastSubclass((PyTypeObject*)(x), Py_TPFLAGS_BASE_EXC_SUBCLASS))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CANNOT_CATCH_MSG</name></cpp:macro> <cpp:value>"catching classes that don't inherit from " \
			 "BaseException is not allowed in 3.x"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cmp_outcome</name><parameter_list>(<param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>register</name> <name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>register</name> <name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>PyCmp_IS</name></expr>:
		<expr_stmt><expr><name>res</name> = (<name>v</name> == <name>w</name>)</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>PyCmp_IS_NOT</name></expr>:
		<expr_stmt><expr><name>res</name> = (<name>v</name> != <name>w</name>)</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>PyCmp_IN</name></expr>:
		<expr_stmt><expr><name>res</name> = <call><name>PySequence_Contains</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<break>break;</break>
	</case><case>case <expr><name>PyCmp_NOT_IN</name></expr>:
		<expr_stmt><expr><name>res</name> = <call><name>PySequence_Contains</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>res</name> = !<name>res</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>PyCmp_EXC_MATCH</name></expr>:
		<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>length</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>i</name> += 1</expr></incr>) <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>int</name></type> <name>ret_val</name></decl>;</decl_stmt>
					<expr_stmt><expr><name>ret_val</name> = <call><name>PyErr_WarnEx</name><argument_list>(
						<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
						<argument><expr>"catching of string "
						"exceptions is deprecated"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>ret_val</name> &lt; 0</expr>)</condition><then>
						<return>return <expr><name>NULL</name></expr>;</return></then></if>
				}</block></then>
				<else>else <if>if <condition>(<expr><name>Py_Py3kWarningFlag</name>  &amp;&amp;
					 !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call> &amp;&amp;
					 !<call><name>Py3kExceptionClass_Check</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<block>{
					<decl_stmt><decl><type><name>int</name></type> <name>ret_val</name></decl>;</decl_stmt>
					<expr_stmt><expr><name>ret_val</name> = <call><name>PyErr_WarnEx</name><argument_list>(
						<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
						<argument><expr><name>CANNOT_CATCH_MSG</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>ret_val</name> &lt; 0</expr>)</condition><then>
						<return>return <expr><name>NULL</name></expr>;</return></then></if>
				}</block></then></if></else></if>
			}</block></for>
		}</block></then>
		<else>else <block>{
			<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>ret_val</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>ret_val</name> = <call><name>PyErr_WarnEx</name><argument_list>(
						<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
						<argument><expr>"catching of string "
						"exceptions is deprecated"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ret_val</name> &lt; 0</expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>Py_Py3kWarningFlag</name>  &amp;&amp;
				 !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> &amp;&amp;
				 !<call><name>Py3kExceptionClass_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<block>{
				<decl_stmt><decl><type><name>int</name></type> <name>ret_val</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>ret_val</name> = <call><name>PyErr_WarnEx</name><argument_list>(
					<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
					<argument><expr><name>CANNOT_CATCH_MSG</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ret_val</name> &lt; 0</expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
			}</block></then></if></else></if>
		}</block></else></if>
		<expr_stmt><expr><name>res</name> = <call><name>PyErr_GivenExceptionMatches</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><default>default:
		<return>return <expr><call><name>PyObject_RichCompare</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
	</default>}</block></switch>
	<expr_stmt><expr><name>v</name> = <name>res</name> ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>import_from</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> &amp;&amp; <call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"cannot import name %.230s"</expr></argument>,
			     <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>x</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>import_all_from</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>all</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"__all__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>skip_leading_underscores</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>all</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if> <comment type="block">/* Unexpected error */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dict</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			<argument><expr>"from-import-* object has no __dict__ and no __all__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>all</name> = <call><name>PyMapping_Keys</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>all</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>skip_leading_underscores</name> = 1</expr>;</expr_stmt>
	}</block></then></if>

	<for>for (<init><expr><name>pos</name> = 0</expr>, <expr><name>err</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>pos</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>name</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>all</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
			<break>break;</break>
		}</block></then></if>
		<if>if <condition>(<expr><name>skip_leading_underscores</name> &amp;&amp;
		    <call><name>PyString_Check</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> &amp;&amp;
		    <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index> == '_'</expr>)</condition><then>
		<block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>
		<expr_stmt><expr><name>value</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>err</name> = -1</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>locals</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>err</name> = <call><name>PyObject_SetItem</name><argument_list>(<argument><expr><name>locals</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>build_class</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>methods</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>bases</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>metaclass</name> <init>= <expr><name>NULL</name></expr></init>, *<name>result</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>methods</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>metaclass</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>methods</name></expr></argument>, <argument><expr>"__metaclass__"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>metaclass</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>metaclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>base</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>bases</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metaclass</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>metaclass</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metaclass</name> = (<name>PyObject</name> *)<name><name>base</name>-&gt;<name>ob_type</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>metaclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>g</name> <init>= <expr><call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>g</name> != <name>NULL</name> &amp;&amp; <call><name>PyDict_Check</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>metaclass</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr>"__metaclass__"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>metaclass</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>metaclass</name> = (<name>PyObject</name> *) &amp;<name>PyClass_Type</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>metaclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>metaclass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>bases</name></expr></argument>, <argument><expr><name>methods</name></expr></argument>,
					      <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>metaclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name> &amp;&amp; <call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* A type error here likely means that the user passed
		   in a base that was not a class (such the random module
		   instead of the random.random type).  Help them out with
		   by augmenting the error message with more information.*/</comment>

		<decl_stmt><decl><type><name>PyObject</name> *</type><name>ptype</name></decl>, *<decl><type ref="prev"/><name>pvalue</name></decl>, *<decl><type ref="prev"/><name>ptraceback</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>ptype</name></expr></argument>, <argument><expr>&amp;<name>pvalue</name></expr></argument>, <argument><expr>&amp;<name>ptraceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>newmsg</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>newmsg</name> = <call><name>PyString_FromFormat</name><argument_list>(
				<argument><expr>"Error when calling the metaclass bases\n"
				"    %s"</expr></argument>,
				<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>newmsg</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pvalue</name> = <name>newmsg</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>ptraceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_statement</name><parameter_list>(<param><decl><type><name>PyFrameObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>prog</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>,
	       <param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>plain</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call> &amp;&amp; <name>globals</name> == <name>Py_None</name> &amp;&amp; <name>locals</name> == <name>Py_None</name> &amp;&amp;
	    ((<name>n</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call>) == 2 || <name>n</name> == 3)</expr>)</condition><then> <block>{
		<comment type="block">/* Backward compatibility hack */</comment>
		<expr_stmt><expr><name>globals</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> == 3</expr>)</condition><then>
			<expr_stmt><expr><name>locals</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>prog</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>globals</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>globals</name> = <call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>locals</name> == <name>Py_None</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>locals</name> = <call><name>PyEval_GetLocals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>plain</name> = 1</expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr>!<name>globals</name> || !<name>locals</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"globals and locals cannot be NULL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>locals</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>locals</name> = <name>globals</name></expr>;</expr_stmt></then></if></else></if>
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call> &amp;&amp;
	    !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call> &amp;&amp;
	    !<call><name>PyCode_Check</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call> &amp;&amp;
	    !<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"exec: arg 1 must be a string, file, or code object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		    <argument><expr>"exec: arg 2 must be a dictionary or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		    <argument><expr>"exec: arg 3 must be a mapping or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_builtins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>PyCode_Check</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyCode_GetNumFree</name><argument_list>(<argument><expr>(<name>PyCodeObject</name> *)<name>prog</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		<argument><expr>"code object passed to exec may not contain free variables"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>v</name> = <call><name>PyEval_EvalCode</name><argument_list>(<argument><expr>(<name>PyCodeObject</name> *) <name>prog</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><call><name>PyFile_Name</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>cf</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyEval_MergeCompilerFlags</name><argument_list>(<argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>v</name> = <call><name>PyRun_FileFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>,
					    <argument><expr><name>locals</name></expr></argument>, <argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>v</name> = <call><name>PyRun_File</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>,
				       <argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>cf</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>tmp</name> = <call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><name>prog</name> = <name>tmp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> |= <name>PyCF_SOURCE_IS_UTF8</name></expr>;</expr_stmt>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyEval_MergeCompilerFlags</name><argument_list>(<argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>v</name> = <call><name>PyRun_StringFlags</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>,
					      <argument><expr><name>locals</name></expr></argument>, <argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>v</name> = <call><name>PyRun_String</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<if>if <condition>(<expr><name>plain</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyFrame_LocalsToFast</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>format_exc_check_arg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format_str</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>obj_str</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>obj_str</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>obj_str</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>format_str</name></expr></argument>, <argument><expr><name>obj_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_concatenate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>,
		   <param><decl><type><name>PyFrameObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>next_instr</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* This function implements 'variable += expr' when both arguments
	   are strings. */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>v_len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>w_len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>new_len</name> <init>= <expr><name>v_len</name> + <name>w_len</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>new_len</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"strings are too large to concat"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_refcnt</name></name> == 2</expr>)</condition><then> <block>{
		<comment type="block">/* In the common case, there are 2 references to the value
		 * stored in 'variable' when the += is performed: one on the
		 * value stack (in 'v') and one still stored in the
		 * 'variable'.  We try to delete the variable now to reduce
		 * the refcnt to 1.
		 */</comment>
		<switch>switch <condition>(<expr>*<name>next_instr</name></expr>)</condition> <block>{
		<case>case <expr><name>STORE_FAST</name></expr>:
		<block>{
			<decl_stmt><decl><type><name>int</name></type> <name>oparg</name> <init>= <expr><call><name>PEEKARG</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> **</type><name>fastlocals</name> <init>= <expr><name><name>f</name>-&gt;<name>f_localsplus</name></name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>GETLOCAL</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call> == <name>v</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>SETLOCAL</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<break>break;</break>
		}</block>
		</case><case>case <expr><name>STORE_DEREF</name></expr>:
		<block>{
			<decl_stmt><decl><type><name>PyObject</name> **</type><name>freevars</name> <init>= <expr>(<name><name>f</name>-&gt;<name>f_localsplus</name></name> +
					       <name><name>f</name>-&gt;<name>f_code</name>-&gt;<name>co_nlocals</name></name>)</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name> <init>= <expr><name><name>freevars</name><index>[<expr><call><name>PEEKARG</name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>PyCell_GET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> == <name>v</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyCell_Set</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<break>break;</break>
		}</block>
		</case><case>case <expr><name>STORE_NAME</name></expr>:
		<block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>names</name> <init>= <expr><name><name>f</name>-&gt;<name>f_code</name>-&gt;<name>co_names</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>GETITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><call><name>PEEKARG</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>locals</name> <init>= <expr><name><name>f</name>-&gt;<name>f_locals</name></name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>locals</name></expr></argument>)</argument_list></call> &amp;&amp;
			    <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>locals</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == <name>v</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>locals</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></then></if>
			<break>break;</break>
		}</block>
		</case>}</block></switch>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_refcnt</name></name> == 1 &amp;&amp; !<call><name>PyString_CHECK_INTERNED</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Now we own the last reference to 'v', so we can resize it
		 * in-place.
		 */</comment>
		<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<comment type="block">/* XXX if _PyString_Resize() fails, 'v' has been
			 * deallocated so it cannot be put back into
			 * 'variable'.  The MemoryError is raised when there
			 * is no value in 'variable', which might (very
			 * remotely) be a cause of incompatibilities.
			 */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* copy 'w' into the newly allocated area of 'v' */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>v_len</name></expr></argument>,
		       <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>w_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* When in-place resizing is not an option. */</comment>
		<expr_stmt><expr><call><name>PyString_Concat</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></else></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DYNAMIC_EXECUTION_PROFILE</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>getarray</name><parameter_list>(<param><decl><type><name>long</name></type> <name><name>a</name><index>[<expr>256</expr>]</index></name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>l</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>256</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>l</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
	<return>return <expr><name>l</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_Py_GetDXProfile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DXPAIRS</name></cpp:ifndef>
	<return>return <expr><call><name>getarray</name><argument_list>(<argument><expr><name>dxp</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>l</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>257</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>l</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 257</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><call><name>getarray</name><argument_list>(<argument><expr><name><name>dxpairs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>l</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
