<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/dynload_win.c">
<comment type="block">/* Support for dynamic loading of extension modules */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DIRECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"importdl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> struct <name>filedescr</name></type> <name><name>_PyImport_DynLoadFiletab</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_DEBUG</name></cpp:ifdef>
	<expr><block>{<expr>"_d.pyd"</expr>, <expr>"rb"</expr>, <expr><name>C_EXTENSION</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr><block>{<expr>".pyd"</expr>, <expr>"rb"</expr>, <expr><name>C_EXTENSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Case insensitive string compare, to avoid any dependencies on particular
   C RTL implementations */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>strcasecmp</name> <parameter_list>(<param><decl><type><name>char</name> *</type><name>string1</name></decl></param>, <param><decl><type><name>char</name> *</type><name>string2</name></decl></param>)</parameter_list>
<block>{ 
	<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>second</name></decl>;</decl_stmt>

	<do>do <block>{
		<expr_stmt><expr><name>first</name>  = <call><name>tolower</name><argument_list>(<argument><expr>*<name>string1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>second</name> = <call><name>tolower</name><argument_list>(<argument><expr>*<name>string2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>string1</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>string2</name>++</expr>;</expr_stmt>
	}</block> while <condition>(<expr><name>first</name> &amp;&amp; <name>first</name> == <name>second</name></expr>)</condition>;</do>

	<return>return <expr>(<name>first</name> - <name>second</name>)</expr>;</return>
}</block></function> 


<comment type="block">/* Function to return the name of the "python" DLL that the supplied module
   directly imports.  Looks through the list of imported modules and
   returns the first entry that starts with "python" (case sensitive) and
   is followed by nothing but numbers until the separator (period).

   Returns a pointer to the import name, or NULL if no matching name was
   located.

   This function parses through the PE header for the module as loaded in
   memory by the system loader.  The PE header is accessed as documented by
   Microsoft in the MSDN PE and COFF specification (2/99), and handles
   both PE32 and PE32+.  It only worries about the direct import table and
   not the delay load import table since it's unlikely an extension is
   going to be delay loading Python (after all, it's already loaded).

   If any magic values are not found (e.g., the PE header or optional
   header magic), then this function simply returns NULL. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DWORD_AT</name><parameter_list>(<param><type><name>mem</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(*(DWORD *)(mem))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORD_AT</name><parameter_list>(<param><type><name>mem</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>(*(WORD *)(mem))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>GetPythonImport</name> <parameter_list>(<param><decl><type><name>HINSTANCE</name></type> <name>hModule</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>dllbase</name></decl>, *<decl><type ref="prev"/><name>import_data</name></decl>, *<decl><type ref="prev"/><name>import_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>pe_offset</name></decl>, <decl><type ref="prev"/><name>opt_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WORD</name></type> <name>opt_magic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_dict_off</name></decl>, <decl><type ref="prev"/><name>import_off</name></decl>;</decl_stmt>

	<comment type="block">/* Safety check input */</comment>
	<if>if <condition>(<expr><name>hModule</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Module instance is also the base load address.  First portion of
	   memory is the MS-DOS loader, which holds the offset to the PE
	   header (from the load base) at 0x3C */</comment>
	<expr_stmt><expr><name>dllbase</name> = (<name>unsigned</name> <name>char</name> *)<name>hModule</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pe_offset</name> = <call><name>DWORD_AT</name><argument_list>(<argument><expr><name>dllbase</name> + 0x3C</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The PE signature must be "PE\0\0" */</comment>
	<if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>dllbase</name>+<name>pe_offset</name></expr></argument>,<argument><expr>"PE\0\0"</expr></argument>,<argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Following the PE signature is the standard COFF header (20
	   bytes) and then the optional header.  The optional header starts
	   with a magic value of 0x10B for PE32 or 0x20B for PE32+ (PE32+
	   uses 64-bits for some fields).  It might also be 0x107 for a ROM
	   image, but we don't process that here.

	   The optional header ends with a data dictionary that directly
	   points to certain types of data, among them the import entries
	   (in the second table entry). Based on the header type, we
	   determine offsets for the data dictionary count and the entry
	   within the dictionary pointing to the imports. */</comment>

	<expr_stmt><expr><name>opt_offset</name> = <name>pe_offset</name> + 4 + 20</expr>;</expr_stmt>
	<expr_stmt><expr><name>opt_magic</name> = <call><name>WORD_AT</name><argument_list>(<argument><expr><name>dllbase</name>+<name>opt_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>opt_magic</name> == 0x10B</expr>)</condition><then> <block>{
		<comment type="block">/* PE32 */</comment>
		<expr_stmt><expr><name>num_dict_off</name> = 92</expr>;</expr_stmt>
		<expr_stmt><expr><name>import_off</name>   = 104</expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>opt_magic</name> == 0x20B</expr>)</condition><then> <block>{
		<comment type="block">/* PE32+ */</comment>
		<expr_stmt><expr><name>num_dict_off</name> = 108</expr>;</expr_stmt>
		<expr_stmt><expr><name>import_off</name>   = 120</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<comment type="block">/* Unsupported */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>

	<comment type="block">/* Now if an import table exists, offset to it and walk the list of
	   imports.  The import table is an array (ending when an entry has
	   empty values) of structures (20 bytes each), which contains (at
	   offset 12) a relative address (to the module base) at which a
	   string constant holding the import name is located. */</comment>

	<if>if <condition>(<expr><call><name>DWORD_AT</name><argument_list>(<argument><expr><name>dllbase</name> + <name>opt_offset</name> + <name>num_dict_off</name></expr></argument>)</argument_list></call> &gt;= 2</expr>)</condition><then> <block>{
		<comment type="block">/* We have at least 2 tables - the import table is the second
		   one.  But still it may be that the table size is zero */</comment>
		<if>if <condition>(<expr>0 == <call><name>DWORD_AT</name><argument_list>(<argument><expr><name>dllbase</name> + <name>opt_offset</name> + <name>import_off</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>DWORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>import_data</name> = <name>dllbase</name> + <call><name>DWORD_AT</name><argument_list>(<argument><expr><name>dllbase</name> +
						 <name>opt_offset</name> +
						 <name>import_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>DWORD_AT</name><argument_list>(<argument><expr><name>import_data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<expr_stmt><expr><name>import_name</name> = <name>dllbase</name> + <call><name>DWORD_AT</name><argument_list>(<argument><expr><name>import_data</name>+12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>import_name</name></expr></argument>)</argument_list></call> &gt;= 6 &amp;&amp;
			    !<call><name>strncmp</name><argument_list>(<argument><expr><name>import_name</name></expr></argument>,<argument><expr>"python"</expr></argument>,<argument><expr>6</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name> *</type><name>pch</name></decl>;</decl_stmt>

				<comment type="block">/* Ensure python prefix is followed only
				   by numbers to the end of the basename */</comment>
				<expr_stmt><expr><name>pch</name> = <name>import_name</name> + 6</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_DEBUG</name></cpp:ifdef>
				<while>while <condition>(<expr>*<name>pch</name> &amp;&amp; <name><name>pch</name><index>[<expr>0</expr>]</index></name> != '_' &amp;&amp; <name><name>pch</name><index>[<expr>1</expr>]</index></name> != 'd' &amp;&amp; <name><name>pch</name><index>[<expr>2</expr>]</index></name> != '.'</expr>)</condition> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<while>while <condition>(<expr>*<name>pch</name> &amp;&amp; *<name>pch</name> != '.'</expr>)</condition> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<if>if <condition>(<expr>*<name>pch</name> &gt;= '0' &amp;&amp; *<name>pch</name> &lt;= '9'</expr>)</condition><then> <block>{
						<expr_stmt><expr><name>pch</name>++</expr>;</expr_stmt>
					}</block></then> <else>else <block>{
						<expr_stmt><expr><name>pch</name> = <name>NULL</name></expr>;</expr_stmt>
						<break>break;</break>
					}</block></else></if>
				}</block></while>
	    
				<if>if <condition>(<expr><name>pch</name></expr>)</condition><then> <block>{
					<comment type="block">/* Found it - return the name */</comment>
					<return>return <expr><name>import_name</name></expr>;</return>
				}</block></then></if>
			}</block></while>
			<expr_stmt><expr><name>import_data</name> += 20</expr>;</expr_stmt>
		}</block></then></if>
	}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>


<function><type><name>dl_funcptr</name></type> <name>_PyImport_GetDynLoadFunc</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fqname</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>shortname</name></decl></param>,
				    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>dl_funcptr</name></type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>funcname</name><index>[<expr>258</expr>]</index></name></decl>, *<decl><type ref="prev"/><name>import_python</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"init%.200s"</expr></argument>, <argument><expr><name>shortname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{
		<decl_stmt><decl><type><name>HINSTANCE</name></type> <name>hDLL</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>pathbuf</name><index>[<expr>260</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LPTSTR</name></type> <name>dummy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>old_mode</name></decl>;</decl_stmt>
		<comment type="block">/* We use LoadLibraryEx so Windows looks for dependent DLLs 
		    in directory of pathname first.  However, Windows95
		    can sometimes not work correctly unless the absolute
		    path is used.  If GetFullPathName() fails, the LoadLibrary
		    will certainly fail too, so use its error code */</comment>

		<comment type="block">/* Don't display a message box when Python can't load a DLL */</comment>
		<expr_stmt><expr><name>old_mode</name> = <call><name>SetErrorMode</name><argument_list>(<argument><expr><name>SEM_FAILCRITICALERRORS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>GetFullPathName</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>,
				    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				    <argument><expr><name>pathbuf</name></expr></argument>,
				    <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<comment type="block">/* XXX This call doesn't exist in Windows CE */</comment>
			<expr_stmt><expr><name>hDLL</name> = <call><name>LoadLibraryEx</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					     <argument><expr><name>LOAD_WITH_ALTERED_SEARCH_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<comment type="block">/* restore old error mode settings */</comment>
		<expr_stmt><expr><call><name>SetErrorMode</name><argument_list>(<argument><expr><name>old_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>hDLL</name>==<name>NULL</name></expr>)</condition><then><block>{
			<decl_stmt><decl><type><name>char</name></type> <name><name>errBuf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errorCode</name></decl>;</decl_stmt>

			<comment type="block">/* Get an error string from Win32 error code */</comment>
			<decl_stmt><decl><type><name>char</name></type> <name><name>theInfo</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Pointer to error text
					      from system */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>theLength</name></decl>;</decl_stmt> <comment type="block">/* Length of error text */</comment>

			<expr_stmt><expr><name>errorCode</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>theLength</name> = <call><name>FormatMessage</name><argument_list>(
				<argument><expr><name>FORMAT_MESSAGE_FROM_SYSTEM</name> |
				<name>FORMAT_MESSAGE_IGNORE_INSERTS</name></expr></argument>, <comment type="block">/* flags */</comment>
				<argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* message source */</comment>
				<argument><expr><name>errorCode</name></expr></argument>, <comment type="block">/* the message (error) ID */</comment>
				<argument><expr>0</expr></argument>, <comment type="block">/* default language environment */</comment>
				<argument><expr>(<name>LPTSTR</name>) <name>theInfo</name></expr></argument>, <comment type="block">/* the buffer */</comment>
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>theInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>, <comment type="block">/* the buffer size */</comment>
				<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no additional format args. */</comment>

			<comment type="block">/* Problem: could not get the error message.
			   This should not happen if called correctly. */</comment>
			<if>if <condition>(<expr><name>theLength</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>errBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				      <argument><expr>"DLL load failed with error code %d"</expr></argument>,
					      <argument><expr><name>errorCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
				<comment type="block">/* For some reason a \r\n
				   is appended to the text */</comment>
				<if>if <condition>(<expr><name>theLength</name> &gt;= 2 &amp;&amp;
				    <name><name>theInfo</name><index>[<expr><name>theLength</name>-2</expr>]</index></name> == '\r' &amp;&amp;
				    <name><name>theInfo</name><index>[<expr><name>theLength</name>-1</expr>]</index></name> == '\n'</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>theLength</name> -= 2</expr>;</expr_stmt>
					<expr_stmt><expr><name><name>theInfo</name><index>[<expr><name>theLength</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>errBuf</name></expr></argument>, <argument><expr>"DLL load failed: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>errBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>errBuf</name>+<name>len</name></expr></argument>, <argument><expr><name>theInfo</name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errBuf</name></expr></argument>)</argument_list></sizeof>-<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>errBuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>errBuf</name></expr></argument>)</argument_list></sizeof>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr><name>errBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then> <else>else <block>{
			<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"python%d%d_d.dll"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<argument><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"python%d%d.dll"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				      <argument><expr><name>PY_MAJOR_VERSION</name></expr></argument>,<argument><expr><name>PY_MINOR_VERSION</name></expr></argument>)</argument_list></call></expr></argument>;</argument_list></call></expr></expr_stmt>
			<expr_stmt><expr><name>import_python</name> = <call><name>GetPythonImport</name><argument_list>(<argument><expr><name>hDLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><name>import_python</name> &amp;&amp;
			    <call><name>strcasecmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,<argument><expr><name>import_python</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					      <argument><expr>"Module use of %.150s conflicts "
					      "with this version of Python."</expr></argument>,
					      <argument><expr><name>import_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>hDLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></else></if>
		<expr_stmt><expr><name>p</name> = <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hDLL</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block>

	<return>return <expr><name>p</name></expr>;</return>
}</block></function></block></function>
</unit>
