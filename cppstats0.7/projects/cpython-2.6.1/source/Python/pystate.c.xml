<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/pystate.c">
<comment type="block">/* Thread and interpreter state structures and their interfaces */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<comment type="block">/* --------------------------------------------------------------------------
CAUTION

Always use malloc() and free() directly in this file.  A number of these
functions are advertised as safe to call when the GIL isn't held, and in
a debug build Python redirects (e.g.) PyMem_NEW (etc) to Python's debugging
obmalloc functions.  Those aren't thread-safe (they rely on the GIL to avoid
the expense of doing their own locking).
-------------------------------------------------------------------------- */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DLOPEN</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DLFCN_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RTLD_LAZY</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTLD_LAZY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyThread_type_lock</name></type> <name>head_mutex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Protects interp-&gt;tstate_head */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAD_INIT</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(void)(head_mutex || (head_mutex = PyThread_allocate_lock()))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAD_LOCK</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>PyThread_acquire_lock(head_mutex, WAIT_LOCK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAD_UNLOCK</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>PyThread_release_lock(head_mutex)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The single PyInterpreterState used by this process'
   GILState implementation
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyInterpreterState</name> *</type><name>autoInterpreterState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>autoTLSkey</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAD_INIT</name><parameter_list>()</parameter_list></cpp:macro></cpp:define> <comment type="block">/* Nothing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAD_LOCK</name><parameter_list>()</parameter_list></cpp:macro></cpp:define> <comment type="block">/* Nothing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAD_UNLOCK</name><parameter_list>()</parameter_list></cpp:macro></cpp:define> <comment type="block">/* Nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyInterpreterState</name> *</type><name>interp_head</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>_PyThreadState_Current</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyThreadFrameGetter</name></type> <name>_PyThreadState_GetFrame</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_PyGILState_NoteThreadState</name><parameter_list>(<param><decl><type><name>PyThreadState</name>*</type> <name>tstate</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>PyInterpreterState</name> *</type>
<name>PyInterpreterState_New</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr>(<name>PyInterpreterState</name> *)
				     <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyInterpreterState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>interp</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>HEAD_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
		<if>if <condition>(<expr><name>head_mutex</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize threads for interpreter"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>modules</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>sysdict</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>builtins</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>tstate_head</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>codec_search_cache</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>codec_error_registry</name></name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DLOPEN</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RTLD_NOW</name></cpp:ifdef>
                <expr_stmt><expr><name><name>interp</name>-&gt;<name>dlopenflags</name></name> = <name>RTLD_NOW</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>dlopenflags</name></name> = <name>RTLD_LAZY</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_TSC</name></cpp:ifdef>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>tscdump</name></name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>HEAD_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>next</name></name> = <name>interp_head</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>interp_head</name> = <name>interp</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HEAD_UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>interp</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name>PyInterpreterState_Clear</name><parameter_list>(<param><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>p</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HEAD_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name><name>interp</name>-&gt;<name>tstate_head</name></name></expr>;</init> <condition><expr><name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr></incr>)
		<expr_stmt><expr><call><name>PyThreadState_Clear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><call><name>HEAD_UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_search_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_error_registry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>modules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>sysdict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>builtins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>zapthreads</name><parameter_list>(<param><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>p</name></decl>;</decl_stmt>
	<comment type="block">/* No need to lock the mutex here because this should only happen
	   when the threads are all really dead (XXX famous last words). */</comment>
	<while>while <condition>(<expr>(<name>p</name> = <name><name>interp</name>-&gt;<name>tstate_head</name></name>) != <name>NULL</name></expr>)</condition> <block>{
		<expr_stmt><expr><call><name>PyThreadState_Delete</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
}</block></function>


<function><type><name>void</name></type>
<name>PyInterpreterState_Delete</name><parameter_list>(<param><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyInterpreterState</name> **</type><name>p</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>zapthreads</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HEAD_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = &amp;<name>interp_head</name></expr>;</init> <condition>;</condition> <incr><expr><name>p</name> = &amp;<name>(*<name>p</name>)-&gt;<name>next</name></name></expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>p</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
				<argument><expr>"PyInterpreterState_Delete: invalid interp"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>*<name>p</name> == <name>interp</name></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>
	<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>tstate_head</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyInterpreterState_Delete: remaining threads"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr>*<name>p</name> = <name><name>interp</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HEAD_UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Default implementation for _PyThreadState_GetFrame */</comment>
<function><type><specifier>static</specifier> struct <name>_frame</name> *</type>
<name>threadstate_getframe</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name><name>self</name>-&gt;<name>frame</name></name></expr>;</return>
}</block></function>

<function><type><name>PyThreadState</name> *</type>
<name>PyThreadState_New</name><parameter_list>(<param><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr>(<name>PyThreadState</name> *)<call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyThreadState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>_PyThreadState_GetFrame</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>_PyThreadState_GetFrame</name> = <name>threadstate_getframe</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>tstate</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>interp</name></name> = <name>interp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>frame</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>recursion_depth</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tracing</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tick_counter</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>gilstate_counter</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>async_exc</name></name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>thread_id</name></name> = <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>thread_id</name></name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>dict</name></name> = <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>curexc_type</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>curexc_value</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>curexc_traceback</name></name> = <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_type</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_value</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_traceback</name></name> = <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name> = <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
		<expr_stmt><expr><call><name>_PyGILState_NoteThreadState</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>HEAD_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>next</name></name> = <name><name>interp</name>-&gt;<name>tstate_head</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp</name>-&gt;<name>tstate_head</name></name> = <name>tstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HEAD_UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>tstate</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name>PyThreadState_Clear</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>Py_VerboseFlag</name> &amp;&amp; <name><name>tstate</name>-&gt;<name>frame</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
		  <argument><expr>"PyThreadState_Clear: warning: thread still has a frame\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>async_exc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>curexc_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>curexc_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>curexc_traceback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>exc_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>exc_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>exc_traceback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Common code for PyThreadState_Delete() and PyThreadState_DeleteCurrent() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tstate_delete_common</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> **</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>prev_p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>tstate</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyThreadState_Delete: NULL tstate"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>interp</name> = <name><name>tstate</name>-&gt;<name>interp</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>interp</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyThreadState_Delete: NULL interp"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>HEAD_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = &amp;<name><name>interp</name>-&gt;<name>tstate_head</name></name></expr>;</init> <condition>;</condition> <incr><expr><name>p</name> = &amp;<name>(*<name>p</name>)-&gt;<name>next</name></name></expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>p</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
				<argument><expr>"PyThreadState_Delete: invalid tstate"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>*<name>p</name> == <name>tstate</name></expr>)</condition><then>
			<break>break;</break></then></if>
		<comment type="block">/* Sanity check.  These states should never happen but if
		 * they do we must abort.  Otherwise we'll end up spinning in
		 * in a tight loop with the lock held.  A similar check is done
		 * in thread.c find_key().  */</comment>
		<if>if <condition>(<expr>*<name>p</name> == <name>prev_p</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
				<argument><expr>"PyThreadState_Delete: small circular list(!)"
                                " and tstate not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>prev_p</name> = *<name>p</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>(*<name>p</name>)-&gt;<name>next</name></name> == <name><name>interp</name>-&gt;<name>tstate_head</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
				<argument><expr>"PyThreadState_Delete: circular list(!) and"
                                " tstate not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr>*<name>p</name> = <name><name>tstate</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HEAD_UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>PyThreadState_Delete</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>tstate</name> == <name>_PyThreadState_Current</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyThreadState_Delete: tstate is still current"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>tstate_delete_common</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name>autoTLSkey</name> &amp;&amp; <call><name>PyThread_get_key_value</name><argument_list>(<argument><expr><name>autoTLSkey</name></expr></argument>)</argument_list></call> == <name>tstate</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyThread_delete_key_value</name><argument_list>(<argument><expr><name>autoTLSkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WITH_THREAD */</comment>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>PyThreadState_DeleteCurrent</name><parameter_list>()</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><name>_PyThreadState_Current</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>tstate</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
			<argument><expr>"PyThreadState_DeleteCurrent: no current tstate"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>_PyThreadState_Current</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tstate_delete_common</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>autoTLSkey</name> &amp;&amp; <call><name>PyThread_get_key_value</name><argument_list>(<argument><expr><name>autoTLSkey</name></expr></argument>)</argument_list></call> == <name>tstate</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyThread_delete_key_value</name><argument_list>(<argument><expr><name>autoTLSkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>PyEval_ReleaseLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WITH_THREAD */</comment>


<function><type><name>PyThreadState</name> *</type>
<name>PyThreadState_Get</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>_PyThreadState_Current</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyThreadState_Get: no current thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<return>return <expr><name>_PyThreadState_Current</name></expr>;</return>
}</block></function>


<function><type><name>PyThreadState</name> *</type>
<name>PyThreadState_Swap</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>newts</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>oldts</name> <init>= <expr><name>_PyThreadState_Current</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>_PyThreadState_Current</name> = <name>newts</name></expr>;</expr_stmt>
	<comment type="block">/* It should not be possible for more than one thread state
	   to be used for a thread.  Check this the best we can in debug
	   builds.
	*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><name>newts</name></expr>)</condition><then> <block>{
		<comment type="block">/* This can be called from PyEval_RestoreThread(). Similar
		   to it, we need to ensure errno doesn't change.
		*/</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>check</name> <init>= <expr><call><name>PyGILState_GetThisThreadState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>check</name> &amp;&amp; <name><name>check</name>-&gt;<name>interp</name></name> == <name><name>newts</name>-&gt;<name>interp</name></name> &amp;&amp; <name>check</name> != <name>newts</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Invalid thread state for this thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>errno</name> = <name>err</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>oldts</name></expr>;</return>
}</block></function>

<comment type="block">/* An extension mechanism to store arbitrary additional per-thread state.
   PyThreadState_GetDict() returns a dictionary that can be used to hold such
   state; the caller should pick a unique key and store its state there.  If
   PyThreadState_GetDict() returns NULL, an exception has *not* been raised
   and the caller should assume no per-thread state is available. */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyThreadState_GetDict</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>_PyThreadState_Current</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>_PyThreadState_Current</name>-&gt;<name>dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>_PyThreadState_Current</name>-&gt;<name>dict</name></name> = <name>d</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<return>return <expr><name><name>_PyThreadState_Current</name>-&gt;<name>dict</name></name></expr>;</return>
}</block></function>


<comment type="block">/* Asynchronously raise an exception in a thread.
   Requested by Just van Rossum and Alex Martelli.
   To prevent naive misuse, you must write your own extension
   to call this, or use ctypes.  Must be called with the GIL held.
   Returns the number of tstates modified (normally 1, but 0 if `id` didn't
   match any known thread id).  Can be called with exc=NULL to clear an
   existing async exception.  This raises no exceptions. */</comment>

<function><type><name>int</name></type>
<name>PyThreadState_SetAsyncExc</name><parameter_list>(<param><decl><type><name>long</name></type> <name>id</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><name><name>tstate</name>-&gt;<name>interp</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>p</name></decl>;</decl_stmt>

	<comment type="block">/* Although the GIL is held, a few C API functions can be called
	 * without the GIL held, and in particular some that create and
	 * destroy thread and interpreter states.  Those can mutate the
	 * list of thread states we're traversing, so to prevent that we lock
	 * head_mutex for the duration.
	 */</comment>
	<expr_stmt><expr><call><name>HEAD_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name><name>interp</name>-&gt;<name>tstate_head</name></name></expr>;</init> <condition><expr><name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>thread_id</name></name> == <name>id</name></expr>)</condition><then> <block>{
			<comment type="block">/* Tricky:  we need to decref the current value
			 * (if any) in p-&gt;async_exc, but that can in turn
			 * allow arbitrary Python code to run, including
			 * perhaps calls to this function.  To prevent
			 * deadlock, we need to release head_mutex before
			 * the decref.
			 */</comment>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_exc</name> <init>= <expr><name><name>p</name>-&gt;<name>async_exc</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>p</name>-&gt;<name>async_exc</name></name> = <name>exc</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HEAD_UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>old_exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>HEAD_UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Routines for advanced debuggers, requested by David Beazley.
   Don't use unless you know what you are doing! */</comment>

<function><type><name>PyInterpreterState</name> *</type>
<name>PyInterpreterState_Head</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>interp_head</name></expr>;</return>
}</block></function>

<function><type><name>PyInterpreterState</name> *</type>
<name>PyInterpreterState_Next</name><parameter_list>(<param><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><name><name>interp</name>-&gt;<name>next</name></name></expr>;</return>
}</block></function>

<function><type><name>PyThreadState</name> *</type>
<name>PyInterpreterState_ThreadHead</name><parameter_list>(<param><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><name><name>interp</name>-&gt;<name>tstate_head</name></name></expr>;</return>
}</block></function>

<function><type><name>PyThreadState</name> *</type>
<name>PyThreadState_Next</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><name><name>tstate</name>-&gt;<name>next</name></name></expr>;</return>
}</block></function>

<comment type="block">/* The implementation of sys._current_frames().  This is intended to be
   called with the GIL held, as it will be when called via
   sys._current_frames().  It's possible it would work fine even without
   the GIL held, but haven't thought enough about that.
*/</comment>
<function><type><name>PyObject</name> *</type>
<name>_PyThread_CurrentFrames</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* for i in all interpreters:
	 *     for t in all of i's thread states:
	 *          if t's frame isn't NULL, map t's id to its frame
	 * Because these lists can mutute even when the GIL is held, we
	 * need to grab head_mutex for the duration.
	 */</comment>
	<expr_stmt><expr><call><name>HEAD_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>interp_head</name></expr>;</init> <condition><expr><name>i</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name> = <name><name>i</name>-&gt;<name>next</name></name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>t</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>t</name> = <name><name>i</name>-&gt;<name>tstate_head</name></name></expr>;</init> <condition><expr><name>t</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>t</name> = <name><name>t</name>-&gt;<name>next</name></name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>id</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>stat</name></decl>;</decl_stmt>
			<decl_stmt><decl><type>struct <name>_frame</name> *</type><name>frame</name> <init>= <expr><name><name>t</name>-&gt;<name>frame</name></name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>frame</name> == <name>NULL</name></expr>)</condition><then>
				<continue>continue;</continue></then></if>
			<expr_stmt><expr><name>id</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>t</name>-&gt;<name>thread_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>id</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
			<expr_stmt><expr><name>stat</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>stat</name> &lt; 0</expr>)</condition><then>
				<goto>goto <name>Fail</name>;</goto></then></if>
		}</block></for>
	}</block></for>
	<expr_stmt><expr><call><name>HEAD_UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>

 <label><name>Fail</name>:</label>
 	<expr_stmt><expr><call><name>HEAD_UNLOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Python "auto thread state" API. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>

<comment type="block">/* Keep this as a static, as it is not reliable!  It can only
   ever be compared to the state for the *current* thread.
   * If not equal, then it doesn't matter that the actual
     value may change immediately after comparison, as it can't
     possibly change to the current thread's state.
   * If equal, then the current thread holds the lock, so the value can't
     change until we yield the lock.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>PyThreadState_IsCurrent</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Must be the tstate for this thread */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyGILState_GetThisThreadState</name><argument_list>()</argument_list></call>==<name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* On Windows at least, simple reads and writes to 32 bit values
	   are atomic.
	*/</comment>
	<return>return <expr><name>tstate</name> == <name>_PyThreadState_Current</name></expr>;</return>
}</block></function>

<comment type="block">/* Internal initialization/finalization functions called by
   Py_Initialize/Py_Finalize
*/</comment>
<function><type><name>void</name></type>
<name>_PyGILState_Init</name><parameter_list>(<param><decl><type><name>PyInterpreterState</name> *</type><name>i</name></decl></param>, <param><decl><type><name>PyThreadState</name> *</type><name>t</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &amp;&amp; <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* must init with valid states */</comment>
	<expr_stmt><expr><name>autoTLSkey</name> = <call><name>PyThread_create_key</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>autoInterpreterState</name> = <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyThread_get_key_value</name><argument_list>(<argument><expr><name>autoTLSkey</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t</name>-&gt;<name>gilstate_counter</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_PyGILState_NoteThreadState</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>_PyGILState_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyThread_delete_key</name><argument_list>(<argument><expr><name>autoTLSkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>autoTLSkey</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>autoInterpreterState</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* When a thread state is created for a thread by some mechanism other than
   PyGILState_Ensure, it's important that the GILState machinery knows about
   it so it doesn't try to create another thread state for the thread (this is
   a better fix for SF bug #1010677 than the first one attempted).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_PyGILState_NoteThreadState</name><parameter_list>(<param><decl><type><name>PyThreadState</name>*</type> <name>tstate</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* If autoTLSkey is 0, this must be the very first threadstate created
	   in Py_Initialize().  Don't do anything for now (we'll be back here
	   when _PyGILState_Init is called). */</comment>
	<if>if <condition>(<expr>!<name>autoTLSkey</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* Stick the thread state for this thread in thread local storage.

	   The only situation where you can legitimately have more than one
	   thread state for an OS level thread is when there are multiple
	   interpreters, when:

	       a) You shouldn't really be using the PyGILState_ APIs anyway,
	          and:

	       b) The slightly odd way PyThread_set_key_value works (see
	          comments by its implementation) means that the first thread
	          state created for that given OS level thread will "win",
	          which seems reasonable behaviour.
	*/</comment>
	<if>if <condition>(<expr><call><name>PyThread_set_key_value</name><argument_list>(<argument><expr><name>autoTLSkey</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>tstate</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Couldn't create autoTLSkey mapping"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* PyGILState_Release must not try to delete this thread state. */</comment>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>gilstate_counter</name></name> = 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* The public functions */</comment>
<function><type><name>PyThreadState</name> *</type>
<name>PyGILState_GetThisThreadState</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>autoInterpreterState</name> == <name>NULL</name> || <name>autoTLSkey</name> == 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr>(<name>PyThreadState</name> *)<call><name>PyThread_get_key_value</name><argument_list>(<argument><expr><name>autoTLSkey</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyGILState_STATE</name></type>
<name>PyGILState_Ensure</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>current</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tcur</name></decl>;</decl_stmt>
	<comment type="block">/* Note that we do not auto-init Python here - apart from
	   potential races with 2 threads auto-initializing, pep-311
	   spells out other issues.  Embedders are expected to have
	   called Py_Initialize() and usually PyEval_InitThreads().
	*/</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>autoInterpreterState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Py_Initialize() hasn't been called! */</comment>
	<expr_stmt><expr><name>tcur</name> = (<name>PyThreadState</name> *)<call><name>PyThread_get_key_value</name><argument_list>(<argument><expr><name>autoTLSkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tcur</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Create a new thread state for this thread */</comment>
		<expr_stmt><expr><name>tcur</name> = <call><name>PyThreadState_New</name><argument_list>(<argument><expr><name>autoInterpreterState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tcur</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Couldn't create thread-state for new thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<comment type="block">/* This is our thread state!  We'll need to delete it in the
		   matching call to PyGILState_Release(). */</comment>
		<expr_stmt><expr><name><name>tcur</name>-&gt;<name>gilstate_counter</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>current</name> = 0</expr>;</expr_stmt> <comment type="block">/* new thread state is never current */</comment>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>current</name> = <call><name>PyThreadState_IsCurrent</name><argument_list>(<argument><expr><name>tcur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>current</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><name>tcur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<comment type="block">/* Update our counter in the thread-state - no need for locks:
	   - tcur will remain valid as we hold the GIL.
	   - the counter is safe as we are the only thread "allowed"
	     to modify this value
	*/</comment>
	<expr_stmt><expr>++<name><name>tcur</name>-&gt;<name>gilstate_counter</name></name></expr>;</expr_stmt>
	<return>return <expr><name>current</name> ? <name>PyGILState_LOCKED</name> : <name>PyGILState_UNLOCKED</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyGILState_Release</name><parameter_list>(<param><decl><type><name>PyGILState_STATE</name></type> <name>oldstate</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tcur</name> <init>= <expr>(<name>PyThreadState</name> *)<call><name>PyThread_get_key_value</name><argument_list>(
                                                                <argument><expr><name>autoTLSkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>tcur</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"auto-releasing thread-state, "
		              "but no thread-state for this thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<comment type="block">/* We must hold the GIL and have our thread state current */</comment>
	<comment type="block">/* XXX - remove the check - the assert should be fine,
	   but while this is very new (April 2003), the extra check
	   by release-only users can't hurt.
	*/</comment>
	<if>if <condition>(<expr>! <call><name>PyThreadState_IsCurrent</name><argument_list>(<argument><expr><name>tcur</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"This thread state must be current when releasing"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyThreadState_IsCurrent</name><argument_list>(<argument><expr><name>tcur</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>--<name><name>tcur</name>-&gt;<name>gilstate_counter</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tcur</name>-&gt;<name>gilstate_counter</name></name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* illegal counter value */</comment>

	<comment type="block">/* If we're going to destroy this thread-state, we must
	 * clear it while the GIL is held, as destructors may run.
	 */</comment>
	<if>if <condition>(<expr><name><name>tcur</name>-&gt;<name>gilstate_counter</name></name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* can't have been locked when we created it */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldstate</name> == <name>PyGILState_UNLOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyThreadState_Clear</name><argument_list>(<argument><expr><name>tcur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Delete the thread-state.  Note this releases the GIL too!
		 * It's vital that the GIL be held here, to avoid shutdown
		 * races; see bugs 225673 and 1061968 (that nasty bug has a
		 * habit of coming back).
		 */</comment>
		<expr_stmt><expr><call><name>PyThreadState_DeleteCurrent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<comment type="block">/* Release the lock if necessary */</comment>
	<else>else <if>if <condition>(<expr><name>oldstate</name> == <name>PyGILState_UNLOCKED</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if></else></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WITH_THREAD */</comment>


</unit>
