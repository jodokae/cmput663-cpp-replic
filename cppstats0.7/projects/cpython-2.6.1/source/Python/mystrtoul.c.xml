<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/mystrtoul.c">
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_SGI_MP_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SGI_MP_SOURCE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* strtol and strtoul, renamed to avoid conflicts */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ERRNO_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Static overflow check values for bases 2 through 36.
 * smallmax[base] is the largest unsigned long i such that
 * i * base doesn't overflow unsigned long.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name><name>smallmax</name><index>[]</index></name> <init>= <expr><block>{
	<expr>0</expr>, <comment type="block">/* bases 0 and 1 are invalid */</comment>
	<expr>0</expr>,
	<expr><name>ULONG_MAX</name> / 2</expr>,
	<expr><name>ULONG_MAX</name> / 3</expr>,
	<expr><name>ULONG_MAX</name> / 4</expr>,
	<expr><name>ULONG_MAX</name> / 5</expr>,
	<expr><name>ULONG_MAX</name> / 6</expr>,
	<expr><name>ULONG_MAX</name> / 7</expr>,
	<expr><name>ULONG_MAX</name> / 8</expr>,
	<expr><name>ULONG_MAX</name> / 9</expr>,
	<expr><name>ULONG_MAX</name> / 10</expr>,
	<expr><name>ULONG_MAX</name> / 11</expr>,
	<expr><name>ULONG_MAX</name> / 12</expr>,
	<expr><name>ULONG_MAX</name> / 13</expr>,
	<expr><name>ULONG_MAX</name> / 14</expr>,
	<expr><name>ULONG_MAX</name> / 15</expr>,
	<expr><name>ULONG_MAX</name> / 16</expr>,
	<expr><name>ULONG_MAX</name> / 17</expr>,
	<expr><name>ULONG_MAX</name> / 18</expr>,
	<expr><name>ULONG_MAX</name> / 19</expr>,
	<expr><name>ULONG_MAX</name> / 20</expr>,
	<expr><name>ULONG_MAX</name> / 21</expr>,
	<expr><name>ULONG_MAX</name> / 22</expr>,
	<expr><name>ULONG_MAX</name> / 23</expr>,
	<expr><name>ULONG_MAX</name> / 24</expr>,
	<expr><name>ULONG_MAX</name> / 25</expr>,
	<expr><name>ULONG_MAX</name> / 26</expr>,
	<expr><name>ULONG_MAX</name> / 27</expr>,
	<expr><name>ULONG_MAX</name> / 28</expr>,
	<expr><name>ULONG_MAX</name> / 29</expr>,
	<expr><name>ULONG_MAX</name> / 30</expr>,
	<expr><name>ULONG_MAX</name> / 31</expr>,
	<expr><name>ULONG_MAX</name> / 32</expr>,
	<expr><name>ULONG_MAX</name> / 33</expr>,
	<expr><name>ULONG_MAX</name> / 34</expr>,
	<expr><name>ULONG_MAX</name> / 35</expr>,
	<expr><name>ULONG_MAX</name> / 36</expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* maximum digits that can't ever overflow for bases 2 through 36,
 * calculated by [int(math.floor(math.log(2**32, i))) for i in range(2, 37)].
 * Note that this is pessimistic if sizeof(long) &gt; 4.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> == 4</expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>digitlimit</name><index>[]</index></name> <init>= <expr><block>{
	<expr>0</expr>,  <expr>0</expr>, <expr>32</expr>, <expr>20</expr>, <expr>16</expr>, <expr>13</expr>, <expr>12</expr>, <expr>11</expr>, <expr>10</expr>, <expr>10</expr>,  <comment type="block">/*  0 -  9 */</comment>
	<expr>9</expr>,  <expr>9</expr>,  <expr>8</expr>,  <expr>8</expr>,  <expr>8</expr>,  <expr>8</expr>,  <expr>8</expr>,  <expr>7</expr>,  <expr>7</expr>,  <expr>7</expr>,  <comment type="block">/* 10 - 19 */</comment>
	<expr>7</expr>,  <expr>7</expr>,  <expr>7</expr>,  <expr>7</expr>,  <expr>6</expr>,  <expr>6</expr>,  <expr>6</expr>,  <expr>6</expr>,  <expr>6</expr>,  <expr>6</expr>,  <comment type="block">/* 20 - 29 */</comment>
	<expr>6</expr>,  <expr>6</expr>,  <expr>6</expr>,  <expr>6</expr>,  <expr>6</expr>,  <expr>6</expr>,  <expr>6</expr>}</block></expr></init></decl>;</decl_stmt>             <comment type="block">/* 30 - 36 */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG</name> == 8</expr></cpp:elif>
<comment type="block">/* [int(math.floor(math.log(2**64, i))) for i in range(2, 37)] */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>digitlimit</name><index>[]</index></name> <init>= <expr><block>{
	 <expr>0</expr>,   <expr>0</expr>, <expr>64</expr>, <expr>40</expr>, <expr>32</expr>, <expr>27</expr>, <expr>24</expr>, <expr>22</expr>, <expr>21</expr>, <expr>20</expr>,  <comment type="block">/*  0 -  9 */</comment>
	<expr>19</expr>,  <expr>18</expr>, <expr>17</expr>, <expr>17</expr>, <expr>16</expr>, <expr>16</expr>, <expr>16</expr>, <expr>15</expr>, <expr>15</expr>, <expr>15</expr>,  <comment type="block">/* 10 - 19 */</comment>
	<expr>14</expr>,  <expr>14</expr>, <expr>14</expr>, <expr>14</expr>, <expr>13</expr>, <expr>13</expr>, <expr>13</expr>, <expr>13</expr>, <expr>13</expr>, <expr>13</expr>,  <comment type="block">/* 20 - 29 */</comment>
	<expr>13</expr>,  <expr>12</expr>, <expr>12</expr>, <expr>12</expr>, <expr>12</expr>, <expr>12</expr>, <expr>12</expr>}</block></expr></init></decl>;</decl_stmt>             <comment type="block">/* 30 - 36 */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "Need table for SIZEOF_LONG"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
**	strtoul
**		This is a general purpose routine for converting
**		an ascii string to an integer in an arbitrary base.
**		Leading white space is ignored.  If 'base' is zero
**		it looks for a leading 0, 0b, 0B, 0o, 0O, 0x or 0X
**		to tell which base.  If these are absent it defaults
**		to 10. Base must be 0 or between 2 and 36 (inclusive).
**		If 'ptr' is non-NULL it will contain a pointer to
**		the end of the scan.
**		Errors due to bad pointers will probably result in
**		exceptions - we don't check for them.
*/</comment>
<function><type><name>unsigned</name> <name>long</name></type>
<name>PyOS_strtoul</name><parameter_list>(<param><decl><type><name>register</name> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>char</name> **</type><name>ptr</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>long</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* return value of the function */</comment>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>	 	<comment type="block">/* current input character */</comment>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>ovlimit</name></decl>;</decl_stmt> 	<comment type="block">/* required digits to overflow */</comment>

	<comment type="block">/* skip leading white space */</comment>
	<while>while <condition>(<expr>*<name>str</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt></while>

	<comment type="block">/* check for leading 0 or 0x for auto-base or base 16 */</comment>
	<switch>switch <condition>(<expr><name>base</name></expr>)</condition> <block>{
	<case>case <expr>0</expr>:		<comment type="block">/* look for leading 0, 0b, 0o or 0x */</comment>
		<if>if <condition>(<expr>*<name>str</name> == '0'</expr>)</condition><then> <block>{
			<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>str</name> == 'x' || *<name>str</name> == 'X'</expr>)</condition><then> <block>{
				<comment type="block">/* there must be at least one digit after 0x */</comment>
				<if>if <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name> &gt;= 16</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ptr</name> = <name>str</name></expr>;</expr_stmt></then></if>
					<return>return <expr>0</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>base</name> = 16</expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr>*<name>str</name> == 'o' || *<name>str</name> == 'O'</expr>)</condition><then> <block>{
				<comment type="block">/* there must be at least one digit after 0o */</comment>
				<if>if <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name> &gt;= 8</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ptr</name> = <name>str</name></expr>;</expr_stmt></then></if>
					<return>return <expr>0</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>base</name> = 8</expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr>*<name>str</name> == 'b' || *<name>str</name> == 'B'</expr>)</condition><then> <block>{
				<comment type="block">/* there must be at least one digit after 0b */</comment>
				<if>if <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name> &gt;= 2</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ptr</name> = <name>str</name></expr>;</expr_stmt></then></if>
					<return>return <expr>0</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>base</name> = 2</expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><name>base</name> = 8</expr>;</expr_stmt>
			}</block></else></if></else></if></else></if>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>base</name> = 10</expr>;</expr_stmt></else></if>
		<break>break;</break>

	</case><case>case <expr>2</expr>:	<comment type="block">/* skip leading 0b or 0B */</comment>
		<if>if <condition>(<expr>*<name>str</name> == '0'</expr>)</condition><then> <block>{
			<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>str</name> == 'b' || *<name>str</name> == 'B'</expr>)</condition><then> <block>{
				<comment type="block">/* there must be at least one digit after 0b */</comment>
				<if>if <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name> &gt;= 2</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ptr</name> = <name>str</name></expr>;</expr_stmt></then></if>
					<return>return <expr>0</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<break>break;</break>

	</case><case>case <expr>8</expr>:	<comment type="block">/* skip leading 0o or 0O */</comment>
		<if>if <condition>(<expr>*<name>str</name> == '0'</expr>)</condition><then> <block>{
			<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>str</name> == 'o' || *<name>str</name> == 'O'</expr>)</condition><then> <block>{
				<comment type="block">/* there must be at least one digit after 0o */</comment>
				<if>if <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name> &gt;= 8</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ptr</name> = <name>str</name></expr>;</expr_stmt></then></if>
					<return>return <expr>0</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<break>break;</break>

	</case><case>case <expr>16</expr>:	<comment type="block">/* skip leading 0x or 0X */</comment>
		<if>if <condition>(<expr>*<name>str</name> == '0'</expr>)</condition><then> <block>{
			<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>str</name> == 'x' || *<name>str</name> == 'X'</expr>)</condition><then> <block>{
				<comment type="block">/* there must be at least one digit after 0x */</comment>
				<if>if <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name> &gt;= 16</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ptr</name> = <name>str</name></expr>;</expr_stmt></then></if>
					<return>return <expr>0</expr>;</return>
				}</block></then></if>
				<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<break>break;</break>
	</case>}</block></switch>

	<comment type="block">/* catch silly bases */</comment>
	<if>if <condition>(<expr><name>base</name> &lt; 2 || <name>base</name> &gt; 36</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
			<expr_stmt><expr>*<name>ptr</name> = <name>str</name></expr>;</expr_stmt></then></if>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* skip leading zeroes */</comment>
	<while>while <condition>(<expr>*<name>str</name> == '0'</expr>)</condition>
		<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt></while>

	<comment type="block">/* base is guaranteed to be in [2, 36] at this point */</comment>
	<expr_stmt><expr><name>ovlimit</name> = <name><name>digitlimit</name><index>[<expr><name>base</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* do the conversion until non-digit character encountered */</comment>
	<while>while <condition>(<expr>(<name>c</name> = <name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>]</index></name>) &lt; <name>base</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><name>ovlimit</name> &gt; 0</expr>)</condition><then> <comment type="block">/* no overflow check required */</comment>
			<expr_stmt><expr><name>result</name> = <name>result</name> * <name>base</name> + <name>c</name></expr>;</expr_stmt></then>
		<else>else <block>{ <comment type="block">/* requires overflow check */</comment>
			<decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>long</name></type> <name>temp_result</name></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>ovlimit</name> &lt; 0</expr>)</condition><then> <comment type="block">/* guaranteed overflow */</comment>
				<goto>goto <name>overflowed</name>;</goto></then></if>

			<comment type="block">/* there could be an overflow */</comment>
			<comment type="block">/* check overflow just from shifting */</comment>
			<if>if <condition>(<expr><name>result</name> &gt; <name><name>smallmax</name><index>[<expr><name>base</name></expr>]</index></name></expr>)</condition><then>
				<goto>goto <name>overflowed</name>;</goto></then></if>

			<expr_stmt><expr><name>result</name> *= <name>base</name></expr>;</expr_stmt>

			<comment type="block">/* check overflow from the digit's value */</comment>
			<expr_stmt><expr><name>temp_result</name> = <name>result</name> + <name>c</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>temp_result</name> &lt; <name>result</name></expr>)</condition><then>
				<goto>goto <name>overflowed</name>;</goto></then></if>

			<expr_stmt><expr><name>result</name> = <name>temp_result</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
		<expr_stmt><expr>--<name>ovlimit</name></expr>;</expr_stmt>
	}</block></while>

	<comment type="block">/* set pointer to point to the last character scanned */</comment>
	<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ptr</name> = <name>str</name></expr>;</expr_stmt></then></if>

	<return>return <expr><name>result</name></expr>;</return>

<label><name>overflowed</name>:</label>
	<if>if <condition>(<expr><name>ptr</name></expr>)</condition><then> <block>{
		<comment type="block">/* spool through remaining digit characters */</comment>
		<while>while <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>]</index></name> &lt; <name>base</name></expr>)</condition>
			<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt></while>
		<expr_stmt><expr>*<name>ptr</name> = <name>str</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt>
	<return>return <expr>(<name>unsigned</name> <name>long</name>)-1</expr>;</return>
}</block></function>

<comment type="block">/* Checking for overflow in PyOS_strtol is a PITA; see comments
 * about PY_ABS_LONG_MIN in longobject.c.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ABS_LONG_MIN</name></cpp:macro>		<cpp:value>(0-(unsigned long)LONG_MIN)</cpp:value></cpp:define>

<function><type><name>long</name></type>
<name>PyOS_strtol</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>char</name> **</type><name>ptr</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>uresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>sign</name></decl>;</decl_stmt>

	<while>while <condition>(<expr>*<name>str</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>

	<expr_stmt><expr><name>sign</name> = *<name>str</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>sign</name> == '+' || <name>sign</name> == '-'</expr>)</condition><then>
		<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>uresult</name> = <call><name>PyOS_strtoul</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>uresult</name> &lt;= (<name>unsigned</name> <name>long</name>)<name>LONG_MAX</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = (<name>long</name>)<name>uresult</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>sign</name> == '-'</expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = -<name>result</name></expr>;</expr_stmt></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>sign</name> == '-' &amp;&amp; <name>uresult</name> == <name>PY_ABS_LONG_MIN</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name>LONG_MIN</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>LONG_MAX</name></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
</unit>
