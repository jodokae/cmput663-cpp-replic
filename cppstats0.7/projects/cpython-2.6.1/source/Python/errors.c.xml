<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/errors.c">
<comment type="block">/* Error handling */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__STDC__</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>strerror</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"windows.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"winbase.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>void</name></type>
<name>PyErr_Restore</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>traceback</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>oldtype</name></decl>, *<decl><type ref="prev"/><name>oldvalue</name></decl>, *<decl><type ref="prev"/><name>oldtraceback</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>traceback</name> != <name>NULL</name> &amp;&amp; !<call><name>PyTraceBack_Check</name><argument_list>(<argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* XXX Should never happen -- fatal error instead? */</comment>
		<comment type="block">/* Well, it could be None. */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>traceback</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Save these in locals to safeguard against recursive
	   invocation through Py_XDECREF */</comment>
	<expr_stmt><expr><name>oldtype</name> = <name><name>tstate</name>-&gt;<name>curexc_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldvalue</name> = <name><name>tstate</name>-&gt;<name>curexc_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldtraceback</name> = <name><name>tstate</name>-&gt;<name>curexc_traceback</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>curexc_type</name></name> = <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>curexc_value</name></name> = <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>curexc_traceback</name></name> = <name>traceback</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>oldtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>oldvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>oldtraceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyErr_SetObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exception</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>exception</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyErr_SetNone</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exception</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyErr_SetString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exception</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>PyErr_Occurred</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>tstate</name>-&gt;<name>curexc_type</name></name></expr>;</return>
}</block></function>


<function><type><name>int</name></type>
<name>PyErr_GivenExceptionMatches</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>err</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>err</name> == <name>NULL</name> || <name>exc</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* maybe caused by "import exceptions" that failed early on */</comment>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<comment type="block">/* Test recursively */</comment>
		     <if>if <condition>(<expr><call><name>PyErr_GivenExceptionMatches</name><argument_list>(
			     <argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		     <block>{
			     <return>return <expr>1</expr>;</return>
		     }</block></then></if>
		}</block></for>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<comment type="block">/* err might be an instance, so check its class. */</comment>
	<if>if <condition>(<expr><call><name>PyExceptionInstance_Check</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>err</name> = <call><name>PyExceptionInstance_Class</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>PyExceptionClass_Check</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyExceptionClass_Check</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>exception</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>exception</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_IsSubclass</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* This function must not fail, so print the error here */</comment>
		<if>if <condition>(<expr><name>res</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><name>err</name> == <name>exc</name></expr>;</return>
}</block></function>


<function><type><name>int</name></type>
<name>PyErr_ExceptionMatches</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyErr_GivenExceptionMatches</name><argument_list>(<argument><expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Used in many places to normalize a raised exception, including in
   eval_code2(), do_raise(), and PyErr_Print()
*/</comment>
<function><type><name>void</name></type>
<name>PyErr_NormalizeException</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>exc</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>val</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>tb</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>type</name> <init>= <expr>*<name>exc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr>*<name>val</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>inclass</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>initial_tb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>type</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* There was no exception, so nothing to do. */</comment>
		<return>return;</return>
	}</block></then></if>

	<comment type="block">/* If PyErr_SetNone() was used, the value will have been actually
	   set to NULL.
	*/</comment>
	<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyExceptionInstance_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>inclass</name> = <call><name>PyExceptionInstance_Class</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* Normalize the exception so that if the type is a class, the
	   value will be an instance.
	*/</comment>
	<if>if <condition>(<expr><call><name>PyExceptionClass_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* if the value was not an instance, or is not an instance
		   whose class is (or is derived from) type, then use the
		   value as an argument to instantiation of the type
		   class.
		*/</comment>
		<if>if <condition>(<expr>!<name>inclass</name> || !<call><name>PyObject_IsSubclass</name><argument_list>(<argument><expr><name>inclass</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then>
				<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>args</name> = <name>value</name></expr>;</expr_stmt>
			}</block></then>
			<else>else
				<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

			<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>finally</name>;</goto></then></if>
			<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>finally</name>;</goto></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> = <name>res</name></expr>;</expr_stmt>
		}</block></then>
		<comment type="block">/* if the class of the instance doesn't exactly match the
		   class of the type, believe the instance
		*/</comment>
		<else>else <if>if <condition>(<expr><name>inclass</name> != <name>type</name></expr>)</condition><then> <block>{
 			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>type</name> = <name>inclass</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></else></if>
	}</block></then></if>
	<expr_stmt><expr>*<name>exc</name> = <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>val</name> = <name>value</name></expr>;</expr_stmt>
	<return>return;</return>
<label><name>finally</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If the new exception doesn't set a traceback and the old
	   exception had a traceback, use the old traceback for the
	   new exception.  It's better than nothing.
	*/</comment>
	<expr_stmt><expr><name>initial_tb</name> = *<name>tb</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>initial_tb</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>*<name>tb</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr>*<name>tb</name> = <name>initial_tb</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>initial_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if>
	<comment type="block">/* normalize recursively */</comment>
	<expr_stmt><expr><name>tstate</name> = <call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>++<name><name>tstate</name>-&gt;<name>recursion_depth</name></name> &gt; <call><name>Py_GetRecursionLimit</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr>--<name><name>tstate</name>-&gt;<name>recursion_depth</name></name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr><name>PyExc_RecursionErrorInst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_NormalizeException</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>--<name><name>tstate</name>-&gt;<name>recursion_depth</name></name></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>PyErr_Fetch</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>p_type</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>p_value</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>p_traceback</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr>*<name>p_type</name> = <name><name>tstate</name>-&gt;<name>curexc_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>p_value</name> = <name><name>tstate</name>-&gt;<name>curexc_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>p_traceback</name> = <name><name>tstate</name>-&gt;<name>curexc_traceback</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>curexc_type</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>curexc_value</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>curexc_traceback</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyErr_Clear</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Convenience functions to set a type error exception and return 0 */</comment>

<function><type><name>int</name></type>
<name>PyErr_BadArgument</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"bad argument type for built-in operation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyErr_NoMemory</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<comment type="block">/* already current */</comment>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* raise the pre-allocated instance if it still exists */</comment>
	<if>if <condition>(<expr><name>PyExc_MemoryErrorInst</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr><name>PyExc_MemoryErrorInst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<comment type="block">/* this will probably fail since there's no memory and hee,
		   hee, we have to instantiate this class
		*/</comment>
		<expr_stmt><expr><call><name>PyErr_SetNone</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyErr_SetFromErrnoWithFilenameObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>filenameObject</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PLAN9</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><name>ERRMAX</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name> *</type><name>s_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>s_small_buf</name><index>[<expr>28</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Room for "Windows Error 0xFFFFFFFF" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EINTR</name></cpp:ifdef>
	<if>if <condition>(<expr><name>i</name> == <name>EINTR</name> &amp;&amp; <call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PLAN9</name></cpp:ifdef>
	<expr_stmt><expr><call><name>rerrstr</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr>sizeof <name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> = <name>errbuf</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>s</name> = "Error"</expr>;</expr_stmt></then> <comment type="block">/* Sometimes errno didn't get set */</comment>
	<else>else
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
		<expr_stmt><expr><name>s</name> = <call><name>strerror</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<block>{
		<comment type="block">/* Note that the Win32 errors do not lineup with the
		   errno error.  So if the error is in the MSVC error
		   table, we use it, otherwise we assume it really _is_
		   a Win32 error code
		*/</comment>
		<if>if <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name>i</name> &lt; <name>_sys_nerr</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>s</name> = <name><name>_sys_errlist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>FormatMessage</name><argument_list>(
				<argument><expr><name>FORMAT_MESSAGE_ALLOCATE_BUFFER</name> |
				<name>FORMAT_MESSAGE_FROM_SYSTEM</name> |
				<name>FORMAT_MESSAGE_IGNORE_INSERTS</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no message source */</comment>
				<argument><expr><name>i</name></expr></argument>,
				<argument><expr><call><name>MAKELANGID</name><argument_list>(<argument><expr><name>LANG_NEUTRAL</name></expr></argument>,
					   <argument><expr><name>SUBLANG_DEFAULT</name></expr></argument>)</argument_list></call></expr></argument>,
				           <comment type="block">/* Default language */</comment>
				<argument><expr>(<name>LPTSTR</name>) &amp;<name>s_buf</name></expr></argument>,
				<argument><expr>0</expr></argument>,	<comment type="block">/* size not used */</comment>
				<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* no args */</comment>
			<if>if <condition>(<expr><name>len</name>==0</expr>)</condition><then> <block>{
				<comment type="block">/* Only ever seen this in out-of-mem
				   situations */</comment>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s_small_buf</name></expr></argument>, <argument><expr>"Windows Error 0x%X"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> = <name>s_small_buf</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>s_buf</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><name>s</name> = <name>s_buf</name></expr>;</expr_stmt>
				<comment type="block">/* remove trailing cr/lf and dots */</comment>
				<while>while <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; (<name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name> &lt;= ' ' || <name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name> == '.')</expr>)</condition>
					<expr_stmt><expr><name><name>s</name><index>[<expr>--<name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt></while>
			}</block></else></if>
		}</block></else></if>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Unix/Windows */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PLAN 9*/</comment>
	<if>if <condition>(<expr><name>filenameObject</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(isO)"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>filenameObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><name>s_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><name>PyObject</name> *</type>
<name>PyErr_SetFromErrnoWithFilename</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>, <param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>filename</name> ? <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyErr_SetFromErrnoWithFilenameObject</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
<function><type><name>PyObject</name> *</type>
<name>PyErr_SetFromErrnoWithUnicodeFilename</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>, <param><decl><type><name>Py_UNICODE</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>filename</name> ?
	                 <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>wcslen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> :
	                 <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyErr_SetFromErrnoWithFilenameObject</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_WIN_WIDE_FILENAMES */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyErr_SetFromErrno</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyErr_SetFromErrnoWithFilenameObject</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<comment type="block">/* Windows specific error code handling */</comment>
<function><type><name>PyObject</name> *</type><name>PyErr_SetExcFromWindowsErrWithFilenameObject</name><parameter_list>(
	<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>,
	<param><decl><type><name>int</name></type> <name>ierr</name></decl></param>,
	<param><decl><type><name>PyObject</name> *</type><name>filenameObject</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>s_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Free via LocalFree */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>s_small_buf</name><index>[<expr>28</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Room for "Windows Error 0xFFFFFFFF" */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>err</name> <init>= <expr>(<name>DWORD</name>)<name>ierr</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>err</name>==0</expr>)</condition><then> <expr_stmt><expr><name>err</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>len</name> = <call><name>FormatMessage</name><argument_list>(
		<comment type="block">/* Error API error */</comment>
		<argument><expr><name>FORMAT_MESSAGE_ALLOCATE_BUFFER</name> |
		<name>FORMAT_MESSAGE_FROM_SYSTEM</name> |
		<name>FORMAT_MESSAGE_IGNORE_INSERTS</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no message source */</comment>
		<argument><expr><name>err</name></expr></argument>,
		<argument><expr><call><name>MAKELANGID</name><argument_list>(<argument><expr><name>LANG_NEUTRAL</name></expr></argument>,
		<argument><expr><name>SUBLANG_DEFAULT</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* Default language */</comment>
		<argument><expr>(<name>LPTSTR</name>) &amp;<name>s_buf</name></expr></argument>,
		<argument><expr>0</expr></argument>,	<comment type="block">/* size not used */</comment>
		<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no args */</comment>
	<if>if <condition>(<expr><name>len</name>==0</expr>)</condition><then> <block>{
		<comment type="block">/* Only seen this in out of mem situations */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s_small_buf</name></expr></argument>, <argument><expr>"Windows Error 0x%X"</expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> = <name>s_small_buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s_buf</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>s</name> = <name>s_buf</name></expr>;</expr_stmt>
		<comment type="block">/* remove trailing cr/lf and dots */</comment>
		<while>while <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; (<name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name> &lt;= ' ' || <name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name> == '.')</expr>)</condition>
			<expr_stmt><expr><name><name>s</name><index>[<expr>--<name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt></while>
	}</block></else></if>
	<if>if <condition>(<expr><name>filenameObject</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(isO)"</expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>filenameObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><name>s_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyErr_SetExcFromWindowsErrWithFilename</name><parameter_list>(
	<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>,
	<param><decl><type><name>int</name></type> <name>ierr</name></decl></param>,
	<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>filename</name> ? <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><call><name>PyErr_SetExcFromWindowsErrWithFilenameObject</name><argument_list>(<argument><expr><name>exc</name></expr></argument>,
	                                                             <argument><expr><name>ierr</name></expr></argument>,
	                                                             <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
<function><type><name>PyObject</name> *</type><name>PyErr_SetExcFromWindowsErrWithUnicodeFilename</name><parameter_list>(
	<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>,
	<param><decl><type><name>int</name></type> <name>ierr</name></decl></param>,
	<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>filename</name> ?
	                 <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>wcslen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> :
	                 <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><call><name>PyErr_SetExcFromWindowsErrWithFilenameObject</name><argument_list>(<argument><expr><name>exc</name></expr></argument>,
	                                                             <argument><expr><name>ierr</name></expr></argument>,
	                                                             <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_WIN_WIDE_FILENAMES */</comment>

<function><type><name>PyObject</name> *</type><name>PyErr_SetExcFromWindowsErr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>, <param><decl><type><name>int</name></type> <name>ierr</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyErr_SetExcFromWindowsErrWithFilename</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>ierr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type><name>PyErr_SetFromWindowsErr</name><parameter_list>(<param><decl><type><name>int</name></type> <name>ierr</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyErr_SetExcFromWindowsErrWithFilename</name><argument_list>(<argument><expr><name>PyExc_WindowsError</name></expr></argument>,
						      <argument><expr><name>ierr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyErr_SetFromWindowsErrWithFilename</name><parameter_list>(
	<param><decl><type><name>int</name></type> <name>ierr</name></decl></param>,
	<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>filename</name> ? <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyErr_SetExcFromWindowsErrWithFilenameObject</name><argument_list>(
						      <argument><expr><name>PyExc_WindowsError</name></expr></argument>,
						      <argument><expr><name>ierr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
<function><type><name>PyObject</name> *</type><name>PyErr_SetFromWindowsErrWithUnicodeFilename</name><parameter_list>(
	<param><decl><type><name>int</name></type> <name>ierr</name></decl></param>,
	<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>filename</name> ?
	                 <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>wcslen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> :
	                 <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyErr_SetExcFromWindowsErrWithFilenameObject</name><argument_list>(
						      <argument><expr><name>PyExc_WindowsError</name></expr></argument>,
						      <argument><expr><name>ierr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_WIN_WIDE_FILENAMES */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<function><type><name>void</name></type>
<name>_PyErr_BadInternalCall</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
		     <argument><expr>"%s:%d: bad argument to internal function"</expr></argument>,
		     <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Remove the preprocessor macro for PyErr_BadInternalCall() so that we can
   export the entry point for existing object code: */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyErr_BadInternalCall</name></cpp:undef>
<function><type><name>void</name></type>
<name>PyErr_BadInternalCall</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
		     <argument><expr>"bad argument to internal function"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyErr_BadInternalCall</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>_PyErr_BadInternalCall(__FILE__, __LINE__)</cpp:value></cpp:define>



<function><type><name>PyObject</name> *</type>
<name>PyErr_Format</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exception</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>string</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STDARG_PROTOTYPES</name></cpp:ifdef>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>string</name> = <call><name>PyString_FromFormatV</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>



<function><type><name>PyObject</name> *</type>
<name>PyErr_NewException</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>base</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>dot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modulename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>classname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mydict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>bases</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>dot</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dot</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			<argument><expr>"PyErr_NewException: name must be module.class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>base</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>base</name> = <name>PyExc_Exception</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>dict</name> = <name>mydict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>failure</name>;</goto></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__module__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>modulename</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
						     <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><name>dot</name>-<name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>modulename</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>failure</name>;</goto></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__module__"</expr></argument>, <argument><expr><name>modulename</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
			<goto>goto <name>failure</name>;</goto></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>bases</name> = <name>base</name></expr>;</expr_stmt>
		<comment type="block">/* INCREF as we create a new ref in the else branch */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>bases</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bases</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>failure</name>;</goto></then></if>
	}</block></else></if>
	<comment type="block">/* Create a real new-style class. */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>"sOO"</expr></argument>,
				       <argument><expr><name>dot</name>+1</expr></argument>, <argument><expr><name>bases</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>failure</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>mydict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Call when an exception has occurred but there is no way for Python
   to handle it.  Examples: exception in __del__ or during GC. */</comment>
<function><type><name>void</name></type>
<name>PyErr_WriteUnraisable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>, *<decl><type ref="prev"/><name>t</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stderr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"Exception "</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>t</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name>*</type> <name>moduleName</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>*</type> <name>className</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyExceptionClass_Check</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>className</name> = <call><name>PyExceptionClass_Name</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>className</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>dot</name> != <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><name>className</name> = <name>dot</name>+1</expr>;</expr_stmt></then></if>
			}</block></then></if>

			<expr_stmt><expr><name>moduleName</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>"__module__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>moduleName</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"&lt;unknown&gt;"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <block>{
				<decl_stmt><decl><type><name>char</name>*</type> <name>modstr</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>moduleName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>modstr</name> &amp;&amp;
				    <call><name>strcmp</name><argument_list>(<argument><expr><name>modstr</name></expr></argument>, <argument><expr>"exceptions"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
				<block>{
					<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>modstr</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"."</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></else></if>
			<if>if <condition>(<expr><name>className</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>"&lt;unknown&gt;"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<if>if <condition>(<expr><name>v</name> &amp;&amp; <name>v</name> != <name>Py_None</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>": "</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>moduleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>" in "</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr>" ignored\n"</expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Just in case */</comment>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>PyModule_GetWarningsModule</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Set file and line information for the current exception.
   If the exception is not a SyntaxError, also sets additional attributes
   to make printing of exceptions believe it is a syntax error. */</comment>

<function><type><name>void</name></type>
<name>PyErr_SyntaxLocation</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

	<comment type="block">/* add attributes for the line number and filename for the error */</comment>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_NormalizeException</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* XXX check that it is, indeed, a syntax error. It might not
	 * be, though. */</comment>
	<expr_stmt><expr><name>tmp</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"lineno"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>filename</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>tmp</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"filename"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><name>tmp</name> = <call><name>PyErr_ProgramText</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmp</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"text"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"offset"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>exc</name> != <name>PyExc_SyntaxError</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"msg"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>tmp</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>tmp</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"msg"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"print_file_and_line"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"print_file_and_line"</expr></argument>,
						   <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* com_fetch_program_text will attempt to load the line of text that
   the exception refers to.  If it fails, it will return NULL but will
   not set an exception.

   XXX The functionality of this function is quite similar to the
   functionality in tb_displayline() in traceback.c.
*/</comment>

<function><type><name>PyObject</name> *</type>
<name>PyErr_ProgramText</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>linebuf</name><index>[<expr>1000</expr>]</index></name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>filename</name> == <name>NULL</name> || *<name>filename</name> == '\0' || <name>lineno</name> &lt;= 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"r" <name>PY_STDIOTEXTMODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>lineno</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>pLastChar</name> <init>= <expr>&amp;<name><name>linebuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>linebuf</name></expr></argument>)</argument_list></sizeof> - 2</expr>]</index></name></expr></init></decl>;</decl_stmt>
		<do>do <block>{
			<expr_stmt><expr>*<name>pLastChar</name> = '\0'</expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>Py_UniversalNewlineFgets</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr>sizeof <name>linebuf</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
				<break>break;</break></then></if>
			<comment type="block">/* fgets read *something*; if it didn't get as
			   far as pLastChar, it must have found a newline
			   or hit the end of the file; if pLastChar is \n,
			   it obviously found a newline; else we haven't
			   yet seen a newline, so must continue */</comment>
		}</block> while <condition>(<expr>*<name>pLastChar</name> != '\0' &amp;&amp; *<name>pLastChar</name> != '\n'</expr>)</condition>;</do>
	}</block></for>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> == <name>lineno</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>linebuf</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr>*<name>p</name> == ' ' || *<name>p</name> == '\t' || *<name>p</name> == '\014'</expr>)</condition>
			<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt></while>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
