<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/sysmodule.c">
<comment type="block">/* System module */</comment>

<comment type="block">/*
Various bits of information used by the interpreter are collected in
module 'sys'.
Function member:
- exit(sts): raise SystemExit
Data members:
- stdin, stdout, stderr: standard file objects
- modules: the table of modules (dictionary)
- path: module search path (list of strings)
- argv: script arguments (list of strings)
- ps1, ps2: optional primary and secondary prompts (strings)
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structseq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"frameobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"windows.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_COREDLL</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>void</name> *</type><name>PyWin_DLLhModule</name></decl>;</decl_stmt>
<comment type="block">/* A string loaded from the DLL at startup: */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> *</type><name>PyWin_DLLVersionString</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unixlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LANGINFO_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;langinfo.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PyObject</name> *</type>
<name>PySys_GetObject</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sd</name> <init>= <expr><name><name>tstate</name>-&gt;<name>interp</name>-&gt;<name>sysdict</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>sd</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>FILE</name> *</type>
<name>PySys_GetFile</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>def</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name> &amp;&amp; <call><name>PyFile_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>fp</name> = <call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>fp</name> = <name>def</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>fp</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PySys_SetObject</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sd</name> <init>= <expr><name><name>tstate</name>-&gt;<name>interp</name>-&gt;<name>sysdict</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then>
		<else>else
			<return>return <expr><call><name>PyDict_DelItemString</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_displayhook</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>outf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><name><name>interp</name>-&gt;<name>modules</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>builtins</name> <init>= <expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>builtins</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"lost __builtin__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Print value except if None */</comment>
	<comment type="block">/* After printing, also assign to '_' */</comment>
	<comment type="block">/* Before, set '_' to None to avoid recursion */</comment>
	<if>if <condition>(<expr><name>o</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>, <argument><expr>"_"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>Py_FlushLine</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>outf</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>outf</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"lost sys.stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>outf</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyFile_SoftSpace</name><argument_list>(<argument><expr><name>outf</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>Py_FlushLine</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>, <argument><expr>"_"</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>displayhook_doc</name></expr></argument>,
<argument><expr>"displayhook(object) -&gt; None\n"
"\n"
"Print an object to sys.stdout and also save it in __builtin__.\n"</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_excepthook</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"excepthook"</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_Display</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>excepthook_doc</name></expr></argument>,
<argument><expr>"excepthook(exctype, value, traceback) -&gt; None\n"
"\n"
"Handle an exception by displaying it with a traceback on sys.stderr.\n"</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_exc_info</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>tstate</name> = <call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(
		<argument><expr>"(OOO)"</expr></argument>,
		<argument><expr><name><name>tstate</name>-&gt;<name>exc_type</name></name> != <name>NULL</name> ? <name><name>tstate</name>-&gt;<name>exc_type</name></name> : <name>Py_None</name></expr></argument>,
		<argument><expr><name><name>tstate</name>-&gt;<name>exc_value</name></name> != <name>NULL</name> ? <name><name>tstate</name>-&gt;<name>exc_value</name></name> : <name>Py_None</name></expr></argument>,
		<argument><expr><name><name>tstate</name>-&gt;<name>exc_traceback</name></name> != <name>NULL</name> ?
			<name><name>tstate</name>-&gt;<name>exc_traceback</name></name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>exc_info_doc</name></expr></argument>,
<argument><expr>"exc_info() -&gt; (type, value, traceback)\n\
\n\
Return information about the most recent exception caught by an except\n\
clause in the current stack frame or in an older stack frame."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_exc_clear</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp_type</name></decl>, *<decl><type ref="prev"/><name>tmp_value</name></decl>, *<decl><type ref="prev"/><name>tmp_tb</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"sys.exc_clear() not supported in 3.x; "
			   "use except clauses"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>tstate</name> = <call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_type</name> = <name><name>tstate</name>-&gt;<name>exc_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_value</name> = <name><name>tstate</name>-&gt;<name>exc_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_tb</name> = <name><name>tstate</name>-&gt;<name>exc_traceback</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_type</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_value</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>exc_traceback</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* For b/w compatibility */</comment>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exc_type"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exc_value"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"exc_traceback"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>exc_clear_doc</name></expr></argument>,
<argument><expr>"exc_clear() -&gt; None\n\
\n\
Clear global information on the current exception.  Subsequent calls to\n\
exc_info() will return (None,None,None) until another exception is raised\n\
in the current thread or the execution stack returns to a frame where\n\
another exception is being handled."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_exit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>exit_code</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"exit"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>exit_code</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* Raise SystemExit so callers may catch it or clean up. */</comment>
	<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_SystemExit</name></expr></argument>, <argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>exit_doc</name></expr></argument>,
<argument><expr>"exit([status])\n\
\n\
Exit the interpreter by raising SystemExit(status).\n\
If the status is omitted or None, it defaults to zero (i.e., success).\n\
If the status is numeric, it will be used as the system exit status.\n\
If it is another kind of object, it will be printed and the system\n\
exit status will be one (i.e., failure)."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getdefaultencoding</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getdefaultencoding_doc</name></expr></argument>,
<argument><expr>"getdefaultencoding() -&gt; string\n\
\n\
Return the current default string encoding used by the Unicode \n\
implementation."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_setdefaultencoding</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>encoding</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:setdefaultencoding"</expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyUnicode_SetDefaultEncoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    	<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setdefaultencoding_doc</name></expr></argument>,
<argument><expr>"setdefaultencoding(encoding)\n\
\n\
Set the current default string encoding used by the Unicode implementation."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getfilesystemencoding</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>Py_FileSystemDefaultEncoding</name></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getfilesystemencoding_doc</name></expr></argument>,
<argument><expr>"getfilesystemencoding() -&gt; string\n\
\n\
Return the encoding used to convert Unicode filenames in\n\
operating system filenames."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Cached interned string objects used for calling the profile and
 * trace functions.  Initialized by trace_init().
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name><name>whatstrings</name><index>[<expr>7</expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>trace_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>whatnames</name><index>[<expr>7</expr>]</index></name> <init>= <expr><block>{<expr>"call"</expr>, <expr>"exception"</expr>, <expr>"line"</expr>, <expr>"return"</expr>,
					<expr>"c_call"</expr>, <expr>"c_exception"</expr>, <expr>"c_return"</expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 7</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>whatstrings</name><index>[<expr><name>i</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name><name>whatnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><name><name>whatstrings</name><index>[<expr><name>i</name></expr>]</index></name> = <name>name</name></expr>;</expr_stmt>
                }</block></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_trampoline</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>callback</name></decl></param>,
		<param><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl></param>, <param><decl><type><name>int</name></type> <name>what</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>whatstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>whatstr</name> = <name><name>whatstrings</name><index>[<expr><name>what</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>whatstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>arg</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>whatstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* call the Python-level function */</comment>
	<expr_stmt><expr><call><name>PyFrame_FastToLocals</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>callback</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyFrame_LocalsToFast</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyTraceBack_Here</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* cleanup */</comment>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>profile_trampoline</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl></param>,
		   <param><decl><type><name>int</name></type> <name>what</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><name><name>frame</name>-&gt;<name>f_tstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>arg</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>call_trampoline</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>trace_trampoline</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl></param>,
		 <param><decl><type><name>int</name></type> <name>what</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><name><name>frame</name>-&gt;<name>f_tstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>callback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>what</name> == <name>PyTrace_CALL</name></expr>)</condition><then>
		<expr_stmt><expr><name>callback</name> = <name>self</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>callback</name> = <name><name>frame</name>-&gt;<name>f_trace</name></name></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>callback</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>call_trampoline</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyEval_SetTrace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>frame</name>-&gt;<name>f_trace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_trace</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>result</name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name><name>frame</name>-&gt;<name>f_trace</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_trace</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frame</name>-&gt;<name>f_trace</name></name> = <name>result</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_settrace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>trace_init</name><argument_list>()</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>args</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyEval_SetTrace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PyEval_SetTrace</name><argument_list>(<argument><expr><name>trace_trampoline</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>settrace_doc</name></expr></argument>,
<argument><expr>"settrace(function)\n\
\n\
Set the global debug tracing function.  It will be called on each\n\
function call.  See the debugger chapter in the library manual."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_gettrace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>temp</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>temp</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gettrace_doc</name></expr></argument>,
<argument><expr>"gettrace()\n\
\n\
Return the global debug tracing function set with sys.settrace.\n\
See the debugger chapter in the library manual."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_setprofile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>trace_init</name><argument_list>()</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>args</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>profile_trampoline</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setprofile_doc</name></expr></argument>,
<argument><expr>"setprofile(function)\n\
\n\
Set the profiling function.  It will be called on each function call\n\
and return.  See the profiler chapter in the library manual."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getprofile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>temp</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>temp</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getprofile_doc</name></expr></argument>,
<argument><expr>"getprofile()\n\
\n\
Return the profiling function set with sys.setprofile.\n\
See the profiler chapter in the library manual."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_setcheckinterval</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:setcheckinterval"</expr></argument>, <argument><expr>&amp;<name>_Py_CheckInterval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setcheckinterval_doc</name></expr></argument>,
<argument><expr>"setcheckinterval(n)\n\
\n\
Tell the Python interpreter to check for asynchronous events every\n\
n instructions.  This also affects how often thread switches occur."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getcheckinterval</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>_Py_CheckInterval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getcheckinterval_doc</name></expr></argument>,
<argument><expr>"getcheckinterval() -&gt; current check interval; see setcheckinterval()."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_TSC</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_settscdump</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>bool</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_Get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:settscdump"</expr></argument>, <argument><expr>&amp;<name>bool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>bool</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>interp</name>-&gt;<name>tscdump</name></name> = 1</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name><name>tstate</name>-&gt;<name>interp</name>-&gt;<name>tscdump</name></name> = 0</expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>

}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>settscdump_doc</name></expr></argument>,
<argument><expr>"settscdump(bool)\n\
\n\
If true, tell the Python interpreter to dump VM measurements to\n\
stderr.  If false, turn off dump.  The measurements are based on the\n\
processor's time-stamp counter."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TSC */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_setrecursionlimit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>new_limit</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:setrecursionlimit"</expr></argument>, <argument><expr>&amp;<name>new_limit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>new_limit</name> &lt;= 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"recursion limit must be positive"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_SetRecursionLimit</name><argument_list>(<argument><expr><name>new_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setrecursionlimit_doc</name></expr></argument>,
<argument><expr>"setrecursionlimit(n)\n\
\n\
Set the maximum depth of the Python interpreter stack to n.  This\n\
limit prevents infinite recursion from causing an overflow of the C\n\
stack and crashing Python.  The highest possible limit is platform-\n\
dependent."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getrecursionlimit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>Py_GetRecursionLimit</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getrecursionlimit_doc</name></expr></argument>,
<argument><expr>"getrecursionlimit()\n\
\n\
Return the current value of the recursion limit, the maximum depth\n\
of the Python interpreter stack.  This limit prevents infinite\n\
recursion from causing an overflow of the C stack and crashing Python."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getwindowsversion_doc</name></expr></argument>,
<argument><expr>"getwindowsversion()\n\
\n\
Return information about the running version of Windows.\n\
The result is a tuple of (major, minor, build, platform, text)\n\
All elements are numbers, except text which is a string.\n\
Platform may be 0 for win32s, 1 for Windows 9x/ME, 2 for Windows NT/2000/XP\n\
"</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getwindowsversion</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>OSVERSIONINFO</name></type> <name>ver</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ver</name>.<name>dwOSVersionInfoSize</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>ver</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>GetVersionEx</name><argument_list>(<argument><expr>&amp;<name>ver</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"HHHHs"</expr></argument>,
	                     <argument><expr><name><name>ver</name>.<name>dwMajorVersion</name></name></expr></argument>,
	                     <argument><expr><name><name>ver</name>.<name>dwMinorVersion</name></name></expr></argument>,
	                     <argument><expr><name><name>ver</name>.<name>dwBuildNumber</name></name></expr></argument>,
	                     <argument><expr><name><name>ver</name>.<name>dwPlatformId</name></name></expr></argument>,
	                     <argument><expr><name><name>ver</name>.<name>szCSDVersion</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DLOPEN</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_setdlopenflags</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>new_val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:setdlopenflags"</expr></argument>, <argument><expr>&amp;<name>new_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<name>tstate</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>tstate</name>-&gt;<name>interp</name>-&gt;<name>dlopenflags</name></name> = <name>new_val</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setdlopenflags_doc</name></expr></argument>,
<argument><expr>"setdlopenflags(n) -&gt; None\n\
\n\
Set the flags that will be used for dlopen() calls. Among other\n\
things, this will enable a lazy resolving of symbols when importing\n\
a module, if called as sys.setdlopenflags(0)\n\
To share symbols across extension modules, call as\n\
sys.setdlopenflags(dl.RTLD_NOW|dl.RTLD_GLOBAL)"</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getdlopenflags</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>tstate</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>interp</name>-&gt;<name>dlopenflags</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getdlopenflags_doc</name></expr></argument>,
<argument><expr>"getdlopenflags() -&gt; int\n\
\n\
Return the current value of the flags that are used for dlopen()\n\
calls. The flag constants are defined in the dl module."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_MALLOPT</name></cpp:ifdef>
<comment type="block">/* Link with -lmalloc (or -lmpc) on an SGI */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_mdebug</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:mdebug"</expr></argument>, <argument><expr>&amp;<name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>mallopt</name><argument_list>(<argument><expr><name>M_DEBUG</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_MALLOPT */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getsizeof</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>str__sizeof__</name></decl>, *<decl><type ref="prev"/><name>gc_head_size</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"object"</expr>, <expr>"default"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>, *<decl><type ref="prev"/><name>dflt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"O|O:getsizeof"</expr></argument>,
					 <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>o</name></expr></argument>, <argument><expr>&amp;<name>dflt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Initialize static variable needed by _PyType_Lookup */</comment>
	<if>if <condition>(<expr><name>str__sizeof__</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>str__sizeof__</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__sizeof__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>str__sizeof__</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

        <comment type="block">/* Initialize static variable for GC head size */</comment>
	<if>if <condition>(<expr><name>gc_head_size</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>gc_head_size</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyGC_Head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>gc_head_size</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<comment type="block">/* Make sure the type is initialized. float gets initialized late */</comment>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Instance of old-style class */</comment>
	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>PyInstance_Type</name>.<name>tp_basicsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<comment type="block">/* all other objects */</comment>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>method</name> <init>= <expr><call><name>_PyType_Lookup</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>str__sizeof__</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>method</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"Type %.100s doesn't define __sizeof__"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>res</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></else></if>
	
	<comment type="block">/* Has a default value been given? */</comment>
	<if>if <condition>(<expr>(<name>res</name> == <name>NULL</name>) &amp;&amp; (<name>dflt</name> != <name>NULL</name>) &amp;&amp;
	    <call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>dflt</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>res</name></expr>;</return></then></if></else></if>

	<comment type="block">/* add gc_head size */</comment>
	<if>if <condition>(<expr><call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>res</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>gc_head_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getsizeof_doc</name></expr></argument>,
<argument><expr>"getsizeof(object, default) -&gt; int\n\
\n\
Return the size of object in bytes."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getrefcount</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>arg</name>-&gt;<name>ob_refcnt</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_REF_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_gettotalrefcount</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><call><name>_Py_GetRefTotal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_REF_DEBUG */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getrefcount_doc</name></expr></argument>,
<argument><expr>"getrefcount(object) -&gt; integer\n\
\n\
Return the reference count of object.  The count returned is generally\n\
one higher than you might expect, because it includes the (temporary)\n\
reference as an argument to getrefcount()."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getcounts</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>get_counts</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

	<return>return <expr><call><name>get_counts</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getframe_doc</name></expr></argument>,
<argument><expr>"_getframe([depth]) -&gt; frameobject\n\
\n\
Return a frame object from the call stack.  If optional integer depth is\n\
given, return the frame object that many calls below the top of the stack.\n\
If that is deeper than the call stack, ValueError is raised.  The default\n\
for depth is zero, returning the frame at the top of the call stack.\n\
\n\
This function should be used for internal and specialized\n\
purposes only."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_getframe</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>f</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>frame</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:_getframe"</expr></argument>, <argument><expr>&amp;<name>depth</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<while>while <condition>(<expr><name>depth</name> &gt; 0 &amp;&amp; <name>f</name> != <name>NULL</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>f</name> = <name><name>f</name>-&gt;<name>f_back</name></name></expr>;</expr_stmt>
		<expr_stmt><expr>--<name>depth</name></expr>;</expr_stmt>
	}</block></while>
	<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"call stack is not deep enough"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name>*)<name>f</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>current_frames_doc</name></expr></argument>,
<argument><expr>"_current_frames() -&gt; dictionary\n\
\n\
Return a dictionary mapping each current thread T's thread id to T's\n\
current stack frame.\n\
\n\
This function should be used for specialized purposes only."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_current_frames</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>_PyThread_CurrentFrames</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>call_tracing_doc</name></expr></argument>,
<argument><expr>"call_tracing(func, args) -&gt; object\n\
\n\
Call func(*args), while tracing is enabled.  The tracing state is\n\
saved, and restored afterwards.  This is intended to be called from\n\
a debugger from a checkpoint, to recursively debug some other code."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_call_tracing</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>funcargs</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"call_tracing"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>funcargs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>_PyEval_CallTracing</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>funcargs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>callstats_doc</name></expr></argument>,
<argument><expr>"callstats() -&gt; tuple of integers\n\
\n\
Return a tuple of function call statistics, if CALL_PROFILE was defined\n\
when Python was built.  Otherwise, return None.\n\
\n\
When enabled, this function returns detailed, implementation-specific\n\
details about the number of function calls executed. The return value is\n\
a 11-tuple where the entries in the tuple are counts of:\n\
0. all function calls\n\
1. calls to PyFunction_Type objects\n\
2. PyFunction calls that do not create an argument tuple\n\
3. PyFunction calls that do not create an argument tuple\n\
   and bypass PyEval_EvalCodeEx()\n\
4. PyMethod calls\n\
5. PyMethod calls on bound methods\n\
6. PyType calls\n\
7. PyCFunction calls\n\
8. generator calls\n\
9. All other calls\n\
10. Number of stack pops performed by call_function()"</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TRACE_REFS</name></cpp:ifdef>
<comment type="block">/* Defined in objects.c because it uses static globals if that file */</comment>
<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>_Py_GetObjects</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DYNAMIC_EXECUTION_PROFILE</name></cpp:ifdef>
<comment type="block">/* Defined in ceval.c because it uses static globals if that file */</comment>
<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>_Py_GetDXProfile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>,  <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sys_clear_type_cache</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyType_ClearCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sys_clear_type_cache__doc__</name></expr></argument>,
<argument><expr>"_clear_type_cache() -&gt; None\n\
Clear the internal type lookup cache."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>sys_methods</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/* Might as well keep this in alphabetic order */</comment>
	<expr><block>{<expr>"callstats"</expr>, <expr>(<name>PyCFunction</name>)<name>PyEval_GetCallStats</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>callstats_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"_clear_type_cache"</expr>,	<expr><name>sys_clear_type_cache</name></expr>,	  <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>sys_clear_type_cache__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"_current_frames"</expr>, <expr><name>sys_current_frames</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>current_frames_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"displayhook"</expr>,	<expr><name>sys_displayhook</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>displayhook_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"exc_info"</expr>,	<expr><name>sys_exc_info</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>exc_info_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"exc_clear"</expr>,	<expr><name>sys_exc_clear</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>exc_clear_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"excepthook"</expr>,	<expr><name>sys_excepthook</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>excepthook_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"exit"</expr>,	<expr><name>sys_exit</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>exit_doc</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr><block>{<expr>"getdefaultencoding"</expr>, <expr>(<name>PyCFunction</name>)<name>sys_getdefaultencoding</name></expr>,
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>getdefaultencoding_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DLOPEN</name></cpp:ifdef>
	<expr><block>{<expr>"getdlopenflags"</expr>, <expr>(<name>PyCFunction</name>)<name>sys_getdlopenflags</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>getdlopenflags_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COUNT_ALLOCS</name></cpp:ifdef>
	<expr><block>{<expr>"getcounts"</expr>,	<expr>(<name>PyCFunction</name>)<name>sys_getcounts</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DYNAMIC_EXECUTION_PROFILE</name></cpp:ifdef>
	<expr><block>{<expr>"getdxp"</expr>,	<expr><name>_Py_GetDXProfile</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr><block>{<expr>"getfilesystemencoding"</expr>, <expr>(<name>PyCFunction</name>)<name>sys_getfilesystemencoding</name></expr>,
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>getfilesystemencoding_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TRACE_REFS</name></cpp:ifdef>
	<expr><block>{<expr>"getobjects"</expr>,	<expr><name>_Py_GetObjects</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_REF_DEBUG</name></cpp:ifdef>
	<expr><block>{<expr>"gettotalrefcount"</expr>, <expr>(<name>PyCFunction</name>)<name>sys_gettotalrefcount</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"getrefcount"</expr>,	<expr>(<name>PyCFunction</name>)<name>sys_getrefcount</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>getrefcount_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getrecursionlimit"</expr>, <expr>(<name>PyCFunction</name>)<name>sys_getrecursionlimit</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>getrecursionlimit_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getsizeof"</expr>,   <expr>(<name>PyCFunction</name>)<name>sys_getsizeof</name></expr>,
	 <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>getsizeof_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"_getframe"</expr>, <expr><name>sys_getframe</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>getframe_doc</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<expr><block>{<expr>"getwindowsversion"</expr>, <expr>(<name>PyCFunction</name>)<name>sys_getwindowsversion</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>getwindowsversion_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_MALLOPT</name></cpp:ifdef>
	<expr><block>{<expr>"mdebug"</expr>,	<expr><name>sys_mdebug</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr><block>{<expr>"setdefaultencoding"</expr>, <expr><name>sys_setdefaultencoding</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>setdefaultencoding_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"setcheckinterval"</expr>,	<expr><name>sys_setcheckinterval</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>setcheckinterval_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getcheckinterval"</expr>,	<expr><name>sys_getcheckinterval</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>getcheckinterval_doc</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DLOPEN</name></cpp:ifdef>
	<expr><block>{<expr>"setdlopenflags"</expr>, <expr><name>sys_setdlopenflags</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>setdlopenflags_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"setprofile"</expr>,	<expr><name>sys_setprofile</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>setprofile_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getprofile"</expr>,	<expr><name>sys_getprofile</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>getprofile_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"setrecursionlimit"</expr>, <expr><name>sys_setrecursionlimit</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>setrecursionlimit_doc</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_TSC</name></cpp:ifdef>
	<expr><block>{<expr>"settscdump"</expr>, <expr><name>sys_settscdump</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>settscdump_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"settrace"</expr>,	<expr><name>sys_settrace</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>settrace_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"gettrace"</expr>,	<expr><name>sys_gettrace</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>gettrace_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"call_tracing"</expr>, <expr><name>sys_call_tracing</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>call_tracing_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list_builtin_module_names</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(
			<argument><expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr><call><name>PyList_Sort</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>list</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>list</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>list</name> = <name>v</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>list</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>warnoptions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>PySys_ResetWarnOptions</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>warnoptions</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>warnoptions</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyList_SetSlice</name><argument_list>(<argument><expr><name>warnoptions</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>warnoptions</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PySys_AddWarnOption</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>warnoptions</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>warnoptions</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>warnoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>warnoptions</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>warnoptions</name> == <name>NULL</name></expr>)</condition><then>
			<return>return;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>str</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>str</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>warnoptions</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<function><type><name>int</name></type>
<name>PySys_HasWarnOptions</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<name>warnoptions</name> != <name>NULL</name> &amp;&amp; (<call><name>PyList_Size</name><argument_list>(<argument><expr><name>warnoptions</name></expr></argument>)</argument_list></call> &gt; 0)) ? 1 : 0</expr>;</return>
}</block></function>

<comment type="block">/* XXX This doc string is too long to be a single string literal in VC++ 5.0.
   Two literals concatenated works just fine.  If you have a K&amp;R compiler
   or other abomination that however *does* understand longer strings,
   get rid of the !!! comment in the middle and the quotes that surround it. */</comment>
<expr_stmt><expr><call><name>PyDoc_VAR</name><argument_list>(<argument><expr><name>sys_doc</name></expr></argument>)</argument_list></call> =
<macro><name>PyDoc_STR</name><argument_list>(
<argument>"This module provides access to some objects used or maintained by the\n\
interpreter and to functions that interact strongly with the interpreter.\n\
\n\
Dynamic objects:\n\
\n\
argv -- command line arguments; argv[0] is the script pathname if known\n\
path -- module search path; path[0] is the script directory, else ''\n\
modules -- dictionary of loaded modules\n\
\n\
displayhook -- called to show results in an interactive session\n\
excepthook -- called to handle any uncaught exception other than SystemExit\n\
  To customize printing in an interactive session or to install a custom\n\
  top-level exception handler, assign other functions to replace these.\n\
\n\
exitfunc -- if sys.exitfunc exists, this routine is called when Python exits\n\
  Assigning to sys.exitfunc is deprecated; use the atexit module instead.\n\
\n\
stdin -- standard input file object; used by raw_input() and input()\n\
stdout -- standard output file object; used by the print statement\n\
stderr -- standard error object; used for error messages\n\
  By assigning other file objects (or objects that behave like files)\n\
  to these, it is possible to redirect all of the interpreter's I/O.\n\
\n\
last_type -- type of last uncaught exception\n\
last_value -- value of last uncaught exception\n\
last_traceback -- traceback of last uncaught exception\n\
  These three are only available in an interactive session after a\n\
  traceback has been printed.\n\
\n\
exc_type -- type of exception currently being handled\n\
exc_value -- value of exception currently being handled\n\
exc_traceback -- traceback of exception currently being handled\n\
  The function exc_info() should be used instead of these three,\n\
  because it is thread-safe.\n\
"</argument>
)</argument_list></macro>
<comment type="block">/* concatenating string here */</comment>
<macro><name>PyDoc_STR</name><argument_list>(
<argument>"\n\
Static objects:\n\
\n\
maxint -- the largest supported integer (the smallest is -maxint-1)\n\
maxsize -- the largest supported length of containers.\n\
maxunicode -- the largest supported character\n\
builtin_module_names -- tuple of module names built into this interpreter\n\
version -- the version of this interpreter as a string\n\
version_info -- version information as a tuple\n\
hexversion -- version information encoded as a single integer\n\
copyright -- copyright notice pertaining to this interpreter\n\
platform -- platform identifier\n\
executable -- pathname of this Python interpreter\n\
prefix -- prefix used to find the Python library\n\
exec_prefix -- prefix used to find the machine-specific Python library\n\
"</argument>
)</argument_list></macro>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<comment type="block">/* concatenating string here */</comment>
<macro><name>PyDoc_STR</name><argument_list>(
<argument>"dllhandle -- [Windows only] integer handle of the Python DLL\n\
winver -- [Windows only] version number of the Python DLL\n\
"</argument>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>
<call><name>PyDoc_STR</name><argument_list>(
<argument><expr>"__stdin__ -- the original stdin; don't touch!\n\
__stdout__ -- the original stdout; don't touch!\n\
__stderr__ -- the original stderr; don't touch!\n\
__displayhook__ -- the original displayhook; don't touch!\n\
__excepthook__ -- the original excepthook; don't touch!\n\
\n\
Functions:\n\
\n\
displayhook() -- print an object to the screen, and save it in __builtin__._\n\
excepthook() -- print an exception and its traceback to sys.stderr\n\
exc_info() -- return thread-safe information about the current exception\n\
exc_clear() -- clear the exception state for the current thread\n\
exit() -- exit the interpreter by raising SystemExit\n\
getdlopenflags() -- returns flags to be used for dlopen() calls\n\
getprofile() -- get the global profiling function\n\
getrefcount() -- return the reference count for an object (plus one :-)\n\
getrecursionlimit() -- return the max recursion depth for the interpreter\n\
getsizeof() -- return the size of an object in bytes\n\
gettrace() -- get the global debug tracing function\n\
setcheckinterval() -- control how often the interpreter checks for events\n\
setdlopenflags() -- set the flags to be used for dlopen() calls\n\
setprofile() -- set the global profiling function\n\
setrecursionlimit() -- set the max recursion depth for the interpreter\n\
settrace() -- set the global debug tracing function\n\
"</expr></argument>
)</argument_list></call></expr>
<comment type="block">/* end of sys_doc */</comment> ;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_check_and_flush</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>prev_fail</name> <init>= <expr><call><name>ferror</name> <argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>fflush</name> <argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call> || <name>prev_fail</name> ? <name>EOF</name> : 0</expr>;</return>
}</block></function>

<comment type="block">/* Subversion branch and revision management */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>_patchlevel_revision</name><index>[]</index></name> <init>= <expr><name>PY_PATCHLEVEL_REVISION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>headurl</name><index>[]</index></name> <init>= <expr>"$HeadURL$"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>svn_initialized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>patchlevel_revision</name><index>[<expr>50</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Just the number */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>branch</name><index>[<expr>50</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>shortbranch</name><index>[<expr>50</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>svn_revision</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>svnversion_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>python</name></decl>, *<decl><type ref="prev"/><name>br_start</name></decl>, *<decl><type ref="prev"/><name>br_end</name></decl>, *<decl><type ref="prev"/><name>br_end2</name></decl>, *<decl><type ref="prev"/><name>svnversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>istag</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>svn_initialized</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>python</name> = <call><name>strstr</name><argument_list>(<argument><expr><name>headurl</name></expr></argument>, <argument><expr>"/python/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>python</name></expr>)</condition><then> <block>{
		<comment type="block">/* XXX quick hack to get bzr working */</comment>
		<expr_stmt><expr>*<name>patchlevel_revision</name> = '\0'</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>shortbranch</name></expr></argument>, <argument><expr>"unknown"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>svn_revision</name> = ""</expr>;</expr_stmt>
		<return>return;</return>
		<comment type="block">/* Py_FatalError("subversion keywords missing"); */</comment>
	}</block></then></if>

	<expr_stmt><expr><name>br_start</name> = <name>python</name> + 8</expr>;</expr_stmt>
	<expr_stmt><expr><name>br_end</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>br_start</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>br_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Works even for trunk,
	   as we are in trunk/Python/sysmodule.c */</comment>
	<expr_stmt><expr><name>br_end2</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>br_end</name>+1</expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>istag</name> = <call><name>strncmp</name><argument_list>(<argument><expr><name>br_start</name></expr></argument>, <argument><expr>"tags"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>br_start</name></expr></argument>, <argument><expr>"trunk"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr>"trunk"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>shortbranch</name></expr></argument>, <argument><expr>"trunk"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	}</block></then>
	<else>else <if>if <condition>(<expr><name>istag</name> || <call><name>strncmp</name><argument_list>(<argument><expr><name>br_start</name></expr></argument>, <argument><expr>"branches"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>len</name> = <name>br_end2</name> - <name>br_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>br_start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>branch</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> = <name>br_end2</name> - (<name>br_end</name> + 1)</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>shortbranch</name></expr></argument>, <argument><expr><name>br_end</name> + 1</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shortbranch</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"bad HeadURL"</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<return>return;</return>
	}</block></else></if></else></if>


	<expr_stmt><expr><name>svnversion</name> = <call><name>_Py_svnversion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>svnversion</name></expr></argument>, <argument><expr>"exported"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<expr_stmt><expr><name>svn_revision</name> = <name>svnversion</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>istag</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>_patchlevel_revision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &gt;= 13</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &lt; (<sizeof>sizeof<argument_list>(<argument><expr><name>patchlevel_revision</name></expr></argument>)</argument_list></sizeof> + 13)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>patchlevel_revision</name></expr></argument>, <argument><expr><name>_patchlevel_revision</name> + 11</expr></argument>,
			<argument><expr><name>len</name> - 13</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>patchlevel_revision</name><index>[<expr><name>len</name> - 13</expr>]</index></name> = '\0'</expr>;</expr_stmt>
		<expr_stmt><expr><name>svn_revision</name> = <name>patchlevel_revision</name></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>svn_revision</name> = ""</expr>;</expr_stmt></else></if></else></if>

	<expr_stmt><expr><name>svn_initialized</name> = 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Return svnversion output if available.
   Else return Revision of patchlevel.h if on branch.
   Else return empty string */</comment>
<function><type><specifier>const</specifier> <name>char</name>*</type>
<name>Py_SubversionRevision</name><parameter_list>()</parameter_list>
<block>{
	<expr_stmt><expr><call><name>svnversion_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>svn_revision</name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name>*</type>
<name>Py_SubversionShortBranch</name><parameter_list>()</parameter_list>
<block>{
	<expr_stmt><expr><call><name>svnversion_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>shortbranch</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>flags__doc__</name></expr></argument>,
<argument><expr>"sys.flags\n\
\n\
Flags provided through command line arguments or environment vars."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>FlagsType</name> <init>= <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>flags_fields</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"debug"</expr>,		<expr>"-d"</expr>}</block></expr>,
	<expr><block>{<expr>"py3k_warning"</expr>,	<expr>"-3"</expr>}</block></expr>,
	<expr><block>{<expr>"division_warning"</expr>,	<expr>"-Q"</expr>}</block></expr>,
	<expr><block>{<expr>"division_new"</expr>,	<expr>"-Qnew"</expr>}</block></expr>,
	<expr><block>{<expr>"inspect"</expr>,		<expr>"-i"</expr>}</block></expr>,
	<expr><block>{<expr>"interactive"</expr>,		<expr>"-i"</expr>}</block></expr>,
	<expr><block>{<expr>"optimize"</expr>,		<expr>"-O or -OO"</expr>}</block></expr>,
	<expr><block>{<expr>"dont_write_bytecode"</expr>,	<expr>"-B"</expr>}</block></expr>,
	<expr><block>{<expr>"no_user_site"</expr>,	<expr>"-s"</expr>}</block></expr>,
	<expr><block>{<expr>"no_site"</expr>,		<expr>"-S"</expr>}</block></expr>,
	<expr><block>{<expr>"ignore_environment"</expr>,	<expr>"-E"</expr>}</block></expr>,
	<expr><block>{<expr>"tabcheck"</expr>,		<expr>"-t or -tt"</expr>}</block></expr>,
	<expr><block>{<expr>"verbose"</expr>,		<expr>"-v"</expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
	<expr><block>{<expr>"riscos_wimp"</expr>,		<expr>"???"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* {"unbuffered",		"-u"}, */</comment>
	<expr><block>{<expr>"unicode"</expr>,		<expr>"-U"</expr>}</block></expr>,
	<comment type="block">/* {"skip_first",		"-x"}, */</comment>
	<expr><block>{<expr>"bytes_warning"</expr>, <expr>"-b"</expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>flags_desc</name> <init>= <expr><block>{
	<expr>"sys.flags"</expr>,	<comment type="block">/* name */</comment>
	<expr><name>flags__doc__</name></expr>,	<comment type="block">/* doc */</comment>
	<expr><name>flags_fields</name></expr>,	<comment type="block">/* fields */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
	<expr>16
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	15</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>make_flags</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>seq</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>seq</name> = <call><name>PyStructSequence_New</name><argument_list>(<argument><expr>&amp;<name>FlagsType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>seq</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SetFlag</name><parameter_list>(<param><type><name>flag</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>PyStructSequence_SET_ITEM(seq, pos++, PyInt_FromLong(flag))</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_DebugFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_Py3kWarningFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_DivisionWarningFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>_Py_QnewFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_InspectFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_InteractiveFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_OptimizeFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_DontWriteBytecodeFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_NoUserSiteDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_NoSiteFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_IgnoreEnvironmentFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_TabcheckFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_VerboseFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_RISCOSWimpFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* SetFlag(saw_unbuffered_flag); */</comment>
	<expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_UnicodeFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* SetFlag(skipfirstline); */</comment>
    <expr_stmt><expr><call><name>SetFlag</name><argument_list>(<argument><expr><name>Py_BytesWarningFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SetFlag</name></cpp:undef>

	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>seq</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PySys_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>sysdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sysin</name></decl>, *<decl><type ref="prev"/><name>sysout</name></decl>, *<decl><type ref="prev"/><name>syserr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"sys"</expr></argument>, <argument><expr><name>sys_methods</name></expr></argument>, <argument><expr><name>sys_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>sysdict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_SYS_FROM_STRING</name><parameter_list>(<param><type><name>key</name></type></param>, <param><type><name>value</name></type></param>)</parameter_list></cpp:macro>			\
	<cpp:value>v = value;					\
	if (v != NULL)					\
		PyDict_SetItemString(sysdict, key, v);	\
	Py_XDECREF(v)</cpp:value></cpp:define>

	<block>{
		<comment type="block">/* XXX: does this work on Win/Win64? (see posix_fstat) */</comment>
		<decl_stmt><decl><type>struct <name>stat</name></type> <name>sb</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>sb</name></expr></argument>)</argument_list></call> == 0 &amp;&amp;
		    <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sb</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* There's nothing more we can do. */</comment>
			<comment type="block">/* Py_FatalError() will core dump, so just exit. */</comment>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"Python error: &lt;stdin&gt; is a directory, cannot continue\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block>

	<comment type="block">/* Closing the standard FILE* if sys.std* goes aways causes problems
	 * for embedded Python usages. Closing them when somebody explicitly
	 * invokes .close() might be possible, but the FAQ promises they get
	 * never closed. However, we still need to get write errors when
	 * writing fails (e.g. because stdout is redirected), so we flush the
	 * streams and check for errors before the file objects are deleted.
	 * On OS X, fflush()ing stdin causes an error, so we exempt stdin
	 * from that procedure.
	 */</comment>
	<expr_stmt><expr><name>sysin</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr>"&lt;stdin&gt;"</expr></argument>, <argument><expr>"r"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sysout</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>"&lt;stdout&gt;"</expr></argument>, <argument><expr>"w"</expr></argument>, <argument><expr><name>_check_and_flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>syserr</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"&lt;stderr&gt;"</expr></argument>, <argument><expr>"w"</expr></argument>, <argument><expr><name>_check_and_flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"stdin"</expr></argument>, <argument><expr><name>sysin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"stdout"</expr></argument>, <argument><expr><name>sysout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"stderr"</expr></argument>, <argument><expr><name>syserr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make backup copies for cleanup */</comment>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"__stdin__"</expr></argument>, <argument><expr><name>sysin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"__stdout__"</expr></argument>, <argument><expr><name>sysout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"__stderr__"</expr></argument>, <argument><expr><name>syserr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"__displayhook__"</expr></argument>,
			     <argument><expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"displayhook"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"__excepthook__"</expr></argument>,
			     <argument><expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"excepthook"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sysin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sysout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>syserr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"version"</expr></argument>,
			     <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Py_GetVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"hexversion"</expr></argument>,
			     <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>PY_VERSION_HEX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>svnversion_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"subversion"</expr></argument>,
			     <argument><expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ssz)"</expr></argument>, <argument><expr>"CPython"</expr></argument>, <argument><expr><name>branch</name></expr></argument>,
					  <argument><expr><name>svn_revision</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"dont_write_bytecode"</expr></argument>,
			     <argument><expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>Py_DontWriteBytecodeFlag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * These release level checks are mutually exclusive and cover
	 * the field, so don't get too fancy with the pre-processor!
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_RELEASE_LEVEL</name> == <name>PY_RELEASE_LEVEL_ALPHA</name></expr></cpp:if>
	<expr_stmt><expr><name>s</name> = "alpha"</expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PY_RELEASE_LEVEL</name> == <name>PY_RELEASE_LEVEL_BETA</name></expr></cpp:elif>
	<expr_stmt><expr><name>s</name> = "beta"</expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PY_RELEASE_LEVEL</name> == <name>PY_RELEASE_LEVEL_GAMMA</name></expr></cpp:elif>
	<expr_stmt><expr><name>s</name> = "candidate"</expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PY_RELEASE_LEVEL</name> == <name>PY_RELEASE_LEVEL_FINAL</name></expr></cpp:elif>
	<expr_stmt><expr><name>s</name> = "final"</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"version_info"</expr></argument>,
			    <argument><expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiisi"</expr></argument>, <argument><expr><name>PY_MAJOR_VERSION</name></expr></argument>,
					       <argument><expr><name>PY_MINOR_VERSION</name></expr></argument>,
					       <argument><expr><name>PY_MICRO_VERSION</name></expr></argument>, <argument><expr><name>s</name></expr></argument>,
					       <argument><expr><name>PY_RELEASE_SERIAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"api_version"</expr></argument>,
			    <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"copyright"</expr></argument>,
			    <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Py_GetCopyright</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"platform"</expr></argument>,
			    <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Py_GetPlatform</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"executable"</expr></argument>,
			    <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Py_GetProgramFullPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"prefix"</expr></argument>,
			    <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Py_GetPrefix</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"exec_prefix"</expr></argument>,
		   	    <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Py_GetExecPrefix</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"maxsize"</expr></argument>,
			    <argument><expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>PY_SSIZE_T_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"maxint"</expr></argument>,
			    <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_GetMax</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"py3kwarning"</expr></argument>,
			    <argument><expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>Py_Py3kWarningFlag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"float_info"</expr></argument>,
			    <argument><expr><call><name>PyFloat_GetInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"maxunicode"</expr></argument>,
			    <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>PyUnicode_GetMax</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"builtin_module_names"</expr></argument>,
			    <argument><expr><call><name>list_builtin_module_names</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{
		<comment type="block">/* Assumes that longs are at least 2 bytes long.
		   Should be safe! */</comment>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>number</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>s</name> = (<name>char</name> *) &amp;<name>number</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>s</name><index>[<expr>0</expr>]</index></name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>value</name> = "big"</expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>value</name> = "little"</expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"byteorder"</expr></argument>,
				    <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_COREDLL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"dllhandle"</expr></argument>,
			    <argument><expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>PyWin_DLLhModule</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"winver"</expr></argument>,
			    <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>PyWin_DLLVersionString</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>warnoptions</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>warnoptions</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>warnoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>warnoptions</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>sysdict</name></expr></argument>, <argument><expr>"warnoptions"</expr></argument>, <argument><expr><name>warnoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>FlagsType</name>.<name>tp_name</name></name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>FlagsType</name></expr></argument>, <argument><expr>&amp;<name>flags_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>SET_SYS_FROM_STRING</name><argument_list>(<argument><expr>"flags"</expr></argument>, <argument><expr><call><name>make_flags</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* prevent user from creating new instances */</comment>
	<expr_stmt><expr><name><name>FlagsType</name>.<name>tp_init</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>FlagsType</name>.<name>tp_new</name></name> = <name>NULL</name></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_SYS_FROM_STRING</name></cpp:undef>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><name>m</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>makepathobject</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>int</name></type> <name>delim</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> = <name>path</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>p</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name>v</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>p</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>p</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> <comment type="block">/* End of string */</comment>
		<expr_stmt><expr><name>w</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call>(<name>Py_ssize_t</name>) <argument_list>(<argument><expr><name>p</name> - <name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>p</name> == '\0'</expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><name>path</name> = <name>p</name>+1</expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PySys_SetPath</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>(<name>v</name> = <call><name>makepathobject</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"can't create sys.path"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"path"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"can't assign sys.path"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>makeargvobject</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>av</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>argc</name> &lt;= 0 || <name>argv</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Ensure at least one (empty) argument is seen */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>empty_argv</name><index>[<expr>1</expr>]</index></name> <init>= <expr><block>{<expr>""</expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>argv</name> = <name>empty_argv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>argc</name> = 1</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>av</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>av</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

			<comment type="block">/* argv[0] is the script pathname if known */</comment>
			<if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name>*</type> <name>fn</name> <init>= <expr><name>decc</name><name/>$<call><name>translate_vms</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr>(<name>fn</name> == (<name>char</name> *)0) || <name>fn</name> == (<name>char</name> *)-1</expr>)</condition><then>
					<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(
						<argument><expr><name>decc</name><name/>$<call><name>translate_vms</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			}</block></then> <else>else
				<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>av</name> = <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>av</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></then></if>
	<return>return <expr><name>av</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PySys_SetArgv</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_REALPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>char</name></type> <name><name>fullpath</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<decl_stmt><decl><type><name>char</name></type> <name><name>fullpath</name><index>[<expr><name>MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>av</name> <init>= <expr><call><name>makeargvobject</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>av</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem for sys.argv"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"argv"</expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"can't assign sys.argv"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>path</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>argv0</name> <init>= <expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>a</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_READLINK</name></cpp:ifdef>
		<decl_stmt><decl><type><name>char</name></type> <name><name>link</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>argv0copy</name><index>[<expr>2*<name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nr</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>argc</name> &gt; 0 &amp;&amp; <name>argv0</name> != <name>NULL</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr>"-c"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
			<expr_stmt><expr><name>nr</name> = <call><name>readlink</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>link</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>nr</name> &gt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* It's a symlink */</comment>
			<expr_stmt><expr><name><name>link</name><index>[<expr><name>nr</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>link</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
				<expr_stmt><expr><name>argv0</name> = <name>link</name></expr>;</expr_stmt></then> <comment type="block">/* Link to absolute path */</comment>
			<else>else <if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>link</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
				<empty_stmt>;</empty_stmt></then> <comment type="block">/* Link without path */</comment>
			<else>else <block>{
				<comment type="block">/* Must join(dirname(argv0), link) */</comment>
				<decl_stmt><decl><type><name>char</name> *</type><name>q</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>q</name> == <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><name>argv0</name> = <name>link</name></expr>;</expr_stmt></then> <comment type="block">/* argv0 without path */</comment>
				<else>else <block>{
					<comment type="block">/* Must make a copy */</comment>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>argv0copy</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>q</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>argv0copy</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>q</name>+1</expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>argv0</name> = <name>argv0copy</name></expr>;</expr_stmt>
				}</block></else></if>
			}</block></else></if></else></if>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_READLINK */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SEP</name> == '\\'</expr></cpp:if> <comment type="block">/* Special case for MS filename syntax */</comment>
		<if>if <condition>(<expr><name>argc</name> &gt; 0 &amp;&amp; <name>argv0</name> != <name>NULL</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr>"-c"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>q</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
			<decl_stmt><decl><type><name>char</name> *</type><name>ptemp</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>GetFullPathName</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fullpath</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>fullpath</name></expr></argument>,
					   <argument><expr>&amp;<name>ptemp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>argv0</name> = <name>fullpath</name></expr>;</expr_stmt>
			}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>p</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Test for alternate separator */</comment>
			<expr_stmt><expr><name>q</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>p</name> ? <name>p</name> : <name>argv0</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>q</name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>p</name> = <name>q</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>n</name> = <name>p</name> + 1 - <name>argv0</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>n</name> &gt; 1 &amp;&amp; <name><name>p</name><index>[<expr>-1</expr>]</index></name> != ':'</expr>)</condition><then>
					<expr_stmt><expr><name>n</name>--</expr>;</expr_stmt></then></if> <comment type="block">/* Drop trailing separator */</comment>
			}</block></then></if>
		}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* All other filename syntaxes */</comment>
		<if>if <condition>(<expr><name>argc</name> &gt; 0 &amp;&amp; <name>argv0</name> != <name>NULL</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr>"-c"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_REALPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<if>if <condition>(<expr><call><name>realpath</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>argv0</name> = <name>fullpath</name></expr>;</expr_stmt>
			}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>p</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RISCOS</name></cpp:ifndef>
			<expr_stmt><expr><name>n</name> = <name>p</name> + 1 - <name>argv0</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* don't include trailing separator */</comment>
			<expr_stmt><expr><name>n</name> = <name>p</name> - <name>argv0</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* RISCOS */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SEP</name> == '/'</expr></cpp:if> <comment type="block">/* Special case for Unix filename syntax */</comment>
			<if>if <condition>(<expr><name>n</name> &gt; 1</expr>)</condition><then>
				<expr_stmt><expr><name>n</name>--</expr>;</expr_stmt></then></if> <comment type="block">/* Drop trailing separator */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Unix */</comment>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* All others */</comment>
		<expr_stmt><expr><name>a</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>a</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"no mem for sys.path insertion"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><call><name>PyList_Insert</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"sys.path.insert(0) failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* APIs to write to sys.stdout or sys.stderr using a printf-like interface.
   Adapted from code submitted by Just van Rossum.

   PySys_WriteStdout(format, ...)
   PySys_WriteStderr(format, ...)

      The first function writes to sys.stdout; the second to sys.stderr.  When
      there is a problem, they write to the real (C level) stdout or stderr;
      no exceptions are raised.

      Both take a printf-style format string as their first argument followed
      by a variable length argument list determined by the format string.

      *** WARNING ***

      The format should limit the total size of the formatted output string to
      1000 bytes.  In particular, this means that no unrestricted "%s" formats
      should occur; these should be limited using "%.&lt;N&gt;s where &lt;N&gt; is a
      decimal number calculated so that &lt;N&gt; plus the maximum size of other
      formatted text does not exceed 1000 bytes.  Also watch out for "%f",
      which can print hundreds of digits for very large numbers.

 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mywrite</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>va</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>error_type</name></decl>, *<decl><type ref="prev"/><name>error_value</name></decl>, *<decl><type ref="prev"/><name>error_traceback</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>error_type</name></expr></argument>, <argument><expr>&amp;<name>error_value</name></expr></argument>, <argument><expr>&amp;<name>error_traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>file</name> == <name>NULL</name> || <call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> == <name>fp</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>1001</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>written</name> <init>= <expr><call><name>PyOS_vsnprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						   <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>written</name> &lt; 0 || (<name>size_t</name>)<name>written</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>truncated</name> <init>= <expr>"... truncated"</expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>PyFile_WriteString</name><argument_list>(<argument><expr><name>truncated</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>truncated</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>error_type</name></expr></argument>, <argument><expr><name>error_value</name></expr></argument>, <argument><expr><name>error_traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PySys_WriteStdout</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mywrite</name><argument_list>(<argument><expr>"stdout"</expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PySys_WriteStderr</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mywrite</name><argument_list>(<argument><expr>"stderr"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
