<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/dynload_beos.c">
<comment type="block">/* Support for dynamic loading of extension modules */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;kernel/image.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;kernel/OS.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"importdl.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> struct <name>filedescr</name></type> <name><name>_PyImport_DynLoadFiletab</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>".so"</expr>, <expr>"rb"</expr>, <expr><name>C_EXTENSION</name></expr>}</block></expr>,
	<expr><block>{<expr>"module.so"</expr>, <expr>"rb"</expr>, <expr><name>C_EXTENSION</name></expr>}</block></expr>,
	<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_SYS_PARAM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAXPATHLEN</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyThread_type_lock</name></type> <name>beos_dyn_lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>beos_dyn_images</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------------------------------------------------------------------
 * BeOS dynamic loading support
 *
 * This uses shared libraries, but BeOS has its own way of doing things
 * (much easier than dlfnc.h, from the look of things).  We'll use a
 * Python Dictionary object to store the images_ids so we can be very
 * nice and unload them when we exit.
 *
 * Note that this is thread-safe.  Probably irrelevent, because of losing
 * systems... Python probably disables threads while loading modules.
 * Note the use of "probably"!  Better to be safe than sorry. [chrish]
 *
 * As of 1.5.1 this should also work properly when you've configured
 * Python without thread support; the 1.5 version required it, which wasn't
 * very friendly.  Note that I haven't tested it without threading... why
 * would you want to avoid threads on BeOS? [chrish]
 *
 * As of 1.5.2, the PyImport_BeImageID() function has been removed; Donn
 * tells me it's not necessary anymore because of PyCObject_Import().
 * [chrish]
 */</comment>

<comment type="block">/* Whack an item; the item is an image_id in disguise, so we'll call
 * unload_add_on() for it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>beos_nuke_dyn</name><parameter_list>( <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param> )</parameter_list>
<block>{
	<decl_stmt><decl><type><name>status_t</name></type> <name>retval</name></decl>;</decl_stmt>

	<if>if<condition>( <expr><name>item</name></expr> )</condition><then> <block>{
		<decl_stmt><decl><type><name>image_id</name></type> <name>id</name> <init>= <expr>(<name>image_id</name>)<call><name>PyInt_AsLong</name><argument_list>( <argument><expr><name>item</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
		
		<expr_stmt><expr><name>retval</name> = <call><name>unload_add_on</name><argument_list>( <argument><expr><name>id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<comment type="block">/* atexit() handler that'll call unload_add_on() for every item in the
 * dictionary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>beos_cleanup_dyn</name><parameter_list>( <param><decl><type><name>void</name></type></decl></param> )</parameter_list>
<block>{
	<if>if<condition>( <expr><name>beos_dyn_images</name></expr> )</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>list_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>id_list</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
		<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>( <argument><expr><name>beos_dyn_lock</name></expr></argument>, <argument><expr>1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>id_list</name> = <call><name>PyDict_Values</name><argument_list>( <argument><expr><name>beos_dyn_images</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>list_size</name> = <call><name>PyList_Size</name><argument_list>( <argument><expr><name>id_list</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<for>for( <init><expr><name>idx</name> = 0</expr>;</init> <condition><expr><name>idx</name> &lt; <name>list_size</name></expr>;</condition> <incr><expr><name>idx</name>++</expr></incr> ) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>the_item</name></decl>;</decl_stmt>
			
			<expr_stmt><expr><name>the_item</name> = <call><name>PyList_GetItem</name><argument_list>( <argument><expr><name>id_list</name></expr></argument>, <argument><expr><name>idx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>beos_nuke_dyn</name><argument_list>( <argument><expr><name>the_item</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		}</block></for>

		<expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>( <argument><expr><name>beos_dyn_images</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
		<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>( <argument><expr><name>beos_dyn_lock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
}</block></function>

<comment type="block">/*
 * Initialize our dictionary, and the dictionary mutex.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>beos_init_dyn</name><parameter_list>( <param><decl><type><name>void</name></type></decl></param> )</parameter_list>
<block>{
	<comment type="block">/* We're protected from a race condition here by the atomic init_count
	 * variable.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type> <name>init_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>val</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>val</name> = <call><name>atomic_add</name><argument_list>( <argument><expr>&amp;<name>init_count</name></expr></argument>, <argument><expr>1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if<condition>( <expr><name>beos_dyn_images</name> == <name>NULL</name> &amp;&amp; <name>val</name> == 0</expr> )</condition><then> <block>{
		<expr_stmt><expr><name>beos_dyn_images</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
		<expr_stmt><expr><name>beos_dyn_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>atexit</name><argument_list>( <argument><expr><name>beos_cleanup_dyn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<comment type="block">/*
 * Add an image_id to the dictionary; the module name of the loaded image
 * is the key.  Note that if the key is already in the dict, we unload
 * that image; this should allow reload() to work on dynamically loaded
 * modules (super-keen!).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>beos_add_dyn</name><parameter_list>( <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>image_id</name></type> <name>id</name></decl></param> )</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>py_id</name></decl>;</decl_stmt>

	<if>if<condition>( <expr><name>beos_dyn_images</name> == <name>NULL</name></expr> )</condition><then> <block>{
		<expr_stmt><expr><call><name>beos_init_dyn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><name>retval</name> = <call><name>PyThread_acquire_lock</name><argument_list>( <argument><expr><name>beos_dyn_lock</name></expr></argument>, <argument><expr>1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* If there's already an object with this key in the dictionary,
	 * we're doing a reload(), so let's nuke it.
	 */</comment>
	<expr_stmt><expr><name>py_id</name> = <call><name>PyDict_GetItemString</name><argument_list>( <argument><expr><name>beos_dyn_images</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if<condition>( <expr><name>py_id</name></expr> )</condition><then> <block>{
		<expr_stmt><expr><call><name>beos_nuke_dyn</name><argument_list>( <argument><expr><name>py_id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retval</name> = <call><name>PyDict_DelItemString</name><argument_list>( <argument><expr><name>beos_dyn_images</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>py_id</name> = <call><name>PyInt_FromLong</name><argument_list>( <argument><expr>(<name>long</name>)<name>id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if<condition>( <expr><name>py_id</name></expr> )</condition><then> <block>{
		<expr_stmt><expr><name>retval</name> = <call><name>PyDict_SetItemString</name><argument_list>( <argument><expr><name>beos_dyn_images</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>py_id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>( <argument><expr><name>beos_dyn_lock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>



<function><type><name>dl_funcptr</name></type> <name>_PyImport_GetDynLoadFunc</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fqname</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>shortname</name></decl></param>,
				    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>dl_funcptr</name></type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>image_id</name></type> <name>the_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>status_t</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>fullpath</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>funcname</name><index>[<expr>258</expr>]</index></name></decl>;</decl_stmt>

	<if>if<condition>( <expr><name>Py_VerboseFlag</name></expr> )</condition><then> <block>{
		<expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr>"load_add_on( %s )\n"</expr></argument>, <argument><expr><name>pathname</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Hmm, this old bug appears to have regenerated itself; if the
	 * path isn't absolute, load_add_on() will fail.  Reported to Be
	 * April 21, 1998.
	 */</comment>
	<if>if<condition>( <expr><name><name>pathname</name><index>[<expr>0</expr>]</index></name> != '/'</expr> )</condition><then> <block>{
		<expr_stmt><expr>(<name>void</name>)<call><name>getcwd</name><argument_list>( <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>)<call><name>strncat</name><argument_list>( <argument><expr><name>fullpath</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>)<call><name>strncat</name><argument_list>( <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
			
		<if>if<condition>( <expr><name>Py_VerboseFlag</name></expr> )</condition><then> <block>{
			<expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr>"load_add_on( %s )\n"</expr></argument>, <argument><expr><name>fullpath</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr>(<name>void</name>)<call><name>strcpy</name><argument_list>( <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>the_id</name> = <call><name>load_add_on</name><argument_list>( <argument><expr><name>fullpath</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if<condition>( <expr><name>the_id</name> &lt; <name>B_NO_ERROR</name></expr> )</condition><then> <block>{
		<comment type="block">/* It's too bad load_add_on() doesn't set errno or something...
		 */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* hate hard-coded string sizes... */</comment>

		<if>if<condition>( <expr><name>Py_VerboseFlag</name></expr> )</condition><then> <block>{
			<expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr>"load_add_on( %s ) failed"</expr></argument>, <argument><expr><name>fullpath</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<if>if<condition>( <expr><name>the_id</name> == <name>B_ERROR</name></expr> )</condition><then>
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>( <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				       <argument><expr>"BeOS: Failed to load %.200s"</expr></argument>,
				       <argument><expr><name>fullpath</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>( <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
				       <argument><expr>"Unknown error loading %.200s"</expr></argument>, 
				       <argument><expr><name>fullpath</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></else></if>

		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>( <argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr><name>buff</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"init%.200s"</expr></argument>, <argument><expr><name>shortname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if<condition>( <expr><name>Py_VerboseFlag</name></expr> )</condition><then> <block>{
		<expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr>"get_image_symbol( %s )\n"</expr></argument>, <argument><expr><name>funcname</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>retval</name> = <call><name>get_image_symbol</name><argument_list>( <argument><expr><name>the_id</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>B_SYMBOL_TYPE_TEXT</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if<condition>( <expr><name>retval</name> != <name>B_NO_ERROR</name> || <name>p</name> == <name>NULL</name></expr> )</condition><then> <block>{
		<comment type="block">/* That's bad, we can't find that symbol in the module...
		 */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* hate hard-coded string sizes... */</comment>

		<if>if<condition>( <expr><name>Py_VerboseFlag</name></expr> )</condition><then> <block>{
			<expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr>"get_image_symbol( %s ) failed"</expr></argument>, <argument><expr><name>funcname</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<switch>switch<condition>( <expr><name>retval</name></expr> )</condition> <block>{
		<case>case <expr><name>B_BAD_IMAGE_ID</name></expr>:
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>( <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			       <argument><expr>"can't load init function for dynamic module: "
		               "Invalid image ID for %.180s"</expr></argument>, <argument><expr><name>fullpath</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>B_BAD_INDEX</name></expr>:
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>( <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			       <argument><expr>"can't load init function for dynamic module: "
		               "Bad index for %.180s"</expr></argument>, <argument><expr><name>funcname</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>( <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			       <argument><expr>"can't load init function for dynamic module: "
		               "Unknown error looking up %.180s"</expr></argument>, <argument><expr><name>funcname</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</default>}</block></switch>

		<expr_stmt><expr><name>retval</name> = <call><name>unload_add_on</name><argument_list>( <argument><expr><name>the_id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>( <argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr><name>buff</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Save the module name and image ID for later so we can clean up
	 * gracefully.
	 */</comment>
	<expr_stmt><expr><call><name>beos_add_dyn</name><argument_list>( <argument><expr><name>fqname</name></expr></argument>, <argument><expr><name>the_id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>p</name></expr>;</return>
}</block></function>
</unit>
