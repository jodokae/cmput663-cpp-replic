<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/import.c">
<comment type="block">/* Module definition and import implementation */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Yield</name></cpp:undef> <comment type="block">/* undefine macro conflicting with winbase.h */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythonrun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"marshal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"importdl.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FCNTL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{ 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<comment type="block">/* for stat.st_mode */</comment>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>mode_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>extern</specifier> <name>time_t</name></type> <name>PyOS_GetLastModificationTime</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
						<comment type="block">/* In getmtime.c */</comment>

<comment type="block">/* Magic word to reject .pyc files generated by other Python versions.
   It should change for each incompatible change to the bytecode.

   The value of CR and LF is incorporated so if you ever read or write
   a .pyc file in text mode the magic number will be wrong; also, the
   Apple MPW compiler swaps their values, botching string constants.

   The magic numbers must be spaced apart atleast 2 values, as the
   -U interpeter flag will cause MAGIC+1 being used. They have been
   odd numbers for some time now.

   There were a variety of old schemes for setting the magic number.
   The current working scheme is to increment the previous value by
   10.

   Known values:
       Python 1.5:   20121
       Python 1.5.1: 20121
       Python 1.5.2: 20121
       Python 1.6:   50428
       Python 2.0:   50823
       Python 2.0.1: 50823
       Python 2.1:   60202
       Python 2.1.1: 60202
       Python 2.1.2: 60202
       Python 2.2:   60717
       Python 2.3a0: 62011
       Python 2.3a0: 62021
       Python 2.3a0: 62011 (!)
       Python 2.4a0: 62041
       Python 2.4a3: 62051
       Python 2.4b1: 62061
       Python 2.5a0: 62071
       Python 2.5a0: 62081 (ast-branch)
       Python 2.5a0: 62091 (with)
       Python 2.5a0: 62092 (changed WITH_CLEANUP opcode)
       Python 2.5b3: 62101 (fix wrong code: for x, in ...)
       Python 2.5b3: 62111 (fix wrong code: x += yield)
       Python 2.5c1: 62121 (fix wrong lnotab with for loops and
       			    storing constants that should have been removed)
       Python 2.5c2: 62131 (fix wrong code: for x, in ... in listcomp/genexp)
       Python 2.6a0: 62151 (peephole optimizations and STORE_MAP opcode)
       Python 2.6a1: 62161 (WITH_CLEANUP optimization)
.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAGIC</name></cpp:macro> <cpp:value>(62161 | ((long)'\r'&lt;&lt;16) | ((long)'\n'&lt;&lt;24))</cpp:value></cpp:define>

<comment type="block">/* Magic word as global; note that _PyImport_Init() can change the
   value of this global to accommodate for alterations of how the
   compiler works which are enabled by command line switches. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>pyc_magic</name> <init>= <expr><name>MAGIC</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* See _PyImport_FixupExtension() below */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>extensions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* This table is defined in config.c: */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> struct <name>_inittab</name></type> <name><name>_PyImport_Inittab</name><index>[]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type>struct <name>_inittab</name> *</type><name>PyImport_Inittab</name> <init>= <expr><name>_PyImport_Inittab</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* these tables define the module suffixes that Python recognizes */</comment>
<decl_stmt><decl><type>struct <name>filedescr</name> *</type> <name>_PyImport_Filetab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>filedescr</name></type> <name><name>_PyImport_StandardFiletab</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"/py"</expr>, <expr>"U"</expr>, <expr><name>PY_SOURCE</name></expr>}</block></expr>,
	<expr><block>{<expr>"/pyc"</expr>, <expr>"rb"</expr>, <expr><name>PY_COMPILED</name></expr>}</block></expr>,
	<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>filedescr</name></type> <name><name>_PyImport_StandardFiletab</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>".py"</expr>, <expr>"U"</expr>, <expr><name>PY_SOURCE</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<expr><block>{<expr>".pyw"</expr>, <expr>"U"</expr>, <expr><name>PY_SOURCE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>".pyc"</expr>, <expr>"rb"</expr>, <expr><name>PY_COMPILED</name></expr>}</block></expr>,
	<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Initialize things */</comment>

<function><type><name>void</name></type>
<name>_PyImport_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> struct <name>filedescr</name> *</type><name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>filetab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>countD</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>countS</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* prepare _PyImport_Filetab: copy entries from
	   _PyImport_DynLoadFiletab and _PyImport_StandardFiletab.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DYNAMIC_LOADING</name></cpp:ifdef>
	<for>for (<init><expr><name>scan</name> = <name>_PyImport_DynLoadFiletab</name></expr>;</init> <condition><expr><name><name>scan</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>scan</name></expr></incr>)
		<expr_stmt><expr>++<name>countD</name></expr>;</expr_stmt></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<for>for (<init><expr><name>scan</name> = <name>_PyImport_StandardFiletab</name></expr>;</init> <condition><expr><name><name>scan</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>scan</name></expr></incr>)
		<expr_stmt><expr>++<name>countS</name></expr>;</expr_stmt></for>
	<expr_stmt><expr><name>filetab</name> = <call><name>PyMem_NEW</name><argument_list>(<argument>struct <expr><name>filedescr</name></expr></argument>, <argument><expr><name>countD</name> + <name>countS</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>filetab</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize import file table."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DYNAMIC_LOADING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>filetab</name></expr></argument>, <argument><expr><name>_PyImport_DynLoadFiletab</name></expr></argument>,
	       <argument><expr><name>countD</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>filedescr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>filetab</name> + <name>countD</name></expr></argument>, <argument><expr><name>_PyImport_StandardFiletab</name></expr></argument>,
	       <argument><expr><name>countS</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>filedescr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filetab</name><index>[<expr><name>countD</name> + <name>countS</name></expr>]</index></name>.<name>suffix</name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>_PyImport_Filetab</name> = <name>filetab</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>Py_OptimizeFlag</name></expr>)</condition><then> <block>{
		<comment type="block">/* Replace ".pyc" with ".pyo" in _PyImport_Filetab */</comment>
		<for>for (<init>;</init> <condition><expr><name><name>filetab</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>filetab</name>++</expr></incr>) <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RISCOS</name></cpp:ifndef>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>filetab</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr>".pyc"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><name><name>filetab</name>-&gt;<name>suffix</name></name> = ".pyo"</expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>filetab</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr>"/pyc"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><name><name>filetab</name>-&gt;<name>suffix</name></name> = "/pyo"</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></for>
	}</block></then></if>

	<if>if <condition>(<expr><name>Py_UnicodeFlag</name></expr>)</condition><then> <block>{
		<comment type="block">/* Fix the pyc_magic so that byte compiled code created
		   using the all-Unicode method doesn't interfere with
		   code created in normal operation mode. */</comment>
		<expr_stmt><expr><name>pyc_magic</name> = <name>MAGIC</name> + 1</expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>_PyImportHooks_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>path_hooks</name> <init>= <expr><name>NULL</name></expr></init>, *<name>zimpimport</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* adding sys.path_hooks and sys.path_importer_cache, setting up
	   zipimport */</comment>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyNullImporter_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# installing zipimport hook\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>v</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>err</name> = <call><name>PySys_SetObject</name><argument_list>(<argument><expr>"meta_path"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>err</name> = <call><name>PySys_SetObject</name><argument_list>(<argument><expr>"path_importer_cache"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>path_hooks</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>path_hooks</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>err</name> = <call><name>PySys_SetObject</name><argument_list>(<argument><expr>"path_hooks"</expr></argument>, <argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
  <label><name>error</name>:</label>
		<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"initializing sys.meta_path, sys.path_hooks, "
			      "path_importer_cache, or NullImporter failed"</expr></argument>
			      )</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>zimpimport</name> = <call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>"zipimport"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>zimpimport</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* No zip import module -- okay */</comment>
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# can't import zipimport\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>zipimporter</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>zimpimport</name></expr></argument>,
							       <argument><expr>"zipimporter"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>zimpimport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>zipimporter</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* No zipimporter object -- okay */</comment>
			<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
				    <argument><expr>"# can't import zipimport.zipimporter\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* sys.path_hooks.append(zipimporter) */</comment>
			<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>, <argument><expr><name>zipimporter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>zipimporter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
			<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
					<argument><expr>"# installed zipimport hook\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></else></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>_PyImport_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>extensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>extensions</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>_PyImport_Filetab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>_PyImport_Filetab</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Locking primitives to prevent parallel imports of the same module
   in different threads to return with a partially loaded module.
   These calls are serialized by the global interpreter lock. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyThread_type_lock</name></type> <name>import_lock</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>import_lock_thread</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>import_lock_level</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>lock_import</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>me</name> <init>= <expr><call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>me</name> == -1</expr>)</condition><then>
		<return>return;</return></then></if> <comment type="block">/* Too bad */</comment>
	<if>if <condition>(<expr><name>import_lock</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>import_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>import_lock</name> == <name>NULL</name></expr>)</condition><then>
			<return>return;</return></then></if>  <comment type="block">/* Nothing much we can do. */</comment>
	}</block></then></if>
	<if>if <condition>(<expr><name>import_lock_thread</name> == <name>me</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>import_lock_level</name>++</expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>import_lock_thread</name> != -1 || !<call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>import_lock</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
	<block>{
		<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>import_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>import_lock_thread</name> = <name>me</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>import_lock_level</name> = 1</expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>unlock_import</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>me</name> <init>= <expr><call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>me</name> == -1 || <name>import_lock</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if> <comment type="block">/* Too bad */</comment>
	<if>if <condition>(<expr><name>import_lock_thread</name> != <name>me</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>import_lock_level</name>--</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>import_lock_level</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>import_lock_thread</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>import_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* This function is called from PyOS_AfterFork to ensure that newly
   created child processes do not share locks with the parent. */</comment>

<function><type><name>void</name></type>
<name>_PyImport_ReInitLock</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_AIX</name></cpp:ifdef>
	<if>if <condition>(<expr><name>import_lock</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>import_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lock_import</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlock_import</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_lock_held</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>import_lock_thread</name> != -1</expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_acquire_lock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>lock_import</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_release_lock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>unlock_import</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"not holding the import lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>imp_modules_reloading_clear</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_Get</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* Helper for sys */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyImport_GetModuleDict</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>modules</name></name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyImport_GetModuleDict: no module dictionary!"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name><name>interp</name>-&gt;<name>modules</name></name></expr>;</return>
}</block></function>


<comment type="block">/* List of names to clear in sys */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>*</type> <name><name>sys_deletes</name><index>[]</index></name> <init>= <expr><block>{
	<expr>"path"</expr>, <expr>"argv"</expr>, <expr>"ps1"</expr>, <expr>"ps2"</expr>, <expr>"exitfunc"</expr>,
	<expr>"exc_type"</expr>, <expr>"exc_value"</expr>, <expr>"exc_traceback"</expr>,
	<expr>"last_type"</expr>, <expr>"last_value"</expr>, <expr>"last_traceback"</expr>,
	<expr>"path_hooks"</expr>, <expr>"path_importer_cache"</expr>, <expr>"meta_path"</expr>,
	<comment type="block">/* misc stuff */</comment>
	<expr>"flags"</expr>, <expr>"float_info"</expr>,
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>*</type> <name><name>sys_files</name><index>[]</index></name> <init>= <expr><block>{
	<expr>"stdin"</expr>, <expr>"__stdin__"</expr>,
	<expr>"stdout"</expr>, <expr>"__stdout__"</expr>,
	<expr>"stderr"</expr>, <expr>"__stderr__"</expr>,
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Un-initialize things, as good as we can */</comment>

<function><type><name>void</name></type>
<name>PyImport_Cleanup</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>ndone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><name><name>interp</name>-&gt;<name>modules</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>modules</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if> <comment type="block">/* Already done */</comment>

	<comment type="block">/* Delete some special variables first.  These are common
	   places where user values hide and people complain when their
	   destructors fail.  Since the modules containing them are
	   deleted *last* of all, they would come too late in the normal
	   destruction order.  Sigh. */</comment>

	<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# clear __builtin__._\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"_"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> **</type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>p</name> = <name>sys_deletes</name></expr>;</init> <condition><expr>*<name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# clear sys.%s\n"</expr></argument>, <argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>*<name>p</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<for>for (<init><expr><name>p</name> = <name>sys_files</name></expr>;</init> <condition><expr>*<name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name>+=2</expr></incr>) <block>{
			<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# restore sys.%s\n"</expr></argument>, <argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>*(<name>p</name>+1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>v</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>*<name>p</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></then></if>

	<comment type="block">/* First, delete __main__ */</comment>
	<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__main__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# cleanup __main__\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__main__"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* The special treatment of __builtin__ here is because even
	   when it's not referenced as a module, its dictionary is
	   referenced by almost every module's __builtins__.  Since
	   deleting a module clears its dictionary (even if there are
	   references left to it), we need to delete the __builtin__
	   module last.  Likewise, we don't delete sys until the very
	   end because it is implicitly referenced (e.g. by print).

	   Also note that we 'delete' modules by replacing their entry
	   in the modules dict with None, rather than really deleting
	   them; this avoids a rehash of the modules dictionary and
	   also marks them as "non existent" so they won't be
	   re-imported. */</comment>

	<comment type="block">/* Next, repeatedly delete modules with a reference count of
	   one (skipping __builtin__ and sys) and delete them */</comment>
	<do>do <block>{
		<expr_stmt><expr><name>ndone</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> = 0</expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<if>if <condition>(<expr><name><name>value</name>-&gt;<name>ob_refcnt</name></name> != 1</expr>)</condition><then>
				<continue>continue;</continue></then></if>
			<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>name</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
					<continue>continue;</continue></then></if>
				<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
						<argument><expr>"# cleanup[1] %s\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ndone</name>++</expr>;</expr_stmt>
			}</block></then></if>
		}</block></while>
	}</block> while <condition>(<expr><name>ndone</name> &gt; 0</expr>)</condition>;</do>

	<comment type="block">/* Next, delete all modules (still skipping __builtin__ and sys) */</comment>
	<expr_stmt><expr><name>pos</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>name</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<continue>continue;</continue></then></if>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<continue>continue;</continue></then></if>
			<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# cleanup[2] %s\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></while>

	<comment type="block">/* Next, delete sys and __builtin__ (in that order) */</comment>
	<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# cleanup sys\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"sys"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# cleanup __builtin__\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Finally, clear and delete the modules directory */</comment>
	<expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interp</name>-&gt;<name>modules</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Helper for pythonrun.c -- return magic number */</comment>

<function><type><name>long</name></type>
<name>PyImport_GetMagicNumber</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>pyc_magic</name></expr>;</return>
}</block></function>


<comment type="block">/* Magic for extension modules (built-in as well as dynamically
   loaded).  To prevent initializing an extension module more than
   once, we keep a static dictionary 'extensions' keyed by module name
   (for built-in modules) or by filename (for dynamically loaded
   modules), containing these modules.  A copy of the module's
   dictionary is stored by calling _PyImport_FixupExtension()
   immediately after the module initialization function succeeds.  A
   copy can be retrieved from there by calling
   _PyImport_FindExtension(). */</comment>

<function><type><name>PyObject</name> *</type>
<name>_PyImport_FixupExtension</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>, *<decl><type ref="prev"/><name>copy</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>extensions</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>extensions</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>extensions</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>modules</name> = <call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mod</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mod</name> == <name>NULL</name> || !<call><name>PyModule_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
		  <argument><expr>"_PyImport_FixupExtension: module %.200s not loaded"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>copy</name> = <call><name>PyDict_Copy</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>copy</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>extensions</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>copy</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyImport_FindExtension</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>, *<decl><type ref="prev"/><name>mdict</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>extensions</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>dict</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>extensions</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>mod</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>mdict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mdict</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>mdict</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s # previously loaded (%s)\n"</expr></argument>,
			<argument><expr><name>name</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>mod</name></expr>;</return>
}</block></function>


<comment type="block">/* Get the module object corresponding to a module name.
   First check the modules dictionary if there's one there,
   if not, create a new one and insert it in the modules dictionary.
   Because the former action is most common, THIS DOES NOT RETURN A
   'NEW' REFERENCE! */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyImport_AddModule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
	    <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>m</name></expr>;</return></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>PyModule_New</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Yes, it still exists, in modules! */</comment>

	<return>return <expr><name>m</name></expr>;</return>
}</block></function>

<comment type="block">/* Remove name from sys.modules, if it's there. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_RemoveModule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<if>if <condition>(<expr><call><name>PyDict_DelItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"import:  deleting existing key in"
			      "sys.modules failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* Execute a code object in a module and return the module object
 * WITH INCREMENTED REFERENCE COUNT.  If an error occurs, name is
 * removed from sys.modules, to avoid leaving damaged module objects
 * in sys.modules.  The caller may wish to restore the original
 * module object (if any) in this case; PyImport_ReloadModule is an
 * example.
 */</comment>
<function><type><name>PyObject</name> *</type>
<name>PyImport_ExecCodeModule</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>co</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyImport_ExecCodeModuleEx</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyImport_ExecCodeModuleEx</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* If the module is being reloaded, we get the old module back
	   and re-use its dict to exec the new code. */</comment>
	<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>,
					 <argument><expr><call><name>PyEval_GetBuiltins</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></then></if>
	<comment type="block">/* Remember the filename as the __file__ attribute */</comment>
	<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pathname</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>v</name> = ((<name>PyCodeObject</name> *)<name>co</name>)-&gt;<name>co_filename</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__file__"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if> <comment type="block">/* Not important enough to report */</comment>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> = <call><name>PyEval_EvalCode</name><argument_list>(<argument><expr>(<name>PyCodeObject</name> *)<name>co</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>(<name>m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"Loaded module %.200s not found in sys.modules"</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>m</name></expr>;</return>

  <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>_RemoveModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<comment type="block">/* Given a pathname for a Python source file, fill a buffer with the
   pathname for the corresponding compiled file.  Return the pathname
   for the compiled file, or NULL if there's no space in the buffer.
   Doesn't set an exception. */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>make_compiled_pathname</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>len</name>+2 &gt; <name>buflen</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<comment type="block">/* Treat .pyw as if it were .py.  The case of ".pyw" must match
	   that used in _PyImport_StandardFiletab. */</comment>
	<if>if <condition>(<expr><name>len</name> &gt;= 4 &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr>&amp;<name><name>pathname</name><index>[<expr><name>len</name>-4</expr>]</index></name></expr></argument>, <argument><expr>".pyw"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr>--<name>len</name></expr>;</expr_stmt></then></if>	<comment type="block">/* pretend 'w' isn't there */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = <name>Py_OptimizeFlag</name> ? 'o' : 'c'</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>+1</expr>]</index></name> = '\0'</expr>;</expr_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
}</block></function>


<comment type="block">/* Given a pathname for a Python source file, its time of last
   modification, and a pathname for a compiled file, check whether the
   compiled file represents the same version of the source.  If so,
   return a FILE pointer for the compiled file, positioned just after
   the header; if not, return NULL.
   Doesn't set an exception. */</comment>

<function><type><specifier>static</specifier> <name>FILE</name> *</type>
<name>check_compiled_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>time_t</name></type> <name>mtime</name></decl></param>, <param><decl><type><name>char</name> *</type><name>cpathname</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>magic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>pyc_mtime</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>magic</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>magic</name> != <name>pyc_magic</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# %s has bad magic\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>pyc_mtime</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pyc_mtime</name> != <name>mtime</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# %s has bad mtime\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# %s matches %s\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>fp</name></expr>;</return>
}</block></function>


<comment type="block">/* Read a code object from a file and check it for validity */</comment>

<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>read_compiled_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>cpathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>co</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>co</name> = <call><name>PyMarshal_ReadLastObjectFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyCode_Check</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"Non-code object in %.200s"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>(<name>PyCodeObject</name> *)<name>co</name></expr>;</return>
}</block></function>


<comment type="block">/* Load a module from a compiled file, execute it, and return its
   module object WITH INCREMENTED REFERENCE COUNT */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_compiled_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>cpathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>magic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>magic</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>magic</name> != <name>pyc_magic</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"Bad magic number in %.200s"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>(<name>void</name>) <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>co</name> = <call><name>read_compiled_module</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s # precompiled from %s\n"</expr></argument>,
			<argument><expr><name>name</name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>PyImport_ExecCodeModuleEx</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>co</name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>m</name></expr>;</return>
}</block></function>

<comment type="block">/* Parse a source file and return the corresponding code object */</comment>

<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>parse_source_module</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name> <init>= <expr><call><name>PyArena_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>arena</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>flags</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>

	<expr_stmt><expr><name>mod</name> = <call><name>PyParser_ASTFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>, 
				   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mod</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>co</name> = <call><name>PyAST_Compile</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>co</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper to open a bytecode file for writing in exclusive mode */</comment>

<function><type><specifier>static</specifier> <name>FILE</name> *</type>
<name>open_exclusive</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>mode_t</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_EXCL</name></expr></argument>)</argument_list></call>&amp;&amp;<call><name>defined</name><argument_list>(<argument><expr><name>O_CREAT</name></expr></argument>)</argument_list></call>&amp;&amp;<call><name>defined</name><argument_list>(<argument><expr><name>O_WRONLY</name></expr></argument>)</argument_list></call>&amp;&amp;<call><name>defined</name><argument_list>(<argument><expr><name>O_TRUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* Use O_EXCL to avoid a race condition when another process tries to
	   write the same file.  When that happens, our open() call fails,
	   which is just fine (since it's only a cache).
	   XXX If the file exists and is writable but the directory is not
	   writable, the file will never be written.  Oh well.
	*/</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<expr_stmt><expr>(<name>void</name>) <call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_EXCL</name>|<name>O_CREAT</name>|<name>O_WRONLY</name>|<name>O_TRUNC</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_BINARY</name></cpp:ifdef>
				|<name>O_BINARY</name></expr></argument>   <comment type="block">/* necessary for Windows */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
                        , <argument><expr><name>mode</name></expr></argument>, <argument><expr>"ctxt=bin"</expr></argument>, <argument><expr>"shr=nil"</expr></argument>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        , <argument><expr><name>mode</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		  )</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Best we can do -- on Windows this can't happen anyway */</comment>
	<return>return <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="block">/* Write a compiled module to a file, placing the time of last
   modification of its source into the header.
   Errors are ignored, if a write error occurs an attempt is made to
   remove the file. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_compiled_module</name><parameter_list>(<param><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>char</name> *</type><name>cpathname</name></decl></param>, <param><decl><type>struct <name>stat</name> *</type><name>srcstat</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type> <name>mtime</name> <init>= <expr><name><name>srcstat</name>-&gt;<name>st_mtime</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name> <init>= <expr><name><name>srcstat</name>-&gt;<name>st_mode</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>fp</name> = <call><name>open_exclusive</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
				<argument><expr>"# can't create %s\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyMarshal_WriteLongToFile</name><argument_list>(<argument><expr><name>pyc_magic</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>Py_MARSHAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* First write a 0 for mtime */</comment>
	<expr_stmt><expr><call><name>PyMarshal_WriteLongToFile</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>Py_MARSHAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMarshal_WriteObjectToFile</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>co</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>Py_MARSHAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> != 0 || <call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# can't write %s\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<comment type="block">/* Don't keep partial file */</comment>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>) <call><name>unlink</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<comment type="block">/* Now write the true mtime */</comment>
	<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>4L</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mtime</name> &lt; <name>LONG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMarshal_WriteLongToFile</name><argument_list>(<argument><expr>(<name>long</name>)<name>mtime</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>Py_MARSHAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# wrote %s\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>


<comment type="block">/* Load a source module from a given file and return its module
   object WITH INCREMENTED REFERENCE COUNT.  If there's a matching
   byte-compiled file, use that instead. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_source_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>stat</name></type> <name>st</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fpc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>cpathname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
	
	<if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
			     <argument><expr>"unable to get file status from '%s'"</expr></argument>,
			     <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_TIME_T</name> &gt; 4</expr></cpp:if>
	<comment type="block">/* Python's .pyc timestamp handling presumes that the timestamp fits
	   in 4 bytes. This will be fine until sometime in the year 2038,
	   when a 4-byte signed time_t will overflow.
	 */</comment>
	<if>if <condition>(<expr><name><name>st</name>.<name>st_mtime</name></name> &gt;&gt; 32</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"modification time overflows a 4 byte field"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>cpathname</name> = <call><name>make_compiled_pathname</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
					   <argument><expr>(<name>size_t</name>)<name>MAXPATHLEN</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cpathname</name> != <name>NULL</name> &amp;&amp;
	    (<name>fpc</name> = <call><name>check_compiled_module</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name><name>st</name>.<name>st_mtime</name></name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>co</name> = <call><name>read_compiled_module</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>, <argument><expr><name>fpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s # precompiled from %s\n"</expr></argument>,
				<argument><expr><name>name</name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>pathname</name> = <name>cpathname</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>co</name> = <call><name>parse_source_module</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s # from %s\n"</expr></argument>,
				<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>cpathname</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>ro</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr>"dont_write_bytecode"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>ro</name> == <name>NULL</name> || !<call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>ro</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>write_compiled_module</name><argument_list>(<argument><expr><name>co</name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
	}</block></else></if>
	<expr_stmt><expr><name>m</name> = <call><name>PyImport_ExecCodeModuleEx</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>co</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>m</name></expr>;</return>
}</block></function>


<comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>load_module</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> struct <name>filedescr</name> *</type><name>find_module</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
				     <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><name>FILE</name> **</type></decl></param>, <param><decl><type><name>PyObject</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> struct <name>_frozen</name> *</type><name>find_frozen</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Load a package and return its module object WITH INCREMENTED
   REFERENCE COUNT */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_package</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s # directory %s\n"</expr></argument>,
			<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>file</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>path</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"[O]"</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__file__"</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__path__"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr><name>fdp</name> = <call><name>find_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"__init__"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fdp</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>m</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
		<goto>goto <name>cleanup</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>load_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<goto>goto <name>cleanup</name>;</goto>

  <label><name>error</name>:</label>
  	<expr_stmt><expr><name>m</name> = <name>NULL</name></expr>;</expr_stmt>
  <label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>m</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper to test for built-in module */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_builtin</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>initfunc</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then>
			<else>else
				<return>return <expr>1</expr>;</return></else></if>
		}</block></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Return an importer object for a sys.path/pkg.__path__ item 'p',
   possibly by fetching it from the path_importer_cache dict. If it
   wasn't yet cached, traverse path_hooks until a hook is found
   that can handle the path item. Return None if no hook could;
   this tells our caller it should fall back to the builtin
   import mechanism. Cache the result in path_importer_cache.
   Returns a borrowed reference. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_path_importer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>path_importer_cache</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>path_hooks</name></decl></param>,
		  <param><decl><type><name>PyObject</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>importer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>nhooks</name></decl>;</decl_stmt>

	<comment type="block">/* These conditions are the caller's responsibility: */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nhooks</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>nhooks</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if> <comment type="block">/* Shouldn't happen */</comment>

	<expr_stmt><expr><name>importer</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>importer</name> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>importer</name></expr>;</return></then></if>

	<comment type="block">/* set path_importer_cache[p] to None to avoid recursion */</comment>
	<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>nhooks</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>hook</name> <init>= <expr><call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>hook</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>importer</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>hook</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>importer</name> != <name>NULL</name></expr>)</condition><then>
			<break>break;</break></then></if>

		<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr><name>importer</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>importer</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(
			<argument><expr>(<name>PyObject</name> *)&amp;<name>PyNullImporter_Type</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>importer</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>Py_None</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>importer</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>importer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>importer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr><name>importer</name></expr>;</return>
}</block></function>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>PyImport_GetImporter</name><argument_list>(<argument>PyObject *path</argument>)</argument_list></macro> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>importer</name><init>=<expr><name>NULL</name></expr></init>, *<name>path_importer_cache</name><init>=<expr><name>NULL</name></expr></init>, *<name>path_hooks</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>path_importer_cache</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path_importer_cache"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>path_hooks</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path_hooks"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>importer</name> = <call><name>get_path_importer</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>,
			                             <argument><expr><name>path_hooks</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>importer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get_path_importer returns a borrowed reference */</comment>
	<return>return <expr><name>importer</name></expr>;</return>
}</block>

<comment type="block">/* Search the path (default sys.path) for a module.  Return the
   corresponding filedescr struct, and (via return arguments) the
   pathname and an open file.  Return NULL if the module is not found. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_COREDLL</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>FILE</name> *</type><name>PyWin_FindRegisteredModule</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type>struct</type> <name>filedescr</name> **</decl></param>,
					<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>case_ok</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>find_init_module</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* Forward */</comment>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>filedescr</name></type> <name>importhookdescr</name> <init>= <expr><block>{<expr>""</expr>, <expr>""</expr>, <expr><name>IMP_HOOK</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> struct <name>filedescr</name> *</type>
<name>find_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>subname</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
	    <param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>, <param><decl><type><name>FILE</name> **</type><name>p_fp</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>p_loader</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>npath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>namelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>filemode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>path_hooks</name></decl>, *<decl><type ref="prev"/><name>path_importer_cache</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RISCOS</name></cpp:ifndef>
	<decl_stmt><decl><type>struct <name>stat</name></type> <name>statbuf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><specifier>static</specifier> struct <name>filedescr</name></type> <name>fd_frozen</name> <init>= <expr><block>{<expr>""</expr>, <expr>""</expr>, <expr><name>PY_FROZEN</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> struct <name>filedescr</name></type> <name>fd_builtin</name> <init>= <expr><block>{<expr>""</expr>, <expr>""</expr>, <expr><name>C_BUILTIN</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> struct <name>filedescr</name></type> <name>fd_package</name> <init>= <expr><block>{<expr>""</expr>, <expr>""</expr>, <expr><name>PKG_DIRECTORY</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>size_t</name></type> <name>saved_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>saved_namelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>saved_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>p_loader</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>p_loader</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call> &gt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"module name is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sys.meta_path import hook */</comment>
	<if>if <condition>(<expr><name>p_loader</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>meta_path</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>meta_path</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"meta_path"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>meta_path</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
					<argument><expr>"sys.meta_path must be a list of "
					"import hooks"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* zap guard */</comment>
		<expr_stmt><expr><name>npath</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>npath</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>loader</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>hook</name> <init>= <expr><call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>loader</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>hook</name></expr></argument>, <argument><expr>"find_module"</expr></argument>,
						     <argument><expr>"sO"</expr></argument>, <argument><expr><name>fullname</name></expr></argument>,
						     <argument><expr><name>path</name> != <name>NULL</name> ?
						     <name>path</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>loader</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>  <comment type="block">/* true error */</comment>
			}</block></then></if>
			<if>if <condition>(<expr><name>loader</name> != <name>Py_None</name></expr>)</condition><then> <block>{
				<comment type="block">/* a loader was found */</comment>
				<expr_stmt><expr>*<name>p_loader</name> = <name>loader</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>&amp;<name>importhookdescr</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>path</name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* The only type of submodule allowed inside a "frozen"
		   package are other frozen modules or packages. */</comment>
		<if>if <condition>(<expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> + 1 + <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> &gt;= (<name>size_t</name>)<name>buflen</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
					<argument><expr>"full frozen module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>&amp;<name>fd_frozen</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"No frozen submodule named %.200s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>is_builtin</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>&amp;<name>fd_builtin</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>(<call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>&amp;<name>fd_frozen</name></expr>;</return>
		}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_COREDLL</name></cpp:ifdef>
		<expr_stmt><expr><name>fp</name> = <call><name>PyWin_FindRegisteredModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>fdp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>p_fp</name> = <name>fp</name></expr>;</expr_stmt>
			<return>return <expr><name>fdp</name></expr>;</return>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>path</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>path</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
				<argument><expr>"sys.path must be a list of directory names"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>path_hooks</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path_hooks"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>path_hooks</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
				<argument><expr>"sys.path_hooks must be a list of "
				"import hooks"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>path_importer_cache</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path_importer_cache"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>path_importer_cache</name> == <name>NULL</name> ||
	    !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
				<argument><expr>"sys.path_importer_cache must be a dict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>npath</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>namelen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>npath</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>copy</name> = <call><name>PyUnicode_Encode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>copy</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><name>v</name> = <name>copy</name></expr>;</expr_stmt>
		}</block></then>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if></else></if>
		<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>len</name> + 2 + <name>namelen</name> + <name>MAXSUFFIXSIZE</name> &gt;= <name>buflen</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue> <comment type="block">/* Too long */</comment>
		}</block></then></if>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> != <name>len</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue> <comment type="block">/* v contains '\0' */</comment>
		}</block></then></if>

		<comment type="block">/* sys.path_hooks import hook */</comment>
		<if>if <condition>(<expr><name>p_loader</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>importer</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>importer</name> = <call><name>get_path_importer</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>,
						     <argument><expr><name>path_hooks</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>importer</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<comment type="block">/* Note: importer is a borrowed reference */</comment>
			<if>if <condition>(<expr><name>importer</name> != <name>Py_None</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>loader</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>loader</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>importer</name></expr></argument>,
							     <argument><expr>"find_module"</expr></argument>,
							     <argument><expr>"s"</expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>loader</name> == <name>NULL</name></expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>  <comment type="block">/* error */</comment>
				<if>if <condition>(<expr><name>loader</name> != <name>Py_None</name></expr>)</condition><then> <block>{
					<comment type="block">/* a loader was found */</comment>
					<expr_stmt><expr>*<name>p_loader</name> = <name>loader</name></expr>;</expr_stmt>
					<return>return <expr>&amp;<name>importhookdescr</name></expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			}</block></then></if>
		}</block></then></if>
		<comment type="block">/* no hook was found, use builtin import */</comment>

		<if>if <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name><name>buf</name><index>[<expr><name>len</name>-1</expr>]</index></name> != <name>SEP</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALTSEP</name></cpp:ifdef>
		    &amp;&amp; <name><name>buf</name><index>[<expr><name>len</name>-1</expr>]</index></name> != <name>ALTSEP</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		    )</condition><then>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>len</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> += <name>namelen</name></expr>;</expr_stmt>

		<comment type="block">/* Check for package import (buf holds a directory name,
		   and there's an __init__ module in that directory */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STAT</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call> == 0 &amp;&amp;         <comment type="block">/* it exists */</comment>
		    <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call> &amp;&amp;         <comment type="block">/* it's a directory */</comment>
		    <call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="block">/* case matches */</comment>
			<if>if <condition>(<expr><call><name>find_init_module</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="block">/* and has __init__.py */</comment>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>&amp;<name>fd_package</name></expr>;</return>
			}</block></then>
			<else>else <block>{
				<decl_stmt><decl><type><name>char</name></type> <name><name>warnstr</name><index>[<expr><name>MAXPATHLEN</name>+80</expr>]</index></name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>warnstr</name></expr></argument>, <argument><expr>"Not importing directory "
					"'%.*s': missing __init__.py"</expr></argument>, 
					<argument><expr><name>MAXPATHLEN</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_ImportWarning</name></expr></argument>,
					       <argument><expr><name>warnstr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				}</block></then></if>
			}</block></else></if>
		}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/* XXX How are you going to test for directories? */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>isdir</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> &amp;&amp;
		    <call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>find_init_module</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>&amp;<name>fd_package</name></expr>;</return>
			}</block></then>
			<else>else <block>{
				<decl_stmt><decl><type><name>char</name></type> <name><name>warnstr</name><index>[<expr><name>MAXPATHLEN</name>+80</expr>]</index></name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>warnstr</name></expr></argument>, <argument><expr>"Not importing directory "
					"'%.*s': missing __init__.py"</expr></argument>, 
					<argument><expr><name>MAXPATHLEN</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_ImportWarning</name></expr></argument>,
					       <argument><expr><name>warnstr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				}</block></then></if>
		}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<comment type="block">/* take a snapshot of the module spec for restoration
		 * after the 8 character DLL hackery
		 */</comment>
		<expr_stmt><expr><name>saved_buf</name> = <call><name>strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>saved_len</name> = <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>saved_namelen</name> = <name>namelen</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PYOS_OS2 */</comment>
		<for>for (<init><expr><name>fdp</name> = <name>_PyImport_Filetab</name></expr>;</init> <condition><expr><name><name>fdp</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>fdp</name>++</expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DYNAMIC_LOADING</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<comment type="block">/* OS/2 limits DLLs to 8 character names (w/o
			   extension)
			 * so if the name is longer than that and its a
			 * dynamically loaded module we're going to try,
			 * truncate the name before trying
			 */</comment>
			<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call> &gt; 8</expr>)</condition><then> <block>{
				<comment type="block">/* is this an attempt to load a C extension? */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> struct <name>filedescr</name> *</type><name>scan</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>scan</name> = <name>_PyImport_DynLoadFiletab</name></expr>;</expr_stmt>
				<while>while <condition>(<expr><name><name>scan</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>)</condition> <block>{
					<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>scan</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
						<break>break;</break></then>
					<else>else
						<expr_stmt><expr><name>scan</name>++</expr>;</expr_stmt></else></if>
				}</block></while>
				<if>if <condition>(<expr><name><name>scan</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
					<comment type="block">/* yes, so truncate the name */</comment>
					<expr_stmt><expr><name>namelen</name> = 8</expr>;</expr_stmt>
					<expr_stmt><expr><name>len</name> -= <call><name>strlen</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call> - <name>namelen</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
				}</block></then></if>
			}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PYOS_OS2 */</comment>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>len</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>Py_VerboseFlag</name> &gt; 1</expr>)</condition><then>
				<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"# trying %s\n"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>filemode</name> = <name><name>fdp</name>-&gt;<name>mode</name></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>filemode</name><index>[<expr>0</expr>]</index></name> == 'U'</expr>)</condition><then>
				<expr_stmt><expr><name>filemode</name> = "r" <name>PY_STDIOTEXTMODE</name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>filemode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<break>break;</break></then>
				<else>else <block>{	 <comment type="block">/* continue search */</comment>
					<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>fp</name> = <name>NULL</name></expr>;</expr_stmt>
				}</block></else></if>
			}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<comment type="block">/* restore the saved snapshot */</comment>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>saved_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> = <name>saved_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>namelen</name> = <name>saved_namelen</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<comment type="block">/* don't need/want the module name snapshot anymore */</comment>
		<if>if <condition>(<expr><name>saved_buf</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>saved_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>saved_buf</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"No module named %.200s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>*<name>p_fp</name> = <name>fp</name></expr>;</expr_stmt>
	<return>return <expr><name>fdp</name></expr>;</return>
}</block></for>

<comment type="block">/* Helpers for main.c
 *  Find the source file corresponding to a named module
 */</comment>
<function><type>struct <name>filedescr</name> *</type>
<name>_PyImport_FindModule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
	    <param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>, <param><decl><type><name>FILE</name> **</type><name>p_fp</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>p_loader</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>find_module</name><argument_list>(<argument><expr>(<name>char</name> *) <name>name</name></expr></argument>, <argument><expr>(<name>char</name> *) <name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
			   <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>p_fp</name></expr></argument>, <argument><expr><name>p_loader</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyImport_IsScript</name><argument_list>(<argument>struct filedescr * fd</argument>)</argument_list></macro>
<block>{
	<return>return <expr><name><name>fd</name>-&gt;<name>type</name></name> == <name>PY_SOURCE</name> || <name><name>fd</name>-&gt;<name>type</name></name> == <name>PY_COMPILED</name></expr>;</return>
}</block>

<comment type="block">/* case_ok(char* buf, Py_ssize_t len, Py_ssize_t namelen, char* name)
 * The arguments here are tricky, best shown by example:
 *    /a/b/c/d/e/f/g/h/i/j/k/some_long_module_name.py\0
 *    ^                      ^                   ^    ^
 *    |--------------------- buf ---------------------|
 *    |------------------- len ------------------|
 *                           |------ name -------|
 *                           |----- namelen -----|
 * buf is the full path, but len only counts up to (&amp; exclusive of) the
 * extension.  name is the module name, also exclusive of extension.
 *
 * We've already done a successful stat() or fopen() on buf, so know that
 * there's some match, possibly case-insensitive.
 *
 * case_ok() is to return 1 if there's a case-sensitive match for
 * name, else 0.  case_ok() is also to return 1 if envar PYTHONCASEOK
 * exists.
 *
 * case_ok() is used to implement case-sensitive import semantics even
 * on platforms with case-insensitive filesystems.  It's trivial to implement
 * for case-sensitive filesystems.  It's pretty much a cross-platform
 * nightmare for systems with case-insensitive filesystems.
 */</comment>

<comment type="block">/* First we may need a pile of platform-specific header files; the sequence
 * of #if's here should match the sequence in the body of case_ok().
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DJGPP</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dir.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>__MACH__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call>) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRENT_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOSERRORS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_NOPMAPI</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oslib/osfscontrol.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>case_ok</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>namelen</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
<comment type="block">/* Pick a platform-specific implementation; the sequence of #if's here should
 * match the sequence just above.
 */</comment>

<comment type="block">/* MS_WINDOWS */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>WIN32_FIND_DATA</name></type> <name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<expr_stmt><expr><name>h</name> = <call><name>FindFirstFile</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>h</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_NameError</name></expr></argument>,
		  <argument><expr>"Can't find file for module %.100s\n(filename %.300s)"</expr></argument>,
		  <argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>data</name>.<name>cFileName</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call> == 0</expr>;</return>

<comment type="block">/* DJGPP */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DJGPP</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<decl_stmt><decl><type>struct <name>ffblk</name></type> <name>ffblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<expr_stmt><expr><name>done</name> = <call><name>findfirst</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>ffblk</name></expr></argument>, <argument><expr><name>FA_ARCH</name>|<name>FA_RDONLY</name>|<name>FA_HIDDEN</name>|<name>FA_DIREC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>done</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_NameError</name></expr></argument>,
		  <argument><expr>"Can't find file for module %.100s\n(filename %.300s)"</expr></argument>,
		  <argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ffblk</name>.<name>ff_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call> == 0</expr>;</return>

<comment type="block">/* new-fangled macintosh (macosx) or Cygwin */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>__MACH__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call>) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRENT_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<decl_stmt><decl><type><name>DIR</name> *</type><name>dirp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>dirent</name> *</type><name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>dirname</name><index>[<expr><name>MAXPATHLEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>dirlen</name> <init>= <expr><name>len</name> - <name>namelen</name> - 1</expr></init></decl>;</decl_stmt> <comment type="block">/* don't want trailing SEP */</comment>

	<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<comment type="block">/* Copy the dir component into dirname; substitute "." if empty */</comment>
	<if>if <condition>(<expr><name>dirlen</name> &lt;= 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>dirname</name><index>[<expr>0</expr>]</index></name> = '.'</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dirname</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dirlen</name> &lt;= <name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dirname</name><index>[<expr><name>dirlen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	}</block></else></if>
	<comment type="block">/* Open the directory and search the entries for an exact match. */</comment>
	<expr_stmt><expr><name>dirp</name> = <call><name>opendir</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dirp</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>nameWithExt</name> <init>= <expr><name>buf</name> + <name>len</name> - <name>namelen</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr>(<name>dp</name> = <call><name>readdir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>thislen</name> <init>=
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_DIRENT_HAVE_D_NAMELEN</name></cpp:ifdef>
						<expr><name><name>dp</name>-&gt;<name>d_namlen</name></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
						<expr_stmt><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>dp</name>-&gt;<name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if>if <condition>(<expr><name>thislen</name> &gt;= <name>namelen</name> &amp;&amp;
			    <call><name>strcmp</name><argument_list>(<argument><expr><name><name>dp</name>-&gt;<name>d_name</name></name></expr></argument>, <argument><expr><name>nameWithExt</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr>(<name>void</name>)<call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>1</expr>;</return> <comment type="block">/* Found */</comment>
			}</block></then></if>
		}</block></while>
		<expr_stmt><expr>(<name>void</name>)<call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>0</expr> ;</return> <comment type="block">/* Not found */</comment>

<comment type="block">/* RISC OS */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<decl_stmt><decl><type><name>char</name></type> <name><name>canon</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* buffer for the canonical form of the path */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf2</name><index>[<expr><name>MAXPATHLEN</name>+2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>nameWithExt</name> <init>= <expr><name>buf</name>+<name>len</name>-<name>namelen</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>canonlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>os_error</name> *</type><name>e</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<comment type="block">/* workaround:
	   append wildcard, otherwise case of filename wouldn't be touched */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>e</name> = <call><name>xosfscontrol_canonicalise_path</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>,<argument><expr><name>canon</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>MAXPATHLEN</name>+1</expr></argument>,<argument><expr>&amp;<name>canonlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>canonlen</name> = <name>MAXPATHLEN</name>+1-<name>canonlen</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>e</name> || <name>canonlen</name>&lt;=0 || <name>canonlen</name>&gt;(<name>MAXPATHLEN</name>+1)</expr> )</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nameWithExt</name></expr></argument>, <argument><expr><name>canon</name>+<name>canonlen</name>-<call><name>strlen</name><argument_list>(<argument><expr><name>nameWithExt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>==0</expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if> <comment type="block">/* match */</comment>

	<return>return <expr>0</expr>;</return>

<comment type="block">/* OS/2 */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<decl_stmt><decl><type><name>HDIR</name></type> <name>hdir</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ULONG</name></type> <name>srchcnt</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILEFINDBUF3</name></type> <name>ffbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<expr_stmt><expr><name>rc</name> = <call><name>DosFindFirst</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
			  <argument><expr>&amp;<name>hdir</name></expr></argument>,
			  <argument><expr><name>FILE_READONLY</name> | <name>FILE_HIDDEN</name> | <name>FILE_SYSTEM</name> | <name>FILE_DIRECTORY</name></expr></argument>,
			  <argument><expr>&amp;<name>ffbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ffbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr>&amp;<name>srchcnt</name></expr></argument>,
			  <argument><expr><name>FIL_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ffbuf</name>.<name>achName</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call> == 0</expr>;</return>

<comment type="block">/* assuming it's a case-sensitive filesystem, so there's nothing to do! */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr>1</expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STAT</name></cpp:ifdef>
<comment type="block">/* Helper to look for __init__.py or __init__.py[co] in potential package */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_init_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>save_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><name>save_len</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pname</name></decl>;</decl_stmt>  <comment type="block">/* pointer to start of __init__ */</comment>
	<decl_stmt><decl><type>struct <name>stat</name></type> <name>statbuf</name></decl>;</decl_stmt>

<comment type="block">/*	For calling case_ok(buf, len, namelen, name):
 *	/a/b/c/d/e/f/g/h/i/j/k/some_long_module_name.py\0
 *	^                      ^                   ^    ^
 *	|--------------------- buf ---------------------|
 *	|------------------- len ------------------|
 *	                       |------ name -------|
 *	                       |----- namelen -----|
 */</comment>
	<if>if <condition>(<expr><name>save_len</name> + 13 &gt;= <name>MAXPATHLEN</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pname</name> = <name>buf</name> + <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>pname</name></expr></argument>, <argument><expr>"__init__.py"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
			    <argument><expr><name>save_len</name> + 9</expr></argument>,	<comment type="block">/* len("/__init__") */</comment>
		            <argument><expr>8</expr></argument>,   		<comment type="block">/* len("__init__") */</comment>
		            <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>i</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>i</name></expr></argument>, <argument><expr><name>Py_OptimizeFlag</name> ? "o" : "c"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
			    <argument><expr><name>save_len</name> + 9</expr></argument>,	<comment type="block">/* len("/__init__") */</comment>
		            <argument><expr>8</expr></argument>,   		<comment type="block">/* len("__init__") */</comment>
		            <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_init_module</name><parameter_list>(<param><decl><type><name>buf</name></type></decl></param>)</parameter_list>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>save_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>save_len</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>save_len</name> + 13 &gt;= <name>MAXPATHLEN</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>i</name></expr></argument>, <argument><expr>"__init__/py"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>Py_OptimizeFlag</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>i</name></expr></argument>, <argument><expr>"o"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>i</name></expr></argument>, <argument><expr>"c"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*RISCOS*/</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_STAT */</comment>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>init_builtin</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* Forward */</comment>

<comment type="block">/* Load an external module using the default search path and return
   its module object WITH INCREMENTED REFERENCE COUNT */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>loader</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

	<comment type="block">/* First check that there's an open file (if we need one)  */</comment>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
	<case>case <expr><name>PY_SOURCE</name></expr>:
	</case><case>case <expr><name>PY_COMPILED</name></expr>:
		<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			   <argument><expr>"file object required for import (type code %d)"</expr></argument>,
				     <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	</case>}</block></switch>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{

	<case>case <expr><name>PY_SOURCE</name></expr>:
		<expr_stmt><expr><name>m</name> = <call><name>load_source_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>

	</case><case>case <expr><name>PY_COMPILED</name></expr>:
		<expr_stmt><expr><name>m</name> = <call><name>load_compiled_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DYNAMIC_LOADING</name></cpp:ifdef>
	</case><case>case <expr><name>C_EXTENSION</name></expr>:
		<expr_stmt><expr><name>m</name> = <call><name>_PyImport_LoadDynamicModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</case><case>case <expr><name>PKG_DIRECTORY</name></expr>:
		<expr_stmt><expr><name>m</name> = <call><name>load_package</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>

	</case><case>case <expr><name>C_BUILTIN</name></expr>:
	</case><case>case <expr><name>PY_FROZEN</name></expr>:
		<if>if <condition>(<expr><name>buf</name> != <name>NULL</name> &amp;&amp; <name><name>buf</name><index>[<expr>0</expr>]</index></name> != '\0'</expr>)</condition><then>
			<expr_stmt><expr><name>name</name> = <name>buf</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>type</name> == <name>C_BUILTIN</name></expr>)</condition><then>
			<expr_stmt><expr><name>err</name> = <call><name>init_builtin</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>err</name> = <call><name>PyImport_ImportFrozenModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
				     <argument><expr>"Purported %s module %.200s not found"</expr></argument>,
				     <argument><expr><name>type</name> == <name>C_BUILTIN</name> ?
						"builtin" : "frozen"</expr></argument>,
				     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>modules</name> = <call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
				<argument><expr><name>PyExc_ImportError</name></expr></argument>,
				<argument><expr>"%s module %.200s not properly initialized"</expr></argument>,
				<argument><expr><name>type</name> == <name>C_BUILTIN</name> ?
					"builtin" : "frozen"</expr></argument>,
				<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>

	</case><case>case <expr><name>IMP_HOOK</name></expr>: <block>{
		<if>if <condition>(<expr><name>loader</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
					<argument><expr>"import hook without loader"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>m</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>loader</name></expr></argument>, <argument><expr>"load_module"</expr></argument>, <argument><expr>"s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	}</block>

	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"Don't know how to import %.200s (type code %d)"</expr></argument>,
			      <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>m</name> = <name>NULL</name></expr>;</expr_stmt>

	</default>}</block></switch>

	<return>return <expr><name>m</name></expr>;</return>
}</block></function>


<comment type="block">/* Initialize a built-in module.
   Return 1 for success, 0 if the module is not found, and -1 with
   an exception set if the initialization failed. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>init_builtin</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>_inittab</name> *</type><name>p</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>_PyImport_FindExtension</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<for>for (<init><expr><name>p</name> = <name>PyImport_Inittab</name></expr>;</init> <condition><expr><name><name>p</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>p</name>-&gt;<name>initfunc</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
				    <argument><expr>"Cannot re-init internal module %.200s"</expr></argument>,
				    <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s # builtin\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call>(*<name><name>p</name>-&gt;<name>initfunc</name></name>)<argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<if>if <condition>(<expr><call><name>_PyImport_FixupExtension</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Frozen modules */</comment>

<function><type><specifier>static</specifier> struct <name>_frozen</name> *</type>
<name>find_frozen</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>_frozen</name> *</type><name>p</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>p</name> = <name>PyImport_FrozenModules</name></expr>;</init> <condition>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>name</name></name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>
	<return>return <expr><name>p</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_frozen_object</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>_frozen</name> *</type><name>p</name> <init>= <expr><call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"No such frozen object named %.200s"</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>p</name>-&gt;<name>code</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"Excluded frozen object named %.200s"</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>size</name> = <name><name>p</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>size</name> = -<name>size</name></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyMarshal_ReadObjectFromString</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>p</name>-&gt;<name>code</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Initialize a frozen module.
   Return 1 for succes, 0 if the module is not found, and -1 with
   an exception set if the initialization failed.
   This function is also used from frozenmain.c */</comment>

<function><type><name>int</name></type>
<name>PyImport_ImportFrozenModule</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>_frozen</name> *</type><name>p</name> <init>= <expr><call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ispackage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>p</name>-&gt;<name>code</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"Excluded frozen object named %.200s"</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>size</name> = <name><name>p</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ispackage</name> = (<name>size</name> &lt; 0)</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ispackage</name></expr>)</condition><then>
		<expr_stmt><expr><name>size</name> = -<name>size</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s # frozen%s\n"</expr></argument>,
			<argument><expr><name>name</name></expr></argument>, <argument><expr><name>ispackage</name> ? " package" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>co</name> = <call><name>PyMarshal_ReadObjectFromString</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>p</name>-&gt;<name>code</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyCode_Check</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"frozen object %.200s is not a code object"</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err_return</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr><name>ispackage</name></expr>)</condition><then> <block>{
		<comment type="block">/* Set __path__ to the package name */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>err_return</name>;</goto></then></if>
		<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>err_return</name>;</goto></then></if>
		<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__path__"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
			<goto>goto <name>err_return</name>;</goto></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>PyImport_ExecCodeModuleEx</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr>"&lt;frozen&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>err_return</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
<label><name>err_return</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>


<comment type="block">/* Import a module, either built-in, frozen, or external, and return
   its module object WITH INCREMENTED REFERENCE COUNT */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyImport_ImportModule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pname</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pname</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyImport_Import</name><argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Import a module without blocking
 *
 * At first it tries to fetch the module from sys.modules. If the module was
 * never loaded before it loads it with PyImport_ImportModule() unless another
 * thread holds the import lock. In the latter case the function raises an
 * ImportError instead of blocking.
 *
 * Returns the module object with incremented ref count.
 */</comment>
<function><type><name>PyObject</name> *</type>
<name>PyImport_ImportModuleNoBlock</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>me</name></decl>;</decl_stmt>

	<comment type="block">/* Try to get the module from sys.modules[name] */</comment>
	<expr_stmt><expr><name>modules</name> = <call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>modules</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<comment type="block">/* check the import lock
	 * me might be -1 but I ignore the error here, the lock function
	 * takes care of the problem */</comment>
	<expr_stmt><expr><name>me</name> = <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>import_lock_thread</name> == -1 || <name>import_lock_thread</name> == <name>me</name></expr>)</condition><then> <block>{
		<comment type="block">/* no thread or me is holding the lock */</comment>
		<return>return <expr><call><name>PyImport_ImportModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"Failed to import %.200s because the import lock"
			     "is held by another thread."</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>PyImport_ImportModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* Forward declarations for helper routines */</comment>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>get_parent</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
			    <param><decl><type><name>Py_ssize_t</name> *</type><name>p_buflen</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>load_next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>altmod</name></decl></param>,
			   <param><decl><type><name>char</name> **</type><name>p_name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>p_buflen</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mark_miss</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ensure_fromlist</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fromlist</name></decl></param>,
			   <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>buflen</name></decl></param>, <param><decl><type><name>int</name></type> <name>recursive</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>import_submodule</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* The Magnum Opus of dotted-name import :-) */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>import_module_level</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>,
		    <param><decl><type><name>PyObject</name> *</type><name>fromlist</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buflen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>parent</name></decl>, *<decl><type ref="prev"/><name>head</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call> != <name>NULL</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	    || <call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'\\'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
				<argument><expr>"Import by filename is not supported."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>parent</name> = <call><name>get_parent</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>parent</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>head</name> = <call><name>load_next</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>head</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>tail</name> = <name>head</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>name</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>next</name> = <call><name>load_next</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>tail</name> = <name>next</name></expr>;</expr_stmt>
	}</block></while>
	<if>if <condition>(<expr><name>tail</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<comment type="block">/* If tail is Py_None, both get_parent and load_next found
		   an empty module name: someone called __import__("") or
		   doctored faulty bytecode */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"Empty module name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>fromlist</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>fromlist</name> == <name>Py_None</name> || !<call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>fromlist</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>fromlist</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>fromlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>head</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>ensure_fromlist</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>fromlist</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><name>tail</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyImport_ImportModuleLevel</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>,
			 <param><decl><type><name>PyObject</name> *</type><name>fromlist</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lock_import</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>import_module_level</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>, <argument><expr><name>fromlist</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>unlock_import</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"not holding the import lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Return the package that an import is being performed in.  If globals comes
   from the module foo.bar.bat (not itself a package), this returns the
   sys.modules entry for foo.bar.  If globals is from a package's __init__.py,
   the package's entry in sys.modules is returned, as a borrowed reference.

   The *name* of the returned package is returned in buf, with the length of
   the name in *p_buflen.

   If globals doesn't come from a package or a module in a package, or a
   corresponding entry is not found in sys.modules, Py_None is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_parent</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>p_buflen</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>namestr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>pathstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>pkgstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pkgname</name></decl>, *<decl><type ref="prev"/><name>modname</name></decl>, *<decl><type ref="prev"/><name>modpath</name></decl>, *<decl><type ref="prev"/><name>modules</name></decl>, *<decl><type ref="prev"/><name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>orig_level</name> <init>= <expr><name>level</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>globals</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call> || !<name>level</name></expr>)</condition><then>
		<return>return <expr><name>Py_None</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>namestr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>namestr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>namestr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>pathstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>pathstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__path__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pathstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>pkgstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>pkgstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__package__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pkgstr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr>*<name>p_buflen</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>pkgname</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pkgstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>(<name>pkgname</name> != <name>NULL</name>) &amp;&amp; (<name>pkgname</name> != <name>Py_None</name>)</expr>)</condition><then> <block>{
		<comment type="block">/* __package__ is set, so use it */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"__package__ set to non-string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>level</name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"Attempted relative import in non-package"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<return>return <expr><name>Py_None</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>len</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"Package name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<comment type="block">/* __package__ not set, so figure it out and set it */</comment>
		<expr_stmt><expr><name>modname</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>namestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>modname</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>Py_None</name></expr>;</return></then></if>
	
		<expr_stmt><expr><name>modpath</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pathstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>modpath</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* __path__ is set, so modname is already the package name */</comment>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>len</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"Module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>error</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pkgstr</name></expr></argument>, <argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"Could not set __package__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></then> <else>else <block>{
			<comment type="block">/* Normal module, so work out the package name if any */</comment>
			<decl_stmt><decl><type><name>char</name> *</type><name>start</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>lastdot</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>lastdot</name> == <name>NULL</name> &amp;&amp; <name>level</name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"Attempted relative import in non-package"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><name>lastdot</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>error</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pkgstr</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"Could not set __package__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				}</block></then></if>
				<return>return <expr><name>Py_None</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>len</name> = <name>lastdot</name> - <name>start</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>len</name> &gt;= <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"Module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<expr_stmt><expr><name>pkgname</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>pkgname</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>error</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pkgstr</name></expr></argument>, <argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"Could not set __package__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></else></if>
	}</block></else></if>
	<while>while <condition>(<expr>--<name>level</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>dot</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"Attempted relative import beyond "
				"toplevel package"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr>*<name>dot</name> = '\0'</expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr>*<name>p_buflen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>modules</name> = <call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>parent</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>orig_level</name> &lt; 1</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>err_msg</name> <init>= <expr><call><name>PyString_FromFormat</name><argument_list>(
				<argument><expr>"Parent module '%.200s' not found "
				"while handling absolute import"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>err_msg</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr>!<call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
					<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
				<expr_stmt><expr>*<name>p_buflen</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr><name>parent</name> = <name>Py_None</name></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"Parent module '%.200s' not loaded, "
				"cannot perform relative import"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>
	<return>return <expr><name>parent</name></expr>;</return>
	<comment type="block">/* We expect, but can't guarantee, if parent != None, that:
	   - parent.__name__ == buf
	   - parent.__dict__ is globals
	   If this is violated...  Who cares? */</comment>
}</block></function>

<comment type="block">/* altmod is either None or same as mod */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>altmod</name></decl></param>, <param><decl><type><name>char</name> **</type><name>p_name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
	  <param><decl><type><name>Py_ssize_t</name> *</type><name>p_buflen</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr>*<name>p_name</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* completely empty module name should only happen in
		   'from . import' (or '__import__("")')*/</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p_name</name> = <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>mod</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>dot</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>p_name</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr>*<name>p_name</name> = <name>dot</name>+1</expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <name>dot</name>-<name>name</name></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"Empty module name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>p</name> = <name>buf</name> + *<name>p_buflen</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name> != <name>buf</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>p</name>++ = '.'</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>p</name>+<name>len</name>-<name>buf</name> &gt;= <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"Module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr>*<name>p_buflen</name> = <name>p</name>+<name>len</name>-<name>buf</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>import_submodule</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_None</name> &amp;&amp; <name>altmod</name> != <name>mod</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Here, altmod must be None and mod must not be None */</comment>
		<expr_stmt><expr><name>result</name> = <call><name>import_submodule</name><argument_list>(<argument><expr><name>altmod</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> != <name>NULL</name> &amp;&amp; <name>result</name> != <name>Py_None</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>mark_miss</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<expr_stmt><expr>*<name>p_buflen</name> = <name>len</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>result</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"No module named %.200s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>mark_miss</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ensure_fromlist</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fromlist</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>buflen</name></decl></param>,
		<param><decl><type><name>int</name></type> <name>recursive</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"__path__"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>fromlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>hasit</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>1</expr>;</return>
			}</block></then></if>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"Item in ``from list'' not a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index> == '*'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>all</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* See if the package defines __all__ */</comment>
			<if>if <condition>(<expr><name>recursive</name></expr>)</condition><then>
				<continue>continue;</continue></then></if> <comment type="block">/* Avoid endless recursion */</comment>
			<expr_stmt><expr><name>all</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"__all__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>all</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
			<else>else <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>ensure_fromlist</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>all</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
					<return>return <expr>0</expr>;</return></then></if>
			}</block></else></if>
			<continue>continue;</continue>
		}</block></then></if>
		<expr_stmt><expr><name>hasit</name> = <call><name>PyObject_HasAttr</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>hasit</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>subname</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>submod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>buflen</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call> &gt;= <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"Module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>p</name> = <name>buf</name> + <name>buflen</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>p</name>++ = '.'</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>submod</name> = <call><name>import_submodule</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>submod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>submod</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* NOTREACHED */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_submodule</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>submod</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>subname</name></decl></param>,
	      <param><decl><type><name>PyObject</name> *</type><name>modules</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>mod</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<comment type="block">/* Irrespective of the success of this load, make a
	   reference to it in the parent package module.  A copy gets
	   saved in the modules dictionary under the full name, so get a
	   reference from there, if need be.  (The exception is when the
	   load failed with a SyntaxError -- then there's no trace in
	   sys.modules.  In that case, of course, do nothing extra.) */</comment>
	<if>if <condition>(<expr><name>submod</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>submod</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>submod</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyModule_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* We can't use setattr here since it can give a
		 * spurious warning if the submodule name shadows a
		 * builtin name */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>submod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>submod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></else></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>import_submodule</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>char</name> *</type><name>subname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Require:
	   if mod == None: subname == fullname
	   else: mod.__name__ + "." + subname == fullname
	*/</comment>

	<if>if <condition>(<expr>(<name>m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>loader</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>mod</name> == <name>Py_None</name></expr>)</condition><then>
			<expr_stmt><expr><name>path</name> = <name>NULL</name></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name>path</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"__path__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>Py_None</name></expr>;</return>
			}</block></then></if>
		}</block></else></if>

		<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
		<expr_stmt><expr><name>fdp</name> = <call><name>find_module</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name>+1</expr></argument>,
				  <argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr>&amp;<name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fdp</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>Py_None</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>m</name> = <call><name>load_module</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fp</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>!<call><name>add_submodule</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>m</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></else></if>

	<return>return <expr><name>m</name></expr>;</return>
}</block></function>


<comment type="block">/* Re-import a module of any kind and return its module object, WITH
   INCREMENTED REFERENCE COUNT */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyImport_ReloadModule</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>m</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_Get</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules_reloading</name> <init>= <expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init>, *<name>loader</name> <init>= <expr><name>NULL</name></expr></init>, *<name>existing_m</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>subname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newm</name></decl>;</decl_stmt>
    
	<if>if <condition>(<expr><name>modules_reloading</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyImport_ReloadModule: "
			      "no modules_reloading dictionary!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>m</name> == <name>NULL</name> || !<call><name>PyModule_Check</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"reload() argument must be module"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>name</name> = <call><name>PyModule_GetName</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>m</name> != <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			     <argument><expr>"reload(): module %.200s not in sys.modules"</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>existing_m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules_reloading</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>existing_m</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Due to a recursive reload, this module is already
		   being reloaded. */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>existing_m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>existing_m</name></expr>;</return>
 	}</block></then></if>
 	<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules_reloading</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>subname</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>subname</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>subname</name> = <name>name</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>parentname</name></decl>, *<decl><type ref="prev"/><name>parent</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>parentname</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>subname</name>-<name>name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>parentname</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>imp_modules_reloading_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
        	}</block></then></if>
		<expr_stmt><expr><name>parent</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>parentname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>parent</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			    <argument><expr>"reload(): parent %.200s not in sys.modules"</expr></argument>,
			    <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>parentname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parentname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>imp_modules_reloading_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parentname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subname</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr>"__path__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr><name>fdp</name> = <call><name>find_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name>+1</expr></argument>, <argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr>&amp;<name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>fdp</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>imp_modules_reloading_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>newm</name> = <call><name>load_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>fp</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>newm</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* load_module probably removed name from modules because of
		 * the error.  Put back the original module object.  We're
		 * going to return NULL in this case regardless of whether
		 * replacing name succeeds, so the return value is ignored.
		 */</comment>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>imp_modules_reloading_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newm</name></expr>;</return>
}</block></function>


<comment type="block">/* Higher-level import emulator which emulates the "import" statement
   more accurately -- it invokes the __import__() function from the
   builtins of the current globals.  This means that the import is
   done using whatever import hooks are installed in the current
   environment, e.g. by "rexec".
   A dummy list ["__doc__"] is passed as the 4th argument so that
   e.g. PyImport_Import(PyString_FromString("win32com.client.gencache"))
   will return &lt;module "gencache"&gt; instead of &lt;module "win32com"&gt;. */</comment>

<function><type><name>PyObject</name> *</type>
<name>PyImport_Import</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module_name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>silly_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>builtins_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>import_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>import</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>builtins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>r</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Initialize constant string objects */</comment>
	<if>if <condition>(<expr><name>silly_list</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>import_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__import__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>import_str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>builtins_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__builtins__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>builtins_str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>silly_list</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"[s]"</expr></argument>, <argument><expr>"__doc__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>silly_list</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<comment type="block">/* Get the builtins from current globals */</comment>
	<expr_stmt><expr><name>globals</name> = <call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>globals</name> != <name>NULL</name></expr>)</condition><then> <block>{
	        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>builtins</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>builtins_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>builtins</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* No globals -- use standard builtins, and fake globals */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>builtins</name> = <call><name>PyImport_ImportModuleLevel</name><argument_list>(<argument><expr>"__builtin__"</expr></argument>,
						      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>builtins</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>globals</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"{OO}"</expr></argument>, <argument><expr><name>builtins_str</name></expr></argument>, <argument><expr><name>builtins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>globals</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
	}</block></else></if>

	<comment type="block">/* Get the __import__ function from the builtins */</comment>
	<if>if <condition>(<expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>import</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>, <argument><expr><name>import_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>import</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>, <argument><expr><name>import_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>import</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>, <argument><expr><name>import_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>import</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>

	<comment type="block">/* Call the __import__ function with the proper argument list
	 * Always use absolute import here. */</comment>
	<expr_stmt><expr><name>r</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>import</name></expr></argument>, <argument><expr>"OOOOi"</expr></argument>, <argument><expr><name>module_name</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>,
				  <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>silly_list</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>err</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>import</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>r</name></expr>;</return>
}</block></function>


<comment type="block">/* Module 'imp' provides Python access to the primitives used for
   importing modules.
*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_get_magic</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>(<name>pyc_magic</name> &gt;&gt;  0) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>(<name>pyc_magic</name> &gt;&gt;  8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr>2</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>(<name>pyc_magic</name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr>3</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>(<name>pyc_magic</name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_get_suffixes</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>fdp</name> = <name>_PyImport_Filetab</name></expr>;</init> <condition><expr><name><name>fdp</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>fdp</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ssi"</expr></argument>,
				       <argument><expr><name><name>fdp</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>mode</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>list</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_find_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
	<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>fclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name></decl>, *<decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>pathname</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pathname</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>path</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>path</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>fdp</name> = <call><name>find_module</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name>+1</expr></argument>, <argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fdp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>fob</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>mode</name></name></expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fob</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>fob</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>fob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Os(ssi)"</expr></argument>,
		      <argument><expr><name>fob</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>mode</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_find_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|O:find_module"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>call_find_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_init_builtin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:init_builtin"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>ret</name> = <call><name>init_builtin</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>m</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_init_frozen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:init_frozen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>ret</name> = <call><name>PyImport_ImportFrozenModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>m</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_get_frozen_object</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:get_frozen_object"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>get_frozen_object</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_is_builtin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:is_builtin"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>is_builtin</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_is_frozen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>_frozen</name> *</type><name>p</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:is_frozen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>p</name> = <call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call>(<name>long</name>) <argument_list>(<argument><expr><name>p</name> == <name>NULL</name> ? 0 : <name><name>p</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>FILE</name> *</type>
<name>get_file</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fob</name></decl></param>, <param><decl><type><name>char</name> *</type><name>mode</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>fob</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>mode</name><index>[<expr>0</expr>]</index></name> == 'U'</expr>)</condition><then>
			<expr_stmt><expr><name>mode</name> = "r" <name>PY_STDIOTEXTMODE</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>fp</name> = <call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>fob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"bad/closed file object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<return>return <expr><name>fp</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_compiled</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss|O!:load_compiled"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>,
			      <argument><expr>&amp;<name>PyFile_Type</name></expr></argument>, <argument><expr>&amp;<name>fob</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>fp</name> = <call><name>get_file</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fob</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>load_compiled_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fob</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>m</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DYNAMIC_LOADING</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_dynamic</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss|O!:load_dynamic"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>,
			      <argument><expr>&amp;<name>PyFile_Type</name></expr></argument>, <argument><expr>&amp;<name>fob</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>fob</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>fp</name> = <call><name>get_file</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fob</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>_PyImport_LoadDynamicModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>m</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_DYNAMIC_LOADING */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_source</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss|O!:load_source"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>,
			      <argument><expr>&amp;<name>PyFile_Type</name></expr></argument>, <argument><expr>&amp;<name>fob</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>fp</name> = <call><name>get_file</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fob</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>m</name> = <call><name>load_source_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fob</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>m</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>suffix</name></decl>;</decl_stmt> <comment type="block">/* Unused */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"sOs(ssi):load_module"</expr></argument>,
			      <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>fob</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>,
			      <argument><expr>&amp;<name>suffix</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>*<name>mode</name></expr>)</condition><then> <block>{
		<comment type="block">/* Mode must start with 'r' or 'U' and must not contain '+'.
		   Implicit in this test is the assumption that the mode
		   may contain other modifiers like 'b' or 't'. */</comment>

		<if>if <condition>(<expr>!(*<name>mode</name> == 'r' || *<name>mode</name> == 'U') || <call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>'+'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				     <argument><expr>"invalid file open mode %.200s"</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>fob</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>fp</name> = <name>NULL</name></expr>;</expr_stmt></then>
	<else>else <block>{
		<if>if <condition>(<expr>!<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>fob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"load_module arg#2 should be a file or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>fp</name> = <call><name>get_file</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fob</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></else></if>
	<return>return <expr><call><name>load_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_package</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss:load_package"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>load_package</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_new_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:new_module"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyModule_New</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_reload</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyImport_ReloadModule</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Doc strings */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_imp</name></expr></argument>,
<argument><expr>"This module provides the components needed to build your own\n\
__import__ function.  Undocumented functions are obsolete."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_reload</name></expr></argument>,
<argument><expr>"reload(module) -&gt; module\n\
\n\
Reload the module.  The module must have been successfully imported before."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_find_module</name></expr></argument>,
<argument><expr>"find_module(name, [path]) -&gt; (file, filename, (suffix, mode, type))\n\
Search for a module.  If path is omitted or None, search for a\n\
built-in, frozen or special module and continue search in sys.path.\n\
The module name cannot contain '.'; to search for a submodule of a\n\
package, pass the submodule name and the package's __path__."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_load_module</name></expr></argument>,
<argument><expr>"load_module(name, file, filename, (suffix, mode, type)) -&gt; module\n\
Load a module, given information returned by find_module().\n\
The module name must include the full package name, if any."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_magic</name></expr></argument>,
<argument><expr>"get_magic() -&gt; string\n\
Return the magic number for .pyc or .pyo files."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_suffixes</name></expr></argument>,
<argument><expr>"get_suffixes() -&gt; [(suffix, mode, type), ...]\n\
Return a list of (suffix, mode, type) tuples describing the files\n\
that find_module() looks for."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_new_module</name></expr></argument>,
<argument><expr>"new_module(name) -&gt; module\n\
Create a new module.  Do not enter it in sys.modules.\n\
The module name must include the full package name, if any."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_lock_held</name></expr></argument>,
<argument><expr>"lock_held() -&gt; boolean\n\
Return True if the import lock is currently held, else False.\n\
On platforms without threads, return False."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_acquire_lock</name></expr></argument>,
<argument><expr>"acquire_lock() -&gt; None\n\
Acquires the interpreter's import lock for the current thread.\n\
This lock should be used by import hooks to ensure thread-safety\n\
when importing modules.\n\
On platforms without threads, this function does nothing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_release_lock</name></expr></argument>,
<argument><expr>"release_lock() -&gt; None\n\
Release the interpreter's import lock.\n\
On platforms without threads, this function does nothing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>imp_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"reload"</expr>,	 <expr><name>imp_reload</name></expr>,	   <expr><name>METH_O</name></expr>,	 <expr><name>doc_reload</name></expr>}</block></expr>,
	<expr><block>{<expr>"find_module"</expr>,	 <expr><name>imp_find_module</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_find_module</name></expr>}</block></expr>,
	<expr><block>{<expr>"get_magic"</expr>,	 <expr><name>imp_get_magic</name></expr>,	   <expr><name>METH_NOARGS</name></expr>,  <expr><name>doc_get_magic</name></expr>}</block></expr>,
	<expr><block>{<expr>"get_suffixes"</expr>, <expr><name>imp_get_suffixes</name></expr>, <expr><name>METH_NOARGS</name></expr>,  <expr><name>doc_get_suffixes</name></expr>}</block></expr>,
	<expr><block>{<expr>"load_module"</expr>,	 <expr><name>imp_load_module</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_load_module</name></expr>}</block></expr>,
	<expr><block>{<expr>"new_module"</expr>,	 <expr><name>imp_new_module</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_new_module</name></expr>}</block></expr>,
	<expr><block>{<expr>"lock_held"</expr>,	 <expr><name>imp_lock_held</name></expr>,	   <expr><name>METH_NOARGS</name></expr>,  <expr><name>doc_lock_held</name></expr>}</block></expr>,
	<expr><block>{<expr>"acquire_lock"</expr>, <expr><name>imp_acquire_lock</name></expr>, <expr><name>METH_NOARGS</name></expr>,  <expr><name>doc_acquire_lock</name></expr>}</block></expr>,
	<expr><block>{<expr>"release_lock"</expr>, <expr><name>imp_release_lock</name></expr>, <expr><name>METH_NOARGS</name></expr>,  <expr><name>doc_release_lock</name></expr>}</block></expr>,
	<comment type="block">/* The rest are obsolete */</comment>
	<expr><block>{<expr>"get_frozen_object"</expr>,	<expr><name>imp_get_frozen_object</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"init_builtin"</expr>,	<expr><name>imp_init_builtin</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"init_frozen"</expr>,		<expr><name>imp_init_frozen</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"is_builtin"</expr>,		<expr><name>imp_is_builtin</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"is_frozen"</expr>,		<expr><name>imp_is_frozen</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"load_compiled"</expr>,	<expr><name>imp_load_compiled</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DYNAMIC_LOADING</name></cpp:ifdef>
	<expr><block>{<expr>"load_dynamic"</expr>,	<expr><name>imp_load_dynamic</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"load_package"</expr>,	<expr><name>imp_load_package</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"load_source"</expr>,		<expr><name>imp_load_source</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,			<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setint</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>d</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <expr_stmt><expr><name>PyObject_HEAD</name></expr></expr_stmt>
}</block></struct></type> <name>NullImporter</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>NullImporter_init</name><parameter_list>(<param><decl><type><name>NullImporter</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pathlen</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"NullImporter()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:NullImporter"</expr></argument>,
			      <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<expr_stmt><expr><name>pathlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pathlen</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr>"empty pathname"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then> <else>else <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RISCOS</name></cpp:ifndef>
		<decl_stmt><decl><type>struct <name>stat</name></type> <name>statbuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rv</name> = <call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
		<comment type="block">/* MS Windows stat() chokes on paths like C:\path\. Try to
		 * recover *one* time by stripping off a trailing slash or
		 * backslash. http://bugs.python.org/issue1293
 		 */</comment>
		<if>if <condition>(<expr><name>rv</name> != 0 &amp;&amp; <name>pathlen</name> &lt;= <name>MAXPATHLEN</name> &amp;&amp;
		    (<name><name>path</name><index>[<expr><name>pathlen</name>-1</expr>]</index></name> == '/' || <name><name>path</name><index>[<expr><name>pathlen</name>-1</expr>]</index></name> == '\\')</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name></type> <name><name>mangled</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mangled</name><index>[<expr><name>pathlen</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<expr_stmt><expr><name>rv</name> = <call><name>stat</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><name>rv</name> == 0</expr>)</condition><then> <block>{
			<comment type="block">/* it exists */</comment>
			<if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* it's a directory */</comment>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
						<argument><expr>"existing directory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><call><name>object_exists</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* it exists */</comment>
			<if>if <condition>(<expr><call><name>isdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* it's a directory */</comment>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
						<argument><expr>"existing directory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>NullImporter_find_module</name><parameter_list>(<param><decl><type><name>NullImporter</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>NullImporter_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"find_module"</expr>, <expr>(<name>PyCFunction</name>)<name>NullImporter_find_module</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr>"Always return None"</expr>
	}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>  <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyNullImporter_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"imp.NullImporter"</expr>,        <comment type="block">/*tp_name*/</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>NullImporter</name></expr></argument>)</argument_list></sizeof></expr>,      <comment type="block">/*tp_basicsize*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_itemsize*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_dealloc*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_print*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_getattr*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_setattr*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_compare*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_repr*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_as_number*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_as_sequence*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_as_mapping*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_hash */</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_call*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_str*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_getattro*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_setattro*/</comment>
	<expr>0</expr>,                         <comment type="block">/*tp_as_buffer*/</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,        <comment type="block">/*tp_flags*/</comment>
	<expr>"Null importer object"</expr>,    <comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,	                   <comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,	                   <comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,	                   <comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,	                   <comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,	                   <comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,	                   <comment type="block">/* tp_iternext */</comment>
	<expr><name>NullImporter_methods</name></expr>,      <comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,                         <comment type="block">/* tp_members */</comment>
	<expr>0</expr>,                         <comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,                         <comment type="block">/* tp_base */</comment>
	<expr>0</expr>,                         <comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,                         <comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,                         <comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,                         <comment type="block">/* tp_dictoffset */</comment>
	<expr>(<name>initproc</name>)<name>NullImporter_init</name></expr>,      <comment type="block">/* tp_init */</comment>
	<expr>0</expr>,                         <comment type="block">/* tp_alloc */</comment>
	<expr><name>PyType_GenericNew</name></expr>          <comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>


<function><type><name>PyMODINIT_FUNC</name></type>
<name>initimp</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyNullImporter_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>failure</name>;</goto></then></if>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"imp"</expr></argument>, <argument><expr><name>imp_methods</name></expr></argument>, <argument><expr><name>doc_imp</name></expr></argument>,
			   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>failure</name>;</goto></then></if>
	<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>failure</name>;</goto></then></if>

	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"SEARCH_ERROR"</expr></argument>, <argument><expr><name>SEARCH_ERROR</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_SOURCE"</expr></argument>, <argument><expr><name>PY_SOURCE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_COMPILED"</expr></argument>, <argument><expr><name>PY_COMPILED</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"C_EXTENSION"</expr></argument>, <argument><expr><name>C_EXTENSION</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_RESOURCE"</expr></argument>, <argument><expr><name>PY_RESOURCE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PKG_DIRECTORY"</expr></argument>, <argument><expr><name>PKG_DIRECTORY</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"C_BUILTIN"</expr></argument>, <argument><expr><name>C_BUILTIN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_FROZEN"</expr></argument>, <argument><expr><name>PY_FROZEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_CODERESOURCE"</expr></argument>, <argument><expr><name>PY_CODERESOURCE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"IMP_HOOK"</expr></argument>, <argument><expr><name>IMP_HOOK</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyNullImporter_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NullImporter"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>PyNullImporter_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>failure</name>:</label>
	<empty_stmt>;</empty_stmt>
}</block></function>


<comment type="block">/* API for embedding applications that want to add their own entries
   to the table of built-in modules.  This should normally be called
   *before* Py_Initialize().  When the table resize fails, -1 is
   returned and the existing table is unchanged.

   After a similar function by Just van Rossum. */</comment>

<function><type><name>int</name></type>
<name>PyImport_ExtendInittab</name><parameter_list>(<param><decl><type>struct <name>_inittab</name> *</type><name>newtab</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> struct <name>_inittab</name> *</type><name>our_copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>_inittab</name> *</type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<comment type="block">/* Count the number of entries in both tables */</comment>
	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name><name>newtab</name><index>[<expr><name>n</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)
		<empty_stmt>;</empty_stmt></for>
	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if> <comment type="block">/* Nothing to do */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<empty_stmt>;</empty_stmt></for>

	<comment type="block">/* Allocate new memory for the combined table */</comment>
	<expr_stmt><expr><name>p</name> = <name>our_copy</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_RESIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument>struct <expr><name>_inittab</name></expr></argument>, <argument><expr><name>i</name>+<name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<comment type="block">/* Copy the tables into the new memory */</comment>
	<if>if <condition>(<expr><name>our_copy</name> != <name>PyImport_Inittab</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>PyImport_Inittab</name></expr></argument>, <argument><expr>(<name>i</name>+1) * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>_inittab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>PyImport_Inittab</name> = <name>our_copy</name> = <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name>+<name>i</name></expr></argument>, <argument><expr><name>newtab</name></expr></argument>, <argument><expr>(<name>n</name>+1) * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>_inittab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Shorthand to add a single entry given a name and a function */</comment>

<function><type><name>int</name></type>
<name>PyImport_AppendInittab</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>initfunc</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>_inittab</name></type> <name><name>newtab</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>newtab</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr>sizeof <name>newtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newtab</name><index>[<expr>0</expr>]</index></name>.<name>name</name> = <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newtab</name><index>[<expr>0</expr>]</index></name>.<name>initfunc</name> = <name>initfunc</name></expr>;</expr_stmt>

	<return>return <expr><call><name>PyImport_ExtendInittab</name><argument_list>(<argument><expr><name>newtab</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></function></block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
