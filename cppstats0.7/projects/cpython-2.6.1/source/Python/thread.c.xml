<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/thread.c">
<comment type="block">/* Thread package.
   This is intended to be usable independently from Python.
   The implementation for system foobar is in a file thread_foobar.h
   which is included by this file dependent on config settings.
   Stuff shared by all thread_*.h files is collected here. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_POSIX_THREADS</name></cpp:ifndef>
<comment type="block">/* This means pthreads are not implemented in libc headers, hence the macro
   not present in unistd.h. But they still can be implemented as an external
   library (e.g. gnu pth in pthread emulation) */</comment>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_H</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include> <comment type="block">/* _POSIX_THREADS */</comment>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DONT_HAVE_STDIO_H</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__sgi</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_PTHREAD_H</name></cpp:ifndef> <comment type="block">/* XXX Need to check in configure.in */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_POSIX_THREADS</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_POSIX_THREADS</name></cpp:ifndef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__sgi</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SGI_THREADS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_THREAD_H</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOLARIS_THREADS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>sun</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SOLARIS_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUN_LWP</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Check if we're running on HP-UX and _SC_THREADS is defined. If so, then
   enough of the Posix threads package is implimented to support python 
   threads.

   This is valid for HP-UX 11.23 running on an ia64 system. If needed, add
   a check of __ia64 to verify that we're running on a ia64 system instead
   of a pa-risc system.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__hpux</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREADS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_POSIX_THREADS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _POSIX_THREADS */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>thread_debug</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dprintf</name><parameter_list>(<param><type><name>args</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(void)((thread_debug &amp; 1) &amp;&amp; printf args)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>d2printf</name><parameter_list>(<param><type><name>args</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((thread_debug &amp; 8) &amp;&amp; printf args)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dprintf</name><parameter_list>(<param><type><name>args</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>d2printf</name><parameter_list>(<param><type><name>args</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PyThread__init_thread</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* Forward */</comment>

<function><type><name>void</name></type>
<name>PyThread_init_thread</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONTHREADDEBUG"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>p</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>*<name>p</name></expr>)</condition><then>
			<expr_stmt><expr><name>thread_debug</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>thread_debug</name> = 1</expr>;</expr_stmt></else></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_DEBUG */</comment>
	<if>if <condition>(<expr><name>initialized</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dprintf</name><argument_list>(<argument><expr>("PyThread_init_thread called\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyThread__init_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Support for runtime thread stack size tuning.
   A value of 0 means using the platform's default stack size
   or the size specified by the THREAD_STACK_SIZE macro. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>_pythread_stacksize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SGI_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_sgi.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SOLARIS_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_solaris.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUN_LWP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_lwp.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTH</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_pth.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_POSIX_THREADS</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_POSIX_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_pthread.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>C_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_cthread.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NT_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_nt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OS2_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_os2.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BEOS_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_beos.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_wince.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PLAN9_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_plan9.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ATHEOS_THREADS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_atheos.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
#ifdef FOOBAR_THREADS
#include "thread_foobar.h"
#endif
*/</comment>

<comment type="block">/* return the current thread stack size */</comment>
<function><type><name>size_t</name></type>
<name>PyThread_get_stacksize</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>_pythread_stacksize</name></expr>;</return>
}</block></function>

<comment type="block">/* Only platforms defining a THREAD_SET_STACKSIZE() macro
   in thread_&lt;platform&gt;.h support changing the stack size.
   Return 0 if stack size is valid,
          -1 if stack size value is invalid,
          -2 if setting stack size is not supported. */</comment>
<function><type><name>int</name></type>
<name>PyThread_set_stacksize</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>THREAD_SET_STACKSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<return>return <expr><call><name>THREAD_SET_STACKSIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr>-2</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_HAVE_NATIVE_TLS</name></cpp:ifndef>
<comment type="block">/* If the platform has not supplied a platform specific
   TLS implementation, provide our own.

   This code stolen from "thread_sgi.h", where it was the only
   implementation of an existing Python TLS API.
*/</comment>
<comment type="block">/* ------------------------------------------------------------------------
Per-thread data ("key") support.

Use PyThread_create_key() to create a new key.  This is typically shared
across threads.

Use PyThread_set_key_value(thekey, value) to associate void* value with
thekey in the current thread.  Each thread has a distinct mapping of thekey
to a void* value.  Caution:  if the current thread already has a mapping
for thekey, value is ignored.

Use PyThread_get_key_value(thekey) to retrieve the void* value associated
with thekey in the current thread.  This returns NULL if no value is
associated with thekey in the current thread.

Use PyThread_delete_key_value(thekey) to forget the current thread's associated
value for thekey.  PyThread_delete_key(thekey) forgets the values associated
with thekey across *all* threads.

While some of these functions have error-return values, none set any
Python exception.

None of the functions does memory management on behalf of the void* values.
You need to allocate and deallocate them yourself.  If the void* values
happen to be PyObject*, these functions don't do refcount operations on
them either.

The GIL does not need to be held when calling these functions; they supply
their own locking.  This isn't true of PyThread_create_key(), though (see
next paragraph).

There's a hidden assumption that PyThread_create_key() will be called before
any of the other functions are called.  There's also a hidden assumption
that calls to PyThread_create_key() are serialized externally.
------------------------------------------------------------------------ */</comment>

<comment type="block">/* A singly-linked list of struct key objects remembers all the key-&gt;value
 * associations.  File static keyhead heads the list.  keymutex is used
 * to enforce exclusion internally.
 */</comment>
<struct>struct <name>key</name> <block>{
	<comment type="block">/* Next record in the list, or NULL if this is the last record. */</comment>
	<decl_stmt><decl><type>struct <name>key</name> *</type><name>next</name></decl>;</decl_stmt>

	<comment type="block">/* The thread id, according to PyThread_get_thread_ident(). */</comment>
	<decl_stmt><decl><type><name>long</name></type> <name>id</name></decl>;</decl_stmt>

	<comment type="block">/* The key and its associated value. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> *</type><name>value</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>key</name> *</type><name>keyhead</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyThread_type_lock</name></type> <name>keymutex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nkeys</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* PyThread_create_key() hands out nkeys+1 next */</comment>

<comment type="block">/* Internal helper.
 * If the current thread has a mapping for key, the appropriate struct key*
 * is returned.  NB:  value is ignored in this case!
 * If there is no mapping for key in the current thread, then:
 *     If value is NULL, NULL is returned.
 *     Else a mapping of key to value is created for the current thread,
 *     and a pointer to a new struct key* is returned; except that if
 *     malloc() can't find room for a new struct key*, NULL is returned.
 * So when value==NULL, this acts like a pure lookup routine, and when
 * value!=NULL, this acts like dict.setdefault(), returning an existing
 * mapping if one exists, else creating a new mapping.
 *
 * Caution:  this used to be too clever, trying to hold keymutex only
 * around the "p-&gt;next = keyhead; keyhead = p" pair.  That allowed
 * another thread to mutate the list, via key deletion, concurrent with
 * find_key() crawling over the list.  Hilarity ensued.  For example, when
 * the for-loop here does "p = p-&gt;next", p could end up pointing at a
 * record that PyThread_delete_key_value() was concurrently free()'ing.
 * That could lead to anything, from failing to find a key that exists, to
 * segfaults.  Now we lock the whole routine.
 */</comment>
<function><type><specifier>static</specifier> struct <name>key</name> *</type>
<name>find_key</name><parameter_list>(<param><decl><type><name>int</name></type> <name>key</name></decl></param>, <param><decl><type><name>void</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>key</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>prev_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>id</name> <init>= <expr><call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>keymutex</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>keymutex</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_p</name> = <name>NULL</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>keyhead</name></expr>;</init> <condition><expr><name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>id</name></name> == <name>id</name> &amp;&amp; <name><name>p</name>-&gt;<name>key</name></name> == <name>key</name></expr>)</condition><then>
			<goto>goto <name>Done</name>;</goto></then></if>
		<comment type="block">/* Sanity check.  These states should never happen but if
		 * they do we must abort.  Otherwise we'll end up spinning in
		 * in a tight loop with the lock held.  A similar check is done
		 * in pystate.c tstate_delete_common().  */</comment>
		<if>if <condition>(<expr><name>p</name> == <name>prev_p</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"tls find_key: small circular list(!)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>prev_p</name> = <name>p</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>next</name></name> == <name>keyhead</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"tls find_key: circular list(!)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>Done</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>p</name> = (struct <name>key</name> *)<call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>p</name>-&gt;<name>id</name></name> = <name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name>-&gt;<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name>-&gt;<name>value</name></name> = <name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name>-&gt;<name>next</name></name> = <name>keyhead</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>keyhead</name> = <name>p</name></expr>;</expr_stmt>
	}</block></then></if>
 <label><name>Done</name>:</label>
	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>keymutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/* Return a new key.  This must be called before any other functions in
 * this family, and callers must arrange to serialize calls to this
 * function.  No violations are detected.
 */</comment>
<function><type><name>int</name></type>
<name>PyThread_create_key</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* All parts of this function are wrong if it's called by multiple
	 * threads simultaneously.
	 */</comment>
	<if>if <condition>(<expr><name>keymutex</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>keymutex</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>++<name>nkeys</name></expr>;</return>
}</block></function>

<comment type="block">/* Forget the associations for key across *all* threads. */</comment>
<function><type><name>void</name></type>
<name>PyThread_delete_key</name><parameter_list>(<param><decl><type><name>int</name></type> <name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>key</name> *</type><name>p</name></decl>, **<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>keymutex</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> = &amp;<name>keyhead</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>p</name> = *<name>q</name>) != <name>NULL</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>key</name></name> == <name>key</name></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>q</name> = <name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr>(<name>void</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* NB This does *not* free p-&gt;value! */</comment>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>q</name> = &amp;<name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt></else></if>
	}</block></while>
	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>keymutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Confusing:  If the current thread has an association for key,
 * value is ignored, and 0 is returned.  Else an attempt is made to create
 * an association of key to value for the current thread.  0 is returned
 * if that succeeds, but -1 is returned if there's not enough memory
 * to create the association.  value must not be NULL.
 */</comment>
<function><type><name>int</name></type>
<name>PyThread_set_key_value</name><parameter_list>(<param><decl><type><name>int</name></type> <name>key</name></decl></param>, <param><decl><type><name>void</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>key</name> *</type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>value</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> = <call><name>find_key</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then>
	<else>else
		<return>return <expr>0</expr>;</return></else></if>
}</block></function>

<comment type="block">/* Retrieve the value associated with key in the current thread, or NULL
 * if the current thread doesn't have an association for key.
 */</comment>
<function><type><name>void</name> *</type>
<name>PyThread_get_key_value</name><parameter_list>(<param><decl><type><name>int</name></type> <name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>key</name> *</type><name>p</name> <init>= <expr><call><name>find_key</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then>
	<else>else
		<return>return <expr><name><name>p</name>-&gt;<name>value</name></name></expr>;</return></else></if>
}</block></function>

<comment type="block">/* Forget the current thread's association for key, if any. */</comment>
<function><type><name>void</name></type>
<name>PyThread_delete_key_value</name><parameter_list>(<param><decl><type><name>int</name></type> <name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>id</name> <init>= <expr><call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>key</name> *</type><name>p</name></decl>, **<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>keymutex</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> = &amp;<name>keyhead</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>p</name> = *<name>q</name>) != <name>NULL</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>key</name></name> == <name>key</name> &amp;&amp; <name><name>p</name>-&gt;<name>id</name></name> == <name>id</name></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>q</name> = <name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr>(<name>void</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* NB This does *not* free p-&gt;value! */</comment>
			<break>break;</break>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>q</name> = &amp;<name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt></else></if>
	}</block></while>
	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>keymutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Forget everything not associated with the current thread id.
 * This function is called from PyOS_AfterFork().  It is necessary
 * because other thread ids which were in use at the time of the fork
 * may be reused for new threads created in the forked process.
 */</comment>
<function><type><name>void</name></type>
<name>PyThread_ReInitTLS</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>id</name> <init>= <expr><call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>key</name> *</type><name>p</name></decl>, **<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>keymutex</name></expr>)</condition><then>
		<return>return;</return></then></if>
	
	<comment type="block">/* As with interpreter_lock in PyEval_ReInitThreads()
	   we just create a new lock without freeing the old one */</comment>
	<expr_stmt><expr><name>keymutex</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete all keys which do not match the current thread id */</comment>
	<expr_stmt><expr><name>q</name> = &amp;<name>keyhead</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>p</name> = *<name>q</name>) != <name>NULL</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>id</name></name> != <name>id</name></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>q</name> = <name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr>(<name>void</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* NB This does *not* free p-&gt;value! */</comment>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>q</name> = &amp;<name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt></else></if>
	}</block></while>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_HAVE_NATIVE_TLS */</comment>
</unit>
