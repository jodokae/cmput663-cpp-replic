<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Python/compile.c"><comment type="block">/*
 * This file compiles an abstract syntax tree (AST) into Python bytecode.
 *
 * The primary entry point is PyAST_Compile(), which returns a
 * PyCodeObject.  The compiler makes several passes to build the code
 * object:
 *   1. Checks for future statements.  See future.c
 *   2. Builds a symbol table.	See symtable.c.
 *   3. Generate code for basic blocks.  See compiler_mod() in this file.
 *   4. Assemble the basic blocks into final code.  See assemble() in
 *	this file.	 
 *   5. Optimize the byte code (peephole optimizations).  See peephole.c
 *
 * Note that compiler_mod() suggests module, but the module ast type
 * (mod_ty) has cases for expressions and interactive statements.
 *
 * CAUTION: The VISIT_* macros abort the current function when they
 * encounter a problem. So don't invoke them when there is memory
 * which needs to be released. Code blocks are OK, as the compiler
 * structure takes care of releasing those.  Use the arena to manage
 * objects.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"symtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"opcode.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>int</name></type> <name>Py_OptimizeFlag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_BLOCK_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_BLOCKS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CODE_SIZE</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_LNOTAB_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<struct>struct <name>instr</name> <block>{
	<expr_stmt><expr><name>unsigned</name> <name>i_jabs</name> : 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>unsigned</name> <name>i_jrel</name> : 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>unsigned</name> <name>i_hasarg</name> : 1</expr>;</expr_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>i_opcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i_oparg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>basicblock_</name> *</type><name>i_target</name></decl>;</decl_stmt> <comment type="block">/* target block (if jump instruction) */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>i_lineno</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>basicblock_</name> <block>{
    <comment type="block">/* Each basicblock in a compilation unit is linked via b_list in the
       reverse order that the block are allocated.  b_list points to the next
       block, not to be confused with b_next, which is next by control flow. */</comment>
	<decl_stmt><decl><type>struct <name>basicblock_</name> *</type><name>b_list</name></decl>;</decl_stmt>
	<comment type="block">/* number of instructions used */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>b_iused</name></decl>;</decl_stmt>
	<comment type="block">/* length of instruction array (b_instr) */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>b_ialloc</name></decl>;</decl_stmt>
	<comment type="block">/* pointer to an array of instructions, initially NULL */</comment>
	<decl_stmt><decl><type>struct <name>instr</name> *</type><name>b_instr</name></decl>;</decl_stmt>
	<comment type="block">/* If b_next is non-NULL, it is a pointer to the next
	   block reached by normal control flow. */</comment>
	<decl_stmt><decl><type>struct <name>basicblock_</name> *</type><name>b_next</name></decl>;</decl_stmt>
	<comment type="block">/* b_seen is used to perform a DFS of basicblocks. */</comment>
	<expr_stmt><expr><name>unsigned</name> <name>b_seen</name> : 1</expr>;</expr_stmt>
	<comment type="block">/* b_return is true if a RETURN_VALUE opcode is inserted. */</comment>
	<expr_stmt><expr><name>unsigned</name> <name>b_return</name> : 1</expr>;</expr_stmt>
	<comment type="block">/* depth of stack upon entry of block, computed by stackdepth() */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>b_startdepth</name></decl>;</decl_stmt>
	<comment type="block">/* instruction offset for block, computed by assemble_jump_offsets() */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>b_offset</name></decl>;</decl_stmt>
}</block></struct></type> <name>basicblock</name>;</typedef>

<comment type="block">/* fblockinfo tracks the current frame block.

A frame block is used to handle loops, try/except, and try/finally.
It's called a frame block to distinguish it from a basic block in the
compiler IR.
*/</comment>

<enum>enum <name>fblocktype</name> <block>{ <decl><name>LOOP</name></decl>, <decl><name>EXCEPT</name></decl>, <decl><name>FINALLY_TRY</name></decl>, <decl><name>FINALLY_END</name></decl> }</block>;</enum>

<struct>struct <name>fblockinfo</name> <block>{
	<enum>enum <name>fblocktype</name> <name>fb_type</name>;</enum>
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>fb_block</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* The following items change on entry and exit of code blocks.
   They must be saved and restored when returning to a block.
*/</comment>
<struct>struct <name>compiler_unit</name> <block>{
	<decl_stmt><decl><type><name>PySTEntryObject</name> *</type><name>u_ste</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_name</name></decl>;</decl_stmt>
	<comment type="block">/* The following fields are dicts that map objects to
	   the index of them in co_XXX.	 The index is used as
	   the argument for opcodes that refer to those collections.
	*/</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_consts</name></decl>;</decl_stmt>    <comment type="block">/* all constants */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_names</name></decl>;</decl_stmt>     <comment type="block">/* all names */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_varnames</name></decl>;</decl_stmt>  <comment type="block">/* local variables */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_cellvars</name></decl>;</decl_stmt>  <comment type="block">/* cell variables */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_freevars</name></decl>;</decl_stmt>  <comment type="block">/* free variables */</comment>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u_private</name></decl>;</decl_stmt>	<comment type="block">/* for private name mangling */</comment>

	<decl_stmt><decl><type><name>int</name></type> <name>u_argcount</name></decl>;</decl_stmt>	   <comment type="block">/* number of arguments for block */</comment> 
	<comment type="block">/* Pointer to the most recently allocated block.  By following b_list
	   members, you can reach all early allocated blocks. */</comment>
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>u_blocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>u_curblock</name></decl>;</decl_stmt> <comment type="block">/* pointer to current block */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>u_tmpname</name></decl>;</decl_stmt>		<comment type="block">/* temporary variables for list comps */</comment>

	<decl_stmt><decl><type><name>int</name></type> <name>u_nfblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>fblockinfo</name></type> <name><name>u_fblock</name><index>[<expr><name>CO_MAXBLOCKS</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>u_firstlineno</name></decl>;</decl_stmt> <comment type="block">/* the first lineno of the block */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>u_lineno</name></decl>;</decl_stmt>	   <comment type="block">/* the lineno for the current stmt */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>u_lineno_set</name></decl>;</decl_stmt> <comment type="block">/* boolean to indicate whether instr
			      has been generated with current lineno */</comment>
}</block>;</struct>

<comment type="block">/* This struct captures the global state of a compilation.  

The u pointer points to the current compilation unit, while units
for enclosing blocks are stored in c_stack.	The u and c_stack are
managed by compiler_enter_scope() and compiler_exit_scope().
*/</comment>

<struct>struct <name>compiler</name> <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>c_filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>symtable</name> *</type><name>c_st</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyFutureFeatures</name> *</type><name>c_future</name></decl>;</decl_stmt> <comment type="block">/* pointer to module's __future__ */</comment>
	<decl_stmt><decl><type><name>PyCompilerFlags</name> *</type><name>c_flags</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>c_interactive</name></decl>;</decl_stmt>	 <comment type="block">/* true if in interactive mode */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>c_nestlevel</name></decl>;</decl_stmt>

	<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl>;</decl_stmt> <comment type="block">/* compiler state for current block */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>c_stack</name></decl>;</decl_stmt>	 <comment type="block">/* Python list holding compiler_unit ptrs */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>c_encoding</name></decl>;</decl_stmt>	 <comment type="block">/* source encoding (a borrowed reference) */</comment>
	<decl_stmt><decl><type><name>PyArena</name> *</type><name>c_arena</name></decl>;</decl_stmt>	 <comment type="block">/* pointer to memory allocation arena */</comment>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_enter_scope</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>identifier</name></type></decl></param>, <param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compiler_free</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>basicblock</name> *</type><name>compiler_new_block</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_next_instr</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>basicblock</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_addop</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_addop_o</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_addop_i</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_addop_j</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>basicblock</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>basicblock</name> *</type><name>compiler_use_new_block</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_error</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_nameop</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>identifier</name></type></decl></param>, <param><decl><type><name>expr_context_ty</name></type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PyCodeObject</name> *</type><name>compiler_mod</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>mod_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_visit_stmt</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>stmt_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_visit_keyword</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>keyword_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_visit_expr</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>expr_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_augassign</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>stmt_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_visit_slice</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>slice_ty</name></type></decl></param>,
				<param><decl><type><name>expr_context_ty</name></type></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_push_fblock</name><argument_list>(<argument>struct <expr><name>compiler</name> *</expr></argument>, <argument><enum>enum <name>fblocktype</name><block/></enum>,
				<expr><name>basicblock</name> *</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>compiler_pop_fblock</name><argument_list>(<argument>struct <expr><name>compiler</name> *</expr></argument>, <argument><enum>enum <name>fblocktype</name><block/></enum>,
				<expr><name>basicblock</name> *</expr></argument>)</argument_list></decl>;</decl_stmt>
<comment type="block">/* Returns true if there is a loop on the fblock stack. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_in_loop</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>inplace_binop</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>operator_ty</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>expr_constant</name><parameter_list>(<param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compiler_with</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>stmt_ty</name></type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PyCodeObject</name> *</type><name>assemble</name><parameter_list>(<param><decl><type>struct</type> <name>compiler</name> *</decl></param>, <param><decl><type><name>int</name></type> <name>addNone</name></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>__doc__</name></decl>;</decl_stmt>

<function><type><name>PyObject</name> *</type>
<name>_Py_Mangle</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>privateobj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>ident</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Name mangling: __private becomes _classname__private.
	   This is independent from how the name is used. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>name</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nlen</name></decl>, <decl><type ref="prev"/><name>plen</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>privateobj</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>privateobj</name></expr></argument>)</argument_list></call> ||
	    <name>name</name> == <name>NULL</name> || <name><name>name</name><index>[<expr>0</expr>]</index></name> != '_' || <name><name>name</name><index>[<expr>1</expr>]</index></name> != '_'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ident</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>p</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>privateobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Don't mangle __id__ or names with dots.

	   The only time a name with a dot can occur is when
	   we are compiling an import statement that has a 
	   package name.

	   TODO(jhylton): Decide whether we want to support
	   mangling of the module name, e.g. __M.X.
	*/</comment>
	<if>if <condition>(<expr>(<name><name>name</name><index>[<expr><name>nlen</name>-1</expr>]</index></name> == '_' &amp;&amp; <name><name>name</name><index>[<expr><name>nlen</name>-2</expr>]</index></name> == '_') 
	    || <call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ident</name></expr>;</return> <comment type="block">/* Don't mangle __whatever__ */</comment>
	}</block></then></if>
	<comment type="block">/* Strip leading underscores from class name */</comment>
	<while>while <condition>(<expr>*<name>p</name> == '_'</expr>)</condition>
		<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr>*<name>p</name> == '\0'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ident</name></expr>;</return> <comment type="block">/* Don't mangle if class is just underscores */</comment>
	}</block></then></if>
	<expr_stmt><expr><name>plen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>1 &lt;= <name>PY_SSIZE_T_MAX</name> - <name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>1 + <name>nlen</name> &lt;= <name>PY_SSIZE_T_MAX</name> - <name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ident</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>1 + <name>nlen</name> + <name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>ident</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<comment type="block">/* ident = "_" + p[:plen] + name # i.e. 1+plen+nlen bytes */</comment>
	<expr_stmt><expr><name>buffer</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><index>[<expr>0</expr>]</index></name> = '_'</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name>+1</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer</name>+1+<name>plen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ident</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_init</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>compiler</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>c</name>-&gt;<name>c_stack</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>c</name>-&gt;<name>c_stack</name></name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>PyCodeObject</name> *</type>
<name>PyAST_Compile</name><parameter_list>(<param><decl><type><name>mod_ty</name></type> <name>mod</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>PyCompilerFlags</name> *</type><name>flags</name></decl></param>,
	      <param><decl><type><name>PyArena</name> *</type><name>arena</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>compiler</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>local_flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>merged</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>__doc__</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>__doc__</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__doc__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>__doc__</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>compiler_init</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>c</name>.<name>c_filename</name></name> = <name>filename</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>.<name>c_arena</name></name> = <name>arena</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>.<name>c_future</name></name> = <call><name>PyFuture_FromAST</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>c</name>.<name>c_future</name></name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>finally</name>;</goto></then></if>
	<if>if <condition>(<expr>!<name>flags</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>local_flags</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> = &amp;<name>local_flags</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>merged</name> = <name><name>c</name>.<name>c_future</name>-&gt;<name>ff_features</name></name> | <name><name>flags</name>-&gt;<name>cf_flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>.<name>c_future</name>-&gt;<name>ff_features</name></name> = <name>merged</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>flags</name>-&gt;<name>cf_flags</name></name> = <name>merged</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>.<name>c_flags</name></name> = <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>.<name>c_nestlevel</name></name> = 0</expr>;</expr_stmt>

	<expr_stmt><expr><name><name>c</name>.<name>c_st</name></name> = <call><name>PySymtable_Build</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>c</name>.<name>c_future</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>c</name>.<name>c_st</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"no symtable"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<goto>goto <name>finally</name>;</goto>
	}</block></then></if>

	<comment type="block">/* XXX initialize to NULL for now, need to handle */</comment>
	<expr_stmt><expr><name><name>c</name>.<name>c_encoding</name></name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>co</name> = <call><name>compiler_mod</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <label><name>finally</name>:</label>
	<expr_stmt><expr><call><name>compiler_free</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>co</name> || <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>co</name></expr>;</return>
}</block></function>

<function><type><name>PyCodeObject</name> *</type>
<name>PyNode_Compile</name><parameter_list>(<param><decl><type>struct <name>_node</name> *</type><name>n</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name> <init>= <expr><call><name>PyArena_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>arena</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>mod</name> = <call><name>PyAST_FromNode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mod</name></expr>)</condition><then>
		<expr_stmt><expr><name>co</name> = <call><name>PyAST_Compile</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>co</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_free</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_st</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PySymtable_Free</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_st</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_future</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_future</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>list2dict</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>n</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>v</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>k</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>k</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>k</name> == <name>NULL</name> || <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>dict</name></expr>;</return>
}</block></function>

<comment type="block">/* Return new dict containing names from src that match scope(s).

src is a symbol table dictionary.  If the scope of a name matches
either scope_type or flag is set, insert it into the new dict.	The
values are integers, starting at offset and increasing by one for
each key.
*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dictbytype</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>src</name></decl></param>, <param><decl><type><name>int</name></type> <name>scope_type</name></decl></param>, <param><decl><type><name>int</name></type> <name>flag</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init>, <name>i</name> <init>= <expr><name>offset</name></expr></init>, <name>scope</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>, *<decl><type ref="prev"/><name>dest</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dest</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<comment type="block">/* XXX this should probably be a macro in symtable.h */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scope</name> = (<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &gt;&gt; <name>SCOPE_OFF</name>) &amp; <name>SCOPE_MASK</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>scope</name> == <name>scope_type</name> || <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp; <name>flag</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>, *<decl><type ref="prev"/><name>item</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>k</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>tuple</name> || <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></while>
	<return>return <expr><name>dest</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_unit_check</name><parameter_list>(<param><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>block</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>block</name> = <name><name>u</name>-&gt;<name>u_blocks</name></name></expr>;</init> <condition><expr><name>block</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>block</name> = <name><name>block</name>-&gt;<name>b_list</name></name></expr></incr>) <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>void</name> *)<name>block</name> != (<name>void</name> *)0xcbcbcbcb</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>void</name> *)<name>block</name> != (<name>void</name> *)0xfbfbfbfb</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>void</name> *)<name>block</name> != (<name>void</name> *)0xdbdbdbdb</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>block</name>-&gt;<name>b_instr</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_ialloc</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_iused</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_ialloc</name></name> &gt;= <name><name>block</name>-&gt;<name>b_iused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_iused</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>block</name>-&gt;<name>b_ialloc</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_unit_free</name><parameter_list>(<param><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>compiler_unit_check</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b</name> = <name><name>u</name>-&gt;<name>u_blocks</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>b</name> != <name>NULL</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_instr</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr>(<name>void</name> *)<name><name>b</name>-&gt;<name>b_instr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>next</name> = <name><name>b</name>-&gt;<name>b_list</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr>(<name>void</name> *)<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>b</name> = <name>next</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_ste</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_consts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_names</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_varnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_freevars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_enter_scope</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>name</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>,
		     <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>u</name> = (struct <name>compiler_unit</name> *)<call><name>PyObject_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(
						<argument>struct <expr><name>compiler_unit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>compiler_unit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_argcount</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_ste</name></name> = <call><name>PySymtable_Lookup</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_st</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_ste</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_name</name></name> = <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_varnames</name></name> = <call><name>list2dict</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_varnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_cellvars</name></name> = <call><name>dictbytype</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>, <argument><expr><name>CELL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_varnames</name></name> || !<name><name>u</name>-&gt;<name>u_cellvars</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_freevars</name></name> = <call><name>dictbytype</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>, <argument><expr><name>FREE</name></expr></argument>, <argument><expr><name>DEF_FREE_CLASS</name></expr></argument>,
				   <argument><expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_freevars</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_blocks</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_tmpname</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_firstlineno</name></name> = <name>lineno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_lineno</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_consts</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_consts</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_names</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>u</name>-&gt;<name>u_names</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_private</name></name> = <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Push the old compiler_unit on the stack. */</comment>
	<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>wrapper</name> <init>= <expr><call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>wrapper</name> || <call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>, <argument><expr><name>wrapper</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>u</name>-&gt;<name>u_private</name></name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name></name> = <name>u</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>c</name>-&gt;<name>c_nestlevel</name></name>++</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>compiler_use_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_exit_scope</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>wrapper</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>c</name>-&gt;<name>c_nestlevel</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_unit_free</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Restore c-&gt;u to the parent unit. */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &gt;= 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>wrapper</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name></name> = (struct <name>compiler_unit</name> *)<call><name>PyCObject_AsVoidPtr</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we are deleting from a list so this really shouldn't fail */</comment>
		<if>if <condition>(<expr><call><name>PySequence_DelItem</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_stack</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"compiler_exit_scope()"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>compiler_unit_check</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

}</block></function>

<comment type="block">/* Allocate a new "anonymous" local variable.
   Used by list comprehensions and with statements.
*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>compiler_new_tmpname</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>tmpname</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"_[%d]"</expr></argument>, <argument><expr>++<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_tmpname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Allocate a new block and return a pointer to it.
   Returns NULL on error.
*/</comment>

<function><type><specifier>static</specifier> <name>basicblock</name> *</type>
<name>compiler_new_block</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>u</name> = <name><name>c</name>-&gt;<name>u</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>b</name> = (<name>basicblock</name> *)<call><name>PyObject_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>basicblock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *)<name>b</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>basicblock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Extend the singly linked list of blocks with new block. */</comment>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>b_list</name></name> = <name><name>u</name>-&gt;<name>u_blocks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_blocks</name></name> = <name>b</name></expr>;</expr_stmt>
	<return>return <expr><name>b</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>basicblock</name> *</type>
<name>compiler_use_new_block</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>block</name> <init>= <expr><call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>block</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name> = <name>block</name></expr>;</expr_stmt>
	<return>return <expr><name>block</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>basicblock</name> *</type>
<name>compiler_next_block</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>block</name> <init>= <expr><call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>block</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_next</name></name> = <name>block</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name> = <name>block</name></expr>;</expr_stmt>
	<return>return <expr><name>block</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>basicblock</name> *</type>
<name>compiler_use_next_block</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>block</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>block</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_next</name></name> = <name>block</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name> = <name>block</name></expr>;</expr_stmt>
	<return>return <expr><name>block</name></expr>;</return>
}</block></function>

<comment type="block">/* Returns the offset of the next instruction in the current block's
   b_instr array.  Resizes the b_instr as necessary.
   Returns -1 on failure.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_next_instr</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_instr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>b</name>-&gt;<name>b_instr</name></name> = (struct <name>instr</name> *)<call><name>PyObject_Malloc</name><argument_list>(
				 <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>instr</name></expr></argument>)</argument_list></sizeof> * <name>DEFAULT_BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_instr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name><name>b</name>-&gt;<name>b_ialloc</name></name> = <name>DEFAULT_BLOCK_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>b</name>-&gt;<name>b_instr</name></name></expr></argument>, <argument><expr>0</expr></argument>,
		       <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>instr</name></expr></argument>)</argument_list></sizeof> * <name>DEFAULT_BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_iused</name></name> == <name><name>b</name>-&gt;<name>b_ialloc</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type>struct <name>instr</name> *</type><name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>oldsize</name></decl>, <decl><type ref="prev"/><name>newsize</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>oldsize</name> = <name><name>b</name>-&gt;<name>b_ialloc</name></name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>instr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>newsize</name> = <name>oldsize</name> &lt;&lt; 1</expr>;</expr_stmt>

		<if>if <condition>(<expr><name>oldsize</name> &gt; (<name>PY_SIZE_MAX</name> &gt;&gt; 1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>

		<if>if <condition>(<expr><name>newsize</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name><name>b</name>-&gt;<name>b_ialloc</name></name> &lt;&lt;= 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> = (struct <name>instr</name> *)<call><name>PyObject_Realloc</name><argument_list>(
						<argument><expr>(<name>void</name> *)<name><name>b</name>-&gt;<name>b_instr</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name><name>b</name>-&gt;<name>b_instr</name></name> = <name>tmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>b</name>-&gt;<name>b_instr</name></name> + <name>oldsize</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>newsize</name> - <name>oldsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<return>return <expr><name><name>b</name>-&gt;<name>b_iused</name></name>++</expr>;</return>
}</block></function>

<comment type="block">/* Set the i_lineno member of the instruction at offset off if the
   line number for the current expression/statement has not
   already been set.  If it has been set, the call has no effect.

   The line number is reset in the following cases:
   - when entering a new scope
   - on each statement
   - on each expression that start a new line
   - before the "except" clause
   - before the "for" and "while" expressions
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_set_lineno</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>off</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>off</name></expr>]</index></name>.<name>i_lineno</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>opcode_stack_effect</name><parameter_list>(<param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>int</name></type> <name>oparg</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{
		<case>case <expr><name>POP_TOP</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>ROT_TWO</name></expr>:
		</case><case>case <expr><name>ROT_THREE</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>DUP_TOP</name></expr>:
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>ROT_FOUR</name></expr>:
			<return>return <expr>0</expr>;</return>

		</case><case>case <expr><name>UNARY_POSITIVE</name></expr>:
		</case><case>case <expr><name>UNARY_NEGATIVE</name></expr>:
		</case><case>case <expr><name>UNARY_NOT</name></expr>:
		</case><case>case <expr><name>UNARY_CONVERT</name></expr>:
		</case><case>case <expr><name>UNARY_INVERT</name></expr>:
			<return>return <expr>0</expr>;</return>

		</case><case>case <expr><name>LIST_APPEND</name></expr>:
			<return>return <expr>-2</expr>;</return>

		</case><case>case <expr><name>BINARY_POWER</name></expr>:
		</case><case>case <expr><name>BINARY_MULTIPLY</name></expr>:
		</case><case>case <expr><name>BINARY_DIVIDE</name></expr>:
		</case><case>case <expr><name>BINARY_MODULO</name></expr>:
		</case><case>case <expr><name>BINARY_ADD</name></expr>:
		</case><case>case <expr><name>BINARY_SUBTRACT</name></expr>:
		</case><case>case <expr><name>BINARY_SUBSCR</name></expr>:
		</case><case>case <expr><name>BINARY_FLOOR_DIVIDE</name></expr>:
		</case><case>case <expr><name>BINARY_TRUE_DIVIDE</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>INPLACE_FLOOR_DIVIDE</name></expr>:
		</case><case>case <expr><name>INPLACE_TRUE_DIVIDE</name></expr>:
			<return>return <expr>-1</expr>;</return>

		</case><case>case <expr><name>SLICE</name>+0</expr>:
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>SLICE</name>+1</expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>SLICE</name>+2</expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>SLICE</name>+3</expr>:
			<return>return <expr>-1</expr>;</return>

		</case><case>case <expr><name>STORE_SLICE</name>+0</expr>:
			<return>return <expr>-2</expr>;</return>
		</case><case>case <expr><name>STORE_SLICE</name>+1</expr>:
			<return>return <expr>-3</expr>;</return>
		</case><case>case <expr><name>STORE_SLICE</name>+2</expr>:
			<return>return <expr>-3</expr>;</return>
		</case><case>case <expr><name>STORE_SLICE</name>+3</expr>:
			<return>return <expr>-4</expr>;</return>

		</case><case>case <expr><name>DELETE_SLICE</name>+0</expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>DELETE_SLICE</name>+1</expr>:
			<return>return <expr>-2</expr>;</return>
		</case><case>case <expr><name>DELETE_SLICE</name>+2</expr>:
			<return>return <expr>-2</expr>;</return>
		</case><case>case <expr><name>DELETE_SLICE</name>+3</expr>:
			<return>return <expr>-3</expr>;</return>

		</case><case>case <expr><name>INPLACE_ADD</name></expr>:
		</case><case>case <expr><name>INPLACE_SUBTRACT</name></expr>:
		</case><case>case <expr><name>INPLACE_MULTIPLY</name></expr>:
		</case><case>case <expr><name>INPLACE_DIVIDE</name></expr>:
		</case><case>case <expr><name>INPLACE_MODULO</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>STORE_SUBSCR</name></expr>:
			<return>return <expr>-3</expr>;</return>
		</case><case>case <expr><name>STORE_MAP</name></expr>:
			<return>return <expr>-2</expr>;</return>
		</case><case>case <expr><name>DELETE_SUBSCR</name></expr>:
			<return>return <expr>-2</expr>;</return>

		</case><case>case <expr><name>BINARY_LSHIFT</name></expr>:
		</case><case>case <expr><name>BINARY_RSHIFT</name></expr>:
		</case><case>case <expr><name>BINARY_AND</name></expr>:
		</case><case>case <expr><name>BINARY_XOR</name></expr>:
		</case><case>case <expr><name>BINARY_OR</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>INPLACE_POWER</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>GET_ITER</name></expr>:
			<return>return <expr>0</expr>;</return>

		</case><case>case <expr><name>PRINT_EXPR</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>PRINT_ITEM</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>PRINT_NEWLINE</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>PRINT_ITEM_TO</name></expr>:
			<return>return <expr>-2</expr>;</return>
		</case><case>case <expr><name>PRINT_NEWLINE_TO</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>INPLACE_LSHIFT</name></expr>:
		</case><case>case <expr><name>INPLACE_RSHIFT</name></expr>:
		</case><case>case <expr><name>INPLACE_AND</name></expr>:
		</case><case>case <expr><name>INPLACE_XOR</name></expr>:
		</case><case>case <expr><name>INPLACE_OR</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>BREAK_LOOP</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>WITH_CLEANUP</name></expr>:
			<return>return <expr>-1</expr>;</return> <comment type="block">/* XXX Sometimes more */</comment>
		</case><case>case <expr><name>LOAD_LOCALS</name></expr>:
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>RETURN_VALUE</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>IMPORT_STAR</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>EXEC_STMT</name></expr>:
			<return>return <expr>-3</expr>;</return>
		</case><case>case <expr><name>YIELD_VALUE</name></expr>:
			<return>return <expr>0</expr>;</return>

		</case><case>case <expr><name>POP_BLOCK</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>END_FINALLY</name></expr>:
			<return>return <expr>-1</expr>;</return> <comment type="block">/* or -2 or -3 if exception occurred */</comment>
		</case><case>case <expr><name>BUILD_CLASS</name></expr>:
			<return>return <expr>-2</expr>;</return>

		</case><case>case <expr><name>STORE_NAME</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>DELETE_NAME</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>UNPACK_SEQUENCE</name></expr>:
			<return>return <expr><name>oparg</name>-1</expr>;</return>
		</case><case>case <expr><name>FOR_ITER</name></expr>:
			<return>return <expr>1</expr>;</return>

		</case><case>case <expr><name>STORE_ATTR</name></expr>:
			<return>return <expr>-2</expr>;</return>
		</case><case>case <expr><name>DELETE_ATTR</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>STORE_GLOBAL</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>DELETE_GLOBAL</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>DUP_TOPX</name></expr>:
			<return>return <expr><name>oparg</name></expr>;</return>
		</case><case>case <expr><name>LOAD_CONST</name></expr>:
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>LOAD_NAME</name></expr>:
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>BUILD_TUPLE</name></expr>:
		</case><case>case <expr><name>BUILD_LIST</name></expr>:
			<return>return <expr>1-<name>oparg</name></expr>;</return>
		</case><case>case <expr><name>BUILD_MAP</name></expr>:
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>LOAD_ATTR</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>COMPARE_OP</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>IMPORT_NAME</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>IMPORT_FROM</name></expr>:
			<return>return <expr>1</expr>;</return>

		</case><case>case <expr><name>JUMP_FORWARD</name></expr>:
		</case><case>case <expr><name>JUMP_IF_FALSE</name></expr>:
		</case><case>case <expr><name>JUMP_IF_TRUE</name></expr>:
		</case><case>case <expr><name>JUMP_ABSOLUTE</name></expr>:
			<return>return <expr>0</expr>;</return>

		</case><case>case <expr><name>LOAD_GLOBAL</name></expr>:
			<return>return <expr>1</expr>;</return>

		</case><case>case <expr><name>CONTINUE_LOOP</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>SETUP_LOOP</name></expr>:
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>SETUP_EXCEPT</name></expr>:
		</case><case>case <expr><name>SETUP_FINALLY</name></expr>:
			<return>return <expr>3</expr>;</return> <comment type="block">/* actually pushed by an exception */</comment>

		</case><case>case <expr><name>LOAD_FAST</name></expr>:
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>STORE_FAST</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><case>case <expr><name>DELETE_FAST</name></expr>:
			<return>return <expr>0</expr>;</return>

		</case><case>case <expr><name>RAISE_VARARGS</name></expr>:
			<return>return <expr>-<name>oparg</name></expr>;</return>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NARGS</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((o) % 256) + 2*((o) / 256))</cpp:value></cpp:define>
		</case><case>case <expr><name>CALL_FUNCTION</name></expr>:
			<return>return <expr>-<call><name>NARGS</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call></expr>;</return>
		</case><case>case <expr><name>CALL_FUNCTION_VAR</name></expr>:
		</case><case>case <expr><name>CALL_FUNCTION_KW</name></expr>:
			<return>return <expr>-<call><name>NARGS</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call>-1</expr>;</return>
		</case><case>case <expr><name>CALL_FUNCTION_VAR_KW</name></expr>:
			<return>return <expr>-<call><name>NARGS</name><argument_list>(<argument><expr><name>oparg</name></expr></argument>)</argument_list></call>-2</expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NARGS</name></cpp:undef>
		</case><case>case <expr><name>MAKE_FUNCTION</name></expr>:
			<return>return <expr>-<name>oparg</name></expr>;</return>
		</case><case>case <expr><name>BUILD_SLICE</name></expr>:
			<if>if <condition>(<expr><name>oparg</name> == 3</expr>)</condition><then>
				<return>return <expr>-2</expr>;</return></then>
			<else>else
				<return>return <expr>-1</expr>;</return></else></if>

		</case><case>case <expr><name>MAKE_CLOSURE</name></expr>:
			<return>return <expr>-<name>oparg</name></expr>;</return>
		</case><case>case <expr><name>LOAD_CLOSURE</name></expr>:
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>LOAD_DEREF</name></expr>:
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>STORE_DEREF</name></expr>:
			<return>return <expr>-1</expr>;</return>
		</case><default>default:
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"opcode = %d\n"</expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"opcode_stack_effect()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</default>}</block></switch>
	<return>return <expr>0</expr>;</return> <comment type="block">/* not reachable */</comment>
}</block></function>

<comment type="block">/* Add an opcode with no argument.
   Returns 0 on failure, 1 on success.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>instr</name> *</type><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>off</name> = <call><name>compiler_next_instr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = &amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>i</name>-&gt;<name>i_opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>i</name>-&gt;<name>i_hasarg</name></name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>opcode</name> == <name>RETURN_VALUE</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>b</name>-&gt;<name>b_return</name></name> = 1</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>compiler_set_lineno</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_add_o</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>t</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>real_part_zero</name></decl>, <decl><type ref="prev"/><name>imag_part_zero</name></decl>;</decl_stmt>

	<comment type="block">/* necessary to make sure types aren't coerced (e.g., int and long) */</comment>
        <comment type="block">/* _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms */</comment>
        <if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>d</name> = <call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name>*) &amp;<name>d</name></expr>;</expr_stmt>
		<comment type="block">/* all we need is to make the tuple different in either the 0.0
		 * or -0.0 case from all others, just to avoid the "coercion".
		 */</comment>
		<if>if <condition>(<expr>*<name>p</name>==0 &amp;&amp; <name><name>p</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof>-1</expr>]</index></name>==0</expr>)</condition><then>
			<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyComplex_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* complex case is even messier: we need to make complex(x,
		   0.) different from complex(x, -0.) and complex(0., y)
		   different from complex(-0., y), for any x and y.  In
		   particular, all four complex zeros should be
		   distinguished.*/</comment>
		<expr_stmt><expr><name>z</name> = <call><name>PyComplex_AsCComplex</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name>*) &amp;(<name><name>z</name>.<name>real</name></name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>q</name> = (<name>unsigned</name> <name>char</name>*) &amp;(<name><name>z</name>.<name>imag</name></name>)</expr>;</expr_stmt>
		<comment type="block">/* all that matters here is that on IEEE platforms
		   real_part_zero will be true if z.real == 0., and false if
		   z.real == -0.  In fact, real_part_zero will also be true
		   for some other rarely occurring nonzero floats, but this
		   doesn't matter. Similar comments apply to
		   imag_part_zero. */</comment>
		<expr_stmt><expr><name>real_part_zero</name> = *<name>p</name>==0 &amp;&amp; <name><name>p</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof>-1</expr>]</index></name>==0</expr>;</expr_stmt>
		<expr_stmt><expr><name>imag_part_zero</name> = *<name>q</name>==0 &amp;&amp; <name><name>q</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof>-1</expr>]</index></name>==0</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>real_part_zero</name> &amp;&amp; <name>imag_part_zero</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>4</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_True</name></expr></argument>, <argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>real_part_zero</name> &amp;&amp; !<name>imag_part_zero</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>4</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_True</name></expr></argument>, <argument><expr><name>Py_False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr>!<name>real_part_zero</name> &amp;&amp; <name>imag_part_zero</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>4</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_False</name></expr></argument>, <argument><expr><name>Py_True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if></else></if></else></if>
        }</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>t</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>o</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
	<if>if <condition>(<expr><name>t</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>arg</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>arg</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>arg</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop_o</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>,
		     <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>arg</name> <init>= <expr><call><name>compiler_add_o</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>arg</name> &lt; 0</expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>
    <return>return <expr><call><name>compiler_addop_i</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop_name</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>,
		    <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>mangled</name> <init>= <expr><call><name>_Py_Mangle</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>mangled</name></expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><name>arg</name> = <call><name>compiler_add_o</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>arg</name> &lt; 0</expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>
    <return>return <expr><call><name>compiler_addop_i</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Add an opcode with an integer argument.
   Returns 0 on failure, 1 on success.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop_i</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>int</name></type> <name>oparg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>instr</name> *</type><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>off</name> = <call><name>compiler_next_instr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>i</name> = &amp;<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_instr</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>i</name>-&gt;<name>i_opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>i</name>-&gt;<name>i_oparg</name></name> = <name>oparg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>i</name>-&gt;<name>i_hasarg</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_set_lineno</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_addop_j</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name></type> <name>absolute</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>instr</name> *</type><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> = <call><name>compiler_next_instr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>i</name> = &amp;<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_instr</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>i</name>-&gt;<name>i_opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>i</name>-&gt;<name>i_target</name></name> = <name>b</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>i</name>-&gt;<name>i_hasarg</name></name> = 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>absolute</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>i</name>-&gt;<name>i_jabs</name></name> = 1</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name><name>i</name>-&gt;<name>i_jrel</name></name> = 1</expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>compiler_set_lineno</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* The distinction between NEW_BLOCK and NEXT_BLOCK is subtle.	(I'd
   like to find better names.)	NEW_BLOCK() creates a new block and sets
   it as the current block.  NEXT_BLOCK() also creates an implicit jump
   from the current block to the new block.
*/</comment>

<comment type="block">/* The returns inside these macros make it impossible to decref objects
   created in the local function.  Local objects should use the arena.
*/</comment>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_BLOCK</name><parameter_list>(<param><type><name>C</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	if (compiler_use_new_block((C)) == NULL) \
		return 0; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_BLOCK</name><parameter_list>(<param><type><name>C</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	if (compiler_next_block((C)) == NULL) \
		return 0; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	if (!compiler_addop((C), (OP))) \
		return 0; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_IN_SCOPE</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	if (!compiler_addop((C), (OP))) { \
		compiler_exit_scope(c); \
		return 0; \
	} \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_O</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>, <param><type><name>TYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	if (!compiler_addop_o((C), (OP), (C)-&gt;u-&gt;u_ ## TYPE, (O))) \
		return 0; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_NAME</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>, <param><type><name>TYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	if (!compiler_addop_name((C), (OP), (C)-&gt;u-&gt;u_ ## TYPE, (O))) \
		return 0; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_I</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	if (!compiler_addop_i((C), (OP), (O))) \
		return 0; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_JABS</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	if (!compiler_addop_j((C), (OP), (O), 1)) \
		return 0; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDOP_JREL</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>OP</name></type></param>, <param><type><name>O</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	if (!compiler_addop_j((C), (OP), (O), 0)) \
		return 0; \
}</cpp:value></cpp:define>

<comment type="block">/* VISIT and VISIT_SEQ takes an ASDL type as their second argument.  They use
   the ASDL name to synthesize the name of the C type and the visit function.
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>V</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{\
	if (!compiler_visit_ ## TYPE((C), (V))) \
		return 0; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_IN_SCOPE</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>V</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{\
	if (!compiler_visit_ ## TYPE((C), (V))) { \
		compiler_exit_scope(c); \
		return 0; \
	} \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SLICE</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>V</name></type></param>, <param><type><name>CTX</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{\
	if (!compiler_visit_slice((C), (V), (CTX))) \
		return 0; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SEQ</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>SEQ</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	int _i; \
	asdl_seq *seq = (SEQ); <comment type="block">/* avoid variable capture */</comment> \
	for (_i = 0; _i &lt; asdl_seq_LEN(seq); _i++) { \
		TYPE ## _ty elt = (TYPE ## _ty)asdl_seq_GET(seq, _i); \
		if (!compiler_visit_ ## TYPE((C), elt)) \
			return 0; \
	} \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISIT_SEQ_IN_SCOPE</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>TYPE</name></type></param>, <param><type><name>SEQ</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
	int _i; \
	asdl_seq *seq = (SEQ); <comment type="block">/* avoid variable capture */</comment> \
	for (_i = 0; _i &lt; asdl_seq_LEN(seq); _i++) { \
		TYPE ## _ty elt = (TYPE ## _ty)asdl_seq_GET(seq, _i); \
		if (!compiler_visit_ ## TYPE((C), elt)) { \
			compiler_exit_scope(c); \
			return 0; \
		} \
	} \
}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_isdocstring</name><parameter_list>(<param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name> != <name>Expr_kind</name></expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>
    <return>return <expr><name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name>-&gt;<name>kind</name></name> == <name>Str_kind</name></expr>;</return>
}</block></function>

<comment type="block">/* Compile a sequence of statements, checking for a docstring. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_body</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>asdl_seq</name> *</type><name>stmts</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>stmt_ty</name></type> <name>st</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<expr_stmt><expr><name>st</name> = (<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>compiler_isdocstring</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Py_OptimizeFlag</name> &lt; 2</expr>)</condition><then> <block>{
		<comment type="block">/* don't generate docstrings if -OO */</comment>
		<expr_stmt><expr><name>i</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>__doc__</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>
	<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	    <expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr>(<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>compiler_mod</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>mod_ty</name></type> <name>mod</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>addNone</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>module</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>module</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>module</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"&lt;module&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>module</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<comment type="block">/* Use 0 for firstlineno initially, will fixup in assemble(). */</comment>
	<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>module</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<switch>switch <condition>(<expr><name><name>mod</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
	<case>case <expr><name>Module_kind</name></expr>: 
		<if>if <condition>(<expr>!<call><name>compiler_body</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>mod</name>-&gt;<name>v</name>.<name>Module</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<break>break;</break>
	</case><case>case <expr><name>Interactive_kind</name></expr>:
		<expr_stmt><expr><name><name>c</name>-&gt;<name>c_interactive</name></name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, 
					<argument><expr><name><name>mod</name>-&gt;<name>v</name>.<name>Interactive</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Expression_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>mod</name>-&gt;<name>v</name>.<name>Expression</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>addNone</name> = 0</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Suite_kind</name></expr>:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"suite should not be possible"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			     <argument><expr>"module kind %d should not be possible"</expr></argument>,
			     <argument><expr><name><name>mod</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	</default>}</block></switch>
	<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>addNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>co</name></expr>;</return>
}</block></function>

<comment type="block">/* The test for LOCAL must come before the test for FREE in order to
   handle classes where name is both local and free.  The local var is
   a method and the free var is a free var referenced within a method.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_ref_type</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>scope</name> <init>= <expr><call><name>PyST_GetScope</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>scope</name> == 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>350</expr>]</index></name></decl>;</decl_stmt>
	    <expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr>"unknown scope for %.100s in %.100s(%s) in %s\n"
			  "symbols: %s\nlocals: %s\nglobals: %s\n"</expr></argument>,
			  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, 
			  <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_name</name></name></expr></argument>)</argument_list></call></expr></argument>, 
			  <argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>,
			  <argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_symbols</name></name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_varnames</name></name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_names</name></name></expr></argument>)</argument_list></call></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>scope</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_lookup_arg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>k</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>name</name>-&gt;<name>ob_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>k</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr>-1</expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr>-1</expr>;</return></then></if>
    <return>return <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_make_closure</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>int</name></type> <name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>free</name> <init>= <expr><call><name>PyCode_GetNumFree</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>free</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)<name>co</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>MAKE_FUNCTION</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>1</expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>free</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<comment type="block">/* Bypass com_addop_varname because it will generate
		   LOAD_DEREF but LOAD_CLOSURE is needed. 
		*/</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_freevars</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>arg</name></decl>, <decl><type ref="prev"/><name>reftype</name></decl>;</decl_stmt>

		<comment type="block">/* Special case: If a class contains a method with a
		   free variable that has the same name as a method,
		   the name will be considered free *and* local in the
		   class.  It should be handled by the closure, as
		   well as by the normal name loookup logic.
		*/</comment>
		<expr_stmt><expr><name>reftype</name> = <call><name>get_ref_type</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>reftype</name> == <name>CELL</name></expr>)</condition><then>
			<expr_stmt><expr><name>arg</name> = <call><name>compiler_lookup_arg</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <comment type="block">/* (reftype == FREE) */</comment>
			<expr_stmt><expr><name>arg</name> = <call><name>compiler_lookup_arg</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_freevars</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>arg</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"lookup %s in %s %d %d\n"
				"freevars of %s: %s\n"</expr></argument>,
				<argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, 
				<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_name</name></name></expr></argument>)</argument_list></call></expr></argument>, 
				<argument><expr><name>reftype</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>,
				<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>PyObject_REPR</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>co_freevars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"compiler_make_closure()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CLOSURE</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_TUPLE</name></expr></argument>, <argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)<name>co</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>MAKE_CLOSURE</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_decorators</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>asdl_seq</name>*</type> <name>decos</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>decos</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>decos</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_arguments</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>arguments_ty</name></type> <name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Correctly handle nested argument lists */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>expr_ty</name></type> <name>arg</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>arg</name>-&gt;<name>kind</name></name> == <name>Tuple_kind</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>id</name> <init>= <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>".%d"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>id</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_function</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>first_const</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arguments_ty</name></type> <name>args</name> <init>= <expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>args</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>asdl_seq</name>*</type> <name>decos</name> <init>= <expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>decorator_list</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>stmt_ty</name></type> <name>st</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>docstring</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>FunctionDef_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>compiler_decorators</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>args</name>-&gt;<name>defaults</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>name</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>s</name></expr></argument>,
				  <argument><expr><name><name>s</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name>st</name> = (<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>body</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>docstring</name> = <call><name>compiler_isdocstring</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>docstring</name> &amp;&amp; <name>Py_OptimizeFlag</name> &lt; 2</expr>)</condition><then>
	    <expr_stmt><expr><name>first_const</name> = <name><name>st</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name>-&gt;<name>v</name>.<name>Str</name>.<name>s</name></name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>compiler_add_o</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_consts</name></name></expr></argument>, <argument><expr><name>first_const</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>	 <block>{
	    <expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* unpack nested arguments */</comment>
	<expr_stmt><expr><call><name>compiler_arguments</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_argcount</name></name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* if there was a docstring, we need to skip the first statement */</comment>
	<for>for (<init><expr><name>i</name> = <name>docstring</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>st</name> = (<name>stmt_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>body</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><call><name>compiler_make_closure</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<return>return <expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>FunctionDef</name>.<name>name</name></name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_class</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>asdl_seq</name>*</type> <name>decos</name> <init>= <expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>decorator_list</name></name></expr></init></decl>;</decl_stmt>
	
	<if>if <condition>(<expr>!<call><name>compiler_decorators</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<comment type="block">/* push class name on stack, needed by BUILD_CLASS */</comment>
	<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* push the tuple of base classes on the stack */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>bases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_TUPLE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>s</name></expr></argument>,
				  <argument><expr><name><name>s</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name> = <name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>str</name> || !<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__module__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>str</name> || !<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>compiler_body</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>ADDOP_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_LOCALS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><call><name>compiler_make_closure</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* apply decorators */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>decos</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ClassDef</name>.<name>name</name></name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_ifexp</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>kind</name></name> == <name>IfExp_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>next</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>IfExp</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>IfExp</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>IfExp</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_lambda</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>identifier</name></type> <name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>arguments_ty</name></type> <name>args</name> <init>= <expr><name><name>e</name>-&gt;<name>v</name>.<name>Lambda</name>.<name>args</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>kind</name></name> == <name>Lambda_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>name</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"&lt;lambda&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>args</name>-&gt;<name>defaults</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>e</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<comment type="block">/* unpack nested arguments */</comment>
	<expr_stmt><expr><call><name>compiler_arguments</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_argcount</name></name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Lambda</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_IN_SCOPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><call><name>compiler_make_closure</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>defaults</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_print</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>dest</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>Print_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest</name> = <name>false</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>dest</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dest</name> = <name>true</name></expr>;</expr_stmt>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>values</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>dest</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>PRINT_ITEM_TO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>PRINT_ITEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></for>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Print</name>.<name>nl</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>dest</name></expr>)</condition><then>
			<macro><name>ADDOP</name><argument_list>(<argument>c</argument>, <argument>PRINT_NEWLINE_TO</argument>)</argument_list></macro></then>
		<else>else
			<macro><name>ADDOP</name><argument_list>(<argument>c</argument>, <argument>PRINT_NEWLINE</argument>)</argument_list></macro></else></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>dest</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_if</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>constant</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>If_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>next</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr>0</expr>;</return></then></if>
	
	<expr_stmt><expr><name>constant</name> = <call><name>expr_constant</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* constant = 0: "if 0"
	 * constant = 1: "if 1", "if 2", ...
	 * constant = -1: rest */</comment>
	<if>if <condition>(<expr><name>constant</name> == 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><name>constant</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>If</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></else></if></else></if>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_for</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>cleanup</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>start</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cleanup</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>start</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name> || <name>cleanup</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_LOOP</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>GET_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* for expressions must be traced on each iteration,
	   so we need to set an extra line number. */</comment>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FOR_ITER</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>For</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_while</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>loop</name></decl>, *<decl><type ref="prev"/><name>orelse</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>, *<decl><type ref="prev"/><name>anchor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>constant</name> <init>= <expr><call><name>expr_constant</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>constant</name> == 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>loop</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>constant</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>anchor</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>anchor</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>loop</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>orelse</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>orelse</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>orelse</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_LOOP</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name>constant</name> == -1</expr>)</condition><then> <block>{
		<comment type="block">/* while expressions must be traced on each iteration,
		   so we need to set an extra line number. */</comment>
		<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX should the two POP instructions be in a separate block
	   if there is no else clause ?
	*/</comment>

	<if>if <condition>(<expr><name>constant</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>orelse</name> != <name>NULL</name></expr>)</condition><then> <comment type="block">/* what if orelse is just pass? */</comment>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>While</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_continue</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>LOOP_ERROR_MSG</name><index>[]</index></name> <init>= <expr>"'continue' not properly in loop"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>IN_FINALLY_ERROR_MSG</name><index>[]</index></name> <init>= 
			<expr>"'continue' not supported inside 'finally' clause"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_nfblocks</name></name></expr>)</condition><then>
		<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP_ERROR_MSG</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>i</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_nfblocks</name></name> - 1</expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_type</name></expr>)</condition> <block>{
	<case>case <expr><name>LOOP</name></expr>:
		<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>EXCEPT</name></expr>:
	</case><case>case <expr><name>FINALLY_TRY</name></expr>:
		<while>while <condition>(<expr>--<name>i</name> &gt;= 0 &amp;&amp; <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_type</name> != <name>LOOP</name></expr>)</condition> <block>{
			<comment type="block">/* Prevent continue anywhere under a finally
			      even if hidden in a sub-try or except. */</comment>
			<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_type</name> == <name>FINALLY_END</name></expr>)</condition><then>
				<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IN_FINALLY_ERROR_MSG</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		}</block></while>
		<if>if <condition>(<expr><name>i</name> == -1</expr>)</condition><then>
			<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP_ERROR_MSG</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CONTINUE_LOOP</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>FINALLY_END</name></expr>:
		<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IN_FINALLY_ERROR_MSG</name></expr></argument>)</argument_list></call></expr>;</return>
	</case>}</block></switch>

	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Code generated for "try: &lt;body&gt; finally: &lt;finalbody&gt;" is as follows:
   
		SETUP_FINALLY	L
		&lt;code for body&gt;
		POP_BLOCK
		LOAD_CONST	&lt;None&gt;
	L:	&lt;code for finalbody&gt;
		END_FINALLY
   
   The special instructions use the block stack.  Each block
   stack entry contains the instruction that created it (here
   SETUP_FINALLY), the level of the value stack at the time the
   block stack entry was created, and a label (here L).
   
   SETUP_FINALLY:
	Pushes the current value stack level and the label
	onto the block stack.
   POP_BLOCK:
	Pops en entry from the block stack, and pops the value
	stack until its level is the same as indicated on the
	block stack.  (The label is ignored.)
   END_FINALLY:
	Pops a variable number of entries from the *value* stack
	and re-raises the exception they specify.  The number of
	entries popped depends on the (pseudo) exception type.
   
   The block stack is unwound when an exception is raised:
   when a SETUP_FINALLY entry is found, the exception is pushed
   onto the value stack (and the exception condition is cleared),
   and the interpreter jumps to the label gotten from the block
   stack.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_try_finally</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>body</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>body</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>body</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_FINALLY</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_TRY</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryFinally</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_TRY</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_END</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryFinally</name>.<name>finalbody</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>END_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_END</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
   Code generated for "try: S except E1, V1: S1 except E2, V2: S2 ...":
   (The contents of the value stack is shown in [], with the top
   at the right; 'tb' is trace-back info, 'val' the exception's
   associated value, and 'exc' the exception.)
   
   Value stack		Label	Instruction	Argument
   []				SETUP_EXCEPT	L1
   []				&lt;code for S&gt;
   []				POP_BLOCK
   []				JUMP_FORWARD	L0
   
   [tb, val, exc]	L1:	DUP				)
   [tb, val, exc, exc]		&lt;evaluate E1&gt;			)
   [tb, val, exc, exc, E1]	COMPARE_OP	EXC_MATCH	) only if E1
   [tb, val, exc, 1-or-0]	JUMP_IF_FALSE	L2		)
   [tb, val, exc, 1]		POP				)
   [tb, val, exc]		POP
   [tb, val]			&lt;assign to V1&gt;	(or POP if no V1)
   [tb]				POP
   []				&lt;code for S1&gt;
				JUMP_FORWARD	L0
   
   [tb, val, exc, 0]	L2:	POP
   [tb, val, exc]		DUP
   .............................etc.......................

   [tb, val, exc, 0]	Ln+1:	POP
   [tb, val, exc]		END_FINALLY	# re-raise exception
   
   []			L0:	&lt;next statement&gt;
   
   Of course, parts are not generated if Vi or Ei is not present.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_try_except</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>body</name></decl>, *<decl><type ref="prev"/><name>orelse</name></decl>, *<decl><type ref="prev"/><name>except</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>body</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>except</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>orelse</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>body</name> == <name>NULL</name> || <name>except</name> == <name>NULL</name> || <name>orelse</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_EXCEPT</name></expr></argument>, <argument><expr><name>except</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>EXCEPT</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>EXCEPT</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>orelse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>handlers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>except</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>excepthandler_ty</name></type> <name>handler</name> <init>= <expr>(<name>excepthandler_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(
						<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>handlers</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name> &amp;&amp; <name>i</name> &lt; <name>n</name>-1</expr>)</condition><then>
		    <return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"default 'except:' must be last"</expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name> = <name><name>handler</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>except</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>except</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>COMPARE_OP</name></expr></argument>, <argument><expr><name>PyCmp_EXC_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>except</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>name</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>except</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>handler</name>-&gt;<name>v</name>.<name>ExceptHandler</name>.<name>type</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>END_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>orelse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>TryExcept</name>.<name>orelse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_import_as</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>name</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>asname</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* The IMPORT_NAME opcode was already generated.  This function
	   merely needs to bind the result to a name.

	   If there is a dot in name, we need to split it and emit a 
	   LOAD_ATTR for each name.
	*/</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>dot</name></expr>)</condition><then> <block>{
		<comment type="block">/* Consume the base module name to get the first attribute */</comment>
		<expr_stmt><expr><name>src</name> = <name>dot</name> + 1</expr>;</expr_stmt>
		<while>while <condition>(<expr><name>dot</name></expr>)</condition> <block>{
			<comment type="block">/* NB src is only defined when dot != NULL */</comment>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>attr</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>dot</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>, 
					    <argument><expr><name>dot</name> ? <name>dot</name> - <name>src</name> : <call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>attr</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_ATTR</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>src</name> = <name>dot</name> + 1</expr>;</expr_stmt>
		}</block></while>
	}</block></then></if>
	<return>return <expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>asname</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_import</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* The Import node stores a module name like a.b.c as a single
	   string.  This is convenient for all cases except
	     import a.b.c as d
	   where we need to parse that string to extract the individual
	   module names.  
	   XXX Perhaps change the representation to make this case simpler?
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Import</name>.<name>names</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>alias_ty</name></type> <name>alias</name> <init>= <expr>(<name>alias_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Import</name>.<name>names</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>level</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_flags</name></name> &amp;&amp; (<name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>CO_FUTURE_ABSOLUTE_IMPORT</name>)</expr>)</condition><then>
			<expr_stmt><expr><name>level</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>level</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>level</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>

		<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IMPORT_NAME</name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name><name>alias</name>-&gt;<name>asname</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>r</name> = <call><name>compiler_import_as</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>asname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>r</name></expr>)</condition><then>
			    <return>return <expr><name>r</name></expr>;</return></then></if>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>identifier</name></type> <name>tmp</name> <init>= <expr><name><name>alias</name>-&gt;<name>name</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>dot</name></expr>)</condition><then>
				<expr_stmt><expr><name>tmp</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>base</name></expr></argument>, 
								 <argument><expr><name>dot</name> - <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>r</name> = <call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>dot</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr>!<name>r</name></expr>)</condition><then>
				<return>return <expr><name>r</name></expr>;</return></then></if>
		}</block></else></if>
	}</block></for>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_from_import</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>names</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>names</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>level</name></decl>;</decl_stmt>
	
	<if>if <condition>(<expr>!<name>names</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>level</name></name> == 0 &amp;&amp; <name><name>c</name>-&gt;<name>c_flags</name></name> &amp;&amp;
	    !(<name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>CO_FUTURE_ABSOLUTE_IMPORT</name>)</expr>)</condition><then>
		<expr_stmt><expr><name>level</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>level</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr>!<name>level</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<comment type="block">/* build up the names */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>alias_ty</name></type> <name>alias</name> <init>= <expr>(<name>alias_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>names</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>lineno</name></name> &gt; <name><name>c</name>-&gt;<name>c_future</name>-&gt;<name>ff_lineno</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>module</name></name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr>"__future__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, 
				      <argument><expr>"from __future__ imports must occur "
				      "at the beginning of the file"</expr></argument>)</argument_list></call></expr>;</return>

		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IMPORT_NAME</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>module</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>alias_ty</name></type> <name>alias</name> <init>= <expr>(<name>alias_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ImportFrom</name>.<name>names</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>identifier</name></type> <name>store_name</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; *<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call> == '*'</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IMPORT_STAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
		    
		<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>IMPORT_FROM</name></expr></argument>, <argument><expr><name><name>alias</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>store_name</name> = <name><name>alias</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>alias</name>-&gt;<name>asname</name></name></expr>)</condition><then>
			<expr_stmt><expr><name>store_name</name> = <name><name>alias</name>-&gt;<name>asname</name></name></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>store_name</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
	}</block></for>
	<comment type="block">/* remove imported module */</comment>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_assert</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>assertion_error</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>Py_OptimizeFlag</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>assertion_error</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>assertion_error</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"AssertionError"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>assertion_error</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>test</name>-&gt;<name>kind</name></name> == <name>Tuple_kind</name> &amp;&amp;
	    <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>test</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>msg</name> <init>=
			<expr>"assertion is always true, perhaps remove parentheses?"</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyErr_WarnExplicit</name><argument_list>(<argument><expr><name>PyExc_SyntaxWarning</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>,
				       <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>test</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_TRUE</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_GLOBAL</name></expr></argument>, <argument><expr><name>assertion_error</name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>msg</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assert</name>.<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RAISE_VARARGS</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RAISE_VARARGS</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_stmt</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<comment type="block">/* Always assign a lineno to the next instruction for a stmt. */</comment>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name> = <name><name>s</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
	<case>case <expr><name>FunctionDef_kind</name></expr>:
		<return>return <expr><call><name>compiler_function</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>ClassDef_kind</name></expr>:
		<return>return <expr><call><name>compiler_class</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Return_kind</name></expr>:
		<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_type</name></name> != <name>FunctionBlock</name></expr>)</condition><then>
			<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"'return' outside function"</expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Return</name>.<name>value</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Return</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Delete_kind</name></expr>:
		<macro><name>VISIT_SEQ</name><argument_list>(<argument>c</argument>, <argument>expr</argument>, <argument>s-&gt;v.Delete.targets</argument>)</argument_list></macro>
		<break>break;</break>
	</case><case>case <expr><name>Assign_kind</name></expr>:
		<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assign</name>.<name>targets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><name>i</name> &lt; <name>n</name> - 1</expr>)</condition><then>
				<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
			      <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Assign</name>.<name>targets</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<break>break;</break>
	</case><case>case <expr><name>AugAssign_kind</name></expr>:
		<return>return <expr><call><name>compiler_augassign</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Print_kind</name></expr>:
		<return>return <expr><call><name>compiler_print</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>For_kind</name></expr>:
		<return>return <expr><call><name>compiler_for</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>While_kind</name></expr>:
		<return>return <expr><call><name>compiler_while</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>If_kind</name></expr>:
		<return>return <expr><call><name>compiler_if</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Raise_kind</name></expr>:
		<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>type</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>inst</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>inst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>tback</name></name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Raise</name>.<name>tback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
				}</block></then></if>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RAISE_VARARGS</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>TryExcept_kind</name></expr>:
		<return>return <expr><call><name>compiler_try_except</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>TryFinally_kind</name></expr>:
		<return>return <expr><call><name>compiler_try_finally</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Assert_kind</name></expr>:
		<return>return <expr><call><name>compiler_assert</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Import_kind</name></expr>:
		<return>return <expr><call><name>compiler_import</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>ImportFrom_kind</name></expr>:
		<return>return <expr><call><name>compiler_from_import</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Exec_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>globals</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>locals</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Exec</name>.<name>locals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>EXEC_STMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Global_kind</name></expr>:
		<break>break;</break>
	</case><case>case <expr><name>Expr_kind</name></expr>:
		<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_interactive</name></name> &amp;&amp; <name><name>c</name>-&gt;<name>c_nestlevel</name></name> &lt;= 1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>PRINT_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name>-&gt;<name>kind</name></name> != <name>Str_kind</name> &amp;&amp;
			 <name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name>-&gt;<name>kind</name></name> != <name>Num_kind</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Expr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></else></if>
		<break>break;</break>
	</case><case>case <expr><name>Pass_kind</name></expr>:
		<break>break;</break>
	</case><case>case <expr><name>Break_kind</name></expr>:
		<if>if <condition>(<expr>!<call><name>compiler_in_loop</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"'break' outside loop"</expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BREAK_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Continue_kind</name></expr>:
		<return>return <expr><call><name>compiler_continue</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>With_kind</name></expr>:
		<return>return <expr><call><name>compiler_with</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
	</case>}</block></switch>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>unaryop</name><parameter_list>(<param><decl><type><name>unaryop_ty</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Invert</name></expr>:
		<return>return <expr><name>UNARY_INVERT</name></expr>;</return>
	</case><case>case <expr><name>Not</name></expr>:
		<return>return <expr><name>UNARY_NOT</name></expr>;</return>
	</case><case>case <expr><name>UAdd</name></expr>:
		<return>return <expr><name>UNARY_POSITIVE</name></expr>;</return>
	</case><case>case <expr><name>USub</name></expr>:
		<return>return <expr><name>UNARY_NEGATIVE</name></expr>;</return>
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			<argument><expr>"unary op %d should not be possible"</expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	</default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>binop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>operator_ty</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Add</name></expr>:
		<return>return <expr><name>BINARY_ADD</name></expr>;</return>
	</case><case>case <expr><name>Sub</name></expr>:
		<return>return <expr><name>BINARY_SUBTRACT</name></expr>;</return>
	</case><case>case <expr><name>Mult</name></expr>:
		<return>return <expr><name>BINARY_MULTIPLY</name></expr>;</return>
	</case><case>case <expr><name>Div</name></expr>:
		<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_flags</name></name> &amp;&amp; <name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>CO_FUTURE_DIVISION</name></expr>)</condition><then>
			<return>return <expr><name>BINARY_TRUE_DIVIDE</name></expr>;</return></then>
		<else>else
			<return>return <expr><name>BINARY_DIVIDE</name></expr>;</return></else></if>
	</case><case>case <expr><name>Mod</name></expr>:
		<return>return <expr><name>BINARY_MODULO</name></expr>;</return>
	</case><case>case <expr><name>Pow</name></expr>:
		<return>return <expr><name>BINARY_POWER</name></expr>;</return>
	</case><case>case <expr><name>LShift</name></expr>:
		<return>return <expr><name>BINARY_LSHIFT</name></expr>;</return>
	</case><case>case <expr><name>RShift</name></expr>:
		<return>return <expr><name>BINARY_RSHIFT</name></expr>;</return>
	</case><case>case <expr><name>BitOr</name></expr>:
		<return>return <expr><name>BINARY_OR</name></expr>;</return>
	</case><case>case <expr><name>BitXor</name></expr>:
		<return>return <expr><name>BINARY_XOR</name></expr>;</return>
	</case><case>case <expr><name>BitAnd</name></expr>:
		<return>return <expr><name>BINARY_AND</name></expr>;</return>
	</case><case>case <expr><name>FloorDiv</name></expr>:
		<return>return <expr><name>BINARY_FLOOR_DIVIDE</name></expr>;</return>
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			<argument><expr>"binary op %d should not be possible"</expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	</default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmpop</name><parameter_list>(<param><decl><type><name>cmpop_ty</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Eq</name></expr>:
		<return>return <expr><name>PyCmp_EQ</name></expr>;</return>
	</case><case>case <expr><name>NotEq</name></expr>:
		<return>return <expr><name>PyCmp_NE</name></expr>;</return>
	</case><case>case <expr><name>Lt</name></expr>:
		<return>return <expr><name>PyCmp_LT</name></expr>;</return>
	</case><case>case <expr><name>LtE</name></expr>:
		<return>return <expr><name>PyCmp_LE</name></expr>;</return>
	</case><case>case <expr><name>Gt</name></expr>:
		<return>return <expr><name>PyCmp_GT</name></expr>;</return>
	</case><case>case <expr><name>GtE</name></expr>:
		<return>return <expr><name>PyCmp_GE</name></expr>;</return>
	</case><case>case <expr><name>Is</name></expr>:
		<return>return <expr><name>PyCmp_IS</name></expr>;</return>
	</case><case>case <expr><name>IsNot</name></expr>:
		<return>return <expr><name>PyCmp_IS_NOT</name></expr>;</return>
	</case><case>case <expr><name>In</name></expr>:
		<return>return <expr><name>PyCmp_IN</name></expr>;</return>
	</case><case>case <expr><name>NotIn</name></expr>:
		<return>return <expr><name>PyCmp_NOT_IN</name></expr>;</return>
	</case><default>default:
		<return>return <expr><name>PyCmp_BAD</name></expr>;</return>
	</default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>inplace_binop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>operator_ty</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Add</name></expr>:
		<return>return <expr><name>INPLACE_ADD</name></expr>;</return>
	</case><case>case <expr><name>Sub</name></expr>:
		<return>return <expr><name>INPLACE_SUBTRACT</name></expr>;</return>
	</case><case>case <expr><name>Mult</name></expr>:
		<return>return <expr><name>INPLACE_MULTIPLY</name></expr>;</return>
	</case><case>case <expr><name>Div</name></expr>:
		<if>if <condition>(<expr><name><name>c</name>-&gt;<name>c_flags</name></name> &amp;&amp; <name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>CO_FUTURE_DIVISION</name></expr>)</condition><then>
			<return>return <expr><name>INPLACE_TRUE_DIVIDE</name></expr>;</return></then>
		<else>else
			<return>return <expr><name>INPLACE_DIVIDE</name></expr>;</return></else></if>
	</case><case>case <expr><name>Mod</name></expr>:
		<return>return <expr><name>INPLACE_MODULO</name></expr>;</return>
	</case><case>case <expr><name>Pow</name></expr>:
		<return>return <expr><name>INPLACE_POWER</name></expr>;</return>
	</case><case>case <expr><name>LShift</name></expr>:
		<return>return <expr><name>INPLACE_LSHIFT</name></expr>;</return>
	</case><case>case <expr><name>RShift</name></expr>:
		<return>return <expr><name>INPLACE_RSHIFT</name></expr>;</return>
	</case><case>case <expr><name>BitOr</name></expr>:
		<return>return <expr><name>INPLACE_OR</name></expr>;</return>
	</case><case>case <expr><name>BitXor</name></expr>:
		<return>return <expr><name>INPLACE_XOR</name></expr>;</return>
	</case><case>case <expr><name>BitAnd</name></expr>:
		<return>return <expr><name>INPLACE_AND</name></expr>;</return>
	</case><case>case <expr><name>FloorDiv</name></expr>:
		<return>return <expr><name>INPLACE_FLOOR_DIVIDE</name></expr>;</return>
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			<argument><expr>"inplace binary op %d should not be possible"</expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	</default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_nameop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>identifier</name></type> <name>name</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>, <decl><type ref="prev"/><name>scope</name></decl>, <decl><type ref="prev"/><name>arg</name></decl>;</decl_stmt>
	<enum>enum <block>{ <decl><name>OP_FAST</name></decl>, <decl><name>OP_GLOBAL</name></decl>, <decl><name>OP_DEREF</name></decl>, <decl><name>OP_NAME</name></decl> }</block> <decl><name>optype</name></decl>;</enum>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_names</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mangled</name></decl>;</decl_stmt>
	<comment type="block">/* XXX AugStore isn't used anywhere! */</comment>

	<comment type="block">/* First check for assignment to __debug__. Param? */</comment>
	<if>if <condition>(<expr>(<name>ctx</name> == <name>Store</name> || <name>ctx</name> == <name>AugStore</name> || <name>ctx</name> == <name>Del</name>)
	    &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"__debug__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"can not assign to __debug__"</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>mangled</name> = <call><name>_Py_Mangle</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_private</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>mangled</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name>op</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>optype</name> = <name>OP_NAME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scope</name> = <call><name>PyST_GetScope</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name></name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>scope</name></expr>)</condition> <block>{
	<case>case <expr><name>FREE</name></expr>:
		<expr_stmt><expr><name>dict</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_freevars</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>optype</name> = <name>OP_DEREF</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>CELL</name></expr>:
		<expr_stmt><expr><name>dict</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_cellvars</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>optype</name> = <name>OP_DEREF</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>LOCAL</name></expr>:
		<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_type</name></name> == <name>FunctionBlock</name></expr>)</condition><then>
			<expr_stmt><expr><name>optype</name> = <name>OP_FAST</name></expr>;</expr_stmt></then></if>
		<break>break;</break>
	</case><case>case <expr><name>GLOBAL_IMPLICIT</name></expr>:
		<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_type</name></name> == <name>FunctionBlock</name> &amp;&amp;
			!<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_unoptimized</name></name></expr>)</condition><then>
			<expr_stmt><expr><name>optype</name> = <name>OP_GLOBAL</name></expr>;</expr_stmt></then></if>
		<break>break;</break>
	</case><case>case <expr><name>GLOBAL_EXPLICIT</name></expr>:
		<expr_stmt><expr><name>optype</name> = <name>OP_GLOBAL</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><default>default:
		<comment type="block">/* scope can be 0 */</comment>
		<break>break;</break>
	</default>}</block></switch>

	<comment type="block">/* XXX Leave assert here, but handle __doc__ and the like better */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>scope</name> || <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index> == '_'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>optype</name></expr>)</condition> <block>{
	<case>case <expr><name>OP_DEREF</name></expr>:
		<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
		<case>case <expr><name>Load</name></expr>: <expr_stmt><expr><name>op</name> = <name>LOAD_DEREF</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Store</name></expr>: <expr_stmt><expr><name>op</name> = <name>STORE_DEREF</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>AugLoad</name></expr>:
		</case><case>case <expr><name>AugStore</name></expr>:
			<break>break;</break>
		</case><case>case <expr><name>Del</name></expr>:
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>,
				     <argument><expr>"can not delete variable '%s' referenced "
				     "in nested scope"</expr></argument>,
				     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		</case><case>case <expr><name>Param</name></expr>:
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"param invalid for deref variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		</default>}</block></switch>
		<break>break;</break>
	</case><case>case <expr><name>OP_FAST</name></expr>:
		<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
		<case>case <expr><name>Load</name></expr>: <expr_stmt><expr><name>op</name> = <name>LOAD_FAST</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Store</name></expr>: <expr_stmt><expr><name>op</name> = <name>STORE_FAST</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Del</name></expr>: <expr_stmt><expr><name>op</name> = <name>DELETE_FAST</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>AugLoad</name></expr>:
		</case><case>case <expr><name>AugStore</name></expr>:
			<break>break;</break>
		</case><case>case <expr><name>Param</name></expr>:
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"param invalid for local variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		</default>}</block></switch>
		<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>, <argument><expr><name>varnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	</case><case>case <expr><name>OP_GLOBAL</name></expr>:
		<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
		<case>case <expr><name>Load</name></expr>: <expr_stmt><expr><name>op</name> = <name>LOAD_GLOBAL</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Store</name></expr>: <expr_stmt><expr><name>op</name> = <name>STORE_GLOBAL</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Del</name></expr>: <expr_stmt><expr><name>op</name> = <name>DELETE_GLOBAL</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>AugLoad</name></expr>:
		</case><case>case <expr><name>AugStore</name></expr>:
			<break>break;</break>
		</case><case>case <expr><name>Param</name></expr>:
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"param invalid for global variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		</default>}</block></switch>
		<break>break;</break>
	</case><case>case <expr><name>OP_NAME</name></expr>:
		<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
		<case>case <expr><name>Load</name></expr>: <expr_stmt><expr><name>op</name> = <name>LOAD_NAME</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Store</name></expr>: <expr_stmt><expr><name>op</name> = <name>STORE_NAME</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Del</name></expr>: <expr_stmt><expr><name>op</name> = <name>DELETE_NAME</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>AugLoad</name></expr>:
		</case><case>case <expr><name>AugStore</name></expr>:
			<break>break;</break>
		</case><case>case <expr><name>Param</name></expr>:
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"param invalid for name variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		</default>}</block></switch>
		<break>break;</break>
	</case>}</block></switch>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arg</name> = <call><name>compiler_add_o</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>arg</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>compiler_addop_i</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_boolop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>jumpi</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>kind</name></name> == <name>BoolOp_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>BoolOp</name>.<name>op</name></name> == <name>And</name></expr>)</condition><then>
		<expr_stmt><expr><name>jumpi</name> = <name>JUMP_IF_FALSE</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>jumpi</name> = <name>JUMP_IF_TRUE</name></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>s</name> = <name><name>e</name>-&gt;<name>v</name>.<name>BoolOp</name>.<name>values</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>jumpi</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>ADDOP</name><argument_list>(<argument>c</argument>, <argument>POP_TOP</argument>)</argument_list></macro>
	}</block></for>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_list</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>ctx</name></name> == <name>Store</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>UNPACK_SEQUENCE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>List</name>.<name>ctx</name></name> == <name>Load</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_LIST</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_tuple</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>ctx</name></name> == <name>Store</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>UNPACK_SEQUENCE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>elts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Tuple</name>.<name>ctx</name></name> == <name>Load</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_TUPLE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_compare</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>cleanup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* XXX the logic can be cleaned up for 1 or multiple comparisons */</comment>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &gt; 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>cleanup</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cleanup</name> == <name>NULL</name></expr>)</condition><then>
		    <return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, 
			<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>comparators</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_THREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>COMPARE_OP</name></expr></argument>,
			<argument><expr><call><name>cmpop</name><argument_list>(<argument><expr><call>(<name>cmpop_ty</name>)<argument_list>(<argument><expr><call><name>asdl_seq_GET</name><argument_list>(
						  <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>ops</name></name></expr></argument>, <argument><expr><name>i</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> &lt; (<name>n</name> - 1)</expr>)</condition><then>
		    <expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, 
			    <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>comparators</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>comparators</name></name></expr></argument>, <argument><expr><name>n</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>COMPARE_OP</name></expr></argument>,
	       <argument><expr><call><name>cmpop</name><argument_list>(<argument><expr><call>(<name>cmpop_ty</name>)<argument_list>(<argument><expr><call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Compare</name>.<name>ops</name></name></expr></argument>, <argument><expr><name>n</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &gt; 1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>basicblock</name> *</type><name>end</name> <init>= <expr><call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>end</name> == <name>NULL</name></expr>)</condition><then>
		    <return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_call</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>code</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>keywords</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>keywords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> |= <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>keywords</name></name></expr></argument>)</argument_list></call> &lt;&lt; 8</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>starargs</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>starargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>code</name> |= 1</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>kwargs</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Call</name>.<name>kwargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>code</name> |= 2</expr>;</expr_stmt>
	}</block></then></if>
	<switch>switch <condition>(<expr><name>code</name></expr>)</condition> <block>{
	<case>case <expr>0</expr>:
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>1</expr>:
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION_VAR</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>2</expr>:
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION_KW</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>3</expr>:
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION_VAR_KW</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case>}</block></switch>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_listcomp_generator</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tmpname</name></decl></param>,
			    <param><decl><type><name>asdl_seq</name> *</type><name>generators</name></decl></param>, <param><decl><type><name>int</name></type> <name>gen_index</name></decl></param>, 
			    <param><decl><type><name>expr_ty</name></type> <name>elt</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* generate code for the iterator, then each of the ifs,
	   and then write to the element */</comment>

	<decl_stmt><decl><type><name>comprehension_ty</name></type> <name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>anchor</name></decl>, *<decl><type ref="prev"/><name>skip</name></decl>, *<decl><type ref="prev"/><name>if_cleanup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>start</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>skip</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>if_cleanup</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>anchor</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>start</name> == <name>NULL</name> || <name>skip</name> == <name>NULL</name> || <name>if_cleanup</name> == <name>NULL</name> ||
		<name>anchor</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name>l</name> = (<name>comprehension_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>generators</name></expr></argument>, <argument><expr><name>gen_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>l</name>-&gt;<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>GET_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FOR_ITER</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>l</name>-&gt;<name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this needs to be cleaned up...a lot! */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>l</name>-&gt;<name>ifs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>l</name>-&gt;<name>ifs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>if_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for> 

	<if>if <condition>(<expr>++<name>gen_index</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>generators</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <if>if <condition>(<expr>!<call><name>compiler_listcomp_generator</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpname</name></expr></argument>, 
					     <argument><expr><name>generators</name></expr></argument>, <argument><expr><name>gen_index</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if></then></if>

	<comment type="block">/* only append after the last for generator */</comment>
	<if>if <condition>(<expr><name>gen_index</name> &gt;= <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>generators</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpname</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	    <expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LIST_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then>
		    <expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>if_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for> 
	<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* delete the temporary list name added to locals */</comment>
	<if>if <condition>(<expr><name>gen_index</name> == 1</expr>)</condition><then>
	    <if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpname</name></expr></argument>, <argument><expr><name>Del</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if></then></if>
	
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_listcomp</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>identifier</name></type> <name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>asdl_seq</name> *</type><name>generators</name> <init>= <expr><name><name>e</name>-&gt;<name>v</name>.<name>ListComp</name>.<name>generators</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>kind</name></name> == <name>ListComp_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> = <call><name>compiler_new_tmpname</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_LIST</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>rc</name> = <call><name>compiler_listcomp_generator</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>generators</name></expr></argument>, <argument><expr>0</expr></argument>, 
					     <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>ListComp</name>.<name>elt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_genexp_generator</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>,
			  <param><decl><type><name>asdl_seq</name> *</type><name>generators</name></decl></param>, <param><decl><type><name>int</name></type> <name>gen_index</name></decl></param>, 
			  <param><decl><type><name>expr_ty</name></type> <name>elt</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* generate code for the iterator, then each of the ifs,
	   and then write to the element */</comment>

	<decl_stmt><decl><type><name>comprehension_ty</name></type> <name>ge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>anchor</name></decl>, *<decl><type ref="prev"/><name>skip</name></decl>, *<decl><type ref="prev"/><name>if_cleanup</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>start</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>skip</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>if_cleanup</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>anchor</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>start</name> == <name>NULL</name> || <name>skip</name> == <name>NULL</name> || <name>if_cleanup</name> == <name>NULL</name> ||
	    <name>anchor</name> == <name>NULL</name> || <name>end</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name>ge</name> = (<name>comprehension_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name>generators</name></expr></argument>, <argument><expr><name>gen_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_LOOP</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<if>if <condition>(<expr><name>gen_index</name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* Receive outermost iter as an implicit argument */</comment>
		<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_argcount</name></name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_FAST</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* Sub-iter - calculate on the fly */</comment>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>ge</name>-&gt;<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>GET_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FOR_ITER</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>ge</name>-&gt;<name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this needs to be cleaned up...a lot! */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>ge</name>-&gt;<name>ifs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>ge</name>-&gt;<name>ifs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>if_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for> 

	<if>if <condition>(<expr>++<name>gen_index</name> &lt; <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>generators</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<if>if <condition>(<expr>!<call><name>compiler_genexp_generator</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>generators</name></expr></argument>, <argument><expr><name>gen_index</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if></then></if>

	<comment type="block">/* only append after the last 'for' generator */</comment>
	<if>if <condition>(<expr><name>gen_index</name> &gt;= <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name>generators</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>YIELD_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_FORWARD</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>if_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for> 
	<expr_stmt><expr><call><name>ADDOP_JABS</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>JUMP_ABSOLUTE</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOOP</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_genexp</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>identifier</name></type> <name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>expr_ty</name></type> <name>outermost_iter</name> <init>= <expr>(<call>(<name>comprehension_ty</name>)
				 <argument_list>(<argument><expr><call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>GeneratorExp</name>.<name>generators</name></name></expr></argument>,
					       <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)-&gt;<name>iter</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>name</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"&lt;genexpr&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>compiler_enter_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>e</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>compiler_genexp_generator</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>GeneratorExp</name>.<name>generators</name></name></expr></argument>, <argument><expr>0</expr></argument>,
				  <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>GeneratorExp</name>.<name>elt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>co</name> = <call><name>assemble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compiler_exit_scope</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><call><name>compiler_make_closure</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>outermost_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>GET_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_keyword</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>keyword_ty</name></type> <name>k</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name><name>k</name>-&gt;<name>arg</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>k</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Test whether expression is constant.	 For constants, report
   whether they are true or false.

   Return values: 1 for true, 0 for false, -1 for non-constant.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>expr_constant</name><parameter_list>(<param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
	<case>case <expr><name>Num_kind</name></expr>:
		<return>return <expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Num</name>.<name>n</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Str_kind</name></expr>:
		<return>return <expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Str</name>.<name>s</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Name_kind</name></expr>:
		<comment type="block">/* __debug__ is not assignable, so we can optimize
		 * it away in if and while statements */</comment>
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr>"__debug__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			   <return>return <expr>! <name>Py_OptimizeFlag</name></expr>;</return></then></if>
		<comment type="block">/* fall through */</comment>
	</case><default>default:
		<return>return <expr>-1</expr>;</return>
	</default>}</block></switch>
}</block></function>

<comment type="block">/*
   Implements the with statement from PEP 343.

   The semantics outlined in that PEP are as follows:  

   with EXPR as VAR:
       BLOCK
  
   It is implemented roughly as:
  
   context = EXPR
   exit = context.__exit__  # not calling it
   value = context.__enter__()
   try:
       VAR = value  # if VAR present in the syntax
       BLOCK
   finally:
       if an exception was raised:
	   exc = copy of (exception, instance, traceback)
       else:
	   exc = (None, None, None)
       exit(*exc)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_with</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>identifier</name></type> <name>enter_attr</name></decl>, <decl><type ref="prev"/><name>exit_attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>basicblock</name> *</type><name>block</name></decl>, *<decl><type ref="prev"/><name>finally</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>identifier</name></type> <name>tmpvalue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>With_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>enter_attr</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>enter_attr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__enter__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>enter_attr</name></expr>)</condition><then>
	    <return>return <expr>0</expr>;</return></then></if>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>exit_attr</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>exit_attr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__exit__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>exit_attr</name></expr>)</condition><then>
	    <return>return <expr>0</expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>block</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>finally</name> = <call><name>compiler_new_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>block</name> || !<name>finally</name></expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr>)</condition><then> <block>{
	<comment type="block">/* Create a temporary variable to hold context.__enter__().
	   We need to do this rather than preserving it on the stack
	   because SETUP_FINALLY remembers the stack level.
	   We need to do the assignment *inside* the try/finally
	   so that context.__exit__() is called when the assignment
	   fails.  But we need to call context.__enter__() *before*
	   the try/finally so that if it fails we won't call
	   context.__exit__().
	*/</comment>
	<expr_stmt><expr><name>tmpvalue</name> = <call><name>compiler_new_tmpname</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmpvalue</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyArena_AddPyObject</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>, <argument><expr><name>tmpvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Evaluate EXPR */</comment>
    <expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>context_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Squirrel away context.__exit__ by stuffing it under context */</comment>
    <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_ATTR</name></expr></argument>, <argument><expr><name>exit_attr</name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Call context.__enter__() */</comment>
    <expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_ATTR</name></expr></argument>, <argument><expr><name>enter_attr</name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CALL_FUNCTION</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr>)</condition><then> <block>{
	<comment type="block">/* Store it in tmpvalue */</comment>
	<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpvalue</name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr>0</expr>;</return></then></if>
    }</block></then>
    <else>else <block>{
	<comment type="block">/* Discard result from context.__enter__() */</comment>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Start the try block */</comment>
    <expr_stmt><expr><call><name>ADDOP_JREL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>SETUP_FINALLY</name></expr></argument>, <argument><expr><name>finally</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_TRY</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr>)</condition><then> <block>{
	<comment type="block">/* Bind saved result of context.__enter__() to VAR */</comment>
	<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpvalue</name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call> ||
	    !<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpvalue</name></expr></argument>, <argument><expr><name>Del</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	  <return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>optional_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* BLOCK code */</comment>
    <expr_stmt><expr><call><name>VISIT_SEQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>With</name>.<name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* End of try block; start the finally block */</comment>
    <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POP_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_TRY</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compiler_use_next_block</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>finally</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>compiler_push_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_END</name></expr></argument>, <argument><expr><name>finally</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>

    <comment type="block">/* Finally block starts; context.__exit__ is on the stack under
       the exception or return information. Just issue our magic
       opcode. */</comment>
    <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>WITH_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Finally block ends. */</comment>
    <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>END_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compiler_pop_fblock</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FINALLY_END</name></expr></argument>, <argument><expr><name>finally</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_expr</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>expr_ty</name></type> <name>e</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<comment type="block">/* If expr e has a different line number than the last expr/stmt,
	   set a new line number for the next instruction.
	*/</comment>
	<if>if <condition>(<expr><name><name>e</name>-&gt;<name>lineno</name></name> &gt; <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name> = <name><name>e</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno_set</name></name> = <name>false</name></expr>;</expr_stmt>
	}</block></then></if>
	<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
	<case>case <expr><name>BoolOp_kind</name></expr>:
		<return>return <expr><call><name>compiler_boolop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>BinOp_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>BinOp</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>BinOp</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>binop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>BinOp</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>UnaryOp_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>UnaryOp</name>.<name>operand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>unaryop</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>UnaryOp</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Lambda_kind</name></expr>:
		<return>return <expr><call><name>compiler_lambda</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>IfExp_kind</name></expr>:
		<return>return <expr><call><name>compiler_ifexp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Dict_kind</name></expr>:
		<expr_stmt><expr><name>n</name> = <call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Dict</name>.<name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_MAP</name></expr></argument>, <argument><expr>(<name>n</name>&gt;0xFFFF ? 0xFFFF : <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, 
				<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Dict</name>.<name>values</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, 
				<argument><expr>(<name>expr_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Dict</name>.<name>keys</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>STORE_MAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<break>break;</break>
	</case><case>case <expr><name>ListComp_kind</name></expr>:
		<return>return <expr><call><name>compiler_listcomp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>GeneratorExp_kind</name></expr>:
		<return>return <expr><call><name>compiler_genexp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Yield_kind</name></expr>:
		<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name>-&gt;<name>ste_type</name></name> != <name>FunctionBlock</name></expr>)</condition><then>
			<return>return <expr><call><name>compiler_error</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"'yield' outside function"</expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Yield</name>.<name>value</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Yield</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>YIELD_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Compare_kind</name></expr>:
		<return>return <expr><call><name>compiler_compare</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Call_kind</name></expr>:
		<return>return <expr><call><name>compiler_call</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Repr_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Repr</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>UNARY_CONVERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Num_kind</name></expr>:
		<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Num</name>.<name>n</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Str_kind</name></expr>:
		<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Str</name>.<name>s</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<comment type="block">/* The following exprs can be assignment targets. */</comment>
	</case><case>case <expr><name>Attribute_kind</name></expr>:
		<if>if <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>ctx</name></name> != <name>AugStore</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>ctx</name></name></expr>)</condition> <block>{
		<case>case <expr><name>AugLoad</name></expr>:
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Fall through to load */</comment>
		</case><case>case <expr><name>Load</name></expr>:
			<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_ATTR</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>attr</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>AugStore</name></expr>:
			<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Fall through to save */</comment>
		</case><case>case <expr><name>Store</name></expr>:
			<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>STORE_ATTR</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>attr</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>Del</name></expr>:
			<expr_stmt><expr><call><name>ADDOP_NAME</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DELETE_ATTR</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>attr</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>Param</name></expr>:
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"param invalid in attribute expression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		</default>}</block></switch>
		<break>break;</break>
	</case><case>case <expr><name>Subscript_kind</name></expr>:
		<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>ctx</name></name></expr>)</condition> <block>{
		<case>case <expr><name>AugLoad</name></expr>:
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>AugLoad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>Load</name></expr>:
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>AugStore</name></expr>:
			<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>AugStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>Store</name></expr>:
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>Del</name></expr>:
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VISIT_SLICE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>, <argument><expr><name>Del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>Param</name></expr>:
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"param invalid in subscript expression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		</default>}</block></switch>
		<break>break;</break>
	</case><case>case <expr><name>Name_kind</name></expr>:
		<return>return <expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
	<comment type="block">/* child nodes of List and Tuple will have expr_context set */</comment>
	</case><case>case <expr><name>List_kind</name></expr>:
		<return>return <expr><call><name>compiler_list</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Tuple_kind</name></expr>:
		<return>return <expr><call><name>compiler_tuple</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
	</case>}</block></switch>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_augassign</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>stmt_ty</name></type> <name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>expr_ty</name></type> <name>e</name> <init>= <expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>target</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>expr_ty</name></type> <name>auge</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>AugAssign_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>e</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
	<case>case <expr><name>Attribute_kind</name></expr>:
		<expr_stmt><expr><name>auge</name> = <call><name>Attribute</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>value</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>attr</name></name></expr></argument>,
				 <argument><expr><name>AugLoad</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>auge</name> == <name>NULL</name></expr>)</condition><then>
		    <return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>auge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>inplace_binop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>auge</name>-&gt;<name>v</name>.<name>Attribute</name>.<name>ctx</name></name> = <name>AugStore</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>auge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Subscript_kind</name></expr>:
		<expr_stmt><expr><name>auge</name> = <call><name>Subscript</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>value</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>slice</name></name></expr></argument>,
				 <argument><expr><name>AugLoad</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>col_offset</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>auge</name> == <name>NULL</name></expr>)</condition><then>
		    <return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>auge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>inplace_binop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>auge</name>-&gt;<name>v</name>.<name>Subscript</name>.<name>ctx</name></name> = <name>AugStore</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>auge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Name_kind</name></expr>:
		<if>if <condition>(<expr>!<call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>, <argument><expr><name>Load</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>inplace_binop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>AugAssign</name>.<name>op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>compiler_nameop</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>v</name>.<name>Name</name>.<name>id</name></name></expr></argument>, <argument><expr><name>Store</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, 
			<argument><expr>"invalid node type (%d) for augmented assignment"</expr></argument>,
			<argument><expr><name><name>e</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	</default>}</block></switch>
	<return>return <expr>1</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_push_fblock</name><argument_list>(<argument>struct <expr><name>compiler</name> *<name>c</name></expr></argument>, <argument>enum <expr><name>fblocktype</name> <name>t</name></expr></argument>, <argument><expr><name>basicblock</name> *<name>b</name></expr></argument>)</argument_list>
<block>{
	<decl_stmt><decl><type>struct <name>fblockinfo</name> *</type><name>f</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_nfblocks</name></name> &gt;= <name>CO_MAXBLOCKS</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"too many statically nested blocks"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>f</name> = &amp;<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_nfblocks</name></name>++</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name>-&gt;<name>fb_type</name></name> = <name>t</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name>-&gt;<name>fb_block</name></name> = <name>b</name></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>compiler_pop_fblock</name><argument_list>(<argument>struct <expr><name>compiler</name> *<name>c</name></expr></argument>, <argument>enum <expr><name>fblocktype</name> <name>t</name></expr></argument>, <argument><expr><name>basicblock</name> *<name>b</name></expr></argument>)</argument_list>
<block>{
	<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name> <init>= <expr><name><name>c</name>-&gt;<name>u</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name></expr>]</index></name>.<name>fb_type</name> == <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name><name>u</name>-&gt;<name>u_nfblocks</name></name></expr>]</index></name>.<name>fb_block</name> == <name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_in_loop</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>compiler_unit</name> *</type><name>u</name> <init>= <expr><name><name>c</name>-&gt;<name>u</name></name></expr></init></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>u</name>-&gt;<name>u_nfblocks</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>u</name>-&gt;<name>u_fblock</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fb_type</name> == <name>LOOP</name></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>
<comment type="block">/* Raises a SyntaxError and returns 0.
   If something goes wrong, a different exception may be raised.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_error</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errstr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name> <init>= <expr><name>NULL</name></expr></init>, *<name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>loc</name> = <call><name>PyErr_ProgramText</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>loc</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>loc</name> = <name>Py_None</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>u</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ziOO)"</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_lineno</name></name></expr></argument>,
			  <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
		<goto>goto <name>exit</name>;</goto></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(zO)"</expr></argument>, <argument><expr><name>errstr</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then>
		<goto>goto <name>exit</name>;</goto></then></if>
	<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 <label><name>exit</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_handle_subscr</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>kind</name></decl></param>, 
		       <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list> 
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* XXX this code is duplicated */</comment>
	<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
		<case>case <expr><name>AugLoad</name></expr>: <comment type="block">/* fall through to Load */</comment>
		</case><case>case <expr><name>Load</name></expr>:    <expr_stmt><expr><name>op</name> = <name>BINARY_SUBSCR</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>AugStore</name></expr>:<comment type="block">/* fall through to Store */</comment>
		</case><case>case <expr><name>Store</name></expr>:   <expr_stmt><expr><name>op</name> = <name>STORE_SUBSCR</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Del</name></expr>:     <expr_stmt><expr><name>op</name> = <name>DELETE_SUBSCR</name></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Param</name></expr>:
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, 
				     <argument><expr>"invalid %s kind %d in subscript\n"</expr></argument>, 
				     <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
	</case>}</block></switch>
	<if>if <condition>(<expr><name>ctx</name> == <name>AugLoad</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOPX</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>ctx</name> == <name>AugStore</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_THREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_slice</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>slice_ty</name></type> <name>s</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>2</expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>kind</name></name> == <name>Slice_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* only handles the cases where BUILD_SLICE is emitted */</comment>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>lower</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
		
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>upper</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>step</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>step</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_SLICE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_simple_slice</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>slice_ty</name></type> <name>s</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr>0</expr></init>, <name>slice_offset</name> <init>= <expr>0</expr></init>, <name>stack_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>step</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>lower</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>slice_offset</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>stack_count</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> 
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>upper</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>slice_offset</name> += 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>stack_count</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> 
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>ctx</name> == <name>AugLoad</name></expr>)</condition><then> <block>{
		<switch>switch <condition>(<expr><name>stack_count</name></expr>)</condition> <block>{
		<case>case <expr>0</expr>: <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>1</expr>: <expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOPX</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>2</expr>: <expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>DUP_TOPX</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</case>}</block></switch>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>ctx</name> == <name>AugStore</name></expr>)</condition><then> <block>{
		<switch>switch <condition>(<expr><name>stack_count</name></expr>)</condition> <block>{
		<case>case <expr>0</expr>: <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_TWO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>1</expr>: <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_THREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr>2</expr>: <expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ROT_FOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</case>}</block></switch>
	}</block></then></if></else></if>

	<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition> <block>{
	<case>case <expr><name>AugLoad</name></expr>: <comment type="block">/* fall through to Load */</comment>
	</case><case>case <expr><name>Load</name></expr>: <expr_stmt><expr><name>op</name> = <name>SLICE</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>AugStore</name></expr>:<comment type="block">/* fall through to Store */</comment>
	</case><case>case <expr><name>Store</name></expr>: <expr_stmt><expr><name>op</name> = <name>STORE_SLICE</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Del</name></expr>: <expr_stmt><expr><name>op</name> = <name>DELETE_SLICE</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr><name>Param</name></expr>:
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"param invalid in simple slice"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	</default>}</block></switch>

	<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>op</name> + <name>slice_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_nested_slice</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>slice_ty</name></type> <name>s</name></decl></param>, 
			    <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
	<case>case <expr><name>Ellipsis_kind</name></expr>:
		<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_Ellipsis</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>Slice_kind</name></expr>:
		<return>return <expr><call><name>compiler_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>Index_kind</name></expr>:
		<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Index</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>ExtSlice_kind</name></expr>:
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"extended slice invalid in nested slice"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	</default>}</block></switch>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compiler_visit_slice</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>slice_ty</name></type> <name>s</name></decl></param>, <param><decl><type><name>expr_context_ty</name></type> <name>ctx</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type> <name>kindname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
	<case>case <expr><name>Index_kind</name></expr>:
		<expr_stmt><expr><name>kindname</name> = "index"</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>VISIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>Index</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<break>break;</break>
	</case><case>case <expr><name>Ellipsis_kind</name></expr>:
		<expr_stmt><expr><name>kindname</name> = "ellipsis"</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_Ellipsis</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<break>break;</break>
	</case><case>case <expr><name>Slice_kind</name></expr>:
		<expr_stmt><expr><name>kindname</name> = "slice"</expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name><name>s</name>-&gt;<name>v</name>.<name>Slice</name>.<name>step</name></name></expr>)</condition><then> 
			<return>return <expr><call><name>compiler_simple_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>compiler_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
		}</block></then></if>
		<break>break;</break>
	</case><case>case <expr><name>ExtSlice_kind</name></expr>:
		<expr_stmt><expr><name>kindname</name> = "extended slice"</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ctx</name> != <name>AugStore</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>asdl_seq_LEN</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ExtSlice</name>.<name>dims</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<decl_stmt><decl><type><name>slice_ty</name></type> <name>sub</name> <init>= <expr>(<name>slice_ty</name>)<call><name>asdl_seq_GET</name><argument_list>(
					<argument><expr><name><name>s</name>-&gt;<name>v</name>.<name>ExtSlice</name>.<name>dims</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr>!<call><name>compiler_visit_nested_slice</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<return>return <expr>0</expr>;</return></then></if>
			}</block></for>
			<expr_stmt><expr><call><name>ADDOP_I</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BUILD_TUPLE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<break>break;</break>
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
			     <argument><expr>"invalid subscript kind %d"</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	</default>}</block></switch>
	<return>return <expr><call><name>compiler_handle_subscr</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>kindname</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* End of the compiler section, beginning of the assembler section */</comment>

<comment type="block">/* do depth-first search of basic block graph, starting with block.
   post records the block indices in post-order.

   XXX must handle implicit jumps from one block to next
*/</comment>

<struct>struct <name>assembler</name> <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>a_bytecode</name></decl>;</decl_stmt>  <comment type="block">/* string containing bytecode */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>a_offset</name></decl>;</decl_stmt>	       <comment type="block">/* offset into bytecode */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>a_nblocks</name></decl>;</decl_stmt>	       <comment type="block">/* number of reachable blocks */</comment>
	<decl_stmt><decl><type><name>basicblock</name> **</type><name>a_postorder</name></decl>;</decl_stmt> <comment type="block">/* list of blocks in dfs postorder */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>a_lnotab</name></decl>;</decl_stmt>    <comment type="block">/* string containing lnotab */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>a_lnotab_off</name></decl>;</decl_stmt>      <comment type="block">/* offset into lnotab */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>a_lineno</name></decl>;</decl_stmt>	       <comment type="block">/* last lineno of emitted instruction */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>a_lineno_off</name></decl>;</decl_stmt>      <comment type="block">/* bytecode offset of last lineno */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dfs</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>, <param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>instr</name> *</type><name>instr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_seen</name></name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>b_seen</name></name> = 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_next</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>dfs</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>b_next</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>instr</name> = &amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_jrel</name></name> || <name><name>instr</name>-&gt;<name>i_jabs</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>dfs</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>instr</name>-&gt;<name>i_target</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>a_postorder</name><index>[<expr><name><name>a</name>-&gt;<name>a_nblocks</name></name>++</expr>]</index></name> = <name>b</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>stackdepth_walk</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name></type> <name>depth</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxdepth</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>instr</name> *</type><name>instr</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_seen</name></name> || <name><name>b</name>-&gt;<name>b_startdepth</name></name> &gt;= <name>depth</name></expr>)</condition><then>
		<return>return <expr><name>maxdepth</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>b_seen</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>b_startdepth</name></name> = <name>depth</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>instr</name> = &amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>depth</name> += <call><name>opcode_stack_effect</name><argument_list>(<argument><expr><name><name>instr</name>-&gt;<name>i_opcode</name></name></expr></argument>, <argument><expr><name><name>instr</name>-&gt;<name>i_oparg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>depth</name> &gt; <name>maxdepth</name></expr>)</condition><then>
			<expr_stmt><expr><name>maxdepth</name> = <name>depth</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>depth</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* invalid code or bug in stackdepth() */</comment>
		<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_jrel</name></name> || <name><name>instr</name>-&gt;<name>i_jabs</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>maxdepth</name> = <call><name>stackdepth_walk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>instr</name>-&gt;<name>i_target</name></name></expr></argument>,
						   <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>maxdepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_opcode</name></name> == <name>JUMP_ABSOLUTE</name> ||
			    <name><name>instr</name>-&gt;<name>i_opcode</name></name> == <name>JUMP_FORWARD</name></expr>)</condition><then> <block>{
				<goto>goto <name>out</name>;</goto> <comment type="block">/* remaining code is dead */</comment>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name><name>b</name>-&gt;<name>b_next</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>maxdepth</name> = <call><name>stackdepth_walk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>b_next</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>maxdepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<label><name>out</name>:</label>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>b_seen</name></name> = 0</expr>;</expr_stmt>
	<return>return <expr><name>maxdepth</name></expr>;</return>
}</block></function>

<comment type="block">/* Find the flow path that needs the largest stack.  We assume that
 * cycles in the flow graph have no net effect on the stack depth.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>stackdepth</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>entryblock</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>entryblock</name> = <name>NULL</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_blocks</name></name></expr>;</init> <condition><expr><name>b</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>b</name> = <name><name>b</name>-&gt;<name>b_list</name></name></expr></incr>) <block>{
		<expr_stmt><expr><name><name>b</name>-&gt;<name>b_seen</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b</name>-&gt;<name>b_startdepth</name></name> = <name>INT_MIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>entryblock</name> = <name>b</name></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr>!<name>entryblock</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>stackdepth_walk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>entryblock</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>assemble_init</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>, <param><decl><type><name>int</name></type> <name>nblocks</name></decl></param>, <param><decl><type><name>int</name></type> <name>firstlineno</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>assembler</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lineno</name></name> = <name>firstlineno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DEFAULT_CODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>a_bytecode</name></name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DEFAULT_LNOTAB_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>a_lnotab</name></name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name>nblocks</name> &gt; <name>PY_SIZE_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>basicblock</name> *</expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>a_postorder</name></name> = (<name>basicblock</name> **)<call><name>PyObject_Malloc</name><argument_list>(
					    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>basicblock</name> *</expr></argument>)</argument_list></sizeof> * <name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>a_postorder</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assemble_free</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>a_postorder</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_postorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* Return the size of a basic block in bytes. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>instrsize</name><parameter_list>(<param><decl><type>struct <name>instr</name> *</type><name>instr</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<name><name>instr</name>-&gt;<name>i_hasarg</name></name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>	<comment type="block">/* 1 byte for the opcode*/</comment>
	<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_oparg</name></name> &gt; 0xffff</expr>)</condition><then>
		<return>return <expr>6</expr>;</return></then></if>	<comment type="block">/* 1 (opcode) + 1 (EXTENDED_ARG opcode) + 2 (oparg) + 2(oparg extended) */</comment>
	<return>return <expr>3</expr>;</return> 		<comment type="block">/* 1 (opcode) + 2 (oparg) */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>blocksize</name><parameter_list>(<param><decl><type><name>basicblock</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><name>size</name> += <call><name>instrsize</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<return>return <expr><name>size</name></expr>;</return>
}</block></function>

<comment type="block">/* All about a_lnotab.

c_lnotab is an array of unsigned bytes disguised as a Python string.
It is used to map bytecode offsets to source code line #s (when needed
for tracebacks).

The array is conceptually a list of
    (bytecode offset increment, line number increment)
pairs.	The details are important and delicate, best illustrated by example:

    byte code offset	source code line number
	0		    1
	6		    2
       50		    7
      350		  307
      361		  308

The first trick is that these numbers aren't stored, only the increments
from one row to the next (this doesn't really work, but it's a start):

    0, 1,  6, 1,  44, 5,  300, 300,  11, 1

The second trick is that an unsigned byte can't hold negative values, or
values larger than 255, so (a) there's a deep assumption that byte code
offsets and their corresponding line #s both increase monotonically, and (b)
if at least one column jumps by more than 255 from one row to the next, more
than one pair is written to the table. In case #b, there's no way to know
from looking at the table later how many were written.	That's the delicate
part.  A user of c_lnotab desiring to find the source line number
corresponding to a bytecode address A should do something like this

    lineno = addr = 0
    for addr_incr, line_incr in c_lnotab:
	addr += addr_incr
	if addr &gt; A:
	    return lineno
	lineno += line_incr

In order for this to work, when the addr field increments by more than 255,
the line # increment in each pair generated must be 0 until the remaining addr
increment is &lt; 256.  So, in the example above, assemble_lnotab (it used
to be called com_set_lineno) should not (as was actually done until 2.2)
expand 300, 300 to 255, 255, 45, 45, 
	    but to 255,	  0, 45, 255, 0, 45.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>assemble_lnotab</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>, <param><decl><type>struct <name>instr</name> *</type><name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>d_bytecode</name></decl>, <decl><type ref="prev"/><name>d_lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>lnotab</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>d_bytecode</name> = <name><name>a</name>-&gt;<name>a_offset</name></name> - <name><name>a</name>-&gt;<name>a_lineno_off</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>d_lineno</name> = <name><name>i</name>-&gt;<name>i_lineno</name></name> - <name><name>a</name>-&gt;<name>a_lineno</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d_bytecode</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d_lineno</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if<condition>(<expr><name>d_bytecode</name> == 0 &amp;&amp; <name>d_lineno</name> == 0</expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<if>if <condition>(<expr><name>d_bytecode</name> &gt; 255</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>nbytes</name></decl>, <decl><type ref="prev"/><name>ncodes</name> <init>= <expr><name>d_bytecode</name> / 255</expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>nbytes</name> = <name><name>a</name>-&gt;<name>a_lnotab_off</name></name> + 2 * <name>ncodes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>nbytes</name> &gt;= <name>len</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>len</name> &lt;= <name>INT_MAX</name> / 2) &amp;&amp; (<name>len</name> * 2 &lt; <name>nbytes</name>)</expr>)</condition><then>
				<expr_stmt><expr><name>len</name> = <name>nbytes</name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name>len</name> &lt;= <name>INT_MAX</name> / 2</expr>)</condition><then>
				<expr_stmt><expr><name>len</name> *= 2</expr>;</expr_stmt></then>
			<else>else <block>{
				<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></else></if></else></if>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>lnotab</name> = (<name>unsigned</name> <name>char</name> *)
			   <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call> + <name><name>a</name>-&gt;<name>a_lnotab_off</name></name></expr>;</expr_stmt>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>ncodes</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<expr_stmt><expr>*<name>lnotab</name>++ = 255</expr>;</expr_stmt>
			<expr_stmt><expr>*<name>lnotab</name>++ = 0</expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><name>d_bytecode</name> -= <name>ncodes</name> * 255</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lnotab_off</name></name> += <name>ncodes</name> * 2</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d_bytecode</name> &lt;= 255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>d_lineno</name> &gt; 255</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>nbytes</name></decl>, <decl><type ref="prev"/><name>ncodes</name> <init>= <expr><name>d_lineno</name> / 255</expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>nbytes</name> = <name><name>a</name>-&gt;<name>a_lnotab_off</name></name> + 2 * <name>ncodes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>nbytes</name> &gt;= <name>len</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>len</name> &lt;= <name>INT_MAX</name> / 2) &amp;&amp; <name>len</name> * 2 &lt; <name>nbytes</name></expr>)</condition><then>
				<expr_stmt><expr><name>len</name> = <name>nbytes</name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name>len</name> &lt;= <name>INT_MAX</name> / 2</expr>)</condition><then>
				<expr_stmt><expr><name>len</name> *= 2</expr>;</expr_stmt></then>
			<else>else <block>{
				<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></else></if></else></if>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>lnotab</name> = (<name>unsigned</name> <name>char</name> *)
			   <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call> + <name><name>a</name>-&gt;<name>a_lnotab_off</name></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>lnotab</name>++ = <name>d_bytecode</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>lnotab</name>++ = 255</expr>;</expr_stmt>
		<expr_stmt><expr><name>d_bytecode</name> = 0</expr>;</expr_stmt>
		<for>for (<init><expr><name>j</name> = 1</expr>;</init> <condition><expr><name>j</name> &lt; <name>ncodes</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<expr_stmt><expr>*<name>lnotab</name>++ = 0</expr>;</expr_stmt>
			<expr_stmt><expr>*<name>lnotab</name>++ = 255</expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><name>d_lineno</name> -= <name>ncodes</name> * 255</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lnotab_off</name></name> += <name>ncodes</name> * 2</expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>a_lnotab_off</name></name> + 2 &gt;= <name>len</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>, <argument><expr><name>len</name> * 2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>lnotab</name> = (<name>unsigned</name> <name>char</name> *)
			<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call> + <name><name>a</name>-&gt;<name>a_lnotab_off</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lnotab_off</name></name> += 2</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>d_bytecode</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>lnotab</name>++ = <name>d_bytecode</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>lnotab</name>++ = <name>d_lineno</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{	<comment type="block">/* First line of a block; def stmt, etc. */</comment>
		<expr_stmt><expr>*<name>lnotab</name>++ = 0</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>lnotab</name>++ = <name>d_lineno</name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lineno</name></name> = <name><name>i</name>-&gt;<name>i_lineno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>a_lineno_off</name></name> = <name><name>a</name>-&gt;<name>a_offset</name></name></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* assemble_emit()
   Extend the bytecode with a new instruction.
   Update lnotab if necessary.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>assemble_emit</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>, <param><decl><type>struct <name>instr</name> *</type><name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>arg</name> <init>= <expr>0</expr></init>, <name>ext</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>code</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> = <call><name>instrsize</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>i</name>-&gt;<name>i_hasarg</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>arg</name> = <name><name>i</name>-&gt;<name>i_oparg</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ext</name> = <name>arg</name> &gt;&gt; 16</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>i</name>-&gt;<name>i_lineno</name></name> &amp;&amp; !<call><name>assemble_lnotab</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>a</name>-&gt;<name>a_offset</name></name> + <name>size</name> &gt;= <name>len</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>len</name> &gt; <name>PY_SSIZE_T_MAX</name> / 2</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>, <argument><expr><name>len</name> * 2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		    <return>return <expr>0</expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>code</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>)</argument_list></call> + <name><name>a</name>-&gt;<name>a_offset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name>-&gt;<name>a_offset</name></name> += <name>size</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> == 6</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>i</name>-&gt;<name>i_hasarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>code</name>++ = (<name>char</name>)<name>EXTENDED_ARG</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>code</name>++ = <name>ext</name> &amp; 0xff</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>code</name>++ = <name>ext</name> &gt;&gt; 8</expr>;</expr_stmt>
		<expr_stmt><expr><name>arg</name> &amp;= 0xffff</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr>*<name>code</name>++ = <name><name>i</name>-&gt;<name>i_opcode</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>i</name>-&gt;<name>i_hasarg</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> == 3 || <name>size</name> == 6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>code</name>++ = <name>arg</name> &amp; 0xff</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>code</name>++ = <name>arg</name> &gt;&gt; 8</expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assemble_jump_offsets</name><parameter_list>(<param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>, <param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bsize</name></decl>, <decl><type ref="prev"/><name>totsize</name></decl>, <decl><type ref="prev"/><name>extended_arg_count</name></decl>, <decl><type ref="prev"/><name>last_extended_arg_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Compute the size of each block and fixup jump args.
	   Replace block pointer with position in bytecode. */</comment>
<label><name>start</name>:</label>
	<expr_stmt><expr><name>totsize</name> = 0</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name><name>a</name>-&gt;<name>a_nblocks</name></name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
		<expr_stmt><expr><name>b</name> = <name><name>a</name>-&gt;<name>a_postorder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bsize</name> = <call><name>blocksize</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b</name>-&gt;<name>b_offset</name></name> = <name>totsize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totsize</name> += <name>bsize</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name>extended_arg_count</name> = 0</expr>;</expr_stmt>
	<for>for (<init><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_blocks</name></name></expr>;</init> <condition><expr><name>b</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>b</name> = <name><name>b</name>-&gt;<name>b_list</name></name></expr></incr>) <block>{
		<expr_stmt><expr><name>bsize</name> = <name><name>b</name>-&gt;<name>b_offset</name></name></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type>struct <name>instr</name> *</type><name>instr</name> <init>= <expr>&amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Relative jumps are computed relative to
			   the instruction pointer after fetching
			   the jump instruction.
			*/</comment>
			<expr_stmt><expr><name>bsize</name> += <call><name>instrsize</name><argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_jabs</name></name></expr>)</condition><then>
				<expr_stmt><expr><name><name>instr</name>-&gt;<name>i_oparg</name></name> = <name><name>instr</name>-&gt;<name>i_target</name>-&gt;<name>b_offset</name></name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_jrel</name></name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name><name>instr</name>-&gt;<name>i_target</name>-&gt;<name>b_offset</name></name> - <name>bsize</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>instr</name>-&gt;<name>i_oparg</name></name> = <name>delta</name></expr>;</expr_stmt>
			}</block></then>
			<else>else
				<continue>continue;</continue></else></if></else></if>
			<if>if <condition>(<expr><name><name>instr</name>-&gt;<name>i_oparg</name></name> &gt; 0xffff</expr>)</condition><then>
				<expr_stmt><expr><name>extended_arg_count</name>++</expr>;</expr_stmt></then></if>
		}</block></for>
	}</block></for>

	<comment type="block">/* XXX: This is an awful hack that could hurt performance, but
		on the bright side it should work until we come up
		with a better solution.

		In the meantime, should the goto be dropped in favor
		of a loop?

		The issue is that in the first loop blocksize() is called
		which calls instrsize() which requires i_oparg be set
		appropriately.	There is a bootstrap problem because
		i_oparg is calculated in the second loop above.

		So we loop until we stop seeing new EXTENDED_ARGs.
		The only EXTENDED_ARGs that could be popping up are
		ones in jump instructions.  So this should converge
		fairly quickly.
	*/</comment>
	<if>if <condition>(<expr><name>last_extended_arg_count</name> != <name>extended_arg_count</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>last_extended_arg_count</name> = <name>extended_arg_count</name></expr>;</expr_stmt>
		<goto>goto <name>start</name>;</goto>
	}</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dict_keys_inorder</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pos</name> <init>= <expr>0</expr></init>, <name>size</name> <init>= <expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<expr_stmt><expr><name>i</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>i</name> - <name>offset</name>) &lt; <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>i</name> - <name>offset</name>) &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name> - <name>offset</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>tuple</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compute_code_flags</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySTEntryObject</name> *</type><name>ste</name> <init>= <expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_ste</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr>0</expr></init>, <name>n</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_type</name></name> != <name>ModuleBlock</name></expr>)</condition><then>
		<expr_stmt><expr><name>flags</name> |= <name>CO_NEWLOCALS</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_type</name></name> == <name>FunctionBlock</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<name><name>ste</name>-&gt;<name>ste_unoptimized</name></name></expr>)</condition><then>
			<expr_stmt><expr><name>flags</name> |= <name>CO_OPTIMIZED</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_nested</name></name></expr>)</condition><then>
			<expr_stmt><expr><name>flags</name> |= <name>CO_NESTED</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_generator</name></name></expr>)</condition><then>
			<expr_stmt><expr><name>flags</name> |= <name>CO_GENERATOR</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_varargs</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>flags</name> |= <name>CO_VARARGS</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_varkeywords</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>flags</name> |= <name>CO_VARKEYWORDS</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>ste</name>-&gt;<name>ste_generator</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>flags</name> |= <name>CO_GENERATOR</name></expr>;</expr_stmt></then></if>

	<comment type="block">/* (Only) inherit compilerflags in PyCF_MASK */</comment>
	<expr_stmt><expr><name>flags</name> |= (<name><name>c</name>-&gt;<name>c_flags</name>-&gt;<name>cf_flags</name></name> &amp; <name>PyCF_MASK</name>)</expr>;</expr_stmt>

	<expr_stmt><expr><name>n</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_freevars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
	    <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>n</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	    <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>flags</name> |= <name>CO_NOFREE</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>

	<return>return <expr><name>flags</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>makecode</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type>struct <name>assembler</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>consts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>varnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>freevars</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>cellvars</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>bytecode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nlocals</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tmp</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_consts</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>consts</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* optimize_code requires a list */</comment>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>names</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_names</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>varnames</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_varnames</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>consts</name> || !<name>names</name> || !<name>varnames</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
      
	<expr_stmt><expr><name>cellvars</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_cellvars</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>cellvars</name></expr>)</condition><then>
	    <goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>freevars</name> = <call><name>dict_keys_inorder</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_freevars</name></name></expr></argument>, <argument><expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>cellvars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>freevars</name></expr>)</condition><then>
	    <goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>filename</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>c_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>filename</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><name>nlocals</name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_varnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flags</name> = <call><name>compute_code_flags</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>flags</name> &lt; 0</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><name>bytecode</name> = <call><name>PyCode_Optimize</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>a_bytecode</name></name></expr></argument>, <argument><expr><name>consts</name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>bytecode</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><name>tmp</name> = <call><name>PyList_AsTuple</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* PyCode_New requires a tuple */</comment>
	<if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>consts</name> = <name>tmp</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>co</name> = <call><name>PyCode_New</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_argcount</name></name></expr></argument>, <argument><expr><name>nlocals</name></expr></argument>, <argument><expr><call><name>stackdepth</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
			<argument><expr><name>bytecode</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><name>varnames</name></expr></argument>,
			<argument><expr><name>freevars</name></expr></argument>, <argument><expr><name>cellvars</name></expr></argument>,
			<argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_name</name></name></expr></argument>,
			<argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name></expr></argument>,
			<argument><expr><name><name>a</name>-&gt;<name>a_lnotab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>varnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>freevars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>cellvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>co</name></expr>;</return>
}</block></function>


<comment type="block">/* For debugging purposes only */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static void
dump_instr(const struct instr *i)
{
	const char *jrel = i-&gt;i_jrel ? "jrel " : "";
	const char *jabs = i-&gt;i_jabs ? "jabs " : "";
	char arg[128];

	*arg = '\0';
	if (i-&gt;i_hasarg)
		sprintf(arg, "arg: %d ", i-&gt;i_oparg);

	fprintf(stderr, "line: %d, opcode: %d %s%s%s\n", 
			i-&gt;i_lineno, i-&gt;i_opcode, arg, jabs, jrel);
}

static void
dump_basicblock(const basicblock *b)
{
	const char *seen = b-&gt;b_seen ? "seen " : "";
	const char *b_return = b-&gt;b_return ? "return " : "";
	fprintf(stderr, "used: %d, depth: %d, offset: %d %s%s\n",
		b-&gt;b_iused, b-&gt;b_startdepth, b-&gt;b_offset, seen, b_return);
	if (b-&gt;b_instr) {
		int i;
		for (i = 0; i &lt; b-&gt;b_iused; i++) {
			fprintf(stderr, "  [%02d] ", i);
			dump_instr(b-&gt;b_instr + i);
		}
	}
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>assemble</name><parameter_list>(<param><decl><type>struct <name>compiler</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>addNone</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>basicblock</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>entryblock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>assembler</name></type> <name>a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure every block that falls off the end returns None.
	   XXX NEXT_BLOCK() isn't quite right, because if the last
	   block ends with a jump or return b_next shouldn't set.
	 */</comment>
	<if>if <condition>(<expr>!<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_curblock</name>-&gt;<name>b_return</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>NEXT_BLOCK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>addNone</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>ADDOP_O</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>LOAD_CONST</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>consts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>ADDOP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>nblocks</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>entryblock</name> = <name>NULL</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>b</name> = <name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_blocks</name></name></expr>;</init> <condition><expr><name>b</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>b</name> = <name><name>b</name>-&gt;<name>b_list</name></name></expr></incr>) <block>{
		<expr_stmt><expr><name>nblocks</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>entryblock</name> = <name>b</name></expr>;</expr_stmt> 
	}</block></for>

	<comment type="block">/* Set firstlineno if it wasn't explicitly set. */</comment>
	<if>if <condition>(<expr>!<name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>entryblock</name> &amp;&amp; <name><name>entryblock</name>-&gt;<name>b_instr</name></name></expr>)</condition><then>
			<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name> = <name><name>entryblock</name>-&gt;<name>b_instr</name>-&gt;<name>i_lineno</name></name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name> = 1</expr>;</expr_stmt></else></if>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>assemble_init</name><argument_list>(<argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>u</name>-&gt;<name>u_firstlineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><call><name>dfs</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>entryblock</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't modify the bytecode after computing jump offsets. */</comment>
	<expr_stmt><expr><call><name>assemble_jump_offsets</name><argument_list>(<argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Emit code in reverse postorder from dfs. */</comment>
	<for>for (<init><expr><name>i</name> = <name><name>a</name>.<name>a_nblocks</name></name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
		<expr_stmt><expr><name>b</name> = <name><name>a</name>.<name>a_postorder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>b</name>-&gt;<name>b_iused</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
			<if>if <condition>(<expr>!<call><name>assemble_emit</name><argument_list>(<argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>b_instr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if></for>
	}</block></for>

	<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>.<name>a_lnotab</name></name></expr></argument>, <argument><expr><name><name>a</name>.<name>a_lnotab_off</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name><name>a</name>.<name>a_bytecode</name></name></expr></argument>, <argument><expr><name><name>a</name>.<name>a_offset</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><name>co</name> = <call><name>makecode</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>assemble_free</name><argument_list>(<argument><expr>&amp;<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>co</name></expr>;</return>
}</block></function>
</unit>
