<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_codecsmodule.c"><comment type="block">/* ------------------------------------------------------------------------

   _codecs -- Provides access to the codec registry and the builtin
              codecs.

   This module should never be imported directly. The standard library
   module "codecs" wraps this builtin module for use within Python.

   The codec registry is accessible via:

     register(search_function) -&gt; None

     lookup(encoding) -&gt; CodecInfo object

   The builtin Unicode codecs use the following interface:

     &lt;encoding&gt;_encode(Unicode_object[,errors='strict']) -&gt;
     	(string object, bytes consumed)

     &lt;encoding&gt;_decode(char_buffer_obj[,errors='strict']) -&gt;
        (Unicode object, bytes consumed)

   &lt;encoding&gt;_encode() interfaces also accept non-Unicode object as
   input. The objects are then converted to Unicode using
   PyUnicode_FromObject() prior to applying the conversion.

   These &lt;encoding&gt;s are available: utf_8, unicode_escape,
   raw_unicode_escape, unicode_internal, latin_1, ascii (7-bit),
   mbcs (on win32).


Written by Marc-Andre Lemburg (mal@lemburg.com).

Copyright (c) Corporation for National Research Initiatives.

   ------------------------------------------------------------------------ */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<comment type="block">/* --- Registry ----------------------------------------------------------- */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>register__doc__</name></expr></argument>,
<argument><expr>"register(search_function)\n\
\n\
Register a codec search function. Search functions are expected to take\n\
one argument, the encoding name in all lower case letters, and return\n\
a tuple of functions (encoder, decoder, stream_reader, stream_writer)\n\
(or a CodecInfo object)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>codec_register</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>search_function</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PyCodec_Register</name><argument_list>(<argument><expr><name>search_function</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lookup__doc__</name></expr></argument>,
<argument><expr>"lookup(encoding) -&gt; CodecInfo\n\
\n\
Looks up a codec tuple in the Python codec registry and returns\n\
a tuple of function (or a CodecInfo object)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>codec_lookup</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>encoding</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:lookup"</expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr><call><name>_PyCodec_Lookup</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>encode__doc__</name></expr></argument>,
<argument><expr>"encode(obj, [encoding[,errors]]) -&gt; object\n\
\n\
Encodes obj using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a ValueError. Other possible values are 'ignore', 'replace' and\n\
'xmlcharrefreplace' as well as any other name registered with\n\
codecs.register_error that can handle ValueErrors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>codec_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|ss:encode"</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"no encoding specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Encode via the codec registry */</comment>
    <return>return <expr><call><name>PyCodec_Encode</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>decode__doc__</name></expr></argument>,
<argument><expr>"decode(obj, [encoding[,errors]]) -&gt; object\n\
\n\
Decodes obj using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a ValueError. Other possible values are 'ignore' and 'replace'\n\
as well as any other name registered with codecs.register_error that is\n\
able to handle ValueErrors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>codec_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|ss:decode"</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"no encoding specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Decode via the codec registry */</comment>
    <return>return <expr><call><name>PyCodec_Decode</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- Helpers ------------------------------------------------------------ */</comment>

<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>codec_tuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
		      <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"On"</expr></argument>, <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* --- String codecs ------------------------------------------------------ */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>escape_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	      <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#|z:escape_decode"</expr></argument>,
			  <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyString_DecodeEscape</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>escape_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	      <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!|z:escape_encode"</expr></argument>,
			      <argument><expr>&amp;<name>PyString_Type</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>str</name> = <call><name>PyString_Repr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* The string will be quoted. Unquote, similar to unicode-escape. */</comment>
	<expr_stmt><expr><name>buf</name> = <call><name>PyString_AS_STRING</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name>+1</expr></argument>, <argument><expr><name>len</name>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>len</name>-2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	
	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<comment type="block">/* --- Decoder ------------------------------------------------------------ */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_internal_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
			<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:unicode_internal_decode"</expr></argument>,
			  <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
    <else>else <block>{
	<if>if <condition>(<expr><call><name>PyObject_AsReadBuffer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>(const <name>void</name> **)&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>_PyUnicode_DecodeUnicodeInternal</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_7_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
             <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>decoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zi:utf_7_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_DecodeUTF7Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
					   <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_8_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>decoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zi:utf_8_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_DecodeUTF8Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
					   <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_16_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>decoded</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zi:utf_16_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt> <comment type="block">/* This is overwritten unless final is true. */</comment>
    <expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_DecodeUTF16Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
					<argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_16_le_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>decoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zi:utf_16_le_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt> <comment type="block">/* This is overwritten unless final is true. */</comment>
    <expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_DecodeUTF16Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
	<argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_16_be_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>decoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zi:utf_16_be_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt> <comment type="block">/* This is overwritten unless final is true. */</comment>
    <expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_DecodeUTF16Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
	<argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* This non-standard version also provides access to the byteorder
   parameter of the builtin UTF-16 codec.

   It returns a tuple (unicode, bytesread, byteorder) with byteorder
   being the value in effect at the end of data.

*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_16_ex_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode</name></decl>, *<decl><type ref="prev"/><name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zii:utf_16_ex_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt> <comment type="block">/* This is overwritten unless final is true. */</comment>
    <expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_DecodeUTF16Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
					<argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>tuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oni"</expr></argument>, <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>, <argument><expr><name>byteorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>tuple</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_32_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>decoded</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zi:utf_32_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt> <comment type="block">/* This is overwritten unless final is true. */</comment>
    <expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_DecodeUTF32Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
					<argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_32_le_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>decoded</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zi:utf_32_le_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt> <comment type="block">/* This is overwritten unless final is true. */</comment>
    <expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_DecodeUTF32Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
					<argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_32_be_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>decoded</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zi:utf_32_be_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt> <comment type="block">/* This is overwritten unless final is true. */</comment>
    <expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_DecodeUTF32Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
					<argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* This non-standard version also provides access to the byteorder
   parameter of the builtin UTF-32 codec.

   It returns a tuple (unicode, bytesread, byteorder) with byteorder
   being the value in effect at the end of data.

*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_32_ex_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode</name></decl>, *<decl><type ref="prev"/><name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zii:utf_32_ex_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt> <comment type="block">/* This is overwritten unless final is true. */</comment>
    <expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_DecodeUTF32Stateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
					<argument><expr>&amp;<name>byteorder</name></expr></argument>, <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>tuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oni"</expr></argument>, <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>, <argument><expr><name>byteorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>tuple</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_escape_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		     <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|z:unicode_escape_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_DecodeUnicodeEscape</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>raw_unicode_escape_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
			<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|z:raw_unicode_escape_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_DecodeRawUnicodeEscape</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>latin_1_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	       <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|z:latin_1_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_DecodeLatin1</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ascii_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	     <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|z:ascii_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_DecodeASCII</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>charmap_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	       <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>mapping</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zO:charmap_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>mapping</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>mapping</name> == <name>Py_None</name></expr>)</condition><then>
	<expr_stmt><expr><name>mapping</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_DecodeCharmap</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mbcs_decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>consumed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>decoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|zi:mbcs_decode"</expr></argument>,
			  <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>consumed</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_DecodeMBCSStateful</name><argument_list>(<argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>len</name></name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
					   <argument><expr><name>final</name> ? <name>NULL</name> : &amp;<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<comment type="block">/* --- Encoder ------------------------------------------------------------ */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>readbuffer_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		  <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#|z:readbuffer_encode"</expr></argument>,
			  <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>charbuffer_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		  <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#|z:charbuffer_encode"</expr></argument>,
			  <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_internal_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
			<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:unicode_internal_encode"</expr></argument>,
			  <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>data</name> = <call><name>PyUnicode_AS_DATA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> = <call><name>PyUnicode_GET_DATA_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
    <else>else <block>{
	<if>if <condition>(<expr><call><name>PyObject_AsReadBuffer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>(const <name>void</name> **)&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_7_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:utf_7_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeUTF7</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr>0</expr></argument>,
					 <argument><expr>0</expr></argument>,
					 <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_8_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:utf_8_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeUTF8</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* This version provides access to the byteorder parameter of the
   builtin UTF-16 codecs as optional third argument. It defaults to 0
   which means: use the native byte order and prepend the data with a
   BOM mark.

*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_16_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|zi:utf_16_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>byteorder</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeUTF16</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>errors</name></expr></argument>,
					  <argument><expr><name>byteorder</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_16_le_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:utf_16_le_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeUTF16</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><name>errors</name></expr></argument>,
					     <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_16_be_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:utf_16_be_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeUTF16</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>errors</name></expr></argument>,
					  <argument><expr>+1</expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* This version provides access to the byteorder parameter of the
   builtin UTF-32 codecs as optional third argument. It defaults to 0
   which means: use the native byte order and prepend the data with a
   BOM mark.

*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_32_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>byteorder</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|zi:utf_32_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>byteorder</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeUTF32</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>errors</name></expr></argument>,
					  <argument><expr><name>byteorder</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_32_le_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:utf_32_le_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeUTF32</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><name>errors</name></expr></argument>,
					     <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>utf_32_be_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		 <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:utf_32_be_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeUTF32</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>errors</name></expr></argument>,
					  <argument><expr>+1</expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_escape_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
		     <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:unicode_escape_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeUnicodeEscape</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>raw_unicode_escape_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
			<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:raw_unicode_escape_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeRawUnicodeEscape</name><argument_list>(
			       <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>latin_1_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	       <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:latin_1_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeLatin1</name><argument_list>(
			       <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ascii_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	     <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:ascii_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeASCII</name><argument_list>(
			       <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>charmap_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	     <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>mapping</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|zO:charmap_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>, <argument><expr>&amp;<name>mapping</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>mapping</name> == <name>Py_None</name></expr>)</condition><then>
	<expr_stmt><expr><name>mapping</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeCharmap</name><argument_list>(
			       <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><name>mapping</name></expr></argument>,
			       <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>charmap_build</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>map</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U:charmap_build"</expr></argument>, <argument><expr>&amp;<name>map</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>PyUnicode_BuildEncodingMap</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>mbcs_encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|z:mbcs_encode"</expr></argument>,
			  <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>codec_tuple</name><argument_list>(<argument><expr><call><name>PyUnicode_EncodeMBCS</name><argument_list>(
			       <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_USING_UNICODE */</comment>

<comment type="block">/* --- Error handler registry --------------------------------------------- */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>register_error__doc__</name></expr></argument>,
<argument><expr>"register_error(errors, handler)\n\
\n\
Register the specified error handler under the name\n\
errors. handler must be a callable object, that\n\
will be called with an exception instance containing\n\
information about the location of the encoding/decoding\n\
error and must return a (replacement, new position) tuple."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>register_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>handler</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"sO:register_error"</expr></argument>,
			  <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>handler</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>PyCodec_RegisterError</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lookup_error__doc__</name></expr></argument>,
<argument><expr>"lookup_error(errors) -&gt; handler\n\
\n\
Return the error handler for the specified error handling name\n\
or raise a LookupError, if no handler exists under this name."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>lookup_error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:lookup_error"</expr></argument>,
			  <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>PyCodec_LookupError</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- Module API --------------------------------------------------------- */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>_codecs_functions</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"register"</expr>,		<expr><name>codec_register</name></expr>,			<expr><name>METH_O</name></expr>,
        <expr><name>register__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"lookup"</expr>,			<expr><name>codec_lookup</name></expr>, 			<expr><name>METH_VARARGS</name></expr>,
        <expr><name>lookup__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"encode"</expr>,			<expr><name>codec_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>,
	<expr><name>encode__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"decode"</expr>,			<expr><name>codec_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>,
	<expr><name>decode__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"escape_encode"</expr>,		<expr><name>escape_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"escape_decode"</expr>,		<expr><name>escape_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
    <expr><block>{<expr>"utf_8_encode"</expr>,		<expr><name>utf_8_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_8_decode"</expr>,		<expr><name>utf_8_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_7_encode"</expr>,		<expr><name>utf_7_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_7_decode"</expr>,		<expr><name>utf_7_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_16_encode"</expr>,		<expr><name>utf_16_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_16_le_encode"</expr>,	<expr><name>utf_16_le_encode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_16_be_encode"</expr>,	<expr><name>utf_16_be_encode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_16_decode"</expr>,		<expr><name>utf_16_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_16_le_decode"</expr>,	<expr><name>utf_16_le_decode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_16_be_decode"</expr>,	<expr><name>utf_16_be_decode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_16_ex_decode"</expr>,	<expr><name>utf_16_ex_decode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_32_encode"</expr>,		<expr><name>utf_32_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_32_le_encode"</expr>,	<expr><name>utf_32_le_encode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_32_be_encode"</expr>,	<expr><name>utf_32_be_encode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_32_decode"</expr>,		<expr><name>utf_32_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_32_le_decode"</expr>,	<expr><name>utf_32_le_decode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_32_be_decode"</expr>,	<expr><name>utf_32_be_decode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"utf_32_ex_decode"</expr>,	<expr><name>utf_32_ex_decode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"unicode_escape_encode"</expr>,	<expr><name>unicode_escape_encode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"unicode_escape_decode"</expr>,	<expr><name>unicode_escape_decode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"unicode_internal_encode"</expr>,	<expr><name>unicode_internal_encode</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"unicode_internal_decode"</expr>,	<expr><name>unicode_internal_decode</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"raw_unicode_escape_encode"</expr>, <expr><name>raw_unicode_escape_encode</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"raw_unicode_escape_decode"</expr>, <expr><name>raw_unicode_escape_decode</name></expr>,	<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"latin_1_encode"</expr>, 		<expr><name>latin_1_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"latin_1_decode"</expr>, 		<expr><name>latin_1_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"ascii_encode"</expr>, 		<expr><name>ascii_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"ascii_decode"</expr>, 		<expr><name>ascii_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"charmap_encode"</expr>, 		<expr><name>charmap_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"charmap_decode"</expr>, 		<expr><name>charmap_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"charmap_build"</expr>, 		<expr><name>charmap_build</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"readbuffer_encode"</expr>,	<expr><name>readbuffer_encode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"charbuffer_encode"</expr>,	<expr><name>charbuffer_encode</name></expr>,		<expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><block>{<expr>"mbcs_encode"</expr>, 		<expr><name>mbcs_encode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
    <expr><block>{<expr>"mbcs_decode"</expr>, 		<expr><name>mbcs_decode</name></expr>,			<expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_USING_UNICODE */</comment>
    <expr><block>{<expr>"register_error"</expr>, 		<expr><name>register_error</name></expr>,			<expr><name>METH_VARARGS</name></expr>,
        <expr><name>register_error__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"lookup_error"</expr>, 		<expr><name>lookup_error</name></expr>,			<expr><name>METH_VARARGS</name></expr>,
        <expr><name>lookup_error__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_codecs</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>Py_InitModule</name><argument_list>(<argument><expr>"_codecs"</expr></argument>, <argument><expr><name>_codecs_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
