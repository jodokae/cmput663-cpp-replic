<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_collectionsmodule.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<comment type="block">/* collections module implementation of a deque() datatype
   Written and maintained by Raymond D. Hettinger &lt;python@rcn.com&gt;
   Copyright (c) 2004 Python Software Foundation.
   All rights reserved.
*/</comment>

<comment type="block">/* The block length may be set to any number over 1.  Larger numbers
 * reduce the number of calls to the memory allocator but take more
 * memory.  Ideally, BLOCKLEN should be set with an eye to the
 * length of a cache line.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCKLEN</name></cpp:macro> <cpp:value>62</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CENTER</name></cpp:macro> <cpp:value>((BLOCKLEN - 1) / 2)</cpp:value></cpp:define>

<comment type="block">/* A `dequeobject` is composed of a doubly-linked list of `block` nodes.
 * This list is not circular (the leftmost block has leftlink==NULL,
 * and the rightmost block has rightlink==NULL).  A deque d's first
 * element is at d.leftblock[leftindex] and its last element is at
 * d.rightblock[rightindex]; note that, unlike as for Python slice
 * indices, these indices are inclusive on both ends.  By being inclusive
 * on both ends, algorithms for left and right operations become
 * symmetrical which simplifies the design.
 *
 * The list of blocks is never empty, so d.leftblock and d.rightblock
 * are never equal to NULL.
 *
 * The indices, d.leftindex and d.rightindex are always in the range
 *     0 &lt;= index &lt; BLOCKLEN.
 * Their exact relationship is:
 *     (d.leftindex + d.len - 1) % BLOCKLEN == d.rightindex.
 *
 * Empty deques have d.len == 0; d.leftblock==d.rightblock;
 * d.leftindex == CENTER+1; and d.rightindex == CENTER.
 * Checking for d.len == 0 is the intended way to see whether d is empty.
 *
 * Whenever d.leftblock == d.rightblock,
 *     d.leftindex + d.len - 1 == d.rightindex.
 *
 * However, when d.leftblock != d.rightblock, d.leftindex and d.rightindex
 * become indices into distinct blocks and either may be larger than the
 * other.
 */</comment>

<typedef>typedef <type><struct>struct <name>BLOCK</name> <block>{
	<decl_stmt><decl><type>struct <name>BLOCK</name> *</type><name>leftlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>BLOCK</name> *</type><name>rightlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name><name>data</name><index>[<expr><name>BLOCKLEN</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>block</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXFREEBLOCKS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>Py_ssize_t</name></type> <name>numfreeblocks</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>block</name> *</type><name><name>freeblocks</name><index>[<expr><name>MAXFREEBLOCKS</name></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>block</name> *</type>
<name>newblock</name><parameter_list>(<param><decl><type><name>block</name> *</type><name>leftlink</name></decl></param>, <param><decl><type><name>block</name> *</type><name>rightlink</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>block</name> *</type><name>b</name></decl>;</decl_stmt>
	<comment type="block">/* To prevent len from overflowing PY_SSIZE_T_MAX on 64-bit machines, we
	 * refuse to allocate new blocks if the current len is dangerously
	 * close.  There is some extra margin to prevent spurious arithmetic
	 * overflows at various places.  The following check ensures that
	 * the blocks allocated to the deque, in the worst case, can only
	 * have PY_SSIZE_T_MAX-2 entries in total.
	 */</comment>
	<if>if <condition>(<expr><name>len</name> &gt;= <name>PY_SSIZE_T_MAX</name> - 2*<name>BLOCKLEN</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"cannot add more blocks to the deque"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>numfreeblocks</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>numfreeblocks</name> -= 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>b</name> = <name><name>freeblocks</name><index>[<expr><name>numfreeblocks</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>b</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></else></if>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>leftlink</name></name> = <name>leftlink</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>rightlink</name></name> = <name>rightlink</name></expr>;</expr_stmt>
	<return>return <expr><name>b</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>freeblock</name><parameter_list>(<param><decl><type><name>block</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>numfreeblocks</name> &lt; <name>MAXFREEBLOCKS</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>freeblocks</name><index>[<expr><name>numfreeblocks</name></expr>]</index></name> = <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numfreeblocks</name>++</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
}</block></function>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>block</name> *</type><name>leftblock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>block</name> *</type><name>rightblock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>leftindex</name></decl>;</decl_stmt>	<comment type="block">/* in range(BLOCKLEN) */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>rightindex</name></decl>;</decl_stmt>	<comment type="block">/* in range(BLOCKLEN) */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>state</name></decl>;</decl_stmt>	<comment type="block">/* incremented whenever the indices move */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>weakreflist</name></decl>;</decl_stmt> <comment type="block">/* List of weak references */</comment>
}</block></struct></type> <name>dequeobject</name>;</typedef>

<comment type="block">/* The deque's size limit is d.maxlen.  The limit can be zero or positive.
 * If there is no limit, then d.maxlen == -1.
 * 
 * After an item is added to a deque, we check to see if the size has grown past
 * the limit. If it has, we get the size back down to the limit by popping an
 * item off of the opposite end.  The methods that can trigger this are append(),
 * appendleft(), extend(), and extendleft().
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRIM</name><parameter_list>(<param><type><name>d</name></type></param>, <param><type><name>popfunction</name></type></param>)</parameter_list></cpp:macro>                               	\
    <cpp:value>if (d-&gt;maxlen != -1 &amp;&amp; d-&gt;len &gt; d-&gt;maxlen) {              	\
            PyObject *rv = popfunction(d, NULL);                \
            assert(rv != NULL  &amp;&amp;  d-&gt;len &lt;= d-&gt;maxlen);        \
            Py_DECREF(rv);                                      \
    }</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>deque_type</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>dequeobject</name> *</type><name>deque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>block</name> *</type><name>b</name></decl>;</decl_stmt>

	<comment type="block">/* create dequeobject structure */</comment>
	<expr_stmt><expr><name>deque</name> = (<name>dequeobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>deque</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>b</name> = <call><name>newblock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>BLOCKLEN</name> &gt;= 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> = <name>b</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightblock</name></name> = <name>b</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftindex</name></name> = <name>CENTER</name> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightindex</name></name> = <name>CENTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>len</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>state</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>maxlen</name></name> = -1</expr>;</expr_stmt>

	<return>return <expr>(<name>PyObject</name> *)<name>deque</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_pop</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>block</name> *</type><name>prevblock</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>len</name></name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"pop from an empty deque"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>item</name> = <name><name>deque</name>-&gt;<name>rightblock</name>-&gt;<name>data</name><index>[<expr><name><name>deque</name>-&gt;<name>rightindex</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightindex</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>len</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>state</name></name>++</expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>rightindex</name></name> == -1</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>len</name></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> == <name><name>deque</name>-&gt;<name>rightblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftindex</name></name> == <name><name>deque</name>-&gt;<name>rightindex</name></name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* re-center instead of freeing a block */</comment>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftindex</name></name> = <name>CENTER</name> + 1</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightindex</name></name> = <name>CENTER</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>prevblock</name> = <name><name>deque</name>-&gt;<name>rightblock</name>-&gt;<name>leftlink</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> != <name><name>deque</name>-&gt;<name>rightblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>freeblock</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>rightblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prevblock</name>-&gt;<name>rightlink</name></name> = <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightblock</name></name> = <name>prevblock</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightindex</name></name> = <name>BLOCKLEN</name> - 1</expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>
	<return>return <expr><name>item</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pop_doc</name></expr></argument>, <argument><expr>"Remove and return the rightmost element."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_popleft</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>block</name> *</type><name>prevblock</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>len</name></name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"pop from an empty deque"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> = <name><name>deque</name>-&gt;<name>leftblock</name>-&gt;<name>data</name><index>[<expr><name><name>deque</name>-&gt;<name>leftindex</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftindex</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>len</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>state</name></name>++</expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>leftindex</name></name> == <name>BLOCKLEN</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>len</name></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> == <name><name>deque</name>-&gt;<name>rightblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftindex</name></name> == <name><name>deque</name>-&gt;<name>rightindex</name></name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* re-center instead of freeing a block */</comment>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftindex</name></name> = <name>CENTER</name> + 1</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightindex</name></name> = <name>CENTER</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> != <name><name>deque</name>-&gt;<name>rightblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prevblock</name> = <name><name>deque</name>-&gt;<name>leftblock</name>-&gt;<name>rightlink</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>freeblock</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prevblock</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prevblock</name>-&gt;<name>leftlink</name></name> = <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> = <name>prevblock</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftindex</name></name> = 0</expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>
	<return>return <expr><name>item</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>popleft_doc</name></expr></argument>, <argument><expr>"Remove and return the leftmost element."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_append</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>state</name></name>++</expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>rightindex</name></name> == <name>BLOCKLEN</name>-1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>block</name> *</type><name>b</name> <init>= <expr><call><name>newblock</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>rightblock</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>deque</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>rightblock</name>-&gt;<name>rightlink</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightblock</name>-&gt;<name>rightlink</name></name> = <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightblock</name></name> = <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightindex</name></name> = -1</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>len</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightindex</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightblock</name>-&gt;<name>data</name><index>[<expr><name><name>deque</name>-&gt;<name>rightindex</name></name></expr>]</index></name> = <name>item</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRIM</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>deque_popleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>append_doc</name></expr></argument>, <argument><expr>"Add an element to the right side of the deque."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_appendleft</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>state</name></name>++</expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>leftindex</name></name> == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>block</name> *</type><name>b</name> <init>= <expr><call><name>newblock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name></expr></argument>, <argument><expr><name><name>deque</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name>-&gt;<name>leftlink</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftblock</name>-&gt;<name>leftlink</name></name> = <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> = <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftindex</name></name> = <name>BLOCKLEN</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>len</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftindex</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftblock</name>-&gt;<name>data</name><index>[<expr><name><name>deque</name>-&gt;<name>leftindex</name></name></expr>]</index></name> = <name>item</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRIM</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>deque_pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>appendleft_doc</name></expr></argument>, <argument><expr>"Add an element to the left side of the deque."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_extend</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>iterable</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<while>while <condition>(<expr>(<name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>state</name></name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>rightindex</name></name> == <name>BLOCKLEN</name>-1</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>block</name> *</type><name>b</name> <init>= <expr><call><name>newblock</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>rightblock</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					    <argument><expr><name><name>deque</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>rightblock</name>-&gt;<name>rightlink</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightblock</name>-&gt;<name>rightlink</name></name> = <name>b</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightblock</name></name> = <name>b</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightindex</name></name> = -1</expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>len</name></name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightindex</name></name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightblock</name>-&gt;<name>data</name><index>[<expr><name><name>deque</name>-&gt;<name>rightindex</name></name></expr>]</index></name> = <name>item</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRIM</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>deque_popleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               
	}</block></while>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>extend_doc</name></expr></argument>,
<argument><expr>"Extend the right side of the deque with elements from the iterable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_extendleft</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>iterable</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<while>while <condition>(<expr>(<name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>state</name></name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>leftindex</name></name> == 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>block</name> *</type><name>b</name> <init>= <expr><call><name>newblock</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name></expr></argument>,
					    <argument><expr><name><name>deque</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name>-&gt;<name>leftlink</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftblock</name>-&gt;<name>leftlink</name></name> = <name>b</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> = <name>b</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftindex</name></name> = <name>BLOCKLEN</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>len</name></name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftindex</name></name>--</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftblock</name>-&gt;<name>data</name><index>[<expr><name><name>deque</name>-&gt;<name>leftindex</name></name></expr>]</index></name> = <name>item</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRIM</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>deque_pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               
	}</block></while>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>extendleft_doc</name></expr></argument>,
<argument><expr>"Extend the left side of the deque with elements from the iterable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_deque_rotate</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name><init>=<expr><name><name>deque</name>-&gt;<name>len</name></name></expr></init>, <name>halflen</name><init>=<expr>(<name>len</name>+1)&gt;&gt;1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>rv</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<if>if <condition>(<expr><name>n</name> &gt; <name>halflen</name> || <name>n</name> &lt; -<name>halflen</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>n</name> %= <name>len</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> &gt; <name>halflen</name></expr>)</condition><then>
			<expr_stmt><expr><name>n</name> -= <name>len</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>n</name> &lt; -<name>halflen</name></expr>)</condition><then>
			<expr_stmt><expr><name>n</name> += <name>len</name></expr>;</expr_stmt></then></if></else></if>
	}</block></then></if>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>item</name> = <call><name>deque_pop</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>item</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> = <call><name>deque_appendleft</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rv</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&gt;<name>n</name></expr> ;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
		<expr_stmt><expr><name>item</name> = <call><name>deque_popleft</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>item</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> = <call><name>deque_append</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rv</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_rotate</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name><init>=<expr>1</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|n:rotate"</expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>_deque_rotate</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rotate_doc</name></expr></argument>,
<argument><expr>"Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>deque_len</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name><name>deque</name>-&gt;<name>len</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_remove</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name><init>=<expr><name><name>deque</name>-&gt;<name>len</name></name></expr></init></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><name><name>deque</name>-&gt;<name>leftblock</name>-&gt;<name>data</name><index>[<expr><name><name>deque</name>-&gt;<name>leftindex</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>len</name></name> != <name>n</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
				<argument><expr>"deque mutated during remove()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>tgt</name> <init>= <expr><call><name>deque_popleft</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>tgt</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>_deque_rotate</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>_deque_rotate</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if></else></if>
		<expr_stmt><expr><call><name>_deque_rotate</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"deque.remove(x): x not in deque"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>remove_doc</name></expr></argument>,
<argument><expr>"D.remove(value) -- remove first occurrence of value."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>deque_clear</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name><name>deque</name>-&gt;<name>len</name></name></expr>)</condition> <block>{
		<expr_stmt><expr><name>item</name> = <call><name>deque_pop</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>item</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> == <name><name>deque</name>-&gt;<name>rightblock</name></name> &amp;&amp;
	       <name><name>deque</name>-&gt;<name>leftindex</name></name> - 1 == <name><name>deque</name>-&gt;<name>rightindex</name></name> &amp;&amp;
	       <name><name>deque</name>-&gt;<name>len</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_item</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>block</name> *</type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>index</name><init>=<expr><name>i</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <name><name>deque</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
				<argument><expr>"deque index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name> = <name><name>deque</name>-&gt;<name>leftindex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>b</name> = <name><name>deque</name>-&gt;<name>leftblock</name></name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>i</name> == <name><name>deque</name>-&gt;<name>len</name></name> - 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name> = <name><name>deque</name>-&gt;<name>rightindex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>b</name> = <name><name>deque</name>-&gt;<name>rightblock</name></name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>i</name> += <name><name>deque</name>-&gt;<name>leftindex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <name>i</name> / <name>BLOCKLEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> %= <name>BLOCKLEN</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>index</name> &lt; (<name><name>deque</name>-&gt;<name>len</name></name> &gt;&gt; 1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>b</name> = <name><name>deque</name>-&gt;<name>leftblock</name></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>n</name>--</expr>)</condition>
				<expr_stmt><expr><name>b</name> = <name><name>b</name>-&gt;<name>rightlink</name></name></expr>;</expr_stmt></while>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>n</name> = (<name><name>deque</name>-&gt;<name>leftindex</name></name> + <name><name>deque</name>-&gt;<name>len</name></name> - 1) / <name>BLOCKLEN</name> - <name>n</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>b</name> = <name><name>deque</name>-&gt;<name>rightblock</name></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>n</name>--</expr>)</condition>
				<expr_stmt><expr><name>b</name> = <name><name>b</name>-&gt;<name>leftlink</name></name></expr>;</expr_stmt></while>
		}</block></else></if>
	}</block></else></if></else></if>
	<expr_stmt><expr><name>item</name> = <name><name>b</name>-&gt;<name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>item</name></expr>;</return>
}</block></function>

<comment type="block">/* delitem() implemented in terms of rotate for simplicity and reasonable
   performance near the end points.  If for some reason this method becomes
   popular, it is not hard to re-implement this using direct data movement
   (similar to code in list slice assignment) and achieve a two or threefold
   performance boost.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>deque_del_item</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>i</name> &gt;= 0 &amp;&amp; <name>i</name> &lt; <name><name>deque</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>_deque_rotate</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr>-<name>i</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<expr_stmt><expr><name>item</name> = <call><name>deque_popleft</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>item</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>_deque_rotate</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>deque_ass_item</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>block</name> *</type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>len</name><init>=<expr><name><name>deque</name>-&gt;<name>len</name></name></expr></init>, <name>halflen</name><init>=<expr>(<name>len</name>+1)&gt;&gt;1</expr></init>, <name>index</name><init>=<expr><name>i</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <name>len</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
				<argument><expr>"deque index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>deque_del_item</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>i</name> += <name><name>deque</name>-&gt;<name>leftindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <name>i</name> / <name>BLOCKLEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> %= <name>BLOCKLEN</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>index</name> &lt;= <name>halflen</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>b</name> = <name><name>deque</name>-&gt;<name>leftblock</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>n</name>--</expr>)</condition>
			<expr_stmt><expr><name>b</name> = <name><name>b</name>-&gt;<name>rightlink</name></name></expr>;</expr_stmt></while>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>n</name> = (<name><name>deque</name>-&gt;<name>leftindex</name></name> + <name>len</name> - 1) / <name>BLOCKLEN</name> - <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>b</name> = <name><name>deque</name>-&gt;<name>rightblock</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>n</name>--</expr>)</condition>
			<expr_stmt><expr><name>b</name> = <name><name>b</name>-&gt;<name>leftlink</name></name></expr>;</expr_stmt></while>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_value</name> = <name><name>b</name>-&gt;<name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>data</name><index>[<expr><name>i</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_clearmethod</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> = <call><name>deque_clear</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>rv</name> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>clear_doc</name></expr></argument>, <argument><expr>"Remove all elements from the deque."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>deque_dealloc</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>leftblock</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>deque_clear</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>freeblock</name><argument_list>(<argument><expr><name><name>deque</name>-&gt;<name>leftblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>leftblock</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>rightblock</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>deque_traverse</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>block</name> *</type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>indexlo</name> <init>= <expr><name><name>deque</name>-&gt;<name>leftindex</name></name></expr></init></decl>;</decl_stmt>

	<for>for (<init><expr><name>b</name> = <name><name>deque</name>-&gt;<name>leftblock</name></name></expr>;</init> <condition><expr><name>b</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>b</name> = <name><name>b</name>-&gt;<name>rightlink</name></name></expr></incr>) <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>indexhi</name> <init>= <expr><name>b</name> == <name><name>deque</name>-&gt;<name>rightblock</name></name> ?
					 <name><name>deque</name>-&gt;<name>rightindex</name></name> :
				    	 <name>BLOCKLEN</name> - 1</expr></init></decl>;</decl_stmt>

		<for>for (<init><expr><name>index</name> = <name>indexlo</name></expr>;</init> <condition><expr><name>index</name> &lt;= <name>indexhi</name></expr>;</condition> <incr><expr>++<name>index</name></expr></incr>) <block>{
			<expr_stmt><expr><name>item</name> = <name><name>b</name>-&gt;<name>data</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><name>indexlo</name> = 0</expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_copy</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>deque</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>((<name>dequeobject</name> *)<name>deque</name>)-&gt;<name>maxlen</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>deque</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"Oi"</expr></argument>,
			<argument><expr><name>deque</name></expr></argument>, <argument><expr>((<name>dequeobject</name> *)<name>deque</name>)-&gt;<name>maxlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>copy_doc</name></expr></argument>, <argument><expr>"Return a shallow copy of a deque."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_reduce</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>, *<decl><type ref="prev"/><name>aslist</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dict</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>deque</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>aslist</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>aslist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>maxlen</name></name> == -1</expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"O(O)"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"O(On)"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aslist</name></expr></argument>, <argument><expr><name><name>deque</name>-&gt;<name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then> <else>else <block>{
		<if>if <condition>(<expr><name><name>deque</name>-&gt;<name>maxlen</name></name> == -1</expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"O(OO)O"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aslist</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"O(On)O"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aslist</name></expr></argument>, <argument><expr><name><name>deque</name>-&gt;<name>maxlen</name></name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>aslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reduce_doc</name></expr></argument>, <argument><expr>"Return state information for pickling."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>deque</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>aslist</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>, *<decl><type ref="prev"/><name>fmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = <call><name>Py_ReprEnter</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"[...]"</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>aslist</name> = <call><name>PySequence_List</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>aslist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>((<name>dequeobject</name> *)<name>deque</name>)-&gt;<name>maxlen</name> != -1</expr>)</condition><then>
		<expr_stmt><expr><name>fmt</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"deque(%%r, maxlen=%zd)"</expr></argument>, 
					<argument><expr>((<name>dequeobject</name> *)<name>deque</name>)-&gt;<name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>fmt</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"deque(%r)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>  
	<if>if <condition>(<expr><name>fmt</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>aslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyString_Format</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>aslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>aslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>deque_tp_print</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>emit</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>	<comment type="block">/* No separator emitted on first pass */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>separator</name> <init>= <expr>", "</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> = <call><name>Py_ReprEnter</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>i</name></expr>;</return></then></if>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>fputs</name><argument_list>(<argument><expr>"[...]"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fputs</name><argument_list>(<argument><expr>"deque(["</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<while>while <condition>(<expr>(<name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
		<function_decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>fputs</name><parameter_list>(<param><decl><type><name>emit</name></type></decl></param>, <param><decl><type><name>fp</name></type></decl></param>)</parameter_list>;</function_decl>
		<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
		<name>emit</name> <init>= <expr><name>separator</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr>((<name>dequeobject</name> *)<name>deque</name>)-&gt;<name>maxlen</name> == -1</expr>)</condition><then>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"])"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"], maxlen=%" <name>PY_FORMAT_SIZE_T</name> "d)"</expr></argument>, <argument><expr>((<name>dequeobject</name> *)<name>deque</name>)-&gt;<name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_richcompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>it1</name><init>=<expr><name>NULL</name></expr></init>, *<name>it2</name><init>=<expr><name>NULL</name></expr></init>, *<name>x</name></decl>, *<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>vs</name></decl>, <decl><type ref="prev"/><name>ws</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>cmp</name><init>=<expr>-1</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>deque_type</name></expr></argument>)</argument_list></call> ||
	    !<call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>deque_type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Shortcuts */</comment>
	<expr_stmt><expr><name>vs</name> = ((<name>dequeobject</name> *)<name>v</name>)-&gt;<name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ws</name> = ((<name>dequeobject</name> *)<name>w</name>)-&gt;<name>len</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>v</name> == <name>w</name></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>vs</name> != <name>ws</name></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>op</name> == <name>Py_NE</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>v</name> == <name>w</name></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>vs</name> != <name>ws</name></expr>)</condition><then>
			<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then></if>
	}</block></then></if>

	<comment type="block">/* Search for the first index where items are different */</comment>
	<expr_stmt><expr><name>it1</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it1</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>done</name>;</goto></then></if>
	<expr_stmt><expr><name>it2</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it2</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>done</name>;</goto></then></if>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<expr_stmt><expr><name>x</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> == <name>NULL</name> &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<goto>goto <name>done</name>;</goto></then></if>
		<expr_stmt><expr><name>y</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <name>y</name> == <name>NULL</name></expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><name>b</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>b</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>done</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>b</name> == -1</expr>)</condition><then>
			<goto>goto <name>done</name>;</goto></then></if>
	}</block></for>
	<comment type="block">/* We reached the end of one deque or both */</comment>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<goto>goto <name>done</name>;</goto></then></if>
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
	<case>case <expr><name>Py_LT</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>y</name> != <name>NULL</name></expr>;</expr_stmt> <break>break;</break>  <comment type="block">/* if w was longer */</comment>
	</case><case>case <expr><name>Py_LE</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>x</name> == <name>NULL</name></expr>;</expr_stmt> <break>break;</break>  <comment type="block">/* if v was not longer */</comment>
	</case><case>case <expr><name>Py_EQ</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>x</name> == <name>y</name></expr>;</expr_stmt>    <break>break;</break>  <comment type="block">/* if we reached the end of both */</comment>
	</case><case>case <expr><name>Py_NE</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>x</name> != <name>y</name></expr>;</expr_stmt>    <break>break;</break>  <comment type="block">/* if one deque continues */</comment>
	</case><case>case <expr><name>Py_GT</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>x</name> != <name>NULL</name></expr>;</expr_stmt> <break>break;</break>  <comment type="block">/* if v was longer */</comment>
	</case><case>case <expr><name>Py_GE</name></expr>: <expr_stmt><expr><name>cmp</name> = <name>y</name> == <name>NULL</name></expr>;</expr_stmt> <break>break;</break>  <comment type="block">/* if w was not longer */</comment>
	</case>}</block></switch>

<label><name>done</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>it1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>it2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cmp</name> == 1</expr>)</condition><then>
		<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>deque_init</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwdargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>iterable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>maxlenobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxlen</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"iterable"</expr>, <expr>"maxlen"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwdargs</name></expr></argument>, <argument><expr>"|OO:deque"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>iterable</name></expr></argument>, <argument><expr>&amp;<name>maxlenobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>maxlenobj</name> != <name>NULL</name> &amp;&amp; <name>maxlenobj</name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>maxlen</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>maxlenobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>maxlen</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>maxlen</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"maxlen must be non-negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name><name>deque</name>-&gt;<name>maxlen</name></name> = <name>maxlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deque_clear</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>iterable</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name> <init>= <expr><call><name>deque_extend</name><argument_list>(<argument><expr><name>deque</name></expr></argument>, <argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>rv</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>deque_as_sequence</name> <init>= <expr><block>{
	<expr>(<name>lenfunc</name>)<name>deque_len</name></expr>,		<comment type="block">/* sq_length */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_concat */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_repeat */</comment>
	<expr>(<name>ssizeargfunc</name>)<name>deque_item</name></expr>,	<comment type="block">/* sq_item */</comment>
	<expr>0</expr>,				<comment type="block">/* sq_slice */</comment>
	<expr>(<name>ssizeobjargproc</name>)<name>deque_ass_item</name></expr>,	<comment type="block">/* sq_ass_item */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* deque object ********************************************************/</comment>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>deque_iter</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>deque_reviter</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>reversed_doc</name></expr></argument>,
	<argument><expr>"D.__reversed__() -- return a reverse iterator over the deque"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>deque_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"append"</expr>,		<expr>(<name>PyCFunction</name>)<name>deque_append</name></expr>,
		<expr><name>METH_O</name></expr>,		 <expr><name>append_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"appendleft"</expr>,		<expr>(<name>PyCFunction</name>)<name>deque_appendleft</name></expr>,
		<expr><name>METH_O</name></expr>,		 <expr><name>appendleft_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"clear"</expr>,		<expr>(<name>PyCFunction</name>)<name>deque_clearmethod</name></expr>,
		<expr><name>METH_NOARGS</name></expr>,	 <expr><name>clear_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__copy__"</expr>,		<expr>(<name>PyCFunction</name>)<name>deque_copy</name></expr>,
		<expr><name>METH_NOARGS</name></expr>,	 <expr><name>copy_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"extend"</expr>,		<expr>(<name>PyCFunction</name>)<name>deque_extend</name></expr>,
		<expr><name>METH_O</name></expr>,		 <expr><name>extend_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"extendleft"</expr>,		<expr>(<name>PyCFunction</name>)<name>deque_extendleft</name></expr>,
		<expr><name>METH_O</name></expr>,		 <expr><name>extendleft_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"pop"</expr>,			<expr>(<name>PyCFunction</name>)<name>deque_pop</name></expr>,
		<expr><name>METH_NOARGS</name></expr>,	 <expr><name>pop_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"popleft"</expr>,		<expr>(<name>PyCFunction</name>)<name>deque_popleft</name></expr>,
		<expr><name>METH_NOARGS</name></expr>,	 <expr><name>popleft_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__reduce__"</expr>,	<expr>(<name>PyCFunction</name>)<name>deque_reduce</name></expr>,
		<expr><name>METH_NOARGS</name></expr>,	 <expr><name>reduce_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"remove"</expr>,		<expr>(<name>PyCFunction</name>)<name>deque_remove</name></expr>,
		<expr><name>METH_O</name></expr>,		 <expr><name>remove_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__reversed__"</expr>,	<expr>(<name>PyCFunction</name>)<name>deque_reviter</name></expr>,
		<expr><name>METH_NOARGS</name></expr>,	 <expr><name>reversed_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"rotate"</expr>,		<expr>(<name>PyCFunction</name>)<name>deque_rotate</name></expr>,
		<expr><name>METH_VARARGS</name></expr>,	<expr><name>rotate_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>	<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>deque_doc</name></expr></argument>,
<argument><expr>"deque(iterable[, maxlen]) --&gt; deque object\n\
\n\
Build an ordered collection accessible from endpoints only."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>deque_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"collections.deque"</expr>,		<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>dequeobject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>deque_dealloc</name></expr>,	<comment type="block">/* tp_dealloc */</comment>
	<expr><name>deque_tp_print</name></expr>,			<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_compare */</comment>
	<expr><name>deque_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>deque_as_sequence</name></expr>,		<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>PyObject_HashNotImplemented</name></expr>,	<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,	<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
		<name>Py_TPFLAGS_HAVE_WEAKREFS</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>deque_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>deque_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>deque_clear</name></expr>,		<comment type="block">/* tp_clear */</comment>
	<expr>(<name>richcmpfunc</name>)<name>deque_richcompare</name></expr>,	<comment type="block">/* tp_richcompare */</comment>
	<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>dequeobject</name></expr></argument>, <argument><expr><name>weakreflist</name></expr></argument>)</argument_list></call></expr>,	<comment type="block">/* tp_weaklistoffset*/</comment>
	<expr>(<name>getiterfunc</name>)<name>deque_iter</name></expr>,	<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iternext */</comment>
	<expr><name>deque_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dictoffset */</comment>
	<expr>(<name>initproc</name>)<name>deque_init</name></expr>,		<comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,		<comment type="block">/* tp_alloc */</comment>
	<expr><name>deque_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_GC_Del</name></expr>,		<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*********************** Deque Iterator **************************/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>Py_ssize_t</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>block</name> *</type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dequeobject</name> *</type><name>deque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>state</name></decl>;</decl_stmt>	<comment type="block">/* state when the iterator is created */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>counter</name></decl>;</decl_stmt>    <comment type="block">/* number of items remaining for iteration */</comment>
}</block></struct></type> <name>dequeiterobject</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>dequeiter_type</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_iter</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>dequeiterobject</name> *</type><name>it</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>dequeiterobject</name></expr></argument>, <argument><expr>&amp;<name>dequeiter_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>b</name></name> = <name><name>deque</name>-&gt;<name>leftblock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>index</name></name> = <name><name>deque</name>-&gt;<name>leftindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>deque</name></name> = <name>deque</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>state</name></name> = <name><name>deque</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>counter</name></name> = <name><name>deque</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>it</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dequeiter_dealloc</name><parameter_list>(<param><decl><type><name>dequeiterobject</name> *</type><name>dio</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>dio</name>-&gt;<name>deque</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>dio</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>dio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dequeiter_next</name><parameter_list>(<param><decl><type><name>dequeiterobject</name> *</type><name>it</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>it</name>-&gt;<name>deque</name>-&gt;<name>state</name></name> != <name><name>it</name>-&gt;<name>state</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>it</name>-&gt;<name>counter</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"deque mutated during iteration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>it</name>-&gt;<name>counter</name></name> == 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>        
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr>!(<name><name>it</name>-&gt;<name>b</name></name> == <name><name>it</name>-&gt;<name>deque</name>-&gt;<name>rightblock</name></name> &amp;&amp;
		  <name><name>it</name>-&gt;<name>index</name></name> &gt; <name><name>it</name>-&gt;<name>deque</name>-&gt;<name>rightindex</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>item</name> = <name><name>it</name>-&gt;<name>b</name>-&gt;<name>data</name><index>[<expr><name><name>it</name>-&gt;<name>index</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>index</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>counter</name></name>--</expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>it</name>-&gt;<name>index</name></name> == <name>BLOCKLEN</name> &amp;&amp; <name><name>it</name>-&gt;<name>counter</name></name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>it</name>-&gt;<name>b</name>-&gt;<name>rightlink</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>it</name>-&gt;<name>b</name></name> = <name><name>it</name>-&gt;<name>b</name>-&gt;<name>rightlink</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>it</name>-&gt;<name>index</name></name> = 0</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>item</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dequeiter_len</name><parameter_list>(<param><decl><type><name>dequeiterobject</name> *</type><name>it</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>counter</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>length_hint_doc</name></expr></argument>, <argument><expr>"Private method returning an estimate of len(list(it))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>dequeiter_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__length_hint__"</expr>, <expr>(<name>PyCFunction</name>)<name>dequeiter_len</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>length_hint_doc</name></expr>}</block></expr>,
 	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>dequeiter_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"deque_iterator"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>dequeiterobject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>dequeiter_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,			<comment type="block">/* tp_flags */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr><name>PyObject_SelfIter</name></expr>,			<comment type="block">/* tp_iter */</comment>
	<expr>(<name>iternextfunc</name>)<name>dequeiter_next</name></expr>,		<comment type="block">/* tp_iternext */</comment>
	<expr><name>dequeiter_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*********************** Deque Reverse Iterator **************************/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>dequereviter_type</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>deque_reviter</name><parameter_list>(<param><decl><type><name>dequeobject</name> *</type><name>deque</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>dequeiterobject</name> *</type><name>it</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>dequeiterobject</name></expr></argument>, <argument><expr>&amp;<name>dequereviter_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>b</name></name> = <name><name>deque</name>-&gt;<name>rightblock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>index</name></name> = <name><name>deque</name>-&gt;<name>rightindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>deque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>deque</name></name> = <name>deque</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>state</name></name> = <name><name>deque</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>counter</name></name> = <name><name>deque</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>it</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dequereviter_next</name><parameter_list>(<param><decl><type><name>dequeiterobject</name> *</type><name>it</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>it</name>-&gt;<name>counter</name></name> == 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name><name>it</name>-&gt;<name>deque</name>-&gt;<name>state</name></name> != <name><name>it</name>-&gt;<name>state</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>it</name>-&gt;<name>counter</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"deque mutated during iteration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr>!(<name><name>it</name>-&gt;<name>b</name></name> == <name><name>it</name>-&gt;<name>deque</name>-&gt;<name>leftblock</name></name> &amp;&amp;
		  <name><name>it</name>-&gt;<name>index</name></name> &lt; <name><name>it</name>-&gt;<name>deque</name>-&gt;<name>leftindex</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>item</name> = <name><name>it</name>-&gt;<name>b</name>-&gt;<name>data</name><index>[<expr><name><name>it</name>-&gt;<name>index</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>index</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name>-&gt;<name>counter</name></name>--</expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>it</name>-&gt;<name>index</name></name> == -1 &amp;&amp; <name><name>it</name>-&gt;<name>counter</name></name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>it</name>-&gt;<name>b</name>-&gt;<name>leftlink</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>it</name>-&gt;<name>b</name></name> = <name><name>it</name>-&gt;<name>b</name>-&gt;<name>leftlink</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>it</name>-&gt;<name>index</name></name> = <name>BLOCKLEN</name> - 1</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>item</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>dequereviter_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"deque_reverse_iterator"</expr>,		<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>dequeiterobject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>dequeiter_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,			<comment type="block">/* tp_flags */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr><name>PyObject_SelfIter</name></expr>,			<comment type="block">/* tp_iter */</comment>
	<expr>(<name>iternextfunc</name>)<name>dequereviter_next</name></expr>,	<comment type="block">/* tp_iternext */</comment>
	<expr><name>dequeiter_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* defaultdict type *********************************************************/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyDictObject</name></type> <name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>default_factory</name></decl>;</decl_stmt>
}</block></struct></type> <name>defdictobject</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>defdict_type</name></decl>;</decl_stmt> <comment type="block">/* Forward */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>defdict_missing_doc</name></expr></argument>,
<argument><expr>"__missing__(key) # Called by __getitem__ for missing key; pseudo-code:\n\
  if self.default_factory is None: raise KeyError((key,))\n\
  self[key] = value = self.default_factory()\n\
  return value\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>defdict_missing</name><parameter_list>(<param><decl><type><name>defdictobject</name> *</type><name>dd</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>factory</name> <init>= <expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>factory</name> == <name>NULL</name> || <name>factory</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<comment type="block">/* XXX Call dict.__missing__(key) */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tup</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>tup</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>tup</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>value</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>factory</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>value</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyObject_SetItem</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dd</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>value</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>defdict_copy_doc</name></expr></argument>, <argument><expr>"D.copy() -&gt; a shallow copy of D."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>defdict_copy</name><parameter_list>(<param><decl><type><name>defdictobject</name> *</type><name>dd</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* This calls the object's class.  That only works for subclasses
	   whose class constructor has the same signature.  Subclasses that
	   define a different constructor signature must override copy().
	*/</comment>
	<return>return <expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></argument>, <argument><expr><name>dd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>defdict_reduce</name><parameter_list>(<param><decl><type><name>defdictobject</name> *</type><name>dd</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* __reduce__ must return a 5-tuple as follows:

	   - factory function
	   - tuple of args for the factory function
	   - additional state (here None)
	   - sequence iterator (here None)
	   - dictionary iterator (yielding successive (key, value) pairs

	   This API is used by pickle.py and copy.py.

	   For this to be useful with pickle.py, the default_factory
	   must be picklable; e.g., None, a built-in, or a global
	   function in a module or package.

	   Both shallow and deep copying are supported, but for deep
	   copying, the default_factory must be deep-copyable; e.g. None,
	   or a built-in (functions are not copyable at this time).

	   This only works for subclasses as long as their constructor
	   signature is compatible; the first argument must be the
	   optional default_factory, defaulting to None.
	*/</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>dd</name>-&gt;<name>default_factory</name></name> == <name>NULL</name> || <name><name>dd</name>-&gt;<name>default_factory</name></name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>items</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dd</name></expr></argument>, <argument><expr>"iteritems"</expr></argument>, <argument><expr>"()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>items</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>,
			      <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>defdict_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__missing__"</expr>, <expr>(<name>PyCFunction</name>)<name>defdict_missing</name></expr>, <expr><name>METH_O</name></expr>,
	 <expr><name>defdict_missing_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"copy"</expr>, <expr>(<name>PyCFunction</name>)<name>defdict_copy</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>defdict_copy_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__copy__"</expr>, <expr>(<name>PyCFunction</name>)<name>defdict_copy</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>defdict_copy_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__reduce__"</expr>, <expr>(<name>PyCFunction</name>)<name>defdict_reduce</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>reduce_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>defdict_members</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"default_factory"</expr>, <expr><name>T_OBJECT</name></expr>,
	 <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>defdictobject</name></expr></argument>, <argument><expr><name>default_factory</name></expr></argument>)</argument_list></call></expr>, <expr>0</expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Factory for default value called by __missing__()."</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>defdict_dealloc</name><parameter_list>(<param><decl><type><name>defdictobject</name> *</type><name>dd</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>PyDict_Type</name>.<name>tp_dealloc</name></name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>defdict_print</name><parameter_list>(<param><decl><type><name>defdictobject</name> *</type><name>dd</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>sts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"defaultdict("</expr></argument>)</argument_list></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name><name>dd</name>-&gt;<name>default_factory</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"None"</expr></argument>)</argument_list></decl>;</decl_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>sts</name> <init>= <expr><call><name><name>PyDict_Type</name>.<name>tp_print</name></name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dd</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>")"</expr></argument>)</argument_list></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<return>return <expr><name>sts</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>defdict_repr</name><parameter_list>(<param><decl><type><name>defdictobject</name> *</type><name>dd</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>defrepr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>baserepr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>baserepr</name> = <call><name><name>PyDict_Type</name>.<name>tp_repr</name></name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>baserepr</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>dd</name>-&gt;<name>default_factory</name></name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>defrepr</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"None"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
	<block>{
		<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>Py_ReprEnter</name><argument_list>(<argument><expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>status</name> != 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><name>defrepr</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"..."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>defrepr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_ReprLeave</name><argument_list>(<argument><expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>defrepr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>baserepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"defaultdict(%s, %s)"</expr></argument>,
				     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>defrepr</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>baserepr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>defrepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>baserepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>defdict_traverse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr>((<name>defdictobject</name> *)<name>self</name>)-&gt;<name>default_factory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name><name>PyDict_Type</name>.<name>tp_traverse</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>visit</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>defdict_tp_clear</name><parameter_list>(<param><decl><type><name>defdictobject</name> *</type><name>dd</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name><name>PyDict_Type</name>.<name>tp_clear</name></name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>defdict_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>defdictobject</name> *</type><name>dd</name> <init>= <expr>(<name>defdictobject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>olddefault</name> <init>= <expr><name><name>dd</name>-&gt;<name>default_factory</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newdefault</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name> || !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>newargs</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>newdefault</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>newdefault</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"first argument must be callable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>                           
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>newargs</name> = <call><name>PySequence_GetSlice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>newargs</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>newdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dd</name>-&gt;<name>default_factory</name></name> = <name>newdefault</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name><name>PyDict_Type</name>.<name>tp_init</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>olddefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>defdict_doc</name></expr></argument>,
<argument><expr>"defaultdict(default_factory) --&gt; dict with default factory\n\
\n\
The default factory is called without arguments to produce\n\
a new value when a key is not present, in __getitem__ only.\n\
A defaultdict compares equal to a dict with the same items.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* See comment in xxsubtype.c */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFERRED_ADDRESS</name><parameter_list>(<param><type><name>ADDR</name></type></param>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>defdict_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><call><name>DEFERRED_ADDRESS</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"collections.defaultdict"</expr>,	<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>defdictobject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>defdict_dealloc</name></expr>,	<comment type="block">/* tp_dealloc */</comment>
	<expr>(<name>printfunc</name>)<name>defdict_print</name></expr>,	<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>defdict_repr</name></expr>,		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,	       			<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,	<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
		<name>Py_TPFLAGS_HAVE_WEAKREFS</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>defdict_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
	<expr><name>defdict_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>defdict_tp_clear</name></expr>,	<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_weaklistoffset*/</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iternext */</comment>
	<expr><name>defdict_methods</name></expr>,		<comment type="block">/* tp_methods */</comment>
	<expr><name>defdict_members</name></expr>,		<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getset */</comment>
	<expr><call><name>DEFERRED_ADDRESS</name><argument_list>(<argument><expr>&amp;<name>PyDict_Type</name></expr></argument>)</argument_list></call></expr>,	<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dictoffset */</comment>
	<expr><name>defdict_init</name></expr>,			<comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,		<comment type="block">/* tp_alloc */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_GC_Del</name></expr>,		<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* module level code ********************************************************/</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"High performance data structures.\n\
- deque:        ordered collection accessible from endpoints only\n\
- defaultdict:  dict subclass with a default value factory\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_collections</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"_collections"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>deque_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>deque_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"deque"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>deque_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>defdict_type</name>.<name>tp_base</name></name> = &amp;<name>PyDict_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>defdict_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>defdict_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"defaultdict"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>defdict_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>dequeiter_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>dequereviter_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<return>return;</return>
}</block></function>
</unit>
