<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/gcmodule.c"><comment type="block">/*

  Reference Cycle Garbage Collection
  ==================================

  Neil Schemenauer &lt;nas@arctrix.com&gt;

  Based on a post on the python-dev list.  Ideas from Guido van Rossum,
  Eric Tiedemann, and various others.

  http://www.arctrix.com/nas/python/gc/
  http://www.python.org/pipermail/python-dev/2000-March/003869.html
  http://www.python.org/pipermail/python-dev/2000-March/004010.html
  http://www.python.org/pipermail/python-dev/2000-March/004022.html

  For a highlevel view of the collection process, read the collect
  function.

*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"frameobject.h"</cpp:file></cpp:include>	<comment type="block">/* for PyFrame_ClearFreeList */</comment>

<comment type="block">/* Get an object's GC head */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AS_GC</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((PyGC_Head *)(o)-1)</cpp:value></cpp:define>

<comment type="block">/* Get the object given the GC head */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FROM_GC</name><parameter_list>(<param><type><name>g</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((PyObject *)(((PyGC_Head *)g)+1))</cpp:value></cpp:define>

<comment type="block">/*** Global GC state ***/</comment>

<struct>struct <name>gc_generation</name> <block>{
	<decl_stmt><decl><type><name>PyGC_Head</name></type> <name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>threshold</name></decl>;</decl_stmt> <comment type="block">/* collection threshold */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt> <comment type="block">/* count of allocations or collections of younger
		      generations */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_GENERATIONS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_HEAD</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(&amp;generations[n].head)</cpp:value></cpp:define>

<comment type="block">/* linked lists of container objects */</comment>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>gc_generation</name></type> <name><name>generations</name><index>[<expr><name>NUM_GENERATIONS</name></expr>]</index></name> <init>= <expr><block>{
	<comment type="block">/* PyGC_Head,				threshold,	count */</comment>
	<expr><block>{<expr><block>{<expr><block>{<expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>}</block></expr>,	<expr>700</expr>,		<expr>0</expr>}</block></expr>,
	<expr><block>{<expr><block>{<expr><block>{<expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>, <expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>}</block></expr>,	<expr>10</expr>,		<expr>0</expr>}</block></expr>,
	<expr><block>{<expr><block>{<expr><block>{<expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>, <expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>}</block></expr>,	<expr>10</expr>,		<expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>_PyGC_generation0</name> <init>= <expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>enabled</name> <init>= <expr>1</expr></init></decl>;</decl_stmt> <comment type="block">/* automatic collection enabled? */</comment>

<comment type="block">/* true if we are currently running the collector */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>collecting</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/* list of uncollectable objects */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>garbage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Python string to use if unhandled exception occurs */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>gc_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Python string used to look for __del__ attribute. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>delstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* set for debugging information */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_STATS</name></cpp:macro>		<cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define> <comment type="block">/* print collection statistics */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_COLLECTABLE</name></cpp:macro>	<cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define> <comment type="block">/* print collectable objects */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_UNCOLLECTABLE</name></cpp:macro>	<cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define> <comment type="block">/* print uncollectable objects */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_INSTANCES</name></cpp:macro>		<cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define> <comment type="block">/* print instances */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_OBJECTS</name></cpp:macro>		<cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define> <comment type="block">/* print other objects */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_SAVEALL</name></cpp:macro>		<cpp:value>(1&lt;&lt;5)</cpp:value></cpp:define> <comment type="block">/* save all garbage in gc.garbage */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_LEAK</name></cpp:macro>		<cpp:value>DEBUG_COLLECTABLE | \
				DEBUG_UNCOLLECTABLE | \
				DEBUG_INSTANCES | \
				DEBUG_OBJECTS | \
				DEBUG_SAVEALL</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>debug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>tmod</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*--------------------------------------------------------------------------
gc_refs values.

Between collections, every gc'ed object has one of two gc_refs values:

GC_UNTRACKED
    The initial state; objects returned by PyObject_GC_Malloc are in this
    state.  The object doesn't live in any generation list, and its
    tp_traverse slot must not be called.

GC_REACHABLE
    The object lives in some generation list, and its tp_traverse is safe to
    call.  An object transitions to GC_REACHABLE when PyObject_GC_Track
    is called.

During a collection, gc_refs can temporarily take on other states:

&gt;= 0
    At the start of a collection, update_refs() copies the true refcount
    to gc_refs, for each object in the generation being collected.
    subtract_refs() then adjusts gc_refs so that it equals the number of
    times an object is referenced directly from outside the generation
    being collected.
    gc_refs remains &gt;= 0 throughout these steps.

GC_TENTATIVELY_UNREACHABLE
    move_unreachable() then moves objects not reachable (whether directly or
    indirectly) from outside the generation into an "unreachable" set.
    Objects that are found to be reachable have gc_refs set to GC_REACHABLE
    again.  Objects that are found to be unreachable have gc_refs set to
    GC_TENTATIVELY_UNREACHABLE.  It's "tentatively" because the pass doing
    this can't be sure until it ends, and GC_TENTATIVELY_UNREACHABLE may
    transition back to GC_REACHABLE.

    Only objects with GC_TENTATIVELY_UNREACHABLE still set are candidates
    for collection.  If it's decided not to collect such an object (e.g.,
    it has a __del__ method), its gc_refs is restored to GC_REACHABLE again.
----------------------------------------------------------------------------
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_UNTRACKED</name></cpp:macro>			<cpp:value>_PyGC_REFS_UNTRACKED</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_REACHABLE</name></cpp:macro>			<cpp:value>_PyGC_REFS_REACHABLE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_TENTATIVELY_UNREACHABLE</name></cpp:macro>	<cpp:value>_PyGC_REFS_TENTATIVELY_UNREACHABLE</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_TRACKED</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((AS_GC(o))-&gt;gc.gc_refs != GC_UNTRACKED)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_REACHABLE</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((AS_GC(o))-&gt;gc.gc_refs == GC_REACHABLE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_TENTATIVELY_UNREACHABLE</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( \
	(AS_GC(o))-&gt;gc.gc_refs == GC_TENTATIVELY_UNREACHABLE)</cpp:value></cpp:define>

<comment type="block">/*** list functions ***/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gc_list_init</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name><name>list</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name>list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>list</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>gc_list_is_empty</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>(<name><name>list</name>-&gt;<name>gc</name>.<name>gc_next</name></name> == <name>list</name>)</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="block">/* This became unused after gc_list_move() was introduced. */</comment>
<comment type="block">/* Append `node` to `list`. */</comment>
static void
gc_list_append(PyGC_Head *node, PyGC_Head *list)
{
	node-&gt;gc.gc_next = list;
	node-&gt;gc.gc_prev = list-&gt;gc.gc_prev;
	node-&gt;gc.gc_prev-&gt;gc.gc_next = node;
	list-&gt;gc.gc_prev = node;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Remove `node` from the gc list it's currently in. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gc_list_remove</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_prev</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name><name>node</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* object is not currently tracked */</comment>
}</block></function>

<comment type="block">/* Move `node` from the gc list it's currently in (which is not explicitly
 * named here) to the end of `list`.  This is semantically the same as
 * gc_list_remove(node) followed by gc_list_append(node, list).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gc_list_move</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>node</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>new_prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>current_prev</name> <init>= <expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>current_next</name> <init>= <expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Unlink from current list. */</comment>
	<expr_stmt><expr><name><name>current_prev</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>current_next</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_next</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name>current_prev</name></expr>;</expr_stmt>
	<comment type="block">/* Relink at end of new list. */</comment>
	<expr_stmt><expr><name>new_prev</name> = <name><name>node</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name><name>list</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_prev</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name><name>list</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>list</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* append list `from` onto list `to`; `from` becomes an empty list */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gc_list_merge</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>from</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>to</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>tail</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>from</name> != <name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>gc_list_is_empty</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>tail</name> = <name><name>to</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tail</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name><name>from</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tail</name>-&gt;<name>gc</name>.<name>gc_next</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name>tail</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>to</name>-&gt;<name>gc</name>.<name>gc_prev</name></name> = <name><name>from</name>-&gt;<name>gc</name>.<name>gc_prev</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>to</name>-&gt;<name>gc</name>.<name>gc_prev</name>-&gt;<name>gc</name>.<name>gc_next</name></name> = <name>to</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>gc_list_init</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>gc_list_size</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<for>for (<init><expr><name>gc</name> = <name><name>list</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>list</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
		<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>n</name></expr>;</return>
}</block></function>

<comment type="block">/* Append objects in a GC list to a Python list.
 * Return 0 if all OK, &lt; 0 if error (out of memory for list).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>append_objects</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>py_list</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>gc_list</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>gc</name> = <name><name>gc_list</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>gc_list</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>op</name> != <name>py_list</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>py_list</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<return>return <expr>-1</expr>;</return> <comment type="block">/* exception */</comment>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*** end of list stuff ***/</comment>


<comment type="block">/* Set all gc_refs = ob_refcnt.  After this, gc_refs is &gt; 0 for all objects
 * in containers, and is GC_REACHABLE for all tracked gc objects not in
 * containers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_refs</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>containers</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>containers</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
	<for>for (<init>;</init> <condition><expr><name>gc</name> != <name>containers</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> == <name>GC_REACHABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <call><name>Py_REFCNT</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Python's cyclic gc should never see an incoming refcount
		 * of 0:  if something decref'ed to 0, it should have been
		 * deallocated immediately at that time.
		 * Possible cause (if the assert triggers):  a tp_dealloc
		 * routine left a gc-aware object tracked during its teardown
		 * phase, and did something-- or allowed something to happen --
		 * that called back into Python.  gc can trigger then, and may
		 * see the still-tracked dying object.  Before this assert
		 * was added, such mistakes went on to allow gc to try to
		 * delete the object again.  In a debug build, that caused
		 * a mysterious segfault, when _Py_ForgetReference tried
		 * to remove the object from the doubly-linked list of all
		 * objects a second time.  In a release build, an actual
		 * double deallocation occurred, which leads to corruption
		 * of the allocator's internal bookkeeping pointers.  That's
		 * so serious that maybe this should be a release-build
		 * check instead of an assert?
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
}</block></function>

<comment type="block">/* A traversal callback for subtract_refs. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>visit_decref</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* We're only interested in gc_refs for objects in the
		 * generation being collected, which can be recognized
		 * because only they have positive gc_refs.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* else refcount was too small */</comment>
		<if>if <condition>(<expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name>--</expr>;</expr_stmt></then></if>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Subtract internal references from gc_refs.  After this, gc_refs is &gt;= 0
 * for all objects in containers, and is GC_REACHABLE for all tracked gc
 * objects not in containers.  The ones with gc_refs &gt; 0 are directly
 * reachable from outside containers, and so can't be collected.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>subtract_refs</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>containers</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>containers</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
	<for>for (<init>;</init> <condition><expr><name>gc</name> != <name>containers</name></expr>;</condition> <incr><expr><name>gc</name>=<name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
		<expr_stmt><expr><name>traverse</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>) <call><name>traverse</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr>(<name>visitproc</name>)<name>visit_decref</name></expr></argument>,
			       <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
}</block></function>

<comment type="block">/* A traversal callback for move_unreachable. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>visit_reachable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>reachable</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>gc_refs</name> <init>= <expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>gc_refs</name> == 0</expr>)</condition><then> <block>{
			<comment type="block">/* This is in move_unreachable's 'young' list, but
			 * the traversal hasn't yet gotten to it.  All
			 * we need to do is tell move_unreachable that it's
			 * reachable.
			 */</comment>
			<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = 1</expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>gc_refs</name> == <name>GC_TENTATIVELY_UNREACHABLE</name></expr>)</condition><then> <block>{
			<comment type="block">/* This had gc_refs = 0 when move_unreachable got
			 * to it, but turns out it's reachable after all.
			 * Move it back to move_unreachable's 'young' list,
			 * and move_unreachable will eventually get to it
			 * again.
			 */</comment>
			<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>reachable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = 1</expr>;</expr_stmt>
		}</block></then>
		<comment type="block">/* Else there's nothing to do.
		 * If gc_refs &gt; 0, it must be in move_unreachable's 'young'
		 * list, and move_unreachable will eventually get to it.
		 * If gc_refs == GC_REACHABLE, it's either in some other
		 * generation so we don't care about it, or move_unreachable
		 * already dealt with it.
		 * If gc_refs == GC_UNTRACKED, it must be ignored.
		 */</comment>
		 <else>else <block>{
		 	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>gc_refs</name> &gt; 0
		 	       || <name>gc_refs</name> == <name>GC_REACHABLE</name>
		 	       || <name>gc_refs</name> == <name>GC_UNTRACKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 }</block></else></if></else></if>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Move the unreachable objects from young to unreachable.  After this,
 * all objects in young have gc_refs = GC_REACHABLE, and all objects in
 * unreachable have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All tracked
 * gc objects not in young or unreachable still have gc_refs = GC_REACHABLE.
 * All objects in young after this are directly or indirectly reachable
 * from outside the original young; and all objects in unreachable are
 * not.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>move_unreachable</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>young</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>unreachable</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>young</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Invariants:  all objects "to the left" of us in young have gc_refs
	 * = GC_REACHABLE, and are indeed reachable (directly or indirectly)
	 * from outside the young list as it was at entry.  All other objects
	 * from the original young "to the left" of us are in unreachable now,
	 * and have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All objects to the
	 * left of us in 'young' now have been scanned, and no objects here
	 * or to the right have been scanned yet.
	 */</comment>

	<while>while <condition>(<expr><name>gc</name> != <name>young</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>next</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name></expr>)</condition><then> <block>{
                        <comment type="block">/* gc is definitely reachable from outside the
                         * original 'young'.  Mark it as such, and traverse
                         * its pointers to find any other objects that may
                         * be directly reachable from it.  Note that the
                         * call to tp_traverse may append objects to young,
                         * so we have to wait until it returns to determine
                         * the next object to visit.
                         */</comment>
                        <decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_REACHABLE</name></expr>;</expr_stmt>
                        <expr_stmt><expr>(<name>void</name>) <call><name>traverse</name><argument_list>(<argument><expr><name>op</name></expr></argument>,
                                        <argument><expr>(<name>visitproc</name>)<name>visit_reachable</name></expr></argument>,
                                        <argument><expr>(<name>void</name> *)<name>young</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>next</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* This *may* be unreachable.  To make progress,
			 * assume it is.  gc isn't directly reachable from
			 * any object we've already traversed, but may be
			 * reachable from an object we haven't gotten to yet.
			 * visit_reachable will eventually move gc back into
			 * young if that's so, and we'll see it again.
			 */</comment>
			<expr_stmt><expr><name>next</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>unreachable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_TENTATIVELY_UNREACHABLE</name></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name>gc</name> = <name>next</name></expr>;</expr_stmt>
	}</block></while>
}</block></function>

<comment type="block">/* Return true if object has a finalization method.
 * CAUTION:  An instance of an old-style class has to be checked for a
 *__del__ method, and earlier versions of this used to call PyObject_HasAttr,
 * which in turn could call the class's __getattr__ hook (if any).  That
 * could invoke arbitrary Python code, mutating the object graph in arbitrary
 * ways, and that was the source of some excruciatingly subtle bugs.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>has_finalizer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>delstr</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>_PyInstance_Lookup</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>delstr</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyType_HasFeature</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>ob_type</name></name></expr></argument>, <argument><expr><name>Py_TPFLAGS_HEAPTYPE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name><name>op</name>-&gt;<name>ob_type</name>-&gt;<name>tp_del</name></name> != <name>NULL</name></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyGen_CheckExact</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyGen_NeedsFinalizing</name><argument_list>(<argument><expr>(<name>PyGenObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr>0</expr>;</return></else></if></else></if></else></if>
}</block></function>

<comment type="block">/* Move the objects in unreachable with __del__ methods into `finalizers`.
 * Objects moved into `finalizers` have gc_refs set to GC_REACHABLE; the
 * objects remaining in unreachable are left at GC_TENTATIVELY_UNREACHABLE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>move_finalizers</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>unreachable</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>finalizers</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>next</name></decl>;</decl_stmt>

	<comment type="block">/* March over unreachable.  Move objects with finalizers into
	 * `finalizers`.
	 */</comment>
	<for>for (<init><expr><name>gc</name> = <name><name>unreachable</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>unreachable</name></expr>;</condition> <incr><expr><name>gc</name> = <name>next</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>has_finalizer</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_REACHABLE</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
}</block></function>

<comment type="block">/* A traversal callback for move_finalizer_reachable. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>visit_move</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>tolist</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>tolist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_REACHABLE</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Move objects that are reachable from finalizers, from the unreachable set
 * into finalizers set.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>move_finalizer_reachable</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>finalizers</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>finalizers</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
	<for>for (<init>;</init> <condition><expr><name>gc</name> != <name>finalizers</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
		<comment type="block">/* Note that the finalizers list may grow during this. */</comment>
		<expr_stmt><expr><name>traverse</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>) <call><name>traverse</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr>(<name>visitproc</name>)<name>visit_move</name></expr></argument>,
				<argument><expr>(<name>void</name> *)<name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
}</block></function>

<comment type="block">/* Clear all weakrefs to unreachable objects, and if such a weakref has a
 * callback, invoke it if necessary.  Note that it's possible for such
 * weakrefs to be outside the unreachable set -- indeed, those are precisely
 * the weakrefs whose callbacks must be invoked.  See gc_weakref.txt for
 * overview &amp; some details.  Some weakrefs with callbacks may be reclaimed
 * directly by this routine; the number reclaimed is the return value.  Other
 * weakrefs with callbacks may be moved into the `old` generation.  Objects
 * moved into `old` have gc_refs set to GC_REACHABLE; the objects remaining in
 * unreachable are left at GC_TENTATIVELY_UNREACHABLE.  When this returns,
 * no object in `unreachable` is weakly referenced anymore.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_weakrefs</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>unreachable</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>old</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name></decl>;</decl_stmt>		<comment type="block">/* generally FROM_GC(gc) */</comment>
	<decl_stmt><decl><type><name>PyWeakReference</name> *</type><name>wr</name></decl>;</decl_stmt>	<comment type="block">/* generally a cast of op */</comment>
	<decl_stmt><decl><type><name>PyGC_Head</name></type> <name>wrcb_to_call</name></decl>;</decl_stmt>	<comment type="block">/* weakrefs with callbacks to call */</comment>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_freed</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gc_list_init</name><argument_list>(<argument><expr>&amp;<name>wrcb_to_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear all weakrefs to the objects in unreachable.  If such a weakref
	 * also has a callback, move it into `wrcb_to_call` if the callback
	 * needs to be invoked.  Note that we cannot invoke any callbacks until
	 * all weakrefs to unreachable objects are cleared, lest the callback
	 * resurrect an unreachable object via a still-active weakref.  We
	 * make another pass over wrcb_to_call, invoking callbacks, after this
	 * pass completes.
	 */</comment>
	<for>for (<init><expr><name>gc</name> = <name><name>unreachable</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>unreachable</name></expr>;</condition> <incr><expr><name>gc</name> = <name>next</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyWeakReference</name> **</type><name>wrlist</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>op</name> = <call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>

		<if>if <condition>(<expr>! <call><name>PyType_SUPPORTS_WEAKREFS</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if>

		<comment type="block">/* It supports weakrefs.  Does it have any? */</comment>
		<expr_stmt><expr><name>wrlist</name> = (<name>PyWeakReference</name> **)
			     		<call><name>PyObject_GET_WEAKREFS_LISTPTR</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* `op` may have some weakrefs.  March over the list, clear
		 * all the weakrefs, and move the weakrefs with callbacks
		 * that must be called into wrcb_to_call.
		 */</comment>
		<for>for (<init><expr><name>wr</name> = *<name>wrlist</name></expr>;</init> <condition><expr><name>wr</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>wr</name> = *<name>wrlist</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>wrasgc</name></decl>;</decl_stmt>	<comment type="block">/* AS_GC(wr) */</comment>

			<comment type="block">/* _PyWeakref_ClearRef clears the weakref but leaves
			 * the callback pointer intact.  Obscure:  it also
			 * changes *wrlist.
			 */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>wr</name>-&gt;<name>wr_object</name></name> == <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_PyWeakref_ClearRef</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>wr</name>-&gt;<name>wr_object</name></name> == <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>wr</name>-&gt;<name>wr_callback</name></name> == <name>NULL</name></expr>)</condition><then>
				<continue>continue;</continue></then></if>	<comment type="block">/* no callback */</comment>

	<comment type="block">/* Headache time.  `op` is going away, and is weakly referenced by
	 * `wr`, which has a callback.  Should the callback be invoked?  If wr
	 * is also trash, no:
	 *
	 * 1. There's no need to call it.  The object and the weakref are
	 *    both going away, so it's legitimate to pretend the weakref is
	 *    going away first.  The user has to ensure a weakref outlives its
	 *    referent if they want a guarantee that the wr callback will get
	 *    invoked.
	 *
	 * 2. It may be catastrophic to call it.  If the callback is also in
	 *    cyclic trash (CT), then although the CT is unreachable from
	 *    outside the current generation, CT may be reachable from the
	 *    callback.  Then the callback could resurrect insane objects.
	 *
	 * Since the callback is never needed and may be unsafe in this case,
	 * wr is simply left in the unreachable set.  Note that because we
	 * already called _PyWeakref_ClearRef(wr), its callback will never
	 * trigger.
	 *
	 * OTOH, if wr isn't part of CT, we should invoke the callback:  the
	 * weakref outlived the trash.  Note that since wr isn't CT in this
	 * case, its callback can't be CT either -- wr acted as an external
	 * root to this generation, and therefore its callback did too.  So
	 * nothing in CT is reachable from the callback either, so it's hard
	 * to imagine how calling it later could create a problem for us.  wr
	 * is moved to wrcb_to_call in this case.
	 */</comment>
	 		<if>if <condition>(<expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	 			<continue>continue;</continue></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_REACHABLE</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create a new reference so that wr can't go away
			 * before we can process it again.
			 */</comment>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Move wr to wrcb_to_call, for the next pass. */</comment>
			<expr_stmt><expr><name>wrasgc</name> = <call><name>AS_GC</name><argument_list>(<argument><expr><name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>wrasgc</name> != <name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* wrasgc is reachable, but
			                           next isn't, so they can't
			                           be the same */</comment>
			<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>wrasgc</name></expr></argument>, <argument><expr>&amp;<name>wrcb_to_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></for>

	<comment type="block">/* Invoke the callbacks we decided to honor.  It's safe to invoke them
	 * because they can't reference unreachable objects.
	 */</comment>
	<while>while <condition>(<expr>! <call><name>gc_list_is_empty</name><argument_list>(<argument><expr>&amp;<name>wrcb_to_call</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>callback</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>gc</name> = <name><name>wrcb_to_call</name>.<name>gc</name>.<name>gc_next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>op</name> = <call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_REACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyWeakref_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wr</name> = (<name>PyWeakReference</name> *)<name>op</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>callback</name> = <name><name>wr</name>-&gt;<name>wr_callback</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>callback</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy-paste of weakrefobject.c's handle_callback() */</comment>
		<expr_stmt><expr><name>temp</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>callback</name></expr></argument>, <argument><expr><name>wr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

		<comment type="block">/* Give up the reference we created in the first pass.  When
		 * op's refcount hits 0 (which it may or may not do right now),
		 * op's tp_dealloc will decref op-&gt;wr_callback too.  Note
		 * that the refcount probably will hit 0 now, and because this
		 * weakref was reachable to begin with, gc didn't already
		 * add it to its count of freed objects.  Example:  a reachable
		 * weak value dict maps some key to this reachable weakref.
		 * The callback removes this key-&gt;weakref mapping from the
		 * dict, leaving no other references to the weakref (excepting
		 * ours).
		 */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>wrcb_to_call</name>.<name>gc</name>.<name>gc_next</name></name> == <name>gc</name></expr>)</condition><then> <block>{
			<comment type="block">/* object is still alive -- move it */</comment>
			<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr>++<name>num_freed</name></expr>;</expr_stmt></else></if>
	}</block></while>

	<return>return <expr><name>num_freed</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>debug_instance</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>PyInstanceObject</name> *</type><name>inst</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>cname</name></decl>;</decl_stmt>
	<comment type="block">/* simple version of instance_repr */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>classname</name> <init>= <expr><name><name>inst</name>-&gt;<name>in_class</name>-&gt;<name>cl_name</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>classname</name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>cname</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>cname</name> = "?"</expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: %.100s &lt;%.100s instance at %p&gt;\n"</expr></argument>,
			  <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>cname</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>debug_cycle</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>(<name>debug</name> &amp; <name>DEBUG_INSTANCES</name>) &amp;&amp; <call><name>PyInstance_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>debug_instance</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr>(<name>PyInstanceObject</name> *)<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_OBJECTS</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: %.100s &lt;%.100s %p&gt;\n"</expr></argument>,
				  <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
}</block></function>

<comment type="block">/* Handle uncollectable garbage (cycles with finalizers, and stuff reachable
 * only from such cycles).
 * If DEBUG_SAVEALL, all objects in finalizers are appended to the module
 * garbage list (a Python list), else only the objects in finalizers with
 * __del__ methods are appended to garbage.  All objects in finalizers are
 * merged into the old list regardless.
 * Returns 0 if all OK, &lt;0 on error (out of memory to grow the garbage list).
 * The finalizers list is made empty on a successful return.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_finalizers</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>finalizers</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>old</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>finalizers</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>garbage</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>garbage</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>garbage</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"gc couldn't create gc.garbage list"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<for>for (<init>;</init> <condition><expr><name>gc</name> != <name>finalizers</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>debug</name> &amp; <name>DEBUG_SAVEALL</name>) || <call><name>has_finalizer</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>garbage</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
	}</block></for>

	<expr_stmt><expr><call><name>gc_list_merge</name><argument_list>(<argument><expr><name>finalizers</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Break reference cycles by clearing the containers involved.	This is
 * tricky business as the lists can be changing and we don't know which
 * objects may be freed.  It is possible I screwed something up here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>delete_garbage</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>collectable</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>old</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>inquiry</name></type> <name>clear</name></decl>;</decl_stmt>

	<while>while <condition>(<expr>!<call><name>gc_list_is_empty</name><argument_list>(<argument><expr><name>collectable</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name> <init>= <expr><name><name>collectable</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_TENTATIVELY_UNREACHABLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_SAVEALL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>garbage</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<if>if <condition>(<expr>(<name>clear</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<name>tp_clear</name>) != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>clear</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></else></if>
		<if>if <condition>(<expr><name><name>collectable</name>-&gt;<name>gc</name>.<name>gc_next</name></name> == <name>gc</name></expr>)</condition><then> <block>{
			<comment type="block">/* object is still alive, move it, it may die later */</comment>
			<expr_stmt><expr><call><name>gc_list_move</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gc</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_REACHABLE</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></while>
}</block></function>

<comment type="block">/* Clear all free lists
 * All free lists are cleared during the collection of the highest generation.
 * Allocated items in the free list may keep a pymalloc arena occupied.
 * Clearing the free lists may give back memory to the OS earlier.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_freelists</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr>(<name>void</name>)<call><name>PyMethod_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>PyFrame_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>PyCFunction_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>PyTuple_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>PyUnicode_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>PyInt_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>)<call><name>PyFloat_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* This is the main function.  Read this to understand how the
 * collection process works. */</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>collect</name><parameter_list>(<param><decl><type><name>int</name></type> <name>generation</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>m</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* # objects collected */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* # unreachable objects that couldn't be collected */</comment>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>young</name></decl>;</decl_stmt> <comment type="block">/* the generation we are examining */</comment>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>old</name></decl>;</decl_stmt> <comment type="block">/* next older generation */</comment>
	<decl_stmt><decl><type><name>PyGC_Head</name></type> <name>unreachable</name></decl>;</decl_stmt> <comment type="block">/* non-problematic unreachable trash */</comment>
	<decl_stmt><decl><type><name>PyGC_Head</name></type> <name>finalizers</name></decl>;</decl_stmt>  <comment type="block">/* objects with, &amp; reachable from, __del__ */</comment>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>t1</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>delstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>delstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__del__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>delstr</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"gc couldn't allocate \"__del__\""</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_STATS</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>tmod</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name> <init>= <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>tmod</name></expr></argument>, <argument><expr>"time"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name>t1</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: collecting generation %d...\n"</expr></argument>,
				  <argument><expr><name>generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: objects in each generation:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_GENERATIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>" %" <name>PY_FORMAT_SIZE_T</name> "d"</expr></argument>,
					  <argument><expr><call><name>gc_list_size</name><argument_list>(<argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* update collection and allocation counters */</comment>
	<if>if <condition>(<expr><name>generation</name>+1 &lt; <name>NUM_GENERATIONS</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>generations</name><index>[<expr><name>generation</name>+1</expr>]</index></name>.<name>count</name> += 1</expr>;</expr_stmt></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>generation</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><name><name>generations</name><index>[<expr><name>i</name></expr>]</index></name>.<name>count</name> = 0</expr>;</expr_stmt></for>

	<comment type="block">/* merge younger generations with one we are currently collecting */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>generation</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>gc_list_merge</name><argument_list>(<argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>generation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* handy references */</comment>
	<expr_stmt><expr><name>young</name> = <call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>generation</name> &lt; <name>NUM_GENERATIONS</name>-1</expr>)</condition><then>
		<expr_stmt><expr><name>old</name> = <call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>generation</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>old</name> = <name>young</name></expr>;</expr_stmt></else></if>

	<comment type="block">/* Using ob_refcnt and gc_refs, calculate which objects in the
	 * container set are reachable from outside the set (i.e., have a
	 * refcount greater than 0 when all the references within the
	 * set are taken into account).
	 */</comment>
	<expr_stmt><expr><call><name>update_refs</name><argument_list>(<argument><expr><name>young</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>subtract_refs</name><argument_list>(<argument><expr><name>young</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Leave everything reachable from outside young in young, and move
	 * everything else (in young) to unreachable.
	 * NOTE:  This used to move the reachable objects into a reachable
	 * set instead.  But most things usually turn out to be reachable,
	 * so it's more efficient to move the unreachable things.
	 */</comment>
	<expr_stmt><expr><call><name>gc_list_init</name><argument_list>(<argument><expr>&amp;<name>unreachable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>move_unreachable</name><argument_list>(<argument><expr><name>young</name></expr></argument>, <argument><expr>&amp;<name>unreachable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Move reachable objects to next generation. */</comment>
	<if>if <condition>(<expr><name>young</name> != <name>old</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>gc_list_merge</name><argument_list>(<argument><expr><name>young</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* All objects in unreachable are trash, but objects reachable from
	 * finalizers can't safely be deleted.  Python programmers should take
	 * care not to create such things.  For Python, finalizers means
	 * instance objects with __del__ methods.  Weakrefs with callbacks
	 * can also call arbitrary Python code but they will be dealt with by
	 * handle_weakrefs().
 	 */</comment>
	<expr_stmt><expr><call><name>gc_list_init</name><argument_list>(<argument><expr>&amp;<name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>move_finalizers</name><argument_list>(<argument><expr>&amp;<name>unreachable</name></expr></argument>, <argument><expr>&amp;<name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* finalizers contains the unreachable objects with a finalizer;
	 * unreachable objects reachable *from* those are also uncollectable,
	 * and we move those into the finalizers list too.
	 */</comment>
	<expr_stmt><expr><call><name>move_finalizer_reachable</name><argument_list>(<argument><expr>&amp;<name>finalizers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collect statistics on collectable objects found and print
	 * debugging information.
	 */</comment>
	<for>for (<init><expr><name>gc</name> = <name><name>unreachable</name>.<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != &amp;<name>unreachable</name></expr>;</condition>
			<incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
		<expr_stmt><expr><name>m</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_COLLECTABLE</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>debug_cycle</name><argument_list>(<argument><expr>"collectable"</expr></argument>, <argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>tmod</name> != <name>NULL</name> &amp;&amp; (<name>debug</name> &amp; <name>DEBUG_STATS</name>)</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name> <init>= <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>tmod</name></expr></argument>, <argument><expr>"time"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name>t1</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call>-<name>t1</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: %.4fs elapsed.\n"</expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then></if>
	}</block></for>

	<comment type="block">/* Clear weakrefs and invoke callbacks as necessary. */</comment>
	<expr_stmt><expr><name>m</name> += <call><name>handle_weakrefs</name><argument_list>(<argument><expr>&amp;<name>unreachable</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Call tp_clear on objects in the unreachable set.  This will cause
	 * the reference cycles to be broken.  It may also cause some objects
	 * in finalizers to be freed.
	 */</comment>
	<expr_stmt><expr><call><name>delete_garbage</name><argument_list>(<argument><expr>&amp;<name>unreachable</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collect statistics on uncollectable objects found and print
	 * debugging information. */</comment>
	<for>for (<init><expr><name>gc</name> = <name><name>finalizers</name>.<name>gc</name>.<name>gc_next</name></name></expr>;</init>
	     <condition><expr><name>gc</name> != &amp;<name>finalizers</name></expr>;</condition>
	     <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
		<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_UNCOLLECTABLE</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>debug_cycle</name><argument_list>(<argument><expr>"uncollectable"</expr></argument>, <argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>debug</name> &amp; <name>DEBUG_STATS</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>m</name> == 0 &amp;&amp; <name>n</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"gc: done.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
			    <argument><expr>"gc: done, "
			    "%" <name>PY_FORMAT_SIZE_T</name> "d unreachable, "
			    "%" <name>PY_FORMAT_SIZE_T</name> "d uncollectable.\n"</expr></argument>,
			    <argument><expr><name>n</name>+<name>m</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if>

	<comment type="block">/* Append instances in the uncollectable set to a Python
	 * reachable list of garbage.  The programmer has to deal with
	 * this if they insist on creating this type of structure.
	 */</comment>
	<expr_stmt><expr>(<name>void</name>)<call><name>handle_finalizers</name><argument_list>(<argument><expr>&amp;<name>finalizers</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear free list only during the collection of the higest
	 * generation */</comment>
	<if>if <condition>(<expr><name>generation</name> == <name>NUM_GENERATIONS</name>-1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>clear_freelists</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>gc_str</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>gc_str</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"garbage collection"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>gc_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"unexpected exception during garbage collection"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>n</name>+<name>m</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>collect_generations</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* Find the oldest generation (higest numbered) where the count
	 * exceeds the threshold.  Objects in the that generation and
	 * generations younger than it will be collected. */</comment>
	<for>for (<init><expr><name>i</name> = <name>NUM_GENERATIONS</name>-1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>generations</name><index>[<expr><name>i</name></expr>]</index></name>.<name>count</name> &gt; <name><name>generations</name><index>[<expr><name>i</name></expr>]</index></name>.<name>threshold</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>n</name> = <call><name>collect</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
	}</block></for>
	<return>return <expr><name>n</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_enable__doc__</name></expr></argument>,
<argument><expr>"enable() -&gt; None\n"
"\n"
"Enable automatic garbage collection.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_enable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name>enabled</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_disable__doc__</name></expr></argument>,
<argument><expr>"disable() -&gt; None\n"
"\n"
"Disable automatic garbage collection.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_disable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name>enabled</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_isenabled__doc__</name></expr></argument>,
<argument><expr>"isenabled() -&gt; status\n"
"\n"
"Returns true if automatic garbage collection is enabled.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_isenabled</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>enabled</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_collect__doc__</name></expr></argument>,
<argument><expr>"collect([generation]) -&gt; n\n"
"\n"
"With no arguments, run a full collection.  The optional argument\n"
"may be an integer specifying which generation to collect.  A ValueError\n"
"is raised if the generation number is invalid.\n\n"
"The number of unreachable objects is returned.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_collect</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kws</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"generation"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>genarg</name> <init>= <expr><name>NUM_GENERATIONS</name> - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kws</name></expr></argument>, <argument><expr>"|i"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr>&amp;<name>genarg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then>

	<else>else <if>if <condition>(<expr><name>genarg</name> &lt; 0 || <name>genarg</name> &gt;= <name>NUM_GENERATIONS</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"invalid generation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if></else></if>

	<if>if <condition>(<expr><name>collecting</name></expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then> <comment type="block">/* already collecting, don't do anything */</comment>
	<else>else <block>{
		<expr_stmt><expr><name>collecting</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>collect</name><argument_list>(<argument><expr><name>genarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collecting</name> = 0</expr>;</expr_stmt>
	}</block></else></if>

	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_set_debug__doc__</name></expr></argument>,
<argument><expr>"set_debug(flags) -&gt; None\n"
"\n"
"Set the garbage collection debugging flags. Debugging information is\n"
"written to sys.stderr.\n"
"\n"
"flags is an integer and can have the following bits turned on:\n"
"\n"
"  DEBUG_STATS - Print statistics during collection.\n"
"  DEBUG_COLLECTABLE - Print collectable objects found.\n"
"  DEBUG_UNCOLLECTABLE - Print unreachable but uncollectable objects found.\n"
"  DEBUG_INSTANCES - Print instance objects.\n"
"  DEBUG_OBJECTS - Print objects other than instances.\n"
"  DEBUG_SAVEALL - Save objects to gc.garbage rather than freeing them.\n"
"  DEBUG_LEAK - Debug leaking programs (everything but STATS).\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_set_debug</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:set_debug"</expr></argument>, <argument><expr>&amp;<name>debug</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_debug__doc__</name></expr></argument>,
<argument><expr>"get_debug() -&gt; flags\n"
"\n"
"Get the garbage collection debugging flags.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_debug</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_set_thresh__doc__</name></expr></argument>,
<argument><expr>"set_threshold(threshold0, [threshold1, threshold2]) -&gt; None\n"
"\n"
"Sets the collection thresholds.  Setting threshold0 to zero disables\n"
"collection.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_set_thresh</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i|ii:set_threshold"</expr></argument>,
			      <argument><expr>&amp;<name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>threshold</name></expr></argument>,
			      <argument><expr>&amp;<name><name>generations</name><index>[<expr>1</expr>]</index></name>.<name>threshold</name></expr></argument>,
			      <argument><expr>&amp;<name><name>generations</name><index>[<expr>2</expr>]</index></name>.<name>threshold</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 2</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_GENERATIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
 		<comment type="block">/* generations higher than 2 get the same threshold */</comment>
		<expr_stmt><expr><name><name>generations</name><index>[<expr><name>i</name></expr>]</index></name>.<name>threshold</name> = <name><name>generations</name><index>[<expr>2</expr>]</index></name>.<name>threshold</name></expr>;</expr_stmt>
	}</block></for>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_thresh__doc__</name></expr></argument>,
<argument><expr>"get_threshold() -&gt; (threshold0, threshold1, threshold2)\n"
"\n"
"Return the current collection thresholds\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_thresh</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(iii)"</expr></argument>,
			     <argument><expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>threshold</name></expr></argument>,
			     <argument><expr><name><name>generations</name><index>[<expr>1</expr>]</index></name>.<name>threshold</name></expr></argument>,
			     <argument><expr><name><name>generations</name><index>[<expr>2</expr>]</index></name>.<name>threshold</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_count__doc__</name></expr></argument>,
<argument><expr>"get_count() -&gt; (count0, count1, count2)\n"
"\n"
"Return the current collection counts\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_count</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(iii)"</expr></argument>,
			     <argument><expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name></expr></argument>,
			     <argument><expr><name><name>generations</name><index>[<expr>1</expr>]</index></name>.<name>count</name></expr></argument>,
			     <argument><expr><name><name>generations</name><index>[<expr>2</expr>]</index></name>.<name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>referrersvisit</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>objs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<if>if <condition>(<expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>objs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == <name>obj</name></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>gc_referrers_for</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>objs</name></decl></param>, <param><decl><type><name>PyGC_Head</name> *</type><name>list</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>resultlist</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>gc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>gc</name> = <name><name>list</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr>;</init> <condition><expr><name>gc</name> != <name>list</name></expr>;</condition> <incr><expr><name>gc</name> = <name><name>gc</name>-&gt;<name>gc</name>.<name>gc_next</name></name></expr></incr>) <block>{
		<expr_stmt><expr><name>obj</name> = <call><name>FROM_GC</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>traverse</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>obj</name> == <name>objs</name> || <name>obj</name> == <name>resultlist</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr><call><name>traverse</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>(<name>visitproc</name>)<name>referrersvisit</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>resultlist</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if> <comment type="block">/* error */</comment>
		}</block></then></if>
	}</block></for>
	<return>return <expr>1</expr>;</return> <comment type="block">/* no error */</comment>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_referrers__doc__</name></expr></argument>,
<argument><expr>"get_referrers(*objs) -&gt; list\n\
Return the list of objects that directly refer to any of objs."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_referrers</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_GENERATIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>!(<call><name>gc_referrers_for</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Append obj to list; return true if error (out of memory), false if OK. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>referentsvisit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> &lt; 0</expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_referents__doc__</name></expr></argument>,
<argument><expr>"get_referents(*objs) -&gt; list\n\
Return the list of objects that are directly referred to by objs."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_referents</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>traverseproc</name></type> <name>traverse</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr>! <call><name>PyObject_IS_GC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><name>traverse</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_traverse</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>! <name>traverse</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<if>if <condition>(<expr><call><name>traverse</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>(<name>visitproc</name>)<name>referentsvisit</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc_get_objects__doc__</name></expr></argument>,
<argument><expr>"get_objects() -&gt; [...]\n"
"\n"
"Return a list of objects tracked by the collector (excluding the list\n"
"returned).\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gc_get_objects</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_GENERATIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>append_objects</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>GEN_HEAD</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gc__doc__</name></expr></argument>,
<argument><expr>"This module provides access to the garbage collector for reference cycles.\n"
"\n"
"enable() -- Enable automatic garbage collection.\n"
"disable() -- Disable automatic garbage collection.\n"
"isenabled() -- Returns true if automatic collection is enabled.\n"
"collect() -- Do a full collection right now.\n"
"get_count() -- Return the current collection counts.\n"
"set_debug() -- Set debugging flags.\n"
"get_debug() -- Get debugging flags.\n"
"set_threshold() -- Set the collection thresholds.\n"
"get_threshold() -- Return the current the collection thresholds.\n"
"get_objects() -- Return a list of all objects tracked by the collector.\n"
"get_referrers() -- Return the list of objects that refer to an object.\n"
"get_referents() -- Return the list of objects that an object refers to.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>GcMethods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"enable"</expr>,	   <expr><name>gc_enable</name></expr>,	  <expr><name>METH_NOARGS</name></expr>,  <expr><name>gc_enable__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"disable"</expr>,	   <expr><name>gc_disable</name></expr>,	  <expr><name>METH_NOARGS</name></expr>,  <expr><name>gc_disable__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"isenabled"</expr>,	   <expr><name>gc_isenabled</name></expr>,  <expr><name>METH_NOARGS</name></expr>,  <expr><name>gc_isenabled__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"set_debug"</expr>,	   <expr><name>gc_set_debug</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>gc_set_debug__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"get_debug"</expr>,	   <expr><name>gc_get_debug</name></expr>,  <expr><name>METH_NOARGS</name></expr>,  <expr><name>gc_get_debug__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"get_count"</expr>,	   <expr><name>gc_get_count</name></expr>,  <expr><name>METH_NOARGS</name></expr>,  <expr><name>gc_get_count__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"set_threshold"</expr>,  <expr><name>gc_set_thresh</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>gc_set_thresh__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"get_threshold"</expr>,  <expr><name>gc_get_thresh</name></expr>, <expr><name>METH_NOARGS</name></expr>,  <expr><name>gc_get_thresh__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"collect"</expr>,	   <expr>(<name>PyCFunction</name>)<name>gc_collect</name></expr>,
         	<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,           <expr><name>gc_collect__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"get_objects"</expr>,    <expr><name>gc_get_objects</name></expr>,<expr><name>METH_NOARGS</name></expr>,  <expr><name>gc_get_objects__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"get_referrers"</expr>,  <expr><name>gc_get_referrers</name></expr>, <expr><name>METH_VARARGS</name></expr>,
		<expr><name>gc_get_referrers__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"get_referents"</expr>,  <expr><name>gc_get_referents</name></expr>, <expr><name>METH_VARARGS</name></expr>,
		<expr><name>gc_get_referents__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,	<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>initgc</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"gc"</expr></argument>,
			      <argument><expr><name>GcMethods</name></expr></argument>,
			      <argument><expr><name>gc__doc__</name></expr></argument>,
			      <argument><expr><name>NULL</name></expr></argument>,
			      <argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<if>if <condition>(<expr><name>garbage</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>garbage</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>garbage</name> == <name>NULL</name></expr>)</condition><then>
			<return>return;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>garbage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"garbage"</expr></argument>, <argument><expr><name>garbage</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* Importing can't be done in collect() because collect()
	 * can be called via PyGC_Collect() in Py_Finalize().
	 * This wouldn't be a problem, except that &lt;initialized&gt; is
	 * reset to 0 before calling collect which trips up
	 * the import and triggers an assertion.
	 */</comment>
	<if>if <condition>(<expr><name>tmod</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>tmod</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"time"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmod</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_INT</name><parameter_list>(<param><type><name>NAME</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (PyModule_AddIntConstant(m, #NAME, NAME) &lt; 0) return</cpp:value></cpp:define>
	<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_STATS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_COLLECTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_UNCOLLECTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_INSTANCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_OBJECTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_SAVEALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADD_INT</name><argument_list>(<argument><expr><name>DEBUG_LEAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ADD_INT</name></cpp:undef>
}</block></function>

<comment type="block">/* API to invoke gc.collect() from C */</comment>
<function><type><name>Py_ssize_t</name></type>
<name>PyGC_Collect</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>collecting</name></expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then> <comment type="block">/* already collecting, don't do anything */</comment>
	<else>else <block>{
		<expr_stmt><expr><name>collecting</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>collect</name><argument_list>(<argument><expr><name>NUM_GENERATIONS</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collecting</name> = 0</expr>;</expr_stmt>
	}</block></else></if>

	<return>return <expr><name>n</name></expr>;</return>
}</block></function>

<comment type="block">/* for debugging */</comment>
<function><type><name>void</name></type>
<name>_PyGC_Dump</name><parameter_list>(<param><decl><type><name>PyGC_Head</name> *</type><name>g</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>_PyObject_Dump</name><argument_list>(<argument><expr><call><name>FROM_GC</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* extension modules might be compiled with GC support so these
   functions must always be available */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_GC_Track</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_GC_UnTrack</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_GC_Del</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_PyObject_GC_Malloc</name></cpp:undef>

<function><type><name>void</name></type>
<name>PyObject_GC_Track</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>_PyObject_GC_TRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* for binary compatibility with 2.2 */</comment>
<function><type><name>void</name></type>
<name>_PyObject_GC_Track</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PyObject_GC_UnTrack</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Obscure:  the Py_TRASHCAN mechanism requires that we be able to
	 * call PyObject_GC_UnTrack twice on an object.
	 */</comment>
	<if>if <condition>(<expr><call><name>IS_TRACKED</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyObject_GC_UNTRACK</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* for binary compatibility with 2.2 */</comment>
<function><type><name>void</name></type>
<name>_PyObject_GC_UnTrack</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyObject_GC_Malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>basicsize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>g</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>basicsize</name> &gt; <name>PY_SSIZE_T_MAX</name> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyGC_Head</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>g</name> = (<name>PyGC_Head</name> *)<call><name>PyObject_MALLOC</name><argument_list>(
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyGC_Head</name></expr></argument>)</argument_list></sizeof> + <name>basicsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>g</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name><name>g</name>-&gt;<name>gc</name>.<name>gc_refs</name></name> = <name>GC_UNTRACKED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name>++</expr>;</expr_stmt> <comment type="block">/* number of allocated GC objects */</comment>
 	<if>if <condition>(<expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name> &gt; <name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>threshold</name> &amp;&amp;
 	    <name>enabled</name> &amp;&amp;
 	    <name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>threshold</name> &amp;&amp;
 	    !<name>collecting</name> &amp;&amp;
 	    !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>collecting</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>collect_generations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collecting</name> = 0</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>op</name> = <call><name>FROM_GC</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>op</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>_PyObject_GC_New</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>op</name> <init>= <expr><call><name>_PyObject_GC_Malloc</name><argument_list>(<argument><expr><call><name>_PyObject_SIZE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>op</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>op</name> = <call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>op</name></expr>;</return>
}</block></function>

<function><type><name>PyVarObject</name> *</type>
<name>_PyObject_GC_NewVar</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>tp</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>nitems</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><call><name>_PyObject_VAR_SIZE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyVarObject</name> *</type><name>op</name> <init>= <expr>(<name>PyVarObject</name> *) <call><name>_PyObject_GC_Malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>op</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>op</name> = <call><name>PyObject_INIT_VAR</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>op</name></expr>;</return>
}</block></function>

<function><type><name>PyVarObject</name> *</type>
<name>_PyObject_GC_Resize</name><parameter_list>(<param><decl><type><name>PyVarObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>nitems</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>basicsize</name> <init>= <expr><call><name>_PyObject_VAR_SIZE</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>g</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>basicsize</name> &gt; <name>PY_SSIZE_T_MAX</name> - <sizeof>sizeof<argument_list>(<argument><expr><name>PyGC_Head</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
		<return>return <expr>(<name>PyVarObject</name> *)<call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>g</name> = (<name>PyGC_Head</name> *)<call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name>g</name></expr></argument>,  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyGC_Head</name></expr></argument>)</argument_list></sizeof> + <name>basicsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>g</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(<name>PyVarObject</name> *)<call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>op</name> = (<name>PyVarObject</name> *) <call><name>FROM_GC</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> = <name>nitems</name></expr>;</expr_stmt>
	<return>return <expr><name>op</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>PyObject_GC_Del</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyGC_Head</name> *</type><name>g</name> <init>= <expr><call><name>AS_GC</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>IS_TRACKED</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>gc_list_remove</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>generations</name><index>[<expr>0</expr>]</index></name>.<name>count</name>--</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* for binary compatibility with 2.2 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_PyObject_GC_Del</name></cpp:undef>
<function><type><name>void</name></type>
<name>_PyObject_GC_Del</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
