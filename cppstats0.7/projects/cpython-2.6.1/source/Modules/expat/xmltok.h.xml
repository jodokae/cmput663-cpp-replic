<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/expat/xmltok.h"><comment type="block">/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XmlTok_INCLUDED</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlTok_INCLUDED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The following token may be returned by XmlContentTok */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_TRAILING_RSQB</name></cpp:macro> <cpp:value>-5</cpp:value></cpp:define> <comment type="block">/* ] or ]] at the end of the scan; might be
                                    start of illegal ]]&gt; sequence */</comment>
<comment type="block">/* The following tokens may be returned by both XmlPrologTok and
   XmlContentTok.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_NONE</name></cpp:macro> <cpp:value>-4</cpp:value></cpp:define>          <comment type="block">/* The string to be scanned is empty */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_TRAILING_CR</name></cpp:macro> <cpp:value>-3</cpp:value></cpp:define>   <comment type="block">/* A CR at the end of the scan;
                                    might be part of CRLF sequence */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_PARTIAL_CHAR</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define>  <comment type="block">/* only part of a multibyte sequence */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_PARTIAL</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>       <comment type="block">/* only part of a token */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_INVALID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* The following tokens are returned by XmlContentTok; some are also
   returned by XmlAttributeValueTok, XmlEntityTok, XmlCdataSectionTok.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_START_TAG_WITH_ATTS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_START_TAG_NO_ATTS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_EMPTY_ELEMENT_WITH_ATTS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> <comment type="block">/* empty element tag &lt;e/&gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_EMPTY_ELEMENT_NO_ATTS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_END_TAG</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_DATA_CHARS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_DATA_NEWLINE</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_CDATA_SECT_OPEN</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_ENTITY_REF</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_CHAR_REF</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>               <comment type="block">/* numeric character reference */</comment>

<comment type="block">/* The following tokens may be returned by both XmlPrologTok and
   XmlContentTok.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_PI</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>                     <comment type="block">/* processing instruction */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_XML_DECL</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>               <comment type="block">/* XML decl or text decl */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_COMMENT</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_BOM</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>                    <comment type="block">/* Byte order mark */</comment>

<comment type="block">/* The following tokens are returned only by XmlPrologTok */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_PROLOG_S</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_DECL_OPEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>              <comment type="block">/* &lt;!foo */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_DECL_CLOSE</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>             <comment type="block">/* &gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_NAME</name></cpp:macro> <cpp:value>18</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_NMTOKEN</name></cpp:macro> <cpp:value>19</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_POUND_NAME</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>             <comment type="block">/* #name */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_OR</name></cpp:macro> <cpp:value>21</cpp:value></cpp:define>                     <comment type="block">/* | */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_PERCENT</name></cpp:macro> <cpp:value>22</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_OPEN_PAREN</name></cpp:macro> <cpp:value>23</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_CLOSE_PAREN</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_OPEN_BRACKET</name></cpp:macro> <cpp:value>25</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_CLOSE_BRACKET</name></cpp:macro> <cpp:value>26</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_LITERAL</name></cpp:macro> <cpp:value>27</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_PARAM_ENTITY_REF</name></cpp:macro> <cpp:value>28</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_INSTANCE_START</name></cpp:macro> <cpp:value>29</cpp:value></cpp:define>

<comment type="block">/* The following occur only in element type declarations */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_NAME_QUESTION</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>          <comment type="block">/* name? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_NAME_ASTERISK</name></cpp:macro> <cpp:value>31</cpp:value></cpp:define>          <comment type="block">/* name* */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_NAME_PLUS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>              <comment type="block">/* name+ */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_COND_SECT_OPEN</name></cpp:macro> <cpp:value>33</cpp:value></cpp:define>         <comment type="block">/* &lt;![ */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_COND_SECT_CLOSE</name></cpp:macro> <cpp:value>34</cpp:value></cpp:define>        <comment type="block">/* ]]&gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_CLOSE_PAREN_QUESTION</name></cpp:macro> <cpp:value>35</cpp:value></cpp:define>   <comment type="block">/* )? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_CLOSE_PAREN_ASTERISK</name></cpp:macro> <cpp:value>36</cpp:value></cpp:define>   <comment type="block">/* )* */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_CLOSE_PAREN_PLUS</name></cpp:macro> <cpp:value>37</cpp:value></cpp:define>       <comment type="block">/* )+ */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_COMMA</name></cpp:macro> <cpp:value>38</cpp:value></cpp:define>

<comment type="block">/* The following token is returned only by XmlAttributeValueTok */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_ATTRIBUTE_VALUE_S</name></cpp:macro> <cpp:value>39</cpp:value></cpp:define>

<comment type="block">/* The following token is returned only by XmlCdataSectionTok */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_CDATA_SECT_CLOSE</name></cpp:macro> <cpp:value>40</cpp:value></cpp:define>

<comment type="block">/* With namespace processing this is returned by XmlPrologTok for a
   name with a colon.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_PREFIXED_NAME</name></cpp:macro> <cpp:value>41</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XML_DTD</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_IGNORE_SECT</name></cpp:macro> <cpp:value>42</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XML_DTD */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XML_DTD</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_N_STATES</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* not XML_DTD */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_N_STATES</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* not XML_DTD */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_PROLOG_STATE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_CONTENT_STATE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_CDATA_SECTION_STATE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XML_DTD</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_IGNORE_SECTION_STATE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XML_DTD */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_N_LITERAL_TYPES</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_ATTRIBUTE_VALUE_LITERAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_ENTITY_VALUE_LITERAL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* The size of the buffer passed to XmlUtf8Encode must be at least this. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_UTF8_ENCODE_MAX</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<comment type="block">/* The size of the buffer passed to XmlUtf16Encode must be at least this. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_UTF16_ENCODE_MAX</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>position</name> <block>{
  <comment type="block">/* first line and first column are 0 not 1 */</comment>
  <decl_stmt><decl><type><name>XML_Size</name></type> <name>lineNumber</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>XML_Size</name></type> <name>columnNumber</name></decl>;</decl_stmt>
}</block></struct></type> <name>POSITION</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>valuePtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>valueEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>normalized</name></decl>;</decl_stmt>
}</block></struct></type> <name>ATTRIBUTE</name>;</typedef>

<struct_decl>struct <name>encoding</name>;</struct_decl>
<typedef>typedef <type>struct <name>encoding</name></type> <name>ENCODING</name>;</typedef>

<typedef>typedef <function_decl><type><name>int</name></type> (<name>PTRCALL</name> *<name>SCANNER</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>,
                               <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>,
                               <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>,
                               <param><decl><type><specifier>const</specifier></type> <name>char</name> **</decl></param>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>encoding</name> <block>{
  <decl_stmt><decl><type><name>SCANNER</name></type> <name><name>scanners</name><index>[<expr><name>XML_N_STATES</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SCANNER</name></type> <name><name>literalScanners</name><index>[<expr><name>XML_N_LITERAL_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (<name>PTRCALL</name> *<name>sameName</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>,
                          <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>,
                          <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<name>PTRCALL</name> *<name>nameMatchesAscii</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>,
                                  <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>,
                                  <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>,
                                  <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>nameLength</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(<name>PTRFASTCALL</name> *<name>skipS</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<name>PTRCALL</name> *<name>getAtts</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
                         <param><decl><type><name>int</name></type> <name>attsMax</name></decl></param>,
                         <param><decl><type><name>ATTRIBUTE</name> *</type><name>atts</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<name>PTRFASTCALL</name> *<name>charRefNumber</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<name>PTRCALL</name> *<name>predefinedEntityName</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>,
                                      <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>,
                                      <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> (<name>PTRCALL</name> *<name>updatePosition</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> *</decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
                                 <param><decl><type><name>POSITION</name> *</type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<name>PTRCALL</name> *<name>isPublicId</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>badPtr</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> (<name>PTRCALL</name> *<name>utf8Convert</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fromP</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromLim</name></decl></param>,
                              <param><decl><type><name>char</name> **</type><name>toP</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>toLim</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> (<name>PTRCALL</name> *<name>utf16Convert</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fromP</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromLim</name></decl></param>,
                               <param><decl><type><name>unsigned</name> <name>short</name> **</type><name>toP</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name> *</type><name>toLim</name></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>int</name></type> <name>minBytesPerChar</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>isUtf8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>isUtf16</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Scan the string starting at ptr until the end of the next complete
   token, but do not scan past eptr.  Return an integer giving the
   type of token.

   Return XML_TOK_NONE when ptr == eptr; nextTokPtr will not be set.

   Return XML_TOK_PARTIAL when the string does not contain a complete
   token; nextTokPtr will not be set.

   Return XML_TOK_INVALID when the string does not start a valid
   token; nextTokPtr will be set to point to the character which made
   the token invalid.

   Otherwise the string starts with a valid token; nextTokPtr will be
   set to point to the character following the end of that token.

   Each data character counts as a single token, but adjacent data
   characters may be returned together.  Similarly for characters in
   the prolog outside literals, comments and processing instructions.
*/</comment>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlTok</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>state</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;scanners[state])(enc, ptr, end, nextTokPtr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlPrologTok</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>XmlTok(enc, XML_PROLOG_STATE, ptr, end, nextTokPtr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlContentTok</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>XmlTok(enc, XML_CONTENT_STATE, ptr, end, nextTokPtr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlCdataSectionTok</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>XmlTok(enc, XML_CDATA_SECTION_STATE, ptr, end, nextTokPtr)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XML_DTD</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlIgnoreSectionTok</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>XmlTok(enc, XML_IGNORE_SECTION_STATE, ptr, end, nextTokPtr)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XML_DTD */</comment>

<comment type="block">/* This is used for performing a 2nd-level tokenization on the content
   of a literal that has already been returned by XmlTok.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlLiteralTok</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>literalType</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;literalScanners[literalType])(enc, ptr, end, nextTokPtr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlAttributeValueTok</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>XmlLiteralTok(enc, XML_ATTRIBUTE_VALUE_LITERAL, ptr, end, nextTokPtr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlEntityValueTok</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>nextTokPtr</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>XmlLiteralTok(enc, XML_ENTITY_VALUE_LITERAL, ptr, end, nextTokPtr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlSameName</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr1</name></type></param>, <param><type><name>ptr2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((enc)-&gt;sameName)(enc, ptr1, ptr2))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlNameMatchesAscii</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr1</name></type></param>, <param><type><name>end1</name></type></param>, <param><type><name>ptr2</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;nameMatchesAscii)(enc, ptr1, end1, ptr2))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlNameLength</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;nameLength)(enc, ptr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlSkipS</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;skipS)(enc, ptr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetAttributes</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>attsMax</name></type></param>, <param><type><name>atts</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;getAtts)(enc, ptr, attsMax, atts))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlCharRefNumber</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;charRefNumber)(enc, ptr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlPredefinedEntityName</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;predefinedEntityName)(enc, ptr, end))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlUpdatePosition</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>pos</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;updatePosition)(enc, ptr, end, pos))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlIsPublicId</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>ptr</name></type></param>, <param><type><name>end</name></type></param>, <param><type><name>badPtr</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;isPublicId)(enc, ptr, end, badPtr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlUtf8Convert</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>fromP</name></type></param>, <param><type><name>fromLim</name></type></param>, <param><type><name>toP</name></type></param>, <param><type><name>toLim</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;utf8Convert)(enc, fromP, fromLim, toP, toLim))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlUtf16Convert</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>fromP</name></type></param>, <param><type><name>fromLim</name></type></param>, <param><type><name>toP</name></type></param>, <param><type><name>toLim</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(((enc)-&gt;utf16Convert)(enc, fromP, fromLim, toP, toLim))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>ENCODING</name></type> <name>initEnc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> **</type><name>encPtr</name></decl>;</decl_stmt>
}</block></struct></type> <name>INIT_ENCODING</name>;</typedef>

<function_decl><type><name>int</name></type> <name>XmlParseXmlDecl</name><parameter_list>(<param><decl><type><name>int</name></type> <name>isGeneralTextEntity</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>badPtr</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>versionPtr</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>versionEndPtr</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>encodingNamePtr</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>ENCODING</name> **</type><name>namedEncodingPtr</name></decl></param>,
                    <param><decl><type><name>int</name> *</type><name>standalonePtr</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>XmlInitEncoding</name><parameter_list>(<param><decl><type><name>INIT_ENCODING</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> **</decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>XmlGetUtf8InternalEncoding</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>XmlGetUtf16InternalEncoding</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name> <name>FASTCALL</name></type> <name>XmlUtf8Encode</name><parameter_list>(<param><decl><type><name>int</name></type> <name>charNumber</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name> <name>FASTCALL</name></type> <name>XmlUtf16Encode</name><parameter_list>(<param><decl><type><name>int</name></type> <name>charNumber</name></decl></param>, <param><decl><type><name>unsigned</name> <name>short</name> *</type><name>buf</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>XmlSizeOfUnknownEncoding</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>


<typedef>typedef <function_decl><type><name>int</name></type> (<name>XMLCALL</name> *<name>CONVERTER</name>) <parameter_list>(<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl></typedef>

<function_decl><type><name>ENCODING</name> *</type>
<name>XmlInitUnknownEncoding</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>mem</name></decl></param>,
                       <param><decl><type><name>int</name> *</type><name>table</name></decl></param>,
                       <param><decl><type><name>CONVERTER</name></type> <name>convert</name></decl></param>,
                       <param><decl><type><name>void</name> *</type><name>userData</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>XmlParseXmlDeclNS</name><parameter_list>(<param><decl><type><name>int</name></type> <name>isGeneralTextEntity</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>badPtr</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>versionPtr</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>versionEndPtr</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>encodingNamePtr</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>ENCODING</name> **</type><name>namedEncodingPtr</name></decl></param>,
                      <param><decl><type><name>int</name> *</type><name>standalonePtr</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>XmlInitEncodingNS</name><parameter_list>(<param><decl><type><name>INIT_ENCODING</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>ENCODING</name> **</decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>XmlGetUtf8InternalEncodingNS</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>XmlGetUtf16InternalEncodingNS</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>ENCODING</name> *</type>
<name>XmlInitUnknownEncodingNS</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>mem</name></decl></param>,
                         <param><decl><type><name>int</name> *</type><name>table</name></decl></param>,
                         <param><decl><type><name>CONVERTER</name></type> <name>convert</name></decl></param>,
                         <param><decl><type><name>void</name> *</type><name>userData</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* not XmlTok_INCLUDED */</comment>
</unit>
