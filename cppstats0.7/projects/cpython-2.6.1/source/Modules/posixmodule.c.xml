<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/posixmodule.c">
<comment type="block">/* POSIX module implementation */</comment>

<comment type="block">/* This file is also used for Windows NT/MS-Win and OS/2.  In that case the
   module actually calls itself 'nt' or 'os2', not 'posix', and a few
   functions are either unimplemented or implemented differently.  The source
   assumes that for Windows NT, the macro 'MS_WINDOWS' is defined independent
   of the compiler used.  Different compilers define their own feature
   test macro, e.g. '__BORLANDC__' or '_MSC_VER'.  For OS/2, the compiler
   independent macro PYOS_OS2 should be defined.  On OS/2 the default
   compiler is assumed to be IBM's VisualAge C++ (VACPP).  PYCC_GCC is used
   as the compiler specific macro for the EMX port of gcc to OS/2. */</comment>

<comment type="block">/* See also ../Dos/dosmodule.c */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
   <comment type="block">/*
    * Step 1 of support for weak-linking a number of symbols existing on 
    * OSX 10.4 and later, see the comment in the #ifdef __APPLE__ block
    * at the end of this file for more information.
    */</comment>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> weak lchown</cpp:pragma>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> weak statvfs</cpp:pragma>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> weak fstatvfs</cpp:pragma>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __APPLE__ */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structseq.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#    <cpp:directive>include</cpp:directive> <cpp:file>&lt;unixio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__VMS) */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix__doc__</name></expr></argument>,
<argument><expr>"This module provides access to operating system functionality that is\n\
standardized by the C Standard and the POSIX standard (a thinly\n\
disguised Unix interface).  Refer to the library manual and\n\
corresponding Unix manual entries for more information on calls."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifndef>
<comment type="block">/* This is used in signatures of functions. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE</name></cpp:macro> <cpp:value>void</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>INCL_DOS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>INCL_DOSERRORS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>INCL_DOSPROCESS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>INCL_NOPMAPI</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_TYPES_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_TYPES_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_STAT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_STAT_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_WAIT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>		<comment type="block">/* For WNOHANG */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SIGNAL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FCNTL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FCNTL_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GRP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSEXITS_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sysexits.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYSEXITS_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_LOADAVG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/loadavg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Various compilers have only certain posix functions */</comment>
<comment type="block">/* XXX Gosh I wish these were all moved into pyconfig.h */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>		<comment type="block">/* Watcom compiler */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETCWD</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_OPENDIR</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SYSTEM</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OS2__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_EXECV</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_WAIT</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__BORLANDC__</name></cpp:ifdef>		<comment type="block">/* Borland compiler */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_EXECV</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETCWD</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_OPENDIR</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_PIPE</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_POPEN</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SYSTEM</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_WAIT</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>		<comment type="block">/* Microsoft compiler */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETCWD</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SPAWNV</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_EXECV</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_PIPE</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_POPEN</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SYSTEM</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_CWAIT</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FSYNC</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fsync</name></cpp:macro> <cpp:value>_commit</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Everything needed is defined in PC/os2emx/pyconfig.h or vms/pyconfig.h */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>			<comment type="block">/* all other compilers */</comment>
<comment type="block">/* Unix functions that the configure script doesn't check for */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_EXECV</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FORK</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__USLC__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__SCO_VERSION__</name></expr></argument>)</argument_list></call></expr></cpp:if>	<comment type="block">/* SCO UDK Compiler */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FORK1</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETCWD</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETEGID</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETEUID</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETGID</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETPPID</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETUID</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_KILL</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_OPENDIR</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_PIPE</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__rtems__</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_POPEN</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SYSTEM</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_WAIT</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_TTYNAME</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* PYOS_OS2 &amp;&amp; PYCC_GCC &amp;&amp; __VMS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* _MSC_VER */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* __BORLANDC__ */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* ! __WATCOMC__ || __QNX__ */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ! __IBMC__ */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_MSC_VER</name></cpp:ifndef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call>&amp;&amp;<name>_COMPILER_VERSION</name>&gt;=700</expr></cpp:if>
<comment type="block">/* declare ctermid_r if compiling with MIPSPro 7.x in ANSI C mode
   (default) */</comment>
<function_decl><type><specifier>extern</specifier> <name>char</name>        *</type><name>ctermid_r</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNISTD_H</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>mkdir</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>( <call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> ) &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>mkdir</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>mkdir</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>mode_t</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__IBMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__IBMCPP__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chdir</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>rmdir</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chdir</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>rmdir</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__BORLANDC__</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chmod</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chmod</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>mode_t</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*#ifdef HAVE_FCHMOD
extern int fchmod(int, mode_t);
#endif*/</comment>
<comment type="block">/*#ifdef HAVE_LCHMOD
extern int lchmod(const char *, mode_t);
#endif*/</comment>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>chown</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>uid_t</name></type></decl></param>, <param><decl><type><name>gid_t</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>getcwd</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>strerror</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>link</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>rename</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>stat</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type>struct</type> <name>stat</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>unlink</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>pclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>symlink</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYMLINK */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LSTAT</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>lstat</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type>struct</type> <name>stat</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LSTAT */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_UNISTD_H */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !_MSC_VER */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIME_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_UTIME_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_UTIME_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utime.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_UTIME_H</name></cpp:macro></cpp:define> <comment type="block">/* pretend we do for the rest of this file */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_UTIME_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_TIMES_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/times.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_TIMES_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_PARAM_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_PARAM_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_UTSNAME_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utsname.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_UTSNAME_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DIRENT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMLEN</name><parameter_list>(<param><type><name>dirent</name></type></param>)</parameter_list></cpp:macro> <cpp:value>strlen((dirent)-&gt;d_name)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMLEN</name><parameter_list>(<param><type><name>dirent</name></type></param>)</parameter_list></cpp:macro> <cpp:value>strlen((dirent)-&gt;d_name)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dirent</name></cpp:macro> <cpp:value>direct</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMLEN</name><parameter_list>(<param><type><name>dirent</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(dirent)-&gt;d_namlen</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_NDIR_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ndir.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_DIR_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/dir.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NDIR_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ndir.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DIRECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IO_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PROCESS_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;shellapi.h&gt;</cpp:file></cpp:include>	<comment type="block">/* for ShellExecute() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>popen</name></cpp:macro>	<cpp:value>_popen</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pclose</name></cpp:macro>	<cpp:value>_pclose</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _MSC_VER */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS2 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAXPATHLEN</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PATH_MAX</name> &gt; 1024</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHLEN</name></cpp:macro> <cpp:value>PATH_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHLEN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MAXPATHLEN */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNION_WAIT</name></cpp:ifdef>
<comment type="block">/* Emulate some macros on systems that have a union instead of macros */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIFEXITED</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIFEXITED</name><parameter_list>(<param><type><name>u_wait</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(!(u_wait).w_termsig &amp;&amp; !(u_wait).w_coredump)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WEXITSTATUS</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WEXITSTATUS</name><parameter_list>(<param><type><name>u_wait</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(WIFEXITED(u_wait)?((u_wait).w_retcode):-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WTERMSIG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WTERMSIG</name><parameter_list>(<param><type><name>u_wait</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((u_wait).w_termsig)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_TYPE</name></cpp:macro> <cpp:value>union wait</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_STATUS_INT</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(s.w_status)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !UNION_WAIT */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_TYPE</name></cpp:macro> <cpp:value>int</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_STATUS_INT</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(s)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* UNION_WAIT */</comment>

<comment type="block">/* Don't use the "_r" form if we don't need it (also, won't have a
   prototype for it, at least on Solaris -- maybe others as well?). */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CTERMID_R</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CTERMID_R</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TMPNAM_R</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_TMPNAM_R</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* choose the appropriate stat and fstat functions and return structs */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STAT</name></cpp:undef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT</name></cpp:macro> <cpp:value>win32_stat</cpp:value></cpp:define>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>FSTAT</name></cpp:macro> <cpp:value>win32_fstat</cpp:value></cpp:define>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>STRUCT_STAT</name></cpp:macro> <cpp:value>struct win32_stat</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT</name></cpp:macro> <cpp:value>stat</cpp:value></cpp:define>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>FSTAT</name></cpp:macro> <cpp:value>fstat</cpp:value></cpp:define>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>STRUCT_STAT</name></cpp:macro> <cpp:value>struct stat</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAJOR_IN_MKDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mkdev.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAJOR_IN_SYSMACROS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysmacros.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKNOD</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_MKDEV_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mkdev.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Return a dictionary corresponding to the POSIX environment table */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_NEXT_FRAMEWORK</name></cpp:ifdef>
<comment type="block">/* On Darwin/MacOSX a shared library or framework has no access to
** environ directly, we must obtain it with _NSGetEnviron().
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crt_externs.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> **</type><name>environ</name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> &amp;&amp; ( !<call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call> )</expr></cpp:elif>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> **</type><name>environ</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !_MSC_VER */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>convertenviron</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>e</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>d</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_NEXT_FRAMEWORK</name></cpp:ifdef>
	<if>if <condition>(<expr><name>environ</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>environ</name> = *<call><name>_NSGetEnviron</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>environ</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>d</name></expr>;</return></then></if>
	<comment type="block">/* This part ignores errors */</comment>
	<for>for (<init><expr><name>e</name> = <name>environ</name></expr>;</init> <condition><expr>*<name>e</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>e</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>k</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr>*<name>e</name></expr></argument>, <argument><expr>'='</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><name>k</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>*<name>e</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>p</name>-*<name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>k</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>
		<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>p</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <block>{
        <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>   <name><name>buffer</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* OS/2 Provides a Documented Max of 1024 Chars */</comment>

        <expr_stmt><expr><name>rc</name> = <call><name>DosQueryExtLIBPATH</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BEGIN_LIBPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then> <block>{ <comment type="block">/* (not a type, envname is NOT 'BEGIN_LIBPATH') */</comment>
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		    <expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"BEGINLIBPATH"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>rc</name> = <call><name>DosQueryExtLIBPATH</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>END_LIBPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then> <block>{ <comment type="block">/* (not a typo, envname is NOT 'END_LIBPATH') */</comment>
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		    <expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"ENDLIBPATH"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>d</name></expr>;</return>
}</block></function>


<comment type="block">/* Set a POSIX-specific error from errno, and return NULL */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_error_with_filename</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>name</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_error_with_unicode_filename</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name>*</type> <name>name</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyErr_SetFromErrnoWithUnicodeFilename</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_WIN_WIDE_FILENAMES */</comment>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_error_with_allocated_filename</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>rc</name> <init>= <expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_error</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>function</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>filename</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX We should pass the function name along in the future.
	   (_winreg.c also wants to pass the function name.)
	   This would however require an additional param to the
	   Windows error object, which is non-trivial.
	*/</comment>
	<expr_stmt><expr><name>errno</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>filename</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_error_unicode</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>function</name></decl></param>, <param><decl><type><name>Py_UNICODE</name>*</type> <name>filename</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX - see win32_error for comments on 'function' */</comment>
	<expr_stmt><expr><name>errno</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>filename</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_SetFromWindowsErrWithUnicodeFilename</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyErr_SetFromWindowsErr</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyUnicode_FromFileSystemEncodedObject</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_to_unicode</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>param</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<comment type="block">/* For a Unicode subtype that's not a Unicode object,
		   return a true Unicode object with the same data. */</comment>
		<expr_stmt><expr>*<name>param</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr></argument>,
					       <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr>*<name>param</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr>*<name>param</name></expr></argument>,
				                     <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
					             <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	<return>return <expr>(*<name>param</name>) != <name>NULL</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_WIN_WIDE_FILENAMES */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/**********************************************************************
 *         Helper Function to Trim and Format OS/2 Messages
 **********************************************************************/</comment>
    <function><type><specifier>static</specifier> <name>void</name></type>
<name>os2_formatmsg</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msgbuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>msglen</name></decl></param>, <param><decl><type><name>char</name> *</type><name>reason</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>msgbuf</name><index>[<expr><name>msglen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt> <comment type="block">/* OS/2 Doesn't Guarantee a Terminator */</comment>

    <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{ <comment type="block">/* If Non-Empty Msg, Trim CRLF */</comment>
        <decl_stmt><decl><type><name>char</name> *</type><name>lastc</name> <init>= <expr>&amp;<name><name>msgbuf</name><index>[ <expr><call><name>strlen</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call>-1</expr> ]</index></name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>lastc</name> &gt; <name>msgbuf</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>lastc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <expr_stmt><expr>*<name>lastc</name>-- = '\0'</expr>;</expr_stmt></while> <comment type="block">/* Trim Trailing Whitespace (CRLF) */</comment>
    }</block></then></if>

    <comment type="block">/* Add Optional Reason Text */</comment>
    <if>if <condition>(<expr><name>reason</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr>" : "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/**********************************************************************
 *             Decode an OS/2 Operating System Error Code
 *
 * A convenience function to lookup an OS/2 error code and return a
 * text message we can use to raise a Python exception.
 *
 * Notes:
 *   The messages for errors returned from the OS/2 kernel reside in
 *   the file OSO001.MSG in the \OS2 directory hierarchy.
 *
 **********************************************************************/</comment>
    <function><type><specifier>static</specifier> <name>char</name> *</type>
<name>os2_strerror</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msgbuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>msgbuflen</name></decl></param>, <param><decl><type><name>int</name></type> <name>errorcode</name></decl></param>, <param><decl><type><name>char</name> *</type><name>reason</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ULONG</name></type>  <name>msglen</name></decl>;</decl_stmt>

    <comment type="block">/* Retrieve Kernel-Related Error Message from OSO001.MSG File */</comment>
    <decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
    <name>rc</name> <init>= <expr><call><name>DosGetMessage</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>msgbuflen</name></expr></argument>,
                       <argument><expr><name>errorcode</name></expr></argument>, <argument><expr>"oso001.msg"</expr></argument>, <argument><expr>&amp;<name>msglen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <macro><name>Py_END_ALLOW_THREADS</name></macro>

    <if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>os2_formatmsg</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>msglen</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>msgbuflen</name></expr></argument>,
        	      <argument><expr>"unknown OS error #%d"</expr></argument>, <argument><expr><name>errorcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <return>return <expr><name>msgbuf</name></expr>;</return>
}</block></function>

<comment type="block">/* Set an OS/2-specific error and return NULL.  OS/2 kernel
   errors are not in a global variable e.g. 'errno' nor are
   they congruent with posix error numbers. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>os2_error</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>text</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>os2_strerror</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* Signal to Python that an Exception is Pending */</comment>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS2 */</comment>

<comment type="block">/* POSIX generic methods */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fildes</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>fdobj</name></decl></param>, <param><function_decl><type><name>int</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>fd</name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>(<argument><expr><name>fdobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unicode_file_names</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>canusewide</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>canusewide</name> == -1</expr>)</condition><then> <block>{
		<comment type="block">/* As per doc for ::GetVersion(), this is the correct test for
		   the Windows NT family. */</comment>
		<expr_stmt><expr><name>canusewide</name> = (<call><name>GetVersion</name><argument_list>()</argument_list></call> &lt; 0x80000000) ? 1 : 0</expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>canusewide</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_1str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>char</name> *</type><name>format</name></decl></param>, <param><function_decl><type><name>int</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name>*</decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_2str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
	   <param><decl><type><name>char</name> *</type><name>format</name></decl></param>,
	   <param><function_decl><type><name>int</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path1</name> <init>= <expr><name>NULL</name></expr></init>, *<name>path2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path1</name></expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call>(*<name>func</name>)<argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>PyMem_Free</name><parameter_list>(<param><decl><type><name>path1</name></type></decl></param>)</parameter_list>;</function_decl>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
		<comment type="block">/* XXX how to report both path1 and path2??? */</comment>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>win32_1str</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>func</name></decl></param>, 
	   <param><decl><type><name>char</name>*</type> <name>format</name></decl></param>, <param><function_decl><type><name>BOOL</name></type> (<name>__stdcall</name> *<name>funcA</name>)<parameter_list>(<param><decl><type><name>LPCSTR</name></type></decl></param>)</parameter_list></function_decl></param>, 
	   <param><decl><type><name>char</name>*</type> <name>wformat</name></decl></param>, <param><function_decl><type><name>BOOL</name></type> (<name>__stdcall</name> *<name>funcW</name>)<parameter_list>(<param><decl><type><name>LPWSTR</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>uni</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>ansi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>wformat</name></expr></argument>, <argument><expr>&amp;<name>uni</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
			<name>result</name> <init>= <expr><call><name>funcW</name><argument_list>(<argument><expr><call><name>PyUnicode_AsUnicode</name><argument_list>(<argument><expr><name>uni</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>Py_END_ALLOW_THREADS</name></macro>
			<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
				<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><call><name>PyUnicode_AsUnicode</name><argument_list>(<argument><expr><name>uni</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>Py_None</name></expr>;</return>
		}</block></else></if>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr>&amp;<name>ansi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>result</name> <init>= <expr><call><name>funcA</name><argument_list>(<argument><expr><name>ansi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>ansi</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>

}</block></function>

<comment type="block">/* This is a reimplementation of the C library's chdir function,
   but one that produces Win32 errors instead of DOS error codes.
   chdir is essentially a wrapper around SetCurrentDirectory; however,
   it also needs to set "magic" environment variables indicating
   the per-drive current directory, which are of the form =&lt;drive&gt;: */</comment>
<function><type><name>BOOL</name> <name>__stdcall</name></type>
<name>win32_chdir</name><parameter_list>(<param><decl><type><name>LPCSTR</name></type> <name>path</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>new_path</name><index>[<expr><name>MAX_PATH</name>+1</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>env</name><index>[<expr>4</expr>]</index></name> <init>= <expr>"=x:"</expr></init></decl>;</decl_stmt>

	<if>if<condition>(<expr>!<call><name>SetCurrentDirectoryA</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>GetCurrentDirectoryA</name><argument_list>(<argument><expr><name>MAX_PATH</name>+1</expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<comment type="block">/* In the ANSI API, there should not be any paths longer
	   than MAX_PATH. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result</name> &lt;= <name>MAX_PATH</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr>"\\\\"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 0 ||
	    <call><name>strncmp</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr>"//"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	    <comment type="block">/* UNC path, nothing to do. */</comment>
	    <return>return <expr><name>TRUE</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>env</name><index>[<expr>1</expr>]</index></name> = <name><name>new_path</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	<return>return <expr><call><name>SetEnvironmentVariableA</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* The Unicode version differs from the ANSI version
   since the current directory might exceed MAX_PATH characters */</comment>
<function><type><name>BOOL</name> <name>__stdcall</name></type>
<name>win32_wchdir</name><parameter_list>(<param><decl><type><name>LPCWSTR</name></type> <name>path</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>wchar_t</name></type> <name><name>_new_path</name><index>[<expr><name>MAX_PATH</name>+1</expr>]</index></name></decl>, *<decl><type ref="prev"/><name>new_path</name> <init>= <expr><name>_new_path</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>wchar_t</name></type> <name><name>env</name><index>[<expr>4</expr>]</index></name> <init>= <expr>L"=x:"</expr></init></decl>;</decl_stmt>

	<if>if<condition>(<expr>!<call><name>SetCurrentDirectoryW</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>GetCurrentDirectoryW</name><argument_list>(<argument><expr><name>MAX_PATH</name>+1</expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>result</name> &gt; <name>MAX_PATH</name>+1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>new_path</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>result</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>new_path</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_OUTOFMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>FALSE</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>GetCurrentDirectoryW</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>FALSE</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>wcsncmp</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr>L"\\\\"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 0 ||
	    <call><name>wcsncmp</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr>L"//"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	    <comment type="block">/* UNC path, nothing to do. */</comment>
	    <return>return <expr><name>TRUE</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>env</name><index>[<expr>1</expr>]</index></name> = <name><name>new_path</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>SetEnvironmentVariableW</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>new_path</name> != <name>_new_path</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<comment type="block">/* The CRT of Windows has a number of flaws wrt. its stat() implementation:
   - time stamps are restricted to second resolution
   - file modification times suffer from forth-and-back conversions between
     UTC and local time
   Therefore, we implement our own stat, based on the Win32 API directly.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_STAT_NSEC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<struct>struct <name>win32_stat</name><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>st_dev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>__int64</name></type> <name>st_ino</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>st_mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_nlink</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_uid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_gid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_rdev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>__int64</name></type> <name>st_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_atime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_atime_nsec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_mtime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_mtime_nsec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_ctime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>st_ctime_nsec</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>__int64</name></type> <name>secs_between_epochs</name> <init>= <expr>11644473600</expr></init></decl>;</decl_stmt> <comment type="block">/* Seconds between 1.1.1601 and 1.1.1970 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FILE_TIME_to_time_t_nsec</name><parameter_list>(<param><decl><type><name>FILETIME</name> *</type><name>in_ptr</name></decl></param>, <param><decl><type><name>int</name> *</type><name>time_out</name></decl></param>, <param><decl><type><name>int</name>*</type> <name>nsec_out</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX endianness. Shouldn't matter, as all Windows implementations are little-endian */</comment>
	<comment type="block">/* Cannot simply cast and dereference in_ptr, 
	   since it might not be aligned properly */</comment>
	<decl_stmt><decl><type><name>__int64</name></type> <name>in</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>in</name></expr></argument>, <argument><expr><name>in_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>nsec_out</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>in</name> % 10000000</expr></argument>)</argument_list></call> * 100</expr>;</expr_stmt> <comment type="block">/* FILETIME is in units of 100 nsec. */</comment>
	<comment type="block">/* XXX Win32 supports time stamps past 2038; we currently don't */</comment>
	<expr_stmt><expr>*<name>time_out</name> = <call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr>(<name>in</name> / 10000000) - <name>secs_between_epochs</name></expr></argument>, <argument><expr><name>__int64</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>time_t_to_FILE_TIME</name><parameter_list>(<param><decl><type><name>int</name></type> <name>time_in</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsec_in</name></decl></param>, <param><decl><type><name>FILETIME</name> *</type><name>out_ptr</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX endianness */</comment>
	<decl_stmt><decl><type><name>__int64</name></type> <name>out</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>out</name> = <name>time_in</name> + <name>secs_between_epochs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>out</name> = <name>out</name> * 10000000 + <name>nsec_in</name> / 100</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out_ptr</name></expr></argument>, <argument><expr>&amp;<name>out</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Below, we *know* that ugo+r is 0444 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_S_IREAD</name> != 0400</expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> Unsupported C library</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>attributes_to_mode</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>attr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>attr</name> &amp; <name>FILE_ATTRIBUTE_DIRECTORY</name></expr>)</condition><then>
		<expr_stmt><expr><name>m</name> |= <name>_S_IFDIR</name> | 0111</expr>;</expr_stmt></then> <comment type="block">/* IFEXEC for user,group,other */</comment>
	<else>else
		<expr_stmt><expr><name>m</name> |= <name>_S_IFREG</name></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>attr</name> &amp; <name>FILE_ATTRIBUTE_READONLY</name></expr>)</condition><then>
		<expr_stmt><expr><name>m</name> |= 0444</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>m</name> |= 0666</expr>;</expr_stmt></else></if>
	<return>return <expr><name>m</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>attribute_data_to_stat</name><parameter_list>(<param><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name> *</type><name>info</name></decl></param>, <param><decl><type>struct <name>win32_stat</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> = <call><name>attributes_to_mode</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>dwFileAttributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>st_size</name></name> = (((<name>__int64</name>)<name><name>info</name>-&gt;<name>nFileSizeHigh</name></name>)&lt;&lt;32) + <name><name>info</name>-&gt;<name>nFileSizeLow</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>-&gt;<name>ftCreationTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_ctime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_ctime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>-&gt;<name>ftLastWriteTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_mtime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_mtime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>-&gt;<name>ftLastAccessTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_atime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_atime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Emulate GetFileAttributesEx[AW] on Windows 95 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>checked</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>BOOL</name></type> (<name>CALLBACK</name> *<name>gfaxa</name>)<parameter_list>(<param><decl><type><name>LPCSTR</name></type></decl></param>, <param><decl><type><name>GET_FILEEX_INFO_LEVELS</name></type></decl></param>, <param><decl><type><name>LPVOID</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BOOL</name></type> (<name>CALLBACK</name> *<name>gfaxw</name>)<parameter_list>(<param><decl><type><name>LPCWSTR</name></type></decl></param>, <param><decl><type><name>GET_FILEEX_INFO_LEVELS</name></type></decl></param>, <param><decl><type><name>LPVOID</name></type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_gfax</name><parameter_list>()</parameter_list>
<block>{
	<decl_stmt><decl><type><name>HINSTANCE</name></type> <name>hKernel32</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>checked</name></expr>)</condition><then>
	    <return>return;</return></then></if>
	<expr_stmt><expr><name>checked</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>hKernel32</name> = <call><name>GetModuleHandle</name><argument_list>(<argument><expr>"KERNEL32"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*(<name>FARPROC</name>*)&amp;<name>gfaxa</name> = <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hKernel32</name></expr></argument>, <argument><expr>"GetFileAttributesExA"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*(<name>FARPROC</name>*)&amp;<name>gfaxw</name> = <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hKernel32</name></expr></argument>, <argument><expr>"GetFileAttributesExW"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>attributes_from_dir</name><parameter_list>(<param><decl><type><name>LPCSTR</name></type> <name>pszFile</name></decl></param>, <param><decl><type><name>LPWIN32_FILE_ATTRIBUTE_DATA</name></type> <name>pfad</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFindFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WIN32_FIND_DATAA</name></type> <name>FileData</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>hFindFile</name> = <call><name>FindFirstFileA</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr>&amp;<name>FileData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>hFindFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>dwFileAttributes</name></name> = <name><name>FileData</name>.<name>dwFileAttributes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftCreationTime</name></name>   = <name><name>FileData</name>.<name>ftCreationTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftLastAccessTime</name></name> = <name><name>FileData</name>.<name>ftLastAccessTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftLastWriteTime</name></name>  = <name><name>FileData</name>.<name>ftLastWriteTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>nFileSizeHigh</name></name>    = <name><name>FileData</name>.<name>nFileSizeHigh</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>nFileSizeLow</name></name>     = <name><name>FileData</name>.<name>nFileSizeLow</name></name></expr>;</expr_stmt>
	<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>attributes_from_dir_w</name><parameter_list>(<param><decl><type><name>LPCWSTR</name></type> <name>pszFile</name></decl></param>, <param><decl><type><name>LPWIN32_FILE_ATTRIBUTE_DATA</name></type> <name>pfad</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFindFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WIN32_FIND_DATAW</name></type> <name>FileData</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>hFindFile</name> = <call><name>FindFirstFileW</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr>&amp;<name>FileData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>hFindFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>dwFileAttributes</name></name> = <name><name>FileData</name>.<name>dwFileAttributes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftCreationTime</name></name>   = <name><name>FileData</name>.<name>ftCreationTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftLastAccessTime</name></name> = <name><name>FileData</name>.<name>ftLastAccessTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>ftLastWriteTime</name></name>  = <name><name>FileData</name>.<name>ftLastWriteTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>nFileSizeHigh</name></name>    = <name><name>FileData</name>.<name>nFileSizeHigh</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfad</name>-&gt;<name>nFileSizeLow</name></name>     = <name><name>FileData</name>.<name>nFileSizeLow</name></name></expr>;</expr_stmt>
	<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type>
<name>Py_GetFileAttributesExA</name><parameter_list>(<param><decl><type><name>LPCSTR</name></type> <name>pszFile</name></decl></param>, 
		       <param><decl><type><name>GET_FILEEX_INFO_LEVELS</name></type> <name>level</name></decl></param>,
                       <param><decl><type><name>LPVOID</name></type> <name>pv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LPWIN32_FILE_ATTRIBUTE_DATA</name></type> <name>pfad</name> <init>= <expr><name>pv</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* First try to use the system's implementation, if that is
	   available and either succeeds to gives an error other than
	   that it isn't implemented. */</comment>
	<expr_stmt><expr><call><name>check_gfax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>gfaxa</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>gfaxa</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> || <call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_CALL_NOT_IMPLEMENTED</name></expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
	}</block></then></if>
	<comment type="block">/* It's either not present, or not implemented.
	   Emulate using FindFirstFile. */</comment>
	<if>if <condition>(<expr><name>level</name> != <name>GetFileExInfoStandard</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_INVALID_PARAMETER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>FALSE</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* Use GetFileAttributes to validate that the file name
	   does not contain wildcards (which FindFirstFile would
	   accept). */</comment>
	<if>if <condition>(<expr><call><name>GetFileAttributesA</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>)</argument_list></call> == 0xFFFFFFFF</expr>)</condition><then>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<return>return <expr><call><name>attributes_from_dir</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr><name>pfad</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type>
<name>Py_GetFileAttributesExW</name><parameter_list>(<param><decl><type><name>LPCWSTR</name></type> <name>pszFile</name></decl></param>, 
		       <param><decl><type><name>GET_FILEEX_INFO_LEVELS</name></type> <name>level</name></decl></param>,
                       <param><decl><type><name>LPVOID</name></type> <name>pv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LPWIN32_FILE_ATTRIBUTE_DATA</name></type> <name>pfad</name> <init>= <expr><name>pv</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* First try to use the system's implementation, if that is
	   available and either succeeds to gives an error other than
	   that it isn't implemented. */</comment>
	<expr_stmt><expr><call><name>check_gfax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>gfaxa</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>gfaxw</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> || <call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_CALL_NOT_IMPLEMENTED</name></expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
	}</block></then></if>
	<comment type="block">/* It's either not present, or not implemented.
	   Emulate using FindFirstFile. */</comment>
	<if>if <condition>(<expr><name>level</name> != <name>GetFileExInfoStandard</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_INVALID_PARAMETER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>FALSE</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* Use GetFileAttributes to validate that the file name
	   does not contain wildcards (which FindFirstFile would
	   accept). */</comment>
	<if>if <condition>(<expr><call><name>GetFileAttributesW</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>)</argument_list></call> == 0xFFFFFFFF</expr>)</condition><then>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<return>return <expr><call><name>attributes_from_dir_w</name><argument_list>(<argument><expr><name>pszFile</name></expr></argument>, <argument><expr><name>pfad</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>win32_stat</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>path</name></decl></param>, <param><decl><type>struct <name>win32_stat</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>dot</name></decl>;</decl_stmt>
	<comment type="block">/* XXX not supported on Win95 and NT 3.x */</comment>
	<if>if <condition>(<expr>!<call><name>Py_GetFileAttributesExA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>GetFileExInfoStandard</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_SHARING_VIOLATION</name></expr>)</condition><then> <block>{
			<comment type="block">/* Protocol violation: we explicitly clear errno, instead of
			   setting it to a POSIX error. Callers should use GetLastError. */</comment>
			<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then> <else>else <block>{
			<comment type="block">/* Could not get attributes on open file. Fall back to
			   reading the directory. */</comment>
			<if>if <condition>(<expr>!<call><name>attributes_from_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* Very strange. This should not fail now */</comment>
				<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></else></if>
	}</block></then></if>
	<expr_stmt><expr><name>code</name> = <call><name>attribute_data_to_stat</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>code</name> != 0</expr>)</condition><then>
		<return>return <expr><name>code</name></expr>;</return></then></if>
	<comment type="block">/* Set S_IFEXEC if it is an .exe, .bat, ... */</comment>
	<expr_stmt><expr><name>dot</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dot</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>".bat"</expr></argument>)</argument_list></call> == 0 ||
		<call><name>stricmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>".cmd"</expr></argument>)</argument_list></call> == 0 ||
		<call><name>stricmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>".exe"</expr></argument>)</argument_list></call> == 0 ||
		<call><name>stricmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>".com"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> |= 0111</expr>;</expr_stmt></then></if>
	}</block></then></if>
	<return>return <expr><name>code</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>win32_wstat</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>wchar_t</name>*</type> <name>path</name></decl></param>, <param><decl><type>struct <name>win32_stat</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>wchar_t</name> *</type><name>dot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name></type> <name>info</name></decl>;</decl_stmt>
	<comment type="block">/* XXX not supported on Win95 and NT 3.x */</comment>
	<if>if <condition>(<expr>!<call><name>Py_GetFileAttributesExW</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>GetFileExInfoStandard</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_SHARING_VIOLATION</name></expr>)</condition><then> <block>{
			<comment type="block">/* Protocol violation: we explicitly clear errno, instead of
			   setting it to a POSIX error. Callers should use GetLastError. */</comment>
			<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then> <else>else <block>{
			<comment type="block">/* Could not get attributes on open file. Fall back to
			   reading the directory. */</comment>
			<if>if <condition>(<expr>!<call><name>attributes_from_dir_w</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/* Very strange. This should not fail now */</comment>
				<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
		}</block></else></if>
	}</block></then></if>
	<expr_stmt><expr><name>code</name> = <call><name>attribute_data_to_stat</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>code</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>code</name></expr>;</return></then></if>
	<comment type="block">/* Set IFEXEC if it is an .exe, .bat, ... */</comment>
	<expr_stmt><expr><name>dot</name> = <call><name>wcsrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dot</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>_wcsicmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>L".bat"</expr></argument>)</argument_list></call> == 0 ||
		    <call><name>_wcsicmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>L".cmd"</expr></argument>)</argument_list></call> == 0 ||
		    <call><name>_wcsicmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>L".exe"</expr></argument>)</argument_list></call> == 0 ||
		    <call><name>_wcsicmp</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr>L".com"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> |= 0111</expr>;</expr_stmt></then></if>
	}</block></then></if>
	<return>return <expr><name>code</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>win32_fstat</name><parameter_list>(<param><decl><type><name>int</name></type> <name>file_number</name></decl></param>, <param><decl><type>struct <name>win32_stat</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>BY_HANDLE_FILE_INFORMATION</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
    
	<expr_stmt><expr><name>h</name> = (<name>HANDLE</name>)<call><name>_get_osfhandle</name><argument_list>(<argument><expr><name>file_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
	<comment type="block">/* Protocol violation: we explicitly clear errno, instead of
	   setting it to a POSIX error. Callers should use GetLastError. */</comment>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr><name>h</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
    		<comment type="block">/* This is really a C library error (invalid file handle).
		   We set the Win32 error to the closes one matching. */</comment>
		<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_INVALID_HANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> = <call><name>GetFileType</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>type</name> == <name>FILE_TYPE_UNKNOWN</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>DWORD</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>error</name> != 0</expr>)</condition><then> <block>{
		<return>return <expr>-1</expr>;</return>
	    }</block></then></if>
	    <comment type="block">/* else: valid but unknown file */</comment>
	}</block></then></if>

	<if>if <condition>(<expr><name>type</name> != <name>FILE_TYPE_DISK</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>type</name> == <name>FILE_TYPE_CHAR</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> = <name>_S_IFCHR</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>type</name> == <name>FILE_TYPE_PIPE</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> = <name>_S_IFIFO</name></expr>;</expr_stmt></then></if></else></if>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>GetFileInformationByHandle</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<comment type="block">/* similar to stat() */</comment>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>st_mode</name></name> = <call><name>attributes_to_mode</name><argument_list>(<argument><expr><name><name>info</name>.<name>dwFileAttributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>st_size</name></name> = (((<name>__int64</name>)<name><name>info</name>.<name>nFileSizeHigh</name></name>)&lt;&lt;32) + <name><name>info</name>.<name>nFileSizeLow</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>.<name>ftCreationTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_ctime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_ctime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>.<name>ftLastWriteTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_mtime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_mtime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FILE_TIME_to_time_t_nsec</name><argument_list>(<argument><expr>&amp;<name><name>info</name>.<name>ftLastAccessTime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_atime</name></name></expr></argument>, <argument><expr>&amp;<name><name>result</name>-&gt;<name>st_atime_nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* specific to fstat() */</comment>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>st_nlink</name></name> = <name><name>info</name>.<name>nNumberOfLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>st_ino</name></name> = (((<name>__int64</name>)<name><name>info</name>.<name>nFileIndexHigh</name></name>)&lt;&lt;32) + <name><name>info</name>.<name>nFileIndexLow</name></name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>stat_result__doc__</name></expr></argument>,
<argument><expr>"stat_result: Result from stat or lstat.\n\n\
This object may be accessed either as a tuple of\n\
  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\n\
or via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\n\
\n\
Posix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\n\
or st_flags, they are available as attributes only.\n\
\n\
See os.stat for more information."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>stat_result_fields</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"st_mode"</expr>,    <expr>"protection bits"</expr>}</block></expr>,
	<expr><block>{<expr>"st_ino"</expr>,     <expr>"inode"</expr>}</block></expr>,
	<expr><block>{<expr>"st_dev"</expr>,     <expr>"device"</expr>}</block></expr>,
	<expr><block>{<expr>"st_nlink"</expr>,   <expr>"number of hard links"</expr>}</block></expr>,
	<expr><block>{<expr>"st_uid"</expr>,     <expr>"user ID of owner"</expr>}</block></expr>,
	<expr><block>{<expr>"st_gid"</expr>,     <expr>"group ID of owner"</expr>}</block></expr>,
	<expr><block>{<expr>"st_size"</expr>,    <expr>"total size, in bytes"</expr>}</block></expr>,
	<comment type="block">/* The NULL is replaced with PyStructSequence_UnnamedField later. */</comment>
	<expr><block>{<expr><name>NULL</name></expr>,   <expr>"integer time of last access"</expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,   <expr>"integer time of last modification"</expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,   <expr>"integer time of last change"</expr>}</block></expr>,
	<expr><block>{<expr>"st_atime"</expr>,   <expr>"time of last access"</expr>}</block></expr>,
	<expr><block>{<expr>"st_mtime"</expr>,   <expr>"time of last modification"</expr>}</block></expr>,
	<expr><block>{<expr>"st_ctime"</expr>,   <expr>"time of last change"</expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_BLKSIZE</name></cpp:ifdef>
	<expr><block>{<expr>"st_blksize"</expr>, <expr>"blocksize for filesystem I/O"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_BLOCKS</name></cpp:ifdef>
	<expr><block>{<expr>"st_blocks"</expr>,  <expr>"number of blocks allocated"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_RDEV</name></cpp:ifdef>
	<expr><block>{<expr>"st_rdev"</expr>,    <expr>"device type (if inode device)"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_FLAGS</name></cpp:ifdef>
	<expr><block>{<expr>"st_flags"</expr>,   <expr>"user defined flags for file"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_GEN</name></cpp:ifdef>
	<expr><block>{<expr>"st_gen"</expr>,    <expr>"generation number"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_BIRTHTIME</name></cpp:ifdef>
	<expr><block>{<expr>"st_birthtime"</expr>,   <expr>"time of creation"</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_BLKSIZE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BLKSIZE_IDX</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BLKSIZE_IDX</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_BLOCKS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BLOCKS_IDX</name></cpp:macro> <cpp:value>(ST_BLKSIZE_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BLOCKS_IDX</name></cpp:macro> <cpp:value>ST_BLKSIZE_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_RDEV</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_RDEV_IDX</name></cpp:macro> <cpp:value>(ST_BLOCKS_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_RDEV_IDX</name></cpp:macro> <cpp:value>ST_BLOCKS_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_FLAGS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_FLAGS_IDX</name></cpp:macro> <cpp:value>(ST_RDEV_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_FLAGS_IDX</name></cpp:macro> <cpp:value>ST_RDEV_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_GEN</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_GEN_IDX</name></cpp:macro> <cpp:value>(ST_FLAGS_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_GEN_IDX</name></cpp:macro> <cpp:value>ST_FLAGS_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_BIRTHTIME</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BIRTHTIME_IDX</name></cpp:macro> <cpp:value>(ST_GEN_IDX+1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_BIRTHTIME_IDX</name></cpp:macro> <cpp:value>ST_GEN_IDX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>stat_result_desc</name> <init>= <expr><block>{
	<expr>"stat_result"</expr>, <comment type="block">/* name */</comment>
	<expr><name>stat_result__doc__</name></expr>, <comment type="block">/* doc */</comment>
	<expr><name>stat_result_fields</name></expr>,
	<expr>10</expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>statvfs_result__doc__</name></expr></argument>,
<argument><expr>"statvfs_result: Result from statvfs or fstatvfs.\n\n\
This object may be accessed either as a tuple of\n\
  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\n\
or via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\n\
\n\
See os.statvfs for more information."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>statvfs_result_fields</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{<expr>"f_bsize"</expr>,  }</block></expr>,
        <expr><block>{<expr>"f_frsize"</expr>, }</block></expr>,
        <expr><block>{<expr>"f_blocks"</expr>, }</block></expr>,
        <expr><block>{<expr>"f_bfree"</expr>,  }</block></expr>,
        <expr><block>{<expr>"f_bavail"</expr>, }</block></expr>,
        <expr><block>{<expr>"f_files"</expr>,  }</block></expr>,
        <expr><block>{<expr>"f_ffree"</expr>,  }</block></expr>,
        <expr><block>{<expr>"f_favail"</expr>, }</block></expr>,
        <expr><block>{<expr>"f_flag"</expr>,   }</block></expr>,
        <expr><block>{<expr>"f_namemax"</expr>,}</block></expr>,
        <expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>statvfs_result_desc</name> <init>= <expr><block>{
	<expr>"statvfs_result"</expr>, <comment type="block">/* name */</comment>
	<expr><name>statvfs_result__doc__</name></expr>, <comment type="block">/* doc */</comment>
	<expr><name>statvfs_result_fields</name></expr>,
	<expr>10</expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>StatResultType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>StatVFSResultType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>newfunc</name></type> <name>structseq_new</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>statresult_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyStructSequence</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> = (<name>PyStructSequence</name>*)<call><name>structseq_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* If we have been initialized from a tuple,
	   st_?time might be set to None. Initialize it
	   from the int slots.  */</comment>
	<for>for (<init><expr><name>i</name> = 7</expr>;</init> <condition><expr><name>i</name> &lt;= 9</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>result</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name>+3</expr>]</index></name> == <name>Py_None</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name>+3</expr>]</index></name> = <name><name>result</name>-&gt;<name>ob_item</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<return>return <expr>(<name>PyObject</name>*)<name>result</name></expr>;</return>
}</block></function>



<comment type="block">/* If true, st_?time is float. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>_stat_float_times</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>stat_float_times__doc__</name></expr></argument>,
<argument><expr>"stat_float_times([newval]) -&gt; oldval\n\n\
Determine whether os.[lf]stat represents time stamps as float objects.\n\
If newval is True, future calls to stat() return floats, if it is False,\n\
future calls return ints. \n\
If newval is omitted, return the current setting.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>stat_float_times</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>newval</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:stat_float_times"</expr></argument>, <argument><expr>&amp;<name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>newval</name> == -1</expr>)</condition><then>
		<comment type="block">/* Return old value */</comment>
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>_stat_float_times</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>_stat_float_times</name> = <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_time</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>int</name></type> <name>index</name></decl></param>, <param><decl><type><name>time_t</name></type> <name>sec</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>nsec</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>fval</name></decl>,*<decl><type ref="prev"/><name>ival</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_TIME_T</name> &gt; <name>SIZEOF_LONG</name></expr></cpp:if>
	<expr_stmt><expr><name>ival</name> = <call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>ival</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>!<name>ival</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<if>if <condition>(<expr><name>_stat_float_times</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>fval</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>sec</name> + 1e-9*<name>nsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>fval</name> = <name>ival</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>index</name>+3</expr></argument>, <argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* pack a system stat C structure into the Python stat tuple
   (used by posix_stat() and posix_fstat()) */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>_pystat_fromstructstat</name><parameter_list>(<param><decl><type><name>STRUCT_STAT</name> *</type><name>st</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ansec</name></decl>, <decl><type ref="prev"/><name>mnsec</name></decl>, <decl><type ref="prev"/><name>cnsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyStructSequence_New</name><argument_list>(<argument><expr>&amp;<name>StatResultType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LARGEFILE_SUPPORT</name></cpp:ifdef>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>,
				  <argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name><name>st</name>-&gt;<name>st_ino</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_ino</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>2</expr></argument>,
				  <argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name><name>st</name>-&gt;<name>st_dev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_dev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_nlink</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_uid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_gid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LARGEFILE_SUPPORT</name></cpp:ifdef>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>6</expr></argument>,
				  <argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name><name>st</name>-&gt;<name>st_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>6</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_TV_NSEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>ansec</name> = <name><name>st</name>-&gt;<name>st_atim</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mnsec</name> = <name><name>st</name>-&gt;<name>st_mtim</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cnsec</name> = <name><name>st</name>-&gt;<name>st_ctim</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_TV_NSEC2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>ansec</name> = <name><name>st</name>-&gt;<name>st_atimespec</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mnsec</name> = <name><name>st</name>-&gt;<name>st_mtimespec</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cnsec</name> = <name><name>st</name>-&gt;<name>st_ctimespec</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_NSEC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>ansec</name> = <name><name>st</name>-&gt;<name>st_atime_nsec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mnsec</name> = <name><name>st</name>-&gt;<name>st_mtime_nsec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cnsec</name> = <name><name>st</name>-&gt;<name>st_ctime_nsec</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>ansec</name> = <name>mnsec</name> = <name>cnsec</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>fill_time</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>7</expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>st_atime</name></name></expr></argument>, <argument><expr><name>ansec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fill_time</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>st_mtime</name></name></expr></argument>, <argument><expr><name>mnsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fill_time</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>9</expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>st_ctime</name></name></expr></argument>, <argument><expr><name>cnsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_BLKSIZE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_BLKSIZE_IDX</name></expr></argument>,
			 <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_blksize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_BLOCKS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_BLOCKS_IDX</name></expr></argument>,
			 <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_blocks</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_RDEV</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_RDEV_IDX</name></expr></argument>,
			 <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_rdev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_GEN</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_GEN_IDX</name></expr></argument>,
			 <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_gen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_BIRTHTIME</name></cpp:ifdef>
	<block>{
	  <decl_stmt><decl><type><name>PyObject</name> *</type><name>val</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>bsec</name></decl>,<decl><type ref="prev"/><name>bnsec</name></decl>;</decl_stmt>
	  <expr_stmt><expr><name>bsec</name> = (<name>long</name>)<name><name>st</name>-&gt;<name>st_birthtime</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STAT_TV_NSEC2</name></cpp:ifdef>
	  <expr_stmt><expr><name>bnsec</name> = <name><name>st</name>-&gt;<name>st_birthtimespec</name>.<name>tv_nsec</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	  <expr_stmt><expr><name>bnsec</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	  <if>if <condition>(<expr><name>_stat_float_times</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>val</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>bsec</name> + 1e-9*<name>bnsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  }</block></then> <else>else <block>{
	    <expr_stmt><expr><name>val</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>bsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  }</block></else></if>
	  <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_BIRTHTIME_IDX</name></expr></argument>,
				    <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_STAT_ST_FLAGS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ST_FLAGS_IDX</name></expr></argument>,
			 <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>st</name>-&gt;<name>st_flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>

<comment type="block">/* IsUNCRoot -- test whether the supplied path is of the form \\SERVER\SHARE\,
   where / can be used in place of \ and the trailing slash is optional.
   Both SERVER and SHARE must have at least one character.
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSLASHA</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) == '\\' || (c) == '/')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSLASHW</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) == L'\\' || (c) == L'/')</cpp:value></cpp:define>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ARRAYSIZE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAYSIZE</name><parameter_list>(<param><type><name>a</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(sizeof(a) / sizeof(a[0]))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>IsUNCRootA</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>int</name></type> <name>pathlen</name></decl></param>)</parameter_list>
<block>{
	<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSLASH</name></cpp:macro> <cpp:value>ISSLASHA</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>share</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>pathlen</name> &lt; 5 || !<call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> || !<call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<comment type="block">/* minimum UNCRoot is \\x\y */</comment>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 2</expr>;</init> <condition><expr><name>i</name> &lt; <name>pathlen</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<if>if <condition>(<expr><call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if></for>
	<if>if <condition>(<expr><name>i</name> == 2 || <name>i</name> == <name>pathlen</name></expr>)</condition><then>
		<comment type="block">/* do not allow \\\SHARE or \\SERVER */</comment>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<expr_stmt><expr><name>share</name> = <name>i</name>+1</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>share</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>pathlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<if>if <condition>(<expr><call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if></for>
	<return>return <expr>(<name>i</name> != <name>share</name> &amp;&amp; (<name>i</name> == <name>pathlen</name> || <name>i</name> == <name>pathlen</name>-1))</expr>;</return>

	<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ISSLASH</name></cpp:undef>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>IsUNCRootW</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>path</name></decl></param>, <param><decl><type><name>int</name></type> <name>pathlen</name></decl></param>)</parameter_list>
<block>{
	<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSLASH</name></cpp:macro> <cpp:value>ISSLASHW</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>share</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>pathlen</name> &lt; 5 || !<call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> || !<call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<comment type="block">/* minimum UNCRoot is \\x\y */</comment>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 2</expr>;</init> <condition><expr><name>i</name> &lt; <name>pathlen</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<if>if <condition>(<expr><call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if></for>
	<if>if <condition>(<expr><name>i</name> == 2 || <name>i</name> == <name>pathlen</name></expr>)</condition><then>
		<comment type="block">/* do not allow \\\SHARE or \\SERVER */</comment>
		<return>return <expr><name>FALSE</name></expr>;</return></then></if>
	<expr_stmt><expr><name>share</name> = <name>i</name>+1</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>share</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>pathlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<if>if <condition>(<expr><call><name>ISSLASH</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if></for>
	<return>return <expr>(<name>i</name> != <name>share</name> &amp;&amp; (<name>i</name> == <name>pathlen</name> || <name>i</name> == <name>pathlen</name>-1))</expr>;</return>

	<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ISSLASH</name></cpp:undef>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_WIN_WIDE_FILENAMES */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_do_stat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
	      <param><decl><type><name>char</name> *</type><name>format</name></decl></param>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
	      <param><function_decl><type><name>int</name></type> (*<name>statfunc</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>STRUCT_STAT</name> *</type></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list></function_decl></param>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	      <param><function_decl><type><name>int</name></type> (*<name>statfunc</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>STRUCT_STAT</name> *</type></decl></param>)</parameter_list></function_decl></param>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	      <param><decl><type><name>char</name> *</type><name>wformat</name></decl></param>,
	      <param><function_decl><type><name>int</name></type> (*<name>wstatfunc</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>Py_UNICODE</name> *</decl></param>, <param><decl><type><name>STRUCT_STAT</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>STRUCT_STAT</name></type> <name>st</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* pass this to stat; do not free() it */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>pathfree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* this memory must be free'd */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
	<comment type="block">/* If on wide-character-capable OS see if argument
	   is Unicode and if so use wide API.  */</comment>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>wformat</name></expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>wpath</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
				<comment type="block">/* PyUnicode_AS_UNICODE result OK without
				   thread lock as it is a simple dereference. */</comment>
			<name>res</name> <init>= <expr><call><name>wstatfunc</name><argument_list>(<argument><expr><name>wpath</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>Py_END_ALLOW_THREADS</name></macro>

			<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
				<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"stat"</expr></argument>, <argument><expr><name>wpath</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
			<return>return <expr><call><name>_pystat_fromstructstat</name><argument_list>(<argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Drop the argument parsing error as narrow strings
		   are also valid. */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>pathfree</name> = <name>path</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call>(*<name>statfunc</name>)<argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
		<expr_stmt><expr><name>result</name> = <call><name>win32_error</name><argument_list>(<argument><expr>"stat"</expr></argument>, <argument><expr><name>pathfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>result</name> = <call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>pathfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> 
	<else>else
		<expr_stmt><expr><name>result</name> = <call><name>_pystat_fromstructstat</name><argument_list>(<argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>pathfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* POSIX methods */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_access__doc__</name></expr></argument>,
<argument><expr>"access(path, mode) -&gt; True if granted, False otherwise\n\n\
Use the real uid/gid to test for access to a path.  Note that most\n\
operations will use the effective uid/gid, therefore this routine can\n\
be used in a suid/sgid environment to test if the invoking user has the\n\
specified access to the path.  The mode argument can be F_OK to test\n\
existence, or the inclusive-OR of R_OK, W_OK, and X_OK."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_access</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
	
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Ui:access"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
			<comment type="block">/* PyUnicode_AS_UNICODE OK without thread lock as
			   it is a simple dereference. */</comment>
			<name>attr</name> <init>= <expr><call><name>GetFileAttributesW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>Py_END_ALLOW_THREADS</name></macro>
			<goto>goto <name>finish</name>;</goto>
		}</block></then></if>
		<comment type="block">/* Drop the argument parsing error as narrow strings
		   are also valid. */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:access"</expr></argument>,
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>attr</name> <init>= <expr><call><name>GetFileAttributesA</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>PyMem_Free</name><parameter_list>(<param><decl><type><name>path</name></type></decl></param>)</parameter_list>;</function_decl>
<label><name>finish</name>:</label>
	<if>if <condition>(<expr><name>attr</name> == 0xFFFFFFFF</expr>)</condition><then>
		<comment type="block">/* File does not exist, or cannot read attributes */</comment>
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<comment type="block">/* Access is possible if either write access wasn't requested, or
	   the file isn't read-only, or if it's a directory, as there are
	   no read-only directories on Windows. */</comment>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>!(<name>mode</name> &amp; 2) 
	                       || !(<name>attr</name> &amp; <name>FILE_ATTRIBUTE_READONLY</name>)
			       || (<name>attr</name> &amp; <name>FILE_ATTRIBUTE_DIRECTORY</name>)</expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:access"</expr></argument>, 
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>PyMem_Free</name><parameter_list>(<param><decl><type><name>path</name></type></decl></param>)</parameter_list>;</function_decl>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>res</name> == 0</expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>F_OK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_OK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>R_OK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_OK</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>W_OK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>W_OK</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>X_OK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_OK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TTYNAME</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_ttyname__doc__</name></expr></argument>,
<argument><expr>"ttyname(fd) -&gt; string\n\n\
Return the name of the terminal device connected to 'fd'."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_ttyname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>ret</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:ttyname"</expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <comment type="block">/* file descriptor 0 only, the default input device (stdin) */</comment>
	<if>if <condition>(<expr><name>id</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ret</name> = <call><name>ttyname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>ret</name> = <call><name>ttyname</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CTERMID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_ctermid__doc__</name></expr></argument>,
<argument><expr>"ctermid() -&gt; string\n\n\
Return the name of the controlling terminal for this process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_ctermid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>ret</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>L_ctermid</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_CTERMID_R</name></cpp:ifdef>
	<expr_stmt><expr><name>ret</name> = <call><name>ctermid_r</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>ret</name> = <call><name>ctermid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chdir__doc__</name></expr></argument>,
<argument><expr>"chdir(path)\n\n\
Change the current working directory to the specified path."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<return>return <expr><call><name>win32_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"chdir"</expr></argument>, <argument><expr>"s:chdir"</expr></argument>, <argument><expr><name>win32_chdir</name></expr></argument>, <argument><expr>"U:chdir"</expr></argument>, <argument><expr><name>win32_wchdir</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:chdir"</expr></argument>, <argument><expr><name>_chdir2</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:chdir"</expr></argument>, <argument><expr>(<call><call><name>int</name> <argument_list>(<argument><expr>*</expr></argument>)</argument_list></call><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>)<name>chdir</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:chdir"</expr></argument>, <argument><expr><name>chdir</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FCHDIR</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fchdir__doc__</name></expr></argument>,
<argument><expr>"fchdir(fildes)\n\n\
Change to the directory of the given file descriptor.  fildes must be\n\
opened on a directory, not a file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fchdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fdobj</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>posix_fildes</name><argument_list>(<argument><expr><name>fdobj</name></expr></argument>, <argument><expr><name>fchdir</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FCHDIR */</comment>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chmod__doc__</name></expr></argument>,
<argument><expr>"chmod(path, mode)\n\n\
Change the access permissions of a file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Ui|:chmod"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
			<name>attr</name> <init>= <expr><call><name>GetFileAttributesW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>attr</name> != 0xFFFFFFFF</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>i</name> &amp; <name>_S_IWRITE</name></expr>)</condition><then>
					<expr_stmt><expr><name>attr</name> &amp;= ~<name>FILE_ATTRIBUTE_READONLY</name></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>attr</name> |= <name>FILE_ATTRIBUTE_READONLY</name></expr>;</expr_stmt></else></if>
				<expr_stmt><expr><name>res</name> = <call><name>SetFileAttributesW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else
				<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt></else></if>
			<macro><name>Py_END_ALLOW_THREADS</name></macro>
			<if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
				<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"chmod"</expr></argument>,
						<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>Py_None</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Drop the argument parsing error as narrow strings
		   are also valid. */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:chmod"</expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
	                      <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>attr</name> <init>= <expr><call><name>GetFileAttributesA</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>attr</name> != 0xFFFFFFFF</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>i</name> &amp; <name>_S_IWRITE</name></expr>)</condition><then>
			<expr_stmt><expr><name>attr</name> &amp;= ~<name>FILE_ATTRIBUTE_READONLY</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>attr</name> |= <name>FILE_ATTRIBUTE_READONLY</name></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>res</name> = <call><name>SetFileAttributesA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt></else></if>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr>!<name>res</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"chmod"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* Py_WIN_WIDE_FILENAMES */</comment>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:chmod"</expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
	                      <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FCHMOD</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fchmod__doc__</name></expr></argument>,
<argument><expr>"fchmod(fd, mode)\n\n\
Change the access permissions of the file given by file\n\
descriptor fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fchmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>mode</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:fchmod"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>fchmod</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FCHMOD */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LCHMOD</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lchmod__doc__</name></expr></argument>,
<argument><expr>"lchmod(path, mode)\n\n\
Change the access permissions of a file. If path is a symlink, this\n\
affects the link itself rather than the target."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lchmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:lchmod"</expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
	                      <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>lchmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LCHMOD */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CHFLAGS</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chflags__doc__</name></expr></argument>,
<argument><expr>"chflags(path, flags)\n\n\
Set file flags."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chflags</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etk:chflags"</expr></argument>,
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>chflags</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CHFLAGS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LCHFLAGS</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lchflags__doc__</name></expr></argument>,
<argument><expr>"lchflags(path, flags)\n\n\
Set file flags.\n\
This function will not follow symbolic links."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lchflags</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etk:lchflags"</expr></argument>,
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>lchflags</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LCHFLAGS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CHROOT</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chroot__doc__</name></expr></argument>,
<argument><expr>"chroot(path)\n\n\
Change root directory to path."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chroot</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:chroot"</expr></argument>, <argument><expr><name>chroot</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FSYNC</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fsync__doc__</name></expr></argument>,
<argument><expr>"fsync(fildes)\n\n\
force write of file with filedescriptor to disk."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fsync</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fdobj</name></decl></param>)</parameter_list>
<block>{
       <return>return <expr><call><name>posix_fildes</name><argument_list>(<argument><expr><name>fdobj</name></expr></argument>, <argument><expr><name>fsync</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FSYNC */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FDATASYNC</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__hpux</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>fdatasync</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* On HP-UX, in libc but not in unistd.h */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fdatasync__doc__</name></expr></argument>,
<argument><expr>"fdatasync(fildes)\n\n\
force write of file with filedescriptor to disk.\n\
 does not force update of metadata."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fdatasync</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fdobj</name></decl></param>)</parameter_list>
<block>{
       <return>return <expr><call><name>posix_fildes</name><argument_list>(<argument><expr><name>fdobj</name></expr></argument>, <argument><expr><name>fdatasync</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FDATASYNC */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CHOWN</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_chown__doc__</name></expr></argument>,
<argument><expr>"chown(path, uid, gid)\n\n\
Change the owner and group id of path to the numeric uid and gid."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_chown</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>gid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etll:chown"</expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>,
	                      <argument><expr>&amp;<name>uid</name></expr></argument>, <argument><expr>&amp;<name>gid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>chown</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>(<name>uid_t</name>) <name>uid</name></expr></argument>, <argument><expr>(<name>gid_t</name>) <name>gid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CHOWN */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FCHOWN</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fchown__doc__</name></expr></argument>,
<argument><expr>"fchown(fd, uid, gid)\n\n\
Change the owner and group id of the file given by file descriptor\n\
fd to the numeric uid and gid."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fchown</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>uid</name></decl>, <decl><type ref="prev"/><name>gid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iii:chown"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>uid</name></expr></argument>, <argument><expr>&amp;<name>gid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>fchown</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>(<name>uid_t</name>) <name>uid</name></expr></argument>, <argument><expr>(<name>gid_t</name>) <name>gid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FCHOWN */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LCHOWN</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lchown__doc__</name></expr></argument>,
<argument><expr>"lchown(path, uid, gid)\n\n\
Change the owner and group id of path to the numeric uid and gid.\n\
This function will not follow symbolic links."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lchown</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>gid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etii:lchown"</expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>,
	                      <argument><expr>&amp;<name>uid</name></expr></argument>, <argument><expr>&amp;<name>gid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>lchown</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>(<name>uid_t</name>) <name>uid</name></expr></argument>, <argument><expr>(<name>gid_t</name>) <name>gid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LCHOWN */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETCWD</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getcwd__doc__</name></expr></argument>,
<argument><expr>"getcwd() -&gt; path\n\n\
Return a string representing the current working directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getcwd</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize_incr</name> <init>= <expr>1024</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>tmpbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dynamic_return</name></decl>;</decl_stmt>

	<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
	<do>do <block>{
		<expr_stmt><expr><name>bufsize</name> = <name>bufsize</name> + <name>bufsize_incr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmpbuf</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmpbuf</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<break>break;</break>
		}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr><name>res</name> = <call><name>_getcwd2</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>res</name> = <call><name>getcwd</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block> while <condition>(<expr>(<name>res</name> == <name>NULL</name>) &amp;&amp; (<name>errno</name> == <name>ERANGE</name>)</expr>)</condition>;</do>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>dynamic_return</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dynamic_return</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getcwdu__doc__</name></expr></argument>,
<argument><expr>"getcwdu() -&gt; path\n\n\
Return a unicode string representing the current working directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getcwdu</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1026</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>len</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>wchar_t</name></type> <name><name>wbuf</name><index>[<expr>1026</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>wchar_t</name> *</type><name>wbuf2</name> <init>= <expr><name>wbuf</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>resobj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>len</name> <init>= <expr><call><name>GetCurrentDirectoryW</name><argument_list>(<argument><expr>sizeof <name>wbuf</name>/ sizeof <name><name>wbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>wbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* If the buffer is large enough, len does not include the
		   terminating \0. If the buffer is too small, len includes
		   the space needed for the terminator. */</comment>
		<if>if <condition>(<expr><name>len</name> &gt;= sizeof <name>wbuf</name>/ sizeof <name><name>wbuf</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>wbuf2</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>wbuf2</name></expr>)</condition><then>
				<expr_stmt><expr><name>len</name> = <call><name>GetCurrentDirectoryW</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>wbuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr>!<name>wbuf2</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<name>len</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>wbuf2</name> != <name>wbuf</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wbuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"getcwdu"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>resobj</name> = <call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>wbuf2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>wbuf2</name> != <name>wbuf</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wbuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><name>resobj</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<name>res</name> <init>= <expr><call><name>_getcwd2</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>sizeof <name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>res</name> = <call><name>getcwd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>sizeof <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,<argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINK</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_link__doc__</name></expr></argument>,
<argument><expr>"link(src, dst)\n\n\
Create a hard link to a file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_link</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>posix_2str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etet:link"</expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LINK */</comment>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_listdir__doc__</name></expr></argument>,
<argument><expr>"listdir(path) -&gt; list_of_strings\n\n\
Return a list containing the names of the entries in the directory.\n\
\n\
	path: path of directory to list\n\
\n\
The list is in arbitrary order.  It does not include the special\n\
entries '.' and '..' even if they are present in the directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_listdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX Should redo this putting the (now four) versions of opendir
	   in separate files instead of having them all here... */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFindFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WIN32_FIND_DATA</name></type> <name>FileData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>namebuf</name><index>[<expr><name>MAX_PATH</name>+5</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Overallocate for \\*.*\0 */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>bufptr</name> <init>= <expr><name>namebuf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>namebuf</name></expr></argument>)</argument_list></sizeof>-5</expr></init></decl>;</decl_stmt> <comment type="block">/* only claim to have space for MAX_PATH */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
	<comment type="block">/* If on wide-character-capable OS see if argument
	   is Unicode and if so use wide API.  */</comment>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>po</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U:listdir"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>WIN32_FIND_DATAW</name></type> <name>wFileData</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>wnamebuf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>wch</name></decl>;</decl_stmt>
			<comment type="block">/* Overallocate for \\*.*\0 */</comment>
			<expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>wnamebuf</name> = <call><name>malloc</name><argument_list>(<argument><expr>(<name>len</name> + 5) * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>wnamebuf</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>wcscpy</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>wch</name> = <name>len</name> &gt; 0 ? <name><name>wnamebuf</name><index>[<expr><name>len</name>-1</expr>]</index></name> : '\0'</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>wch</name> != L'/' &amp;&amp; <name>wch</name> != L'\\' &amp;&amp; <name>wch</name> != L':'</expr>)</condition><then>
				<expr_stmt><expr><name><name>wnamebuf</name><index>[<expr><name>len</name>++</expr>]</index></name> = L'\\'</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>wcscpy</name><argument_list>(<argument><expr><name>wnamebuf</name> + <name>len</name></expr></argument>, <argument><expr>L"*.*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>d</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>hFindFile</name> = <call><name>FindFirstFileW</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>, <argument><expr>&amp;<name>wFileData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>hFindFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>error</name> == <name>ERROR_FILE_NOT_FOUND</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>d</name></expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"FindFirstFileW"</expr></argument>, <argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<do>do <block>{
				<comment type="block">/* Skip over . and .. */</comment>
				<if>if <condition>(<expr><call><name>wcscmp</name><argument_list>(<argument><expr><name><name>wFileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr>L"."</expr></argument>)</argument_list></call> != 0 &amp;&amp;
				    <call><name>wcscmp</name><argument_list>(<argument><expr><name><name>wFileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr>L".."</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name><name>wFileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr><call><name>wcslen</name><argument_list>(<argument><expr><name><name>wFileData</name>.<name>cFileName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
						<break>break;</break>
					}</block></then></if>
					<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
						<break>break;</break>
					}</block></then></if>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
				<name>result</name> <init>= <expr><call><name>FindNextFileW</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>, <argument><expr>&amp;<name>wFileData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<macro><name>Py_END_ALLOW_THREADS</name></macro>
				<comment type="block">/* FindNextFile sets error to ERROR_NO_MORE_FILES if
				   it got to the end of the directory. */</comment>
				<if>if <condition>(<expr>!<name>result</name> &amp;&amp; <call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_NO_MORE_FILES</name></expr>)</condition><then> <block>{
				    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				    <expr_stmt><expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"FindNextFileW"</expr></argument>, <argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				    <expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				    <return>return <expr><name>NULL</name></expr>;</return>
				}</block></then></if>
			}</block> while <condition>(<expr><name>result</name> == <name>TRUE</name></expr>)</condition>;</do>

			<if>if <condition>(<expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call> == <name>FALSE</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"FindClose"</expr></argument>, <argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>d</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Drop the argument parsing error as narrow strings
		   are also valid. */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et#:listdir"</expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>bufptr</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><name><name>namebuf</name><index>[<expr><name>len</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>ch</name> != <name>SEP</name> &amp;&amp; <name>ch</name> != <name>ALTSEP</name> &amp;&amp; <name>ch</name> != ':'</expr>)</condition><then>
			<expr_stmt><expr><name><name>namebuf</name><index>[<expr><name>len</name>++</expr>]</index></name> = '/'</expr>;</expr_stmt></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>namebuf</name> + <name>len</name></expr></argument>, <argument><expr>"*.*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>(<name>d</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>hFindFile</name> = <call><name>FindFirstFile</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr>&amp;<name>FileData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>hFindFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>error</name> == <name>ERROR_FILE_NOT_FOUND</name></expr>)</condition><then>
			<return>return <expr><name>d</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"FindFirstFile"</expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<do>do <block>{
		<comment type="block">/* Skip over . and .. */</comment>
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>FileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr>"."</expr></argument>)</argument_list></call> != 0 &amp;&amp;
		    <call><name>strcmp</name><argument_list>(<argument><expr><name><name>FileData</name>.<name>cFileName</name></name></expr></argument>, <argument><expr>".."</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>FileData</name>.<name>cFileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>result</name> <init>= <expr><call><name>FindNextFile</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>, <argument><expr>&amp;<name>FileData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<comment type="block">/* FindNextFile sets error to ERROR_NO_MORE_FILES if
		   it got to the end of the directory. */</comment>
		<if>if <condition>(<expr>!<name>result</name> &amp;&amp; <call><name>GetLastError</name><argument_list>()</argument_list></call> != <name>ERROR_NO_MORE_FILES</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"FindNextFile"</expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block> while <condition>(<expr><name>result</name> == <name>TRUE</name></expr>)</condition>;</do>

	<if>if <condition>(<expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call> == <name>FALSE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"FindClose"</expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<return>return <expr><name>d</name></expr>;</return>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX_PATH</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PATH</name></cpp:macro>    <cpp:value>CCHMAXPATH</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>pt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>namebuf</name><index>[<expr><name>MAX_PATH</name>+5</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HDIR</name></type>  <name>hdir</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ULONG</name></type> <name>srchcnt</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILEFINDBUF3</name></type>   <name>ep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#:listdir"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>len</name> &gt;= <name>MAX_PATH</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"path too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>pt</name> = <name>namebuf</name></expr>;</init> <condition><expr>*<name>pt</name></expr>;</condition> <incr><expr><name>pt</name>++</expr></incr>)
        <if>if <condition>(<expr>*<name>pt</name> == <name>ALTSEP</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>pt</name> = <name>SEP</name></expr>;</expr_stmt></then></if></for>
    <if>if <condition>(<expr><name><name>namebuf</name><index>[<expr><name>len</name>-1</expr>]</index></name> != <name>SEP</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>namebuf</name><index>[<expr><name>len</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>namebuf</name> + <name>len</name></expr></argument>, <argument><expr>"*.*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>(<name>d</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rc</name> = <call><name>DosFindFirst</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>,         <comment type="block">/* Wildcard Pattern to Match */</comment>
                      <argument><expr>&amp;<name>hdir</name></expr></argument>,           <comment type="block">/* Handle to Use While Search Directory */</comment>
                      <argument><expr><name>FILE_READONLY</name> | <name>FILE_HIDDEN</name> | <name>FILE_SYSTEM</name> | <name>FILE_DIRECTORY</name></expr></argument>,
                      <argument><expr>&amp;<name>ep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></sizeof></expr></argument>, <comment type="block">/* Structure to Receive Directory Entry */</comment>
                      <argument><expr>&amp;<name>srchcnt</name></expr></argument>,        <comment type="block">/* Max and Actual Count of Entries Per Iteration */</comment>
                      <argument><expr><name>FIL_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Format of Entry (EAs or Not) */</comment>

    <if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>errno</name> = <name>ENOENT</name></expr>;</expr_stmt>
        <return>return <expr><call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>srchcnt</name> &gt; 0</expr>)</condition><then> <block>{ <comment type="block">/* If Directory is NOT Totally Empty, */</comment>
        <do>do <block>{
            <if>if <condition>(<expr><name><name>ep</name>.<name>achName</name><index>[<expr>0</expr>]</index></name> == '.'
            &amp;&amp; (<name><name>ep</name>.<name>achName</name><index>[<expr>1</expr>]</index></name> == '\0' || (<name><name>ep</name>.<name>achName</name><index>[<expr>1</expr>]</index></name> == '.' &amp;&amp; <name><name>ep</name>.<name>achName</name><index>[<expr>2</expr>]</index></name> == '\0'))</expr>)</condition><then>
                <continue>continue;</continue></then></if> <comment type="block">/* Skip Over "." and ".." Names */</comment>

            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><name><name>ep</name>.<name>achName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Leave Case of Name Alone -- In Native Form */</comment>
            <comment type="block">/* (Removed Forced Lowercasing Code) */</comment>

            <expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> while <condition>(<expr><call><name>DosFindNext</name><argument_list>(<argument><expr><name>hdir</name></expr></argument>, <argument><expr>&amp;<name>ep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>srchcnt</name></expr></argument>)</argument_list></call> == <name>NO_ERROR</name> &amp;&amp; <name>srchcnt</name> &gt; 0</expr>)</condition>;</do>
    }</block></then></if>

    <return>return <expr><name>d</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name> *</type><name>dirp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>dirent</name> *</type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>arg_is_unicode</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U:listdir"</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>arg_is_unicode</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:listdir"</expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>(<name>dirp</name> = <call><name>opendir</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>d</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>ep</name> <init>= <expr><call><name>readdir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>ep</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>errno</name> == 0</expr>)</condition><then> <block>{
				<break>break;</break>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></else></if>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>ep</name>-&gt;<name>d_name</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp;
		    (<call><name>NAMLEN</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call> == 1 ||
		     (<name><name>ep</name>-&gt;<name>d_name</name><index>[<expr>1</expr>]</index></name> == '.' &amp;&amp; <call><name>NAMLEN</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call> == 2))</expr>)</condition><then>
			<continue>continue;</continue></then></if>
		<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>ep</name>-&gt;<name>d_name</name></name></expr></argument>, <argument><expr><call><name>NAMLEN</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><name>arg_is_unicode</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>w</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>,
					<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
					<argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>w</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>v</name> = <name>w</name></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<comment type="block">/* fall back to the original byte string, as
				   discussed in patch #683592 */</comment>
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>d</name> = <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>d</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* which OS */</comment>
}</block></function>  <comment type="block">/* end of posix_listdir */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<comment type="block">/* A helper function for abspath on win32 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix__getfullpathname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* assume encoded strings wont more than double no of chars */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>inbuf</name><index>[<expr><name>MAX_PATH</name>*2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>inbufp</name> <init>= <expr><name>inbuf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>insize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>inbuf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>outbuf</name><index>[<expr><name>MAX_PATH</name>*2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>temp</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U|:_getfullpathname"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>woutbuf</name><index>[<expr><name>MAX_PATH</name>*2</expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>wtemp</name></decl>;</decl_stmt>
			<if>if <condition>(<expr>!<call><name>GetFullPathNameW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>woutbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>woutbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
						 <argument><expr><name>woutbuf</name></expr></argument>, <argument><expr>&amp;<name>wtemp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"GetFullPathName"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</return></then></if>
			<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>woutbuf</name></expr></argument>, <argument><expr><call><name>wcslen</name><argument_list>(<argument><expr><name>woutbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Drop the argument parsing error as narrow strings
		   are also valid. */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et#:_getfullpathname"</expr></argument>,
	                       <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>inbufp</name></expr></argument>,
	                       <argument><expr>&amp;<name>insize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>GetFullPathName</name><argument_list>(<argument><expr><name>inbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>outbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
	                     <argument><expr><name>outbuf</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"GetFullPathName"</expr></argument>, <argument><expr><name>inbuf</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function> <comment type="block">/* end of posix__getfullpathname */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_mkdir__doc__</name></expr></argument>,
<argument><expr>"mkdir(path [, mode=0777])\n\n\
Create a directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_mkdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>0777</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U|i:mkdir"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
			<comment type="block">/* PyUnicode_AS_UNICODE OK without thread lock as
			   it is a simple dereference. */</comment>
			<name>res</name> <init>= <expr><call><name>CreateDirectoryW</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>Py_END_ALLOW_THREADS</name></macro>
			<if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
				<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"mkdir"</expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>Py_None</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Drop the argument parsing error as narrow strings
		   are also valid. */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et|i:mkdir"</expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<comment type="block">/* PyUnicode_AS_UNICODE OK without thread lock as
	   it is a simple dereference. */</comment>
	<name>res</name> <init>= <expr><call><name>CreateDirectoryA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr>!<name>res</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"mkdir"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et|i:mkdir"</expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>( <call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call> ) &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<name>res</name> = <call><name>mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>res</name> = <call><name>mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="block">/* sys/resource.h is needed for at least: wait3(), wait4(), broken nice. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_RESOURCE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NICE</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_nice__doc__</name></expr></argument>,
<argument><expr>"nice(inc) -&gt; new_priority\n\n\
Decrease the priority of process by inc and return the new priority."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_nice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>increment</name></decl>, <decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:nice"</expr></argument>, <argument><expr>&amp;<name>increment</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* There are two flavours of 'nice': one that returns the new
	   priority (as required by almost all standards out there) and the
	   Linux/FreeBSD/BSDI one, which returns '0' on success and advices
	   the use of getpriority() to get the new priority.

	   If we are of the nice family that returns the new priority, we
	   need to clear errno before the call, and check if errno is filled
	   before calling posix_error() on a returnvalue of -1, because the
	   -1 may be the actual new priority! */</comment>

	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>value</name> = <call><name>nice</name><argument_list>(<argument><expr><name>increment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BROKEN_NICE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPRIORITY</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><name>value</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>value</name> = <call><name>getpriority</name><argument_list>(<argument><expr><name>PRIO_PROCESS</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>value</name> == -1 &amp;&amp; <name>errno</name> != 0</expr>)</condition><then>
		<comment type="block">/* either nice() or getpriority() returned an error */</comment>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_NICE */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_rename__doc__</name></expr></argument>,
<argument><expr>"rename(old, new)\n\n\
Rename a file or directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_rename</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o1</name></decl>, *<decl><type ref="prev"/><name>o2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO:rename"</expr></argument>, <argument><expr>&amp;<name>o1</name></expr></argument>, <argument><expr>&amp;<name>o2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	    <if>if <condition>(<expr>!<call><name>convert_to_unicode</name><argument_list>(<argument><expr>&amp;<name>o1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	    <if>if <condition>(<expr>!<call><name>convert_to_unicode</name><argument_list>(<argument><expr>&amp;<name>o2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	    }</block></then></if>
	    <decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	    <name>result</name> <init>= <expr><call><name>MoveFileW</name><argument_list>(<argument><expr><call><name>PyUnicode_AsUnicode</name><argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call><name>PyUnicode_AsUnicode</name><argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
	    <name>Py_DECREF</name><parameter_list>(<param><decl><type><name>o1</name></type></decl></param>)</parameter_list>;</function_decl>
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		    <return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"rename"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>Py_None</name></expr>;</return>
<label><name>error</name>:</label>
	    <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss:rename"</expr></argument>, <argument><expr>&amp;<name>p1</name></expr></argument>, <argument><expr>&amp;<name>p2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>result</name> <init>= <expr><call><name>MoveFileA</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"rename"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>posix_2str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etet:rename"</expr></argument>, <argument><expr><name>rename</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_rmdir__doc__</name></expr></argument>,
<argument><expr>"rmdir(path)\n\n\
Remove a directory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_rmdir</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<return>return <expr><call><name>win32_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"rmdir"</expr></argument>, <argument><expr>"s:rmdir"</expr></argument>, <argument><expr><name>RemoveDirectoryA</name></expr></argument>, <argument><expr>"U:rmdir"</expr></argument>, <argument><expr><name>RemoveDirectoryW</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:rmdir"</expr></argument>, <argument><expr><name>rmdir</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_stat__doc__</name></expr></argument>,
<argument><expr>"stat(path) -&gt; stat result\n\n\
Perform a stat system call on the given path."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_stat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:stat"</expr></argument>, <argument><expr><name>STAT</name></expr></argument>, <argument><expr>"U:stat"</expr></argument>, <argument><expr><name>win32_wstat</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:stat"</expr></argument>, <argument><expr><name>STAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSTEM</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_system__doc__</name></expr></argument>,
<argument><expr>"system(command) -&gt; exit_status\n\n\
Execute the command (a string) in a subshell."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_system</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>command</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>sts</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:system"</expr></argument>, <argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>sts</name> <init>= <expr><call><name>system</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>sts</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_umask__doc__</name></expr></argument>,
<argument><expr>"umask(new_mask) -&gt; old_mask\n\n\
Set the current numeric umask and return the previous umask."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_umask</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:umask"</expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>i</name> = (<name>int</name>)<call><name>umask</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_unlink__doc__</name></expr></argument>,
<argument><expr>"unlink(path)\n\n\
Remove a file (same as remove(path))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_remove__doc__</name></expr></argument>,
<argument><expr>"remove(path)\n\n\
Remove a file (same as unlink(path))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_unlink</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<return>return <expr><call><name>win32_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"remove"</expr></argument>, <argument><expr>"s:remove"</expr></argument>, <argument><expr><name>DeleteFileA</name></expr></argument>, <argument><expr>"U:remove"</expr></argument>, <argument><expr><name>DeleteFileW</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>posix_1str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:remove"</expr></argument>, <argument><expr><name>unlink</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNAME</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_uname__doc__</name></expr></argument>,
<argument><expr>"uname() -&gt; (sysname, nodename, release, version, machine)\n\n\
Return a tuple identifying the current operating system."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_uname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>utsname</name></type> <name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>uname</name><argument_list>(<argument><expr>&amp;<name>u</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(sssss)"</expr></argument>,
			     <argument><expr><name><name>u</name>.<name>sysname</name></name></expr></argument>,
			     <argument><expr><name><name>u</name>.<name>nodename</name></name></expr></argument>,
			     <argument><expr><name><name>u</name>.<name>release</name></name></expr></argument>,
			     <argument><expr><name><name>u</name>.<name>version</name></name></expr></argument>,
			     <argument><expr><name><name>u</name>.<name>machine</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_UNAME */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>extract_time</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>t</name></decl></param>, <param><decl><type><name>long</name>*</type> <name>sec</name></decl></param>, <param><decl><type><name>long</name>*</type> <name>usec</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>intval</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>double</name></type> <name>tval</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>intobj</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call>-&gt;<call><name><name>tp_as_number</name>-&gt;<name>nb_int</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>intobj</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>intval</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>intval</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr>*<name>sec</name> = <name>intval</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>usec</name> = <call>(<name>long</name>)<argument_list>(<argument><expr>(<name>tval</name> - <name>intval</name>) * 1e6</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* can't exceed 1000000 */</comment>
		<if>if <condition>(<expr>*<name>usec</name> &lt; 0</expr>)</condition><then>
			<comment type="block">/* If rounding gave us a negative number,
			   truncate.  */</comment>
			<expr_stmt><expr>*<name>usec</name> = 0</expr>;</expr_stmt></then></if>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>intval</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>intval</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>sec</name> = <name>intval</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>usec</name> = 0</expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_utime__doc__</name></expr></argument>,
<argument><expr>"utime(path, (atime, mtime))\n\
utime(path, None)\n\n\
Set the access and modified time of the file to the given values.  If the\n\
second form is used, set the access and modified times to the current time."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_utime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>obwpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>wchar_t</name> *</type><name>wpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>apath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>atimesec</name></decl>, <decl><type ref="prev"/><name>mtimesec</name></decl>, <decl><type ref="prev"/><name>ausec</name></decl>, <decl><type ref="prev"/><name>musec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILETIME</name></type> <name>atime</name></decl>, <decl><type ref="prev"/><name>mtime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"UO|:utime"</expr></argument>, <argument><expr>&amp;<name>obwpath</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>wpath</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obwpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
			<name>hFile</name> <init>= <expr><call><name>CreateFileW</name><argument_list>(<argument><expr><name>wpath</name></expr></argument>, <argument><expr><name>FILE_WRITE_ATTRIBUTES</name></expr></argument>, <argument><expr>0</expr></argument>,
					    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OPEN_EXISTING</name></expr></argument>,
					    <argument><expr><name>FILE_FLAG_BACKUP_SEMANTICS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>Py_END_ALLOW_THREADS</name></macro>
			<if>if <condition>(<expr><name>hFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
				<return>return <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"utime"</expr></argument>, <argument><expr><name>wpath</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		}</block></then> <else>else
			<comment type="block">/* Drop the argument parsing error as narrow strings
			   are also valid. */</comment>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if>
	<if>if <condition>(<expr>!<name>wpath</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etO:utime"</expr></argument>,
				<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>apath</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>hFile</name> <init>= <expr><call><name>CreateFileA</name><argument_list>(<argument><expr><name>apath</name></expr></argument>, <argument><expr><name>FILE_WRITE_ATTRIBUTES</name></expr></argument>, <argument><expr>0</expr></argument>,
				    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OPEN_EXISTING</name></expr></argument>,
				    <argument><expr><name>FILE_FLAG_BACKUP_SEMANTICS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>hFile</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"utime"</expr></argument>, <argument><expr><name>apath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>apath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>apath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	
	<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>now</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>SystemTimeToFileTime</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>, <argument><expr>&amp;<name>mtime</name></expr></argument>)</argument_list></call> ||
		    !<call><name>SystemTimeToFileTime</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>, <argument><expr>&amp;<name>atime</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"utime"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>done</name>;</goto>
		    }</block></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"utime() arg 2 must be a tuple (atime, mtime)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><call><name>extract_time</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>atimesec</name></expr></argument>, <argument><expr>&amp;<name>ausec</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<goto>goto <name>done</name>;</goto></then></if>
		<expr_stmt><expr><call><name>time_t_to_FILE_TIME</name><argument_list>(<argument><expr><name>atimesec</name></expr></argument>, <argument><expr>1000*<name>ausec</name></expr></argument>, <argument><expr>&amp;<name>atime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>extract_time</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>mtimesec</name></expr></argument>, <argument><expr>&amp;<name>musec</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<goto>goto <name>done</name>;</goto></then></if>
		<expr_stmt><expr><call><name>time_t_to_FILE_TIME</name><argument_list>(<argument><expr><name>mtimesec</name></expr></argument>, <argument><expr>1000*<name>musec</name></expr></argument>, <argument><expr>&amp;<name>mtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<if>if <condition>(<expr>!<call><name>SetFileTime</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>atime</name></expr></argument>, <argument><expr>&amp;<name>mtime</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Avoid putting the file name into the error here,
		   as that may confuse the user into believing that
		   something is wrong with the file, when it also
		   could be the time stamp that gives a problem. */</comment>
		<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"utime"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
<label><name>done</name>:</label>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* Py_WIN_WIDE_FILENAMES */</comment>

	<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>atime</name></decl>, <decl><type ref="prev"/><name>mtime</name></decl>, <decl><type ref="prev"/><name>ausec</name></decl>, <decl><type ref="prev"/><name>musec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>arg</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type>struct <name>timeval</name></type> <name><name>buf</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATIME</name></cpp:macro> <cpp:value>buf[0].tv_sec</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MTIME</name></cpp:macro> <cpp:value>buf[1].tv_sec</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIME_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* XXX should define struct utimbuf instead, above */</comment>
	<decl_stmt><decl><type>struct <name>utimbuf</name></type> <name>buf</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATIME</name></cpp:macro> <cpp:value>buf.actime</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MTIME</name></cpp:macro> <cpp:value>buf.modtime</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTIME_ARG</name></cpp:macro> <cpp:value>&amp;buf</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* HAVE_UTIMES */</comment>
	<decl_stmt><decl><type><name>time_t</name></type> <name><name>buf</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATIME</name></cpp:macro> <cpp:value>buf[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MTIME</name></cpp:macro> <cpp:value>buf[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTIME_ARG</name></cpp:macro> <cpp:value>buf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_UTIMES */</comment>


	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etO:utime"</expr></argument>,
				  <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<comment type="block">/* optional time values not given */</comment>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>res</name> <init>= <expr><call><name>utime</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"utime() arg 2 must be a tuple (atime, mtime)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><call><name>extract_time</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>atime</name></expr></argument>, <argument><expr>&amp;<name>ausec</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>extract_time</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>mtime</name></expr></argument>, <argument><expr>&amp;<name>musec</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>ATIME</name> = <name>atime</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>MTIME</name> = <name>mtime</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIMES</name></cpp:ifdef>
		<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name>.<name>tv_usec</name> = <name>ausec</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name>.<name>tv_usec</name> = <name>musec</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>res</name> <init>= <expr><call><name>utimes</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<name>Py_BEGIN_ALLOW_THREADS</name>
		<name>res</name> = <call><name>utime</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>UTIME_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_UTIMES */</comment>
	}</block></else></if></else></if>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UTIME_ARG</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ATIME</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MTIME</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_WIN_WIDE_FILENAMES */</comment>
}</block></function>


<comment type="block">/* Process operations */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix__exit__doc__</name></expr></argument>,
<argument><expr>"_exit(status)\n\n\
Exit to the system with specified status, without normal exit processing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix__exit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>sts</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:_exit"</expr></argument>, <argument><expr>&amp;<name>sts</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><name>sts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* Make gcc -Wall happy */</comment>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXECV</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_string_array</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>array</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_EXECV</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_execv__doc__</name></expr></argument>,
<argument><expr>"execv(path, args)\n\n\
Execute an executable path with arguments, replacing current process.\n\
\n\
	path: path of executable file\n\
	args: tuple or list of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_execv</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>;</decl_stmt>
	<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>

	<comment type="block">/* execv has two arguments: (path, argv), where
	   argv is a list or tuple of strings. */</comment>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etO:execv"</expr></argument>,
                              <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
                              <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"execv() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>

	<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"et"</expr></argument>,
				 <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
				 <argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"execv() arg 2 must contain only strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>

		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>execv</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we get here it's definitely an error */</comment>

	<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_execve__doc__</name></expr></argument>,
<argument><expr>"execve(path, args, env)\n\n\
Execute a path with arguments and environment, replacing current process.\n\
\n\
	path: path of executable file\n\
	args: tuple or list of arguments\n\
	env: dictionary of strings mapping to strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_execve</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>, *<decl><type ref="prev"/><name>env</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>envlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>, *<decl><type ref="prev"/><name>keys</name><init>=<expr><name>NULL</name></expr></init>, *<name>vals</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>, <decl><type ref="prev"/><name>envc</name></decl>;</decl_stmt>
	<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lastarg</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* execve has three arguments: (path, argv, env), where
	   argv is a list or tuple of strings and env is a dictionary
	   like posix.environ. */</comment>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etOO:execve"</expr></argument>,
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
			      <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>, <argument><expr>&amp;<name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"execve() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_0</name>;</goto>
	}</block></else></if></else></if>
	<if>if <condition>(<expr>!<call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"execve() arg 3 must be a mapping object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_0</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_0</name>;</goto>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>"et;execve() arg 2 must contain only strings"</expr></argument>,
				 <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
				 <argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name>lastarg</name> = <name>i</name></expr>;</expr_stmt>
			<goto>goto <name>fail_1</name>;</goto>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><name>lastarg</name> = <name>argc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> = <call><name>PyMapping_Size</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<goto>goto <name>fail_1</name>;</goto></then></if>
	<expr_stmt><expr><name>envlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>envlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_1</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>envc</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>keys</name> = <call><name>PyMapping_Keys</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vals</name> = <call><name>PyMapping_Values</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>keys</name> || !<name>vals</name></expr>)</condition><then>
		<goto>goto <name>fail_2</name>;</goto></then></if>
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"execve(): env.keys() or env.values() is not a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_2</name>;</goto>
	}</block></then></if>

	<for>for (<init><expr><name>pos</name> = 0</expr>;</init> <condition><expr><name>pos</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>pos</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>key</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>vals</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>key</name> || !<name>val</name></expr>)</condition><then>
			<goto>goto <name>fail_2</name>;</goto></then></if>

		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(
			    <argument><expr><name>key</name></expr></argument>,
			    <argument><expr>"s;execve() arg 3 contains a non-string key"</expr></argument>,
			    <argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call> ||
		    !<call><name>PyArg_Parse</name><argument_list>(
			    <argument><expr><name>val</name></expr></argument>,
			    <argument><expr>"s;execve() arg 3 contains a non-string value"</expr></argument>,
			    <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<block>{
			<goto>goto <name>fail_2</name>;</goto>
		}</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <comment type="block">/* Omit Pseudo-Env Vars that Would Confuse Programs if Passed On */</comment>
        <if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr>"BEGINLIBPATH"</expr></argument>)</argument_list></call> != 0 &amp;&amp; <call><name>stricmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr>"ENDLIBPATH"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>len</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> + <call><name>PyString_Size</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> + 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail_2</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name>++</expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></for>
	<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name> = 0</expr>;</expr_stmt>

	<expr_stmt><expr><call><name>execve</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we get here it's definitely an error */</comment>

	<expr_stmt><expr>(<name>void</name>) <call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <label><name>fail_2</name>:</label>
	<while>while <condition>(<expr>--<name>envc</name> &gt;= 0</expr>)</condition>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
	<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>fail_1</name>:</label>
	<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>lastarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>fail_0</name>:</label>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_EXECV */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SPAWNV</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_spawnv__doc__</name></expr></argument>,
<argument><expr>"spawnv(mode, path, args)\n\n\
Execute the program 'path' in a new process.\n\
\n\
	mode: mode of process creation\n\
	path: path of executable file\n\
	args: tuple or list of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_spawnv</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>argc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>spawnval</name></decl>;</decl_stmt>
	<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>

	<comment type="block">/* spawnv has three arguments: (mode, path, argv), where
	   argv is a list or tuple of strings. */</comment>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ietO:spawnv"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>,
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
			      <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"spawnv() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>

	<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"et"</expr></argument>,
				 <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
				 <argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"spawnv() arg 2 must contain only strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>spawnval</name> <init>= <expr><call><name>spawnv</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	if (<name>mode</name> == <name>_OLD_P_OVERLAY</name></function_decl>)</block>
		mode = _P_OVERLAY;</function>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>spawnval</name> <init>= <expr><call><name>_spawnv</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<name>free_string_array</name><parameter_list>(<param><decl><type><name>argvlist</name></type></decl></param>, <param><decl><type><name>argc</name></type></decl></param>)</parameter_list>;</function_decl>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>spawnval</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then>
	<else>else
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> == <name>SIZEOF_VOID_P</name></expr></cpp:if>
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"l"</expr></argument>, <argument><expr>(<name>long</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"L"</expr></argument>, <argument><expr>(<name>PY_LONG_LONG</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></extern>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_spawnve__doc__</name></expr></argument>,
<argument><expr>"spawnve(mode, path, args, env)\n\n\
Execute the program 'path' in a new process.\n\
\n\
	mode: mode of process creation\n\
	path: path of executable file\n\
	args: tuple or list of arguments\n\
	env: dictionary of strings mapping to strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_spawnve</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>, *<decl><type ref="prev"/><name>env</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>envlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>, *<decl><type ref="prev"/><name>keys</name><init>=<expr><name>NULL</name></expr></init>, *<name>vals</name><init>=<expr><name>NULL</name></expr></init>, *<name>res</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>, <decl><type ref="prev"/><name>envc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>argc</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>spawnval</name></decl>;</decl_stmt>
	<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lastarg</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* spawnve has four arguments: (mode, path, argv, env), where
	   argv is a list or tuple of strings and env is a dictionary
	   like posix.environ. */</comment>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ietOO:spawnve"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>,
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
			      <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>, <argument><expr>&amp;<name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"spawnve() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_0</name>;</goto>
	}</block></else></if></else></if>
	<if>if <condition>(<expr>!<call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"spawnve() arg 3 must be a mapping object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_0</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_0</name>;</goto>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
			     <argument><expr>"et;spawnve() arg 2 must contain only strings"</expr></argument>,
				 <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
				 <argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name>lastarg</name> = <name>i</name></expr>;</expr_stmt>
			<goto>goto <name>fail_1</name>;</goto>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><name>lastarg</name> = <name>argc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> = <call><name>PyMapping_Size</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<goto>goto <name>fail_1</name>;</goto></then></if>
	<expr_stmt><expr><name>envlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>envlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_1</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>envc</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>keys</name> = <call><name>PyMapping_Keys</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vals</name> = <call><name>PyMapping_Values</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>keys</name> || !<name>vals</name></expr>)</condition><then>
		<goto>goto <name>fail_2</name>;</goto></then></if>
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"spawnve(): env.keys() or env.values() is not a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_2</name>;</goto>
	}</block></then></if>

	<for>for (<init><expr><name>pos</name> = 0</expr>;</init> <condition><expr><name>pos</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>pos</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>key</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>vals</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>key</name> || !<name>val</name></expr>)</condition><then>
			<goto>goto <name>fail_2</name>;</goto></then></if>

		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(
			    <argument><expr><name>key</name></expr></argument>,
			    <argument><expr>"s;spawnve() arg 3 contains a non-string key"</expr></argument>,
			    <argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call> ||
		    !<call><name>PyArg_Parse</name><argument_list>(
			    <argument><expr><name>val</name></expr></argument>,
			    <argument><expr>"s;spawnve() arg 3 contains a non-string value"</expr></argument>,
			    <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<block>{
			<goto>goto <name>fail_2</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>len</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> + <call><name>PyString_Size</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> + 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail_2</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name>++</expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name> = 0</expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>spawnval</name> <init>= <expr><call><name>spawnve</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><name>mode</name> == <name>_OLD_P_OVERLAY</name></expr>)</condition><then>
		<expr_stmt><expr><name>mode</name> = <name>_P_OVERLAY</name></expr>;</expr_stmt></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>spawnval</name> <init>= <expr><call><name>_spawnve</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>spawnval</name> == -1</expr>)</condition><then>
		<expr_stmt><expr>(<name>void</name>) <call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> == <name>SIZEOF_VOID_P</name></expr></cpp:if>
		<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"l"</expr></argument>, <argument><expr>(<name>long</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"L"</expr></argument>, <argument><expr>(<name>PY_LONG_LONG</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <label><name>fail_2</name>:</label>
	<while>while <condition>(<expr>--<name>envc</name> &gt;= 0</expr>)</condition>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
	<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>fail_1</name>:</label>
	<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>lastarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>fail_0</name>:</label>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* OS/2 supports spawnvp &amp; spawnvpe natively */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_spawnvp__doc__</name></expr></argument>,
<argument><expr>"spawnvp(mode, file, args)\n\n\
Execute the program 'file' in a new process, using the environment\n\
search path to find the file.\n\
\n\
	mode: mode of process creation\n\
	file: executable file name\n\
	args: tuple or list of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_spawnvp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>spawnval</name></decl>;</decl_stmt>
	<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>

	<comment type="block">/* spawnvp has three arguments: (mode, path, argv), where
	   argv is a list or tuple of strings. */</comment>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ietO:spawnvp"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>,
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
			      <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"spawnvp() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>

	<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"et"</expr></argument>,
				 <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
				 <argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"spawnvp() arg 2 must contain only strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<name>spawnval</name> <init>= <expr><call><name>spawnvp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>spawnval</name> = <call><name>_spawnvp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>

	<name>free_string_array</name><parameter_list>(<param><decl><type><name>argvlist</name></type></decl></param>, <param><decl><type><name>argc</name></type></decl></param>)</parameter_list>;</function_decl>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>spawnval</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"l"</expr></argument>, <argument><expr>(<name>long</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_spawnvpe__doc__</name></expr></argument>,
<argument><expr>"spawnvpe(mode, file, args, env)\n\n\
Execute the program 'file' in a new process, using the environment\n\
search path to find the file.\n\
\n\
	mode: mode of process creation\n\
	file: executable file name\n\
	args: tuple or list of arguments\n\
	env: dictionary of strings mapping to strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_spawnvpe</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv</name></decl>, *<decl><type ref="prev"/><name>env</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>argvlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>envlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>, *<decl><type ref="prev"/><name>keys</name><init>=<expr><name>NULL</name></expr></init>, *<name>vals</name><init>=<expr><name>NULL</name></expr></init>, *<name>res</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>, <decl><type ref="prev"/><name>envc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>spawnval</name></decl>;</decl_stmt>
	<function_decl><type><name>PyObject</name> *</type>(*<name>getitem</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>int</name></type> <name>lastarg</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* spawnvpe has four arguments: (mode, path, argv, env), where
	   argv is a list or tuple of strings and env is a dictionary
	   like posix.environ. */</comment>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ietOO:spawnvpe"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>,
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
			      <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>, <argument><expr>&amp;<name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyList_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getitem</name> = <name>PyTuple_GetItem</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"spawnvpe() arg 2 must be a tuple or list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_0</name>;</goto>
	}</block></else></if></else></if>
	<if>if <condition>(<expr>!<call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"spawnvpe() arg 3 must be a mapping object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_0</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>argvlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>argc</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>argvlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_0</name>;</goto>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><call>(*<name>getitem</name>)<argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
			     <argument><expr>"et;spawnvpe() arg 2 must contain only strings"</expr></argument>,
				 <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
				 <argument><expr>&amp;<name><name>argvlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name>lastarg</name> = <name>i</name></expr>;</expr_stmt>
			<goto>goto <name>fail_1</name>;</goto>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><name>lastarg</name> = <name>argc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argvlist</name><index>[<expr><name>argc</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> = <call><name>PyMapping_Size</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
		<goto>goto <name>fail_1</name>;</goto></then></if>
	<expr_stmt><expr><name>envlist</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>envlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_1</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>envc</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>keys</name> = <call><name>PyMapping_Keys</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vals</name> = <call><name>PyMapping_Values</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>keys</name> || !<name>vals</name></expr>)</condition><then>
		<goto>goto <name>fail_2</name>;</goto></then></if>
	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"spawnvpe(): env.keys() or env.values() is not a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail_2</name>;</goto>
	}</block></then></if>

	<for>for (<init><expr><name>pos</name> = 0</expr>;</init> <condition><expr><name>pos</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>pos</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>k</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>key</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>vals</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>key</name> || !<name>val</name></expr>)</condition><then>
			<goto>goto <name>fail_2</name>;</goto></then></if>

		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(
			    <argument><expr><name>key</name></expr></argument>,
			    <argument><expr>"s;spawnvpe() arg 3 contains a non-string key"</expr></argument>,
			    <argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call> ||
		    !<call><name>PyArg_Parse</name><argument_list>(
			    <argument><expr><name>val</name></expr></argument>,
			    <argument><expr>"s;spawnvpe() arg 3 contains a non-string value"</expr></argument>,
			    <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<block>{
			<goto>goto <name>fail_2</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>len</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> + <call><name>PyString_Size</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> + 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail_2</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name>++</expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name> = 0</expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<name>spawnval</name> <init>= <expr><call><name>spawnvpe</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>spawnval</name> = <call><name>_spawnvpe</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<if>if <condition>(<expr><name>spawnval</name> == -1</expr>)</condition><then>
		<expr_stmt><expr>(<name>void</name>) <call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"l"</expr></argument>, <argument><expr>(<name>long</name>) <name>spawnval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <label><name>fail_2</name>:</label>
	<while>while <condition>(<expr>--<name>envc</name> &gt;= 0</expr>)</condition>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name><name>envlist</name><index>[<expr><name>envc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
	<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>envlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>fail_1</name>:</label>
	<expr_stmt><expr><call><name>free_string_array</name><argument_list>(<argument><expr><name>argvlist</name></expr></argument>, <argument><expr><name>lastarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>fail_0</name>:</label>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PYOS_OS2 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SPAWNV */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FORK1</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fork1__doc__</name></expr></argument>,
<argument><expr>"fork1() -&gt; pid\n\n\
Fork a child process with a single multiplexed (i.e., not bound) thread.\n\
\n\
Return 0 to child process and PID of child to parent process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fork1</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><call><name>fork1</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyOS_AfterFork</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FORK</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fork__doc__</name></expr></argument>,
<argument><expr>"fork() -&gt; pid\n\n\
Fork a child process.\n\
Return 0 to child process and PID of child to parent process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fork</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><call><name>fork</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyOS_AfterFork</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* AIX uses /dev/ptc but is otherwise the same as /dev/ptmx */</comment>
<comment type="block">/* IRIX has both /dev/ptc and /dev/ptmx, use ptmx */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTC</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEV_PTY_FILE</name></cpp:macro> <cpp:value>"/dev/ptc"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_DEV_PTMX</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEV_PTY_FILE</name></cpp:macro> <cpp:value>"/dev/ptmx"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FORKPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTY_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pty.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBUTIL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libutil.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LIBUTIL_H */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_PTY_H */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STROPTS_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stropts.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) || defined(HAVE_DEV_PTMX */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__GETPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_openpty__doc__</name></expr></argument>,
<argument><expr>"openpty() -&gt; (master_fd, slave_fd)\n\n\
Open a pseudo-terminal, returning open fd's for both master and slave end.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_openpty</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>master_fd</name></decl>, <decl><type ref="prev"/><name>slave_fd</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_OPENPTY</name></cpp:ifndef>
	<decl_stmt><decl><type><name>char</name> *</type> <name>slave_name</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE__GETPTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>PyOS_sighandler_t</name></type> <name>sig_saved</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>sun</name></cpp:ifdef>
	<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>ptsname</name><parameter_list>(<param><decl><type><name>int</name></type> <name>fildes</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_OPENPTY</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>openpty</name><argument_list>(<argument><expr>&amp;<name>master_fd</name></expr></argument>, <argument><expr>&amp;<name>slave_fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__GETPTY</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>slave_name</name> = <call><name>_getpty</name><argument_list>(<argument><expr>&amp;<name>master_fd</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr>0666</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>slave_name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>slave_fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>slave_name</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>slave_fd</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>master_fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>DEV_PTY_FILE</name></expr></argument>, <argument><expr><name>O_RDWR</name> | <name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* open master */</comment>
	<if>if <condition>(<expr><name>master_fd</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>sig_saved</name> = <call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* change permission of slave */</comment>
	<if>if <condition>(<expr><call><name>grantpt</name><argument_list>(<argument><expr><name>master_fd</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>sig_saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<comment type="block">/* unlock slave */</comment>
	<if>if <condition>(<expr><call><name>unlockpt</name><argument_list>(<argument><expr><name>master_fd</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>sig_saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyOS_setsig</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>sig_saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slave_name</name> = <call><name>ptsname</name><argument_list>(<argument><expr><name>master_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get name of slave */</comment>
	<if>if <condition>(<expr><name>slave_name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>slave_fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>slave_name</name></expr></argument>, <argument><expr><name>O_RDWR</name> | <name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* open slave */</comment>
	<if>if <condition>(<expr><name>slave_fd</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name>slave_fd</name></expr></argument>, <argument><expr><name>I_PUSH</name></expr></argument>, <argument><expr>"ptem"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* push ptem */</comment>
	<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name>slave_fd</name></expr></argument>, <argument><expr><name>I_PUSH</name></expr></argument>, <argument><expr>"ldterm"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* push ldterm */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__hpux</name></cpp:ifndef>
	<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name>slave_fd</name></expr></argument>, <argument><expr><name>I_PUSH</name></expr></argument>, <argument><expr>"ttcompat"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* push ttcompat */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __hpux */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CYGWIN */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_OPENPTY */</comment>

	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>, <argument><expr><name>master_fd</name></expr></argument>, <argument><expr><name>slave_fd</name></expr></argument>)</argument_list></call></expr>;</return>

}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(HAVE_OPENPTY) || defined(HAVE__GETPTY) || defined(HAVE_DEV_PTMX) */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FORKPTY</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_forkpty__doc__</name></expr></argument>,
<argument><expr>"forkpty() -&gt; (pid, master_fd)\n\n\
Fork a new process with a new pseudo-terminal as controlling tty.\n\n\
Like fork(), return 0 as pid to child process, and PID of child to parent.\n\
To both, return fd of newly opened pseudo-terminal.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_forkpty</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>master_fd</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pid</name> = <call><name>forkpty</name><argument_list>(<argument><expr>&amp;<name>master_fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyOS_AfterFork</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(li)"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>master_fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETEGID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getegid__doc__</name></expr></argument>,
<argument><expr>"getegid() -&gt; egid\n\n\
Return the current process's effective group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getegid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getegid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETEUID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_geteuid__doc__</name></expr></argument>,
<argument><expr>"geteuid() -&gt; euid\n\n\
Return the current process's effective user id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_geteuid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>geteuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETGID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getgid__doc__</name></expr></argument>,
<argument><expr>"getgid() -&gt; gid\n\n\
Return the current process's group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getgid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getgid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getpid__doc__</name></expr></argument>,
<argument><expr>"getpid() -&gt; pid\n\n\
Return the current process id"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getpid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETGROUPS</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getgroups__doc__</name></expr></argument>,
<argument><expr>"getgroups() -&gt; list of group IDs\n\n\
Return list of supplemental group IDs for the process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getgroups</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NGROUPS_MAX</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_GROUPS</name></cpp:macro> <cpp:value>NGROUPS_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* defined to be 16 on Solaris7, so this should be a small number */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_GROUPS</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><name>gid_t</name></type> <name><name>grouplist</name><index>[<expr><name>MAX_GROUPS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>n</name> = <call><name>getgroups</name><argument_list>(<argument><expr><name>MAX_GROUPS</name></expr></argument>, <argument><expr><name>grouplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
        <else>else <block>{
            <expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                    <decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
        }</block></else></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETPGID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getpgid__doc__</name></expr></argument>,
<argument><expr>"getpgid(pid) -&gt; pgid\n\n\
Call the system call getpgid()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getpgid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>, <decl><type ref="prev"/><name>pgid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:getpgid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>pgid</name> = <call><name>getpgid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pgid</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>pgid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETPGID */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETPGRP</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getpgrp__doc__</name></expr></argument>,
<argument><expr>"getpgrp() -&gt; pgrp\n\n\
Return the current process group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getpgrp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GETPGRP_HAVE_ARG</name></cpp:ifdef>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getpgrp</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* GETPGRP_HAVE_ARG */</comment>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getpgrp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* GETPGRP_HAVE_ARG */</comment>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETPGRP */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETPGRP</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setpgrp__doc__</name></expr></argument>,
<argument><expr>"setpgrp()\n\n\
Make this process a session leader."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setpgrp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SETPGRP_HAVE_ARG</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>setpgrp</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* SETPGRP_HAVE_ARG */</comment>
	<if>if <condition>(<expr><call><name>setpgrp</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SETPGRP_HAVE_ARG */</comment>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETPGRP */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETPPID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getppid__doc__</name></expr></argument>,
<argument><expr>"getppid() -&gt; ppid\n\n\
Return the parent's process id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getppid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>getppid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETLOGIN</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getlogin__doc__</name></expr></argument>,
<argument><expr>"getlogin() -&gt; string\n\n\
Return the actual login name."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getlogin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>old_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>name</name> = <call><name>getlogin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>errno</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>,
                                <argument><expr>"unable to determine login name"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><name>errno</name> = <name>old_errno</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETUID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getuid__doc__</name></expr></argument>,
<argument><expr>"getuid() -&gt; uid\n\n\
Return the current process's user id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getuid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>getuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_KILL</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_kill__doc__</name></expr></argument>,
<argument><expr>"kill(pid, sig)\n\n\
Kill a process with a signal."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_kill</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sig</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:kill"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>sig</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if>if <condition>(<expr><name>sig</name> == <name>XCPT_SIGNAL_INTR</name> || <name>sig</name> == <name>XCPT_SIGNAL_BREAK</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>rc</name> = <call><name>DosSendSignalException</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call>) != <name>NO_ERROR</name></expr>)</condition><then>
            <return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    }</block></then> <else>else <if>if <condition>(<expr><name>sig</name> == <name>XCPT_SIGNAL_KILLPROC</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>rc</name> = <call><name>DosKillProcess</name><argument_list>(<argument><expr><name>DKP_PROCESS</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call>) != <name>NO_ERROR</name></expr>)</condition><then>
            <return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    }</block></then> <else>else
        <return>return <expr><name>NULL</name></expr>;</return></else></if></else></if> <comment type="block">/* Unrecognized Signal Requested */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_KILLPG</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_killpg__doc__</name></expr></argument>,
<argument><expr>"killpg(pgid, sig)\n\n\
Kill a process group with a signal."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_killpg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>pgid</name></decl>, <decl><type ref="prev"/><name>sig</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:killpg"</expr></argument>, <argument><expr>&amp;<name>pgid</name></expr></argument>, <argument><expr>&amp;<name>sig</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>killpg</name><argument_list>(<argument><expr><name>pgid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PLOCK</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_LOCK_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/lock.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_plock__doc__</name></expr></argument>,
<argument><expr>"plock(op)\n\n\
Lock program segments into memory."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_plock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:plock"</expr></argument>, <argument><expr>&amp;<name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>plock</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POPEN</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_popen__doc__</name></expr></argument>,
<argument><expr>"popen(command [, mode='r' [, bufsize]]) -&gt; pipe\n\n\
Open a pipe to/from a command returning a file object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>async_system</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>command</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>errormsg</name><index>[<expr>256</expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>args</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RESULTCODES</name></type> <name>rcodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> *</type><name>shell</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"COMSPEC"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>shell</name></expr>)</condition><then>
		<expr_stmt><expr><name>shell</name> = "cmd"</expr>;</expr_stmt></then></if>

	<comment type="block">/* avoid overflowing the argument buffer */</comment>
	<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call> + 3 + <call><name>strlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> &gt;= 1024</expr>)</condition><then>
		<return>return <expr><name>ERROR_NOT_ENOUGH_MEMORY</name>

	<name><name>args</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</return></then></if>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"/c "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* execute asynchronously, inheriting the environment */</comment>
	<expr_stmt><expr><name>rc</name> = <call><name>DosExecPgm</name><argument_list>(<argument><expr><name>errormsg</name></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errormsg</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			<argument><expr><name>EXEC_ASYNC</name></expr></argument>,
			<argument><expr><name>args</name></expr></argument>,
			<argument><expr><name>NULL</name></expr></argument>,
			<argument><expr>&amp;<name>rcodes</name></expr></argument>,
			<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>FILE</name> *</type>
<name>popen</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>command</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mode</name></decl></param>, <param><decl><type><name>int</name></type> <name>pipesize</name></decl></param>, <param><decl><type><name>int</name> *</type><name>err</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>oldfd</name></decl>, <decl><type ref="prev"/><name>tgtfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HFILE</name></type> <name><name>pipeh</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* mode determines which of stdin or stdout is reconnected to
	 * the pipe to the child
	 */</comment>
	<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>'r'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>tgt_fd</name> = 1</expr>;</expr_stmt>	<comment type="block">/* stdout */</comment>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>'w'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>tgt_fd</name> = 0</expr>;</expr_stmt>	<comment type="block">/* stdin */</comment>
	}</block></then> <else>else <block>{
		<expr_stmt><expr>*<name>err</name> = <name>ERROR_INVALID_ACCESS</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>

	<comment type="block">/* setup the pipe */</comment>
	<if>if <condition>(<expr>(<name>rc</name> = <call><name>DosCreatePipe</name><argument_list>(<argument><expr>&amp;<name><name>pipeh</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>pipeh</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>pipesize</name></expr></argument>)</argument_list></call>) != <name>NO_ERROR</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>err</name> = <name>rc</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* prevent other threads accessing stdio */</comment>
	<expr_stmt><expr><call><name>DosEnterCritSec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reconnect stdio and execute child */</comment>
	<expr_stmt><expr><name>oldfd</name> = <call><name>dup</name><argument_list>(<argument><expr><name>tgtfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>tgtfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>pipeh</name><index>[<expr><name>tgtfd</name></expr>]</index></name></expr></argument>, <argument><expr><name>tgtfd</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>DosClose</name><argument_list>(<argument><expr><name><name>pipeh</name><index>[<expr><name>tgtfd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> = <call><name>async_system</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* restore stdio */</comment>
	<expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>, <argument><expr><name>tgtfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allow other threads access to stdio */</comment>
	<expr_stmt><expr><call><name>DosExitCritSec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if execution of child was successful return file stream */</comment>
	<if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then>
		<return>return <expr><call><name>fdopen</name><argument_list>(<argument><expr><name><name>pipeh</name><index>[<expr>1 - <name>tgtfd</name></expr>]</index></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>DosClose</name><argument_list>(<argument><expr><name><name>pipeh</name><index>[<expr>1 - <name>tgtfd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>err</name> = <name>rc</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_popen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>err</name></decl>, <decl><type ref="prev"/><name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fp</name> <init>= <expr><call><name>popen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr>(<name>bufsize</name> &gt; 0) ? <name>bufsize</name> : 4096</expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<comment type="block">/* standard posix version of popen() support */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_popen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fp</name> <init>= <expr><call><name>popen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<comment type="block">/* fork() under OS/2 has lots'o'warts
 * EMX supports pipe() and spawn*() so we can synthesize popen[234]()
 * most of this code is a ripoff of the win32 code, but using the
 * capabilities of EMX's C library routines
 */</comment>

<comment type="block">/* These tell _PyPopen() whether to return 1, 2, or 3 file objects. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_1</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_2</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_3</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_4</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyPopen</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_PyPclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Internal dictionary mapping popen* file pointers to process handles,
 * for use when retrieving the process exit code.  See _PyPclose() below
 * for more information on this dictionary's use.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyPopenProcs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* os2emx version of popen2()
 *
 * The result of this function is a pipe (file) connected to the
 * process's stdin, and a pipe connected to the process's stdout.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>os2emx_popen2</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name>  *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tm</name><init>=<expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen2"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
		<expr_stmt><expr><name>tm</name> = <name>O_TEXT</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"mode must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><name>tm</name> = <name>O_BINARY</name></expr>;</expr_stmt></else></if></else></if>

	<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_2</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Variation on os2emx.popen2
 *
 * The result of this function is 3 pipes - the process's stdin,
 * stdout and stderr
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>os2emx_popen3</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen3"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
		<expr_stmt><expr><name>tm</name> = <name>O_TEXT</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"mode must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><name>tm</name> = <name>O_BINARY</name></expr>;</expr_stmt></else></if></else></if>

	<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_3</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Variation on os2emx.popen2
 *
 * The result of this function is 2 pipes - the processes stdin,
 * and stdout+stderr combined as a single pipe.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>os2emx_popen4</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name>  *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen4"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
		<expr_stmt><expr><name>tm</name> = <name>O_TEXT</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"mode must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><name>tm</name> = <name>O_BINARY</name></expr>;</expr_stmt></else></if></else></if>

	<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_4</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<comment type="block">/* a couple of structures for convenient handling of multiple
 * file handles and pipes
 */</comment>
<struct>struct <name>file_ref</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>pipe_ref</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>rd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wr</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* The following code is derived from the win32 code */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_PyPopen</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>cmdstring</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>file_ref</name></type> <name><name>stdio</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>pipe_ref</name></type> <name><name>p_fd</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name><name>p_s</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>file_count</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>pipe_err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pipe_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>shell</name></decl>, *<decl><type ref="prev"/><name>sh_name</name></decl>, *<decl><type ref="prev"/><name>opt</name></decl>, *<decl><type ref="prev"/><name>rd_mode</name></decl>, *<decl><type ref="prev"/><name>wr_mode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>, *<decl><type ref="prev"/><name><name>p_f</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* file modes for subsequent fdopen's on pipe handles */</comment>
	<if>if <condition>(<expr><name>mode</name> == <name>O_TEXT</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><name>rd_mode</name> = "rt"</expr>;</expr_stmt>
		<expr_stmt><expr><name>wr_mode</name> = "wt"</expr>;</expr_stmt>
	}</block></then>
	<else>else
	<block>{
		<expr_stmt><expr><name>rd_mode</name> = "rb"</expr>;</expr_stmt>
		<expr_stmt><expr><name>wr_mode</name> = "wb"</expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* prepare shell references */</comment>
	<if>if <condition>(<expr>(<name>shell</name> = <call><name>getenv</name><argument_list>(<argument><expr>"EMXSHELL"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<if>if <condition>(<expr>(<name>shell</name> = <call><name>getenv</name><argument_list>(<argument><expr>"COMSPEC"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name>errno</name> = <name>ENOENT</name></expr>;</expr_stmt>
			<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
		}</block></then></if></then></if>

	<expr_stmt><expr><name>sh_name</name> = <call><name>_getname</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>sh_name</name></expr></argument>, <argument><expr>"cmd.exe"</expr></argument>)</argument_list></call> == 0 || <call><name>stricmp</name><argument_list>(<argument><expr><name>sh_name</name></expr></argument>, <argument><expr>"4os2.exe"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>opt</name> = "/c"</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>opt</name> = "-c"</expr>;</expr_stmt></else></if>

	<comment type="block">/* save current stdio fds + their flags, and set not inheritable */</comment>
	<expr_stmt><expr><name>i</name> = <name>pipe_err</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><name>pipe_err</name> &gt;= 0 &amp;&amp; <name>i</name> &lt; 3</expr>)</condition>
	<block>{
		<expr_stmt><expr><name>pipe_err</name> = <name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name> = <call><name>dup</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>flags</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>flags</name> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
	}</block></while>
	<if>if <condition>(<expr><name>pipe_err</name> &lt; 0</expr>)</condition><then>
	<block>{
		<comment type="block">/* didn't get them all saved - clean up and bail out */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>saved_err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>i</name>-- &gt; 0</expr>)</condition>
		<block>{
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><name>errno</name> = <name>saved_err</name></expr>;</expr_stmt>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* create pipe ends */</comment>
	<expr_stmt><expr><name>file_count</name> = 2</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> == <name>POPEN_3</name></expr>)</condition><then>
		<expr_stmt><expr><name>file_count</name> = 3</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>i</name> = <name>pipe_err</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>pipe_err</name> == 0) &amp;&amp; (<name>i</name> &lt; <name>file_count</name>)</expr>)</condition>
		<expr_stmt><expr><name>pipe_err</name> = <call><name>pipe</name><argument_list>(<argument><expr>(<name>int</name> *)&amp;<name><name>p_fd</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
	<if>if <condition>(<expr><name>pipe_err</name> &lt; 0</expr>)</condition><then>
	<block>{
		<comment type="block">/* didn't get them all made - clean up and bail out */</comment>
		<while>while <condition>(<expr><name>i</name>-- &gt; 0</expr>)</condition>
		<block>{
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><name>errno</name> = <name>EPIPE</name></expr>;</expr_stmt>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* change the actual standard IO streams over temporarily,
	 * making the retained pipe ends non-inheritable
	 */</comment>
	<expr_stmt><expr><name>pipe_err</name> = 0</expr>;</expr_stmt>

	<comment type="block">/* - stdin */</comment>
	<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	<block>{
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>i</name> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name><name>p_s</name><index>[<expr>0</expr>]</index></name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr><name>wr_mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>0</expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
		}</block></then></if>
	}</block></then>
	<else>else
	<block>{
		<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
	}</block></else></if>

	<comment type="block">/* - stdout */</comment>
	<if>if <condition>(<expr><name>pipe_err</name> == 0</expr>)</condition><then>
	<block>{
		<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
		<block>{
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>i</name> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name><name>p_s</name><index>[<expr>1</expr>]</index></name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>rd_mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
			<block>{
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>1</expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
			}</block></then></if>
		}</block></then>
		<else>else
		<block>{
			<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>

	<comment type="block">/* - stderr, as required */</comment>
	<if>if <condition>(<expr><name>pipe_err</name> == 0</expr>)</condition><then>
		<switch>switch <condition>(<expr><name>n</name></expr>)</condition>
		<block>{
			<case>case <expr><name>POPEN_3</name></expr>:
			<block>{
				<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>wr</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 2</expr>)</condition><then>
				<block>{
					<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>i</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>i</name> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr>(<name><name>p_s</name><index>[<expr>2</expr>]</index></name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>rd</name></expr></argument>, <argument><expr><name>rd_mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
					<block>{
						<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr>2</expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
					}</block></then></if>
				}</block></then>
				<else>else
				<block>{
					<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
				}</block></else></if>
				<break>break;</break>
			}</block>

			</case><case>case <expr><name>POPEN_4</name></expr>:
			<block>{
				<if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> != 2</expr>)</condition><then>
				<block>{
					<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
				}</block></then></if>
				<break>break;</break>
			}</block>
		</case>}</block></switch></then></if>

	<comment type="block">/* spawn the child process */</comment>
	<if>if <condition>(<expr><name>pipe_err</name> == 0</expr>)</condition><then>
	<block>{
		<expr_stmt><expr><name>pipe_pid</name> = <call><name>spawnlp</name><argument_list>(<argument><expr><name>P_NOWAIT</name></expr></argument>, <argument><expr><name>shell</name></expr></argument>, <argument><expr><name>shell</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>(<name>char</name> *)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pipe_pid</name> == -1</expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name>pipe_err</name> = -1</expr>;</expr_stmt>
		}</block></then>
		<else>else
		<block>{
			<comment type="block">/* save the PID into the FILE structure
			 * NOTE: this implementation doesn't actually
			 * take advantage of this, but do it for
			 * completeness - AIM Apr01
			 */</comment>
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>file_count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
				<expr_stmt><expr><name><name>p_s</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>_pid</name> = <name>pipe_pid</name></expr>;</expr_stmt></for>
		}</block></else></if>
	}</block></then></if>

	<comment type="block">/* reset standard IO to normal */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<block>{
		<expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>stdio</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* if any remnant problems, clean up and bail out */</comment>
	<if>if <condition>(<expr><name>pipe_err</name> &lt; 0</expr>)</condition><then>
	<block>{
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<block>{
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p_fd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>wr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><name>errno</name> = <name>EPIPE</name></expr>;</expr_stmt>
		<return>return <expr><call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<comment type="block">/* build tuple of file objects to return */</comment>
	<if>if <condition>(<expr>(<name><name>p_f</name><index>[<expr>0</expr>]</index></name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>wr_mode</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name><name>p_f</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name><name>p_f</name><index>[<expr>1</expr>]</index></name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>rd_mode</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name><name>p_f</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>n</name> == <name>POPEN_3</name></expr>)</condition><then>
	<block>{
		<if>if <condition>(<expr>(<name><name>p_f</name><index>[<expr>2</expr>]</index></name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>rd_mode</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name><name>p_f</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>f</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>f</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>p_f</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<comment type="block">/*
	 * Insert the files we've created into the process dictionary
	 * all referencing the list with the process handle and the
	 * initial number of files (see description below in _PyPclose).
	 * Since if _PyPclose later tried to wait on a process when all
	 * handles weren't closed, it could create a deadlock with the
	 * child, we spend some energy here to try to ensure that we
	 * either insert all file handles into the dictionary or none
	 * at all.  It's a little clumsy with the various popen modes
	 * and variable number of files involved.
	 */</comment>
	<if>if <condition>(<expr>!<name>_PyPopenProcs</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><name>_PyPopenProcs</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>_PyPopenProcs</name></expr>)</condition><then>
	<block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>procObj</name></decl>, *<decl><type ref="prev"/><name>pidObj</name></decl>, *<decl><type ref="prev"/><name>intObj</name></decl>, *<decl><type ref="prev"/><name><name>fileObj</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name><name>ins_rc</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name> = <name><name>fileObj</name><index>[<expr>1</expr>]</index></name> = <name><name>fileObj</name><index>[<expr>2</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name>  = <name><name>ins_rc</name><index>[<expr>1</expr>]</index></name>  = <name><name>ins_rc</name><index>[<expr>2</expr>]</index></name>  = 0</expr>;</expr_stmt>

		<expr_stmt><expr><name>procObj</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pidObj</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>pipe_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>intObj</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>file_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>procObj</name> &amp;&amp; <name>pidObj</name> &amp;&amp; <name>intObj</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pidObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>intObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
			<block>{
			    <expr_stmt><expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
						       <argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>,
						       <argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then>
			<block>{
			    <expr_stmt><expr><name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
						       <argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>,
						       <argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><name>file_count</name> &gt;= 3</expr>)</condition><then>
			<block>{
				<expr_stmt><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name><name>p_s</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then>
				<block>{
				    <expr_stmt><expr><name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
							       <argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>,
							       <argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></then></if>

			<if>if <condition>(<expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> &lt; 0 || !<name><name>fileObj</name><index>[<expr>0</expr>]</index></name> ||
			    <name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> &lt; 0 || (<name>file_count</name> &gt; 1 &amp;&amp; !<name><name>fileObj</name><index>[<expr>1</expr>]</index></name>) ||
			    <name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> &lt; 0 || (<name>file_count</name> &gt; 2 &amp;&amp; !<name><name>fileObj</name><index>[<expr>2</expr>]</index></name>)</expr>)</condition><then>
			<block>{
				<comment type="block">/* Something failed - remove any dictionary
				 * entries that did make it.
				 */</comment>
				<if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
							<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
							<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
							<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></then></if>
		}</block></then></if>

		<comment type="block">/*
		 * Clean up our localized references for the dictionary keys
		 * and value since PyDict_SetItem will Py_INCREF any copies
		 * that got placed in the dictionary.
		 */</comment>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Child is launched. */</comment>
	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Wrapper for fclose() to use for popen* files, so we can retrieve the
 * exit code for the child process and return as a result of the close.
 *
 * This function uses the _PyPopenProcs dictionary in order to map the
 * input file pointer to information about the process that was
 * originally created by the popen* call that created the file pointer.
 * The dictionary uses the file pointer as a key (with one entry
 * inserted for each file returned by the original popen* call) and a
 * single list object as the value for all files from a single call.
 * The list object contains the Win32 process handle at [0], and a file
 * count at [1], which is initialized to the total number of file
 * handles using that list.
 *
 * This function closes whichever handle it is passed, and decrements
 * the file count in the dictionary for the process handle pointed to
 * by this file.  On the last close (when the file count reaches zero),
 * this function will wait for the child process and then return its
 * exit code as the result of the close() operation.  This permits the
 * files to be closed in any order - it is always the close() of the
 * final handle that will return the exit code.
 *
 * NOTE: This function is currently called with the GIL released.
 * hence we use the GILState API to manage our state.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>_PyPclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>exit_code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pipe_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>procObj</name></decl>, *<decl><type ref="prev"/><name>pidObj</name></decl>, *<decl><type ref="prev"/><name>intObj</name></decl>, *<decl><type ref="prev"/><name>fileObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>file_count</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>state</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Close the file handle first, to ensure it can't block the
	 * child from exiting if it's the last handle.
	 */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><name>state</name> = <call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>_PyPopenProcs</name></expr>)</condition><then>
	<block>{
		<if>if <condition>(<expr>(<name>fileObj</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
		    (<name>procObj</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
					      <argument><expr><name>fileObj</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
		    (<name>pidObj</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
		    (<name>intObj</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name>pipe_pid</name> = (<name>int</name>) <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>pidObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>file_count</name> = (<name>int</name>) <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>intObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><name>file_count</name> &gt; 1</expr>)</condition><then>
			<block>{
				<comment type="block">/* Still other files referencing process */</comment>
				<expr_stmt><expr><name>file_count</name>--</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>,
					       <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>file_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else
			<block>{
				<comment type="block">/* Last file for this process */</comment>
				<if>if <condition>(<expr><name>result</name> != <name>EOF</name> &amp;&amp;
				    <call><name>waitpid</name><argument_list>(<argument><expr><name>pipe_pid</name></expr></argument>, <argument><expr>&amp;<name>exit_code</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == <name>pipe_pid</name></expr>)</condition><then>
				<block>{
					<comment type="block">/* extract exit status */</comment>
					<if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<block>{
						<expr_stmt><expr><name>result</name> = <call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then>
					<else>else
					<block>{
						<expr_stmt><expr><name>errno</name> = <name>EPIPE</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
					}</block></else></if>
				}</block></then>
				<else>else
				<block>{
					<comment type="block">/* Indicate failure - this will cause the file object
					 * to raise an I/O error and translate the last
					 * error code from errno.  We do have a problem with
					 * last errors that overlap the normal errno table,
					 * but that's a consistent problem with the file object.
					 */</comment>
					<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
				}</block></else></if>
			}</block></else></if>

			<comment type="block">/* Remove this file pointer from dictionary */</comment>
			<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>, <argument><expr><name>fileObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>_PyPopenProcs</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></then></if>

		}</block></then></if> <comment type="block">/* if object retrieval ok */</comment>

		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>fileObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if> <comment type="block">/* if _PyPopenProcs */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PYCC_??? */</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<comment type="block">/*
 * Portable 'popen' replacement for Win32.
 *
 * Written by Bill Tutt &lt;billtut@microsoft.com&gt;.  Minor tweaks
 * and 2.0 integration by Fredrik Lundh &lt;fredrik@pythonware.com&gt;
 * Return code handling by David Bolen &lt;db3l@fitlinxx.com&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<comment type="block">/* These tell _PyPopen() wether to return 1, 2, or 3 file objects. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_1</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_2</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_3</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPEN_4</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyPopen</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_PyPclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Internal dictionary mapping popen* file pointers to process handles,
 * for use when retrieving the process exit code.  See _PyPclose() below
 * for more information on this dictionary's use.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_PyPopenProcs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* popen that works from a GUI.
 *
 * The result of this function is a pipe (file) connected to the
 * processes stdin or stdout, depending on the requested mode.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_popen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>*<name>mode</name> == 'r'</expr>)</condition><then>
		<expr_stmt><expr><name>tm</name> = <name>_O_RDONLY</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*<name>mode</name> != 'w'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen() arg 2 must be 'r' or 'w'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><name>tm</name> = <name>_O_WRONLY</name></expr>;</expr_stmt></else></if></else></if>

	<if>if <condition>(<expr><name>bufsize</name> != -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen() arg 3 must be -1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>*(<name>mode</name>+1) == 't'</expr>)</condition><then>
		<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name> | <name>_O_TEXT</name></expr></argument>, <argument><expr><name>POPEN_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*(<name>mode</name>+1) == 'b'</expr>)</condition><then>
		<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name> | <name>_O_BINARY</name></expr></argument>, <argument><expr><name>POPEN_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name> | <name>_O_TEXT</name></expr></argument>, <argument><expr><name>POPEN_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<comment type="block">/* Variation on win32pipe.popen
 *
 * The result of this function is a pipe (file) connected to the
 * process's stdin, and a pipe connected to the process's stdout.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_popen2</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name>  *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tm</name><init>=<expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen2"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
		<expr_stmt><expr><name>tm</name> = <name>_O_TEXT</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen2() arg 2 must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><name>tm</name> = <name>_O_BINARY</name></expr>;</expr_stmt></else></if></else></if>

	<if>if <condition>(<expr><name>bufsize</name> != -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen2() arg 3 must be -1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Variation on &lt;om win32pipe.popen&gt;
 *
 * The result of this function is 3 pipes - the process's stdin,
 * stdout and stderr
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_popen3</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen3"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
		<expr_stmt><expr><name>tm</name> = <name>_O_TEXT</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen3() arg 2 must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><name>tm</name> = <name>_O_BINARY</name></expr>;</expr_stmt></else></if></else></if>

	<if>if <condition>(<expr><name>bufsize</name> != -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen3() arg 3 must be -1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Variation on win32pipe.popen
 *
 * The result of this function is 2 pipes - the processes stdin,
 * and stdout+stderr combined as a single pipe.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_popen4</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name>  *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tm</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> *</type><name>cmdstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"t"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen4"</expr></argument>, <argument><expr>&amp;<name>cmdstring</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>*<name>mode</name> == 't'</expr>)</condition><then>
		<expr_stmt><expr><name>tm</name> = <name>_O_TEXT</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>*<name>mode</name> != 'b'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen4() arg 2 must be 't' or 'b'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><name>tm</name> = <name>_O_BINARY</name></expr>;</expr_stmt></else></if></else></if>

	<if>if <condition>(<expr><name>bufsize</name> != -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"popen4() arg 3 must be -1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>f</name> = <call><name>_PyPopen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>POPEN_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>_PyPopenCreateProcess</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>cmdstring</name></decl></param>,
		      <param><decl><type><name>HANDLE</name></type> <name>hStdin</name></decl></param>,
		      <param><decl><type><name>HANDLE</name></type> <name>hStdout</name></decl></param>,
		      <param><decl><type><name>HANDLE</name></type> <name>hStderr</name></decl></param>,
		      <param><decl><type><name>HANDLE</name> *</type><name>hProcess</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>piProcInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>siStartInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>dwProcessFlags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* no NEW_CONSOLE by default for Ctrl+C handling */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>s1</name></decl>,*<decl><type ref="prev"/><name>s2</name></decl>, *<decl><type ref="prev"/><name>s3</name> <init>= <expr>" /c "</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>szConsoleSpawn</name> <init>= <expr>"w9xpopen.exe"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>x</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>i</name> = <call><name>GetEnvironmentVariable</name><argument_list>(<argument><expr>"COMSPEC"</expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>comshell</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>s1</name> = (<name>char</name> *)<call><name>alloca</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!(<name>x</name> = <call><name>GetEnvironmentVariable</name><argument_list>(<argument><expr>"COMSPEC"</expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
			<comment type="block">/* x &lt; i, so x fits into an integer */</comment>
			<return>return <expr>(<name>int</name>)<name>x</name></expr>;</return></then></if>

		<comment type="block">/* Explicitly check if we are using COMMAND.COM.  If we are
		 * then use the w9xpopen hack.
		 */</comment>
		<expr_stmt><expr><name>comshell</name> = <name>s1</name> + <name>x</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>comshell</name> &gt;= <name>s1</name> &amp;&amp; *<name>comshell</name> != '\\'</expr>)</condition>
			<expr_stmt><expr>--<name>comshell</name></expr>;</expr_stmt></while>
		<expr_stmt><expr>++<name>comshell</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>GetVersion</name><argument_list>()</argument_list></call> &lt; 0x80000000 &amp;&amp;
		    <call><name>_stricmp</name><argument_list>(<argument><expr><name>comshell</name></expr></argument>, <argument><expr>"command.com"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<comment type="block">/* NT/2000 and not using command.com. */</comment>
			<expr_stmt><expr><name>x</name> = <name>i</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>s3</name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>s2</name> = (<name>char</name> *)<call><name>alloca</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr>"%s%s%s"</expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s3</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<comment type="block">/*
			 * Oh gag, we're on Win9x or using COMMAND.COM. Use
			 * the workaround listed in KB: Q150956
			 */</comment>
			<decl_stmt><decl><type><name>char</name></type> <name><name>modulepath</name><index>[<expr><name>_MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type>struct <name>stat</name></type> <name>statinfo</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>GetModuleFileName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>modulepath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>x</name> = <name>i</name> = 0</expr>;</init> <condition><expr><name><name>modulepath</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
				<if>if <condition>(<expr><name><name>modulepath</name><index>[<expr><name>i</name></expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
					<expr_stmt><expr><name>x</name> = <name>i</name>+1</expr>;</expr_stmt></then></if></for>
			<expr_stmt><expr><name><name>modulepath</name><index>[<expr><name>x</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<comment type="block">/* Create the full-name to w9xpopen, so we can test it exists */</comment>
			<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>,
			        <argument><expr><name>szConsoleSpawn</name></expr></argument>,
			        <argument><expr>(<sizeof>sizeof<argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>modulepath</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof>)
			               -<call><name>strlen</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>, <argument><expr>&amp;<name>statinfo</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>size_t</name></type> <name>mplen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>modulepath</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
				<comment type="block">/* Eeek - file-not-found - possibly an embedding
				   situation - see if we can locate it in sys.prefix
				*/</comment>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>,
				        <argument><expr><call><name>Py_GetExecPrefix</name><argument_list>()</argument_list></call></expr></argument>,
				        <argument><expr><name>mplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>modulepath</name><index>[<expr><name>mplen</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>modulepath</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></call>-1</expr>]</index></name> != '\\'</expr>)</condition><then>
					<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>, <argument><expr>"\\"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>,
				        <argument><expr><name>szConsoleSpawn</name></expr></argument>,
				        <argument><expr><name>mplen</name>-<call><name>strlen</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* No where else to look - raise an easily identifiable
				   error, rather than leaving Windows to report
				   "file not found" - as the user is probably blissfully
				   unaware this shim EXE is used, and it will confuse them.
				   (well, it confused me for a while ;-)
				*/</comment>
				<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>, <argument><expr>&amp;<name>statinfo</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
					    <argument><expr>"Can not locate '%s' which is needed "
					    "for popen to work with your shell "
					    "or platform."</expr></argument>,
					    <argument><expr><name>szConsoleSpawn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>FALSE</name></expr>;</return>
				}</block></then></if>
			}</block></then></if>
			<expr_stmt><expr><name>x</name> = <name>i</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>s3</name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call> + 1 +
				<call><name>strlen</name><argument_list>(<argument><expr><name>modulepath</name></expr></argument>)</argument_list></call> +
				<call><name>strlen</name><argument_list>(<argument><expr><name>szConsoleSpawn</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>

			<expr_stmt><expr><name>s2</name> = (<name>char</name> *)<call><name>alloca</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* To maintain correct argument passing semantics,
			   we pass the command-line as it stands, and allow
			   quoting to be applied.  w9xpopen.exe will then
			   use its argv vector, and re-quote the necessary
			   args for the ultimate child process.
			*/</comment>
			<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(
				<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>x</name></expr></argument>,
				<argument><expr>"\"%s\" %s%s%s"</expr></argument>,
				<argument><expr><name>modulepath</name></expr></argument>,
				<argument><expr><name>s1</name></expr></argument>,
				<argument><expr><name>s3</name></expr></argument>,
				<argument><expr><name>cmdstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Not passing CREATE_NEW_CONSOLE has been known to
			   cause random failures on win9x.  Specifically a
			   dialog:
			   "Your program accessed mem currently in use at xxx"
			   and a hopeful warning about the stability of your
			   system.
			   Cost is Ctrl+C wont kill children, but anyone
			   who cares can have a go!
			*/</comment>
			<expr_stmt><expr><name>dwProcessFlags</name> |= <name>CREATE_NEW_CONSOLE</name></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then>

	<comment type="block">/* Could be an else here to try cmd.exe / command.com in the path
	   Now we'll just error out.. */</comment>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
			<argument><expr>"Cannot locate a COMSPEC environment variable to "
			"use as the shell"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>FALSE</name></expr>;</return>
	}</block></else></if>

	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr>&amp;<name>siStartInfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STARTUPINFO</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>siStartInfo</name>.<name>cb</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>STARTUPINFO</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>siStartInfo</name>.<name>dwFlags</name></name> = <name>STARTF_USESTDHANDLES</name> | <name>STARTF_USESHOWWINDOW</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>siStartInfo</name>.<name>hStdInput</name></name> = <name>hStdin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>siStartInfo</name>.<name>hStdOutput</name></name> = <name>hStdout</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>siStartInfo</name>.<name>hStdError</name></name> = <name>hStderr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>siStartInfo</name>.<name>wShowWindow</name></name> = <name>SW_HIDE</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>CreateProcess</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
			  <argument><expr><name>s2</name></expr></argument>,
			  <argument><expr><name>NULL</name></expr></argument>,
			  <argument><expr><name>NULL</name></expr></argument>,
			  <argument><expr><name>TRUE</name></expr></argument>,
			  <argument><expr><name>dwProcessFlags</name></expr></argument>,
			  <argument><expr><name>NULL</name></expr></argument>,
			  <argument><expr><name>NULL</name></expr></argument>,
			  <argument><expr>&amp;<name>siStartInfo</name></expr></argument>,
			  <argument><expr>&amp;<name>piProcInfo</name></expr></argument>)</argument_list></call></expr> )</condition><then> <block>{
		<comment type="block">/* Close the handles now so anyone waiting is woken. */</comment>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>piProcInfo</name>.<name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Return process handle */</comment>
		<expr_stmt><expr>*<name>hProcess</name> = <name><name>piProcInfo</name>.<name>hProcess</name></name></expr>;</expr_stmt>
		<return>return <expr><name>TRUE</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreateProcess"</expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* The following code is based off of KB: Q190351 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_PyPopen</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>cmdstring</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>hChildStdinRd</name></decl>, <decl><type ref="prev"/><name>hChildStdinWr</name></decl>, <decl><type ref="prev"/><name>hChildStdoutRd</name></decl>, <decl><type ref="prev"/><name>hChildStdoutWr</name></decl>,
		<decl><type ref="prev"/><name>hChildStderrRd</name></decl>, <decl><type ref="prev"/><name>hChildStderrWr</name></decl>, <decl><type ref="prev"/><name>hChildStdinWrDup</name></decl>, <decl><type ref="prev"/><name>hChildStdoutRdDup</name></decl>,
		<decl><type ref="prev"/><name>hChildStderrRdDup</name></decl>, <decl><type ref="prev"/><name>hProcess</name></decl>;</decl_stmt> <comment type="block">/* hChildStdoutWrDup; */</comment>

	<decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>saAttr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOOL</name></type> <name>fSuccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd1</name></decl>, <decl><type ref="prev"/><name>fd2</name></decl>, <decl><type ref="prev"/><name>fd3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>f1</name></decl>, *<decl><type ref="prev"/><name>f2</name></decl>, *<decl><type ref="prev"/><name>f3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>file_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>saAttr</name>.<name>nLength</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>saAttr</name>.<name>bInheritHandle</name></name> = <name>TRUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>saAttr</name>.<name>lpSecurityDescriptor</name></name> = <name>NULL</name></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>CreatePipe</name><argument_list>(<argument><expr>&amp;<name>hChildStdinRd</name></expr></argument>, <argument><expr>&amp;<name>hChildStdinWr</name></expr></argument>, <argument><expr>&amp;<name>saAttr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreatePipe"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* Create new output read handle and the input write handle. Set
	 * the inheritance properties to FALSE. Otherwise, the child inherits
	 * these handles; resulting in non-closeable handles to the pipes
	 * being created. */</comment>
	 <expr_stmt><expr><name>fSuccess</name> = <call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hChildStdinWr</name></expr></argument>,
				    <argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>hChildStdinWrDup</name></expr></argument>, <argument><expr>0</expr></argument>,
				    <argument><expr><name>FALSE</name></expr></argument>,
				    <argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 <if>if <condition>(<expr>!<name>fSuccess</name></expr>)</condition><then>
		 <return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"DuplicateHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	 <comment type="block">/* Close the inheritable version of ChildStdin
	that we're using. */</comment>
	 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdinWr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	 <if>if <condition>(<expr>!<call><name>CreatePipe</name><argument_list>(<argument><expr>&amp;<name>hChildStdoutRd</name></expr></argument>, <argument><expr>&amp;<name>hChildStdoutWr</name></expr></argument>, <argument><expr>&amp;<name>saAttr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		 <return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreatePipe"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	 <expr_stmt><expr><name>fSuccess</name> = <call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hChildStdoutRd</name></expr></argument>,
				    <argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr>0</expr></argument>,
				    <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 <if>if <condition>(<expr>!<name>fSuccess</name></expr>)</condition><then>
		 <return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"DuplicateHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	 <comment type="block">/* Close the inheritable version of ChildStdout
		that we're using. */</comment>
	 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdoutRd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	 <if>if <condition>(<expr><name>n</name> != <name>POPEN_4</name></expr>)</condition><then> <block>{
		 <if>if <condition>(<expr>!<call><name>CreatePipe</name><argument_list>(<argument><expr>&amp;<name>hChildStderrRd</name></expr></argument>, <argument><expr>&amp;<name>hChildStderrWr</name></expr></argument>, <argument><expr>&amp;<name>saAttr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
			 <return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreatePipe"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		 <expr_stmt><expr><name>fSuccess</name> = <call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
					    <argument><expr><name>hChildStderrRd</name></expr></argument>,
					    <argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
					    <argument><expr>&amp;<name>hChildStderrRdDup</name></expr></argument>, <argument><expr>0</expr></argument>,
					    <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <if>if <condition>(<expr>!<name>fSuccess</name></expr>)</condition><then>
			 <return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"DuplicateHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		 <comment type="block">/* Close the inheritable version of ChildStdErr that we're using. */</comment>
		 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 }</block></then></if>

	 <switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{
	 <case>case <expr><name>POPEN_1</name></expr>:
		 <switch>switch <condition>(<expr><name>mode</name> &amp; (<name>_O_RDONLY</name> | <name>_O_TEXT</name> | <name>_O_BINARY</name> | <name>_O_WRONLY</name>)</expr>)</condition> <block>{
		 <case>case <expr><name>_O_WRONLY</name> | <name>_O_TEXT</name></expr>:
			 <comment type="block">/* Case for writing to child Stdin in text mode. */</comment>
			 <expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdinWrDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>"w"</expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <comment type="block">/* We don't care about these pipes anymore, so close them. */</comment>
			 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdoutRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <break>break;</break>

		 </case><case>case <expr><name>_O_RDONLY</name> | <name>_O_TEXT</name></expr>:
			 <comment type="block">/* Case for reading from child Stdout in text mode. */</comment>
			 <expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>"r"</expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <comment type="block">/* We don't care about these pipes anymore, so close them. */</comment>
			 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdinWrDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <break>break;</break>

		 </case><case>case <expr><name>_O_RDONLY</name> | <name>_O_BINARY</name></expr>:
			 <comment type="block">/* Case for readinig from child Stdout in binary mode. */</comment>
			 <expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>"rb"</expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <comment type="block">/* We don't care about these pipes anymore, so close them. */</comment>
			 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdinWrDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <break>break;</break>

		 </case><case>case <expr><name>_O_WRONLY</name> | <name>_O_BINARY</name></expr>:
			 <comment type="block">/* Case for writing to child Stdin in binary mode. */</comment>
			 <expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdinWrDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr>"wb"</expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <comment type="block">/* We don't care about these pipes anymore, so close them. */</comment>
			 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdoutRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <break>break;</break>
		 </case>}</block></switch>
		 <expr_stmt><expr><name>file_count</name> = 1</expr>;</expr_stmt>
		 <break>break;</break>

	 </case><case>case <expr><name>POPEN_2</name></expr>:
	 </case><case>case <expr><name>POPEN_4</name></expr>:
	 <block>{
		 <decl_stmt><decl><type><name>char</name> *</type><name>m1</name></decl>, *<decl><type ref="prev"/><name>m2</name></decl>;</decl_stmt>
		 <decl_stmt><decl><type><name>PyObject</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>

		 <if>if <condition>(<expr><name>mode</name> &amp; <name>_O_TEXT</name></expr>)</condition><then> <block>{
			 <expr_stmt><expr><name>m1</name> = "r"</expr>;</expr_stmt>
			 <expr_stmt><expr><name>m2</name> = "w"</expr>;</expr_stmt>
		 }</block></then> <else>else <block>{
			 <expr_stmt><expr><name>m1</name> = "rb"</expr>;</expr_stmt>
			 <expr_stmt><expr><name>m2</name> = "wb"</expr>;</expr_stmt>
		 }</block></else></if>

		 <expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdinWrDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>fd2</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>f2</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd2</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>p1</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>p2</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f2</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		 <if>if <condition>(<expr><name>n</name> != 4</expr>)</condition><then>
			 <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrRdDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		 <expr_stmt><expr><name>f</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>,<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>file_count</name> = 2</expr>;</expr_stmt>
		 <break>break;</break>
	 }</block>

	 </case><case>case <expr><name>POPEN_3</name></expr>:
	 <block>{
		 <decl_stmt><decl><type><name>char</name> *</type><name>m1</name></decl>, *<decl><type ref="prev"/><name>m2</name></decl>;</decl_stmt>
		 <decl_stmt><decl><type><name>PyObject</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>, *<decl><type ref="prev"/><name>p3</name></decl>;</decl_stmt>

		 <if>if <condition>(<expr><name>mode</name> &amp; <name>_O_TEXT</name></expr>)</condition><then> <block>{
			 <expr_stmt><expr><name>m1</name> = "r"</expr>;</expr_stmt>
			 <expr_stmt><expr><name>m2</name> = "w"</expr>;</expr_stmt>
		 }</block></then> <else>else <block>{
			 <expr_stmt><expr><name>m1</name> = "rb"</expr>;</expr_stmt>
			 <expr_stmt><expr><name>m2</name> = "wb"</expr>;</expr_stmt>
		 }</block></else></if>

		 <expr_stmt><expr><name>fd1</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdinWrDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>f1</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>fd2</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStdoutRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>f2</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd2</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>fd3</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>hChildStderrRdDup</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>f3</name> = <call><name>_fdopen</name><argument_list>(<argument><expr><name>fd3</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>p1</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>p2</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f2</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>p3</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>f3</name></expr></argument>, <argument><expr><name>cmdstring</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>, <argument><expr><name>_PyPclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>p3</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>f</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>,<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>p2</name></expr></argument>,<argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>file_count</name> = 3</expr>;</expr_stmt>
		 <break>break;</break>
	 }</block>
	 </case>}</block></switch>

	 <if>if <condition>(<expr><name>n</name> == <name>POPEN_4</name></expr>)</condition><then> <block>{
		 <if>if <condition>(<expr>!<call><name>_PyPopenCreateProcess</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>,
					    <argument><expr><name>hChildStdinRd</name></expr></argument>,
					    <argument><expr><name>hChildStdoutWr</name></expr></argument>,
					    <argument><expr><name>hChildStdoutWr</name></expr></argument>,
					    <argument><expr>&amp;<name>hProcess</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			 <return>return <expr><name>NULL</name></expr>;</return></then></if>
	 }</block></then>
	 <else>else <block>{
		 <if>if <condition>(<expr>!<call><name>_PyPopenCreateProcess</name><argument_list>(<argument><expr><name>cmdstring</name></expr></argument>,
					    <argument><expr><name>hChildStdinRd</name></expr></argument>,
					    <argument><expr><name>hChildStdoutWr</name></expr></argument>,
					    <argument><expr><name>hChildStderrWr</name></expr></argument>,
					    <argument><expr>&amp;<name>hProcess</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			 <return>return <expr><name>NULL</name></expr>;</return></then></if>
	 }</block></else></if>

	 <comment type="block">/*
	  * Insert the files we've created into the process dictionary
	  * all referencing the list with the process handle and the
	  * initial number of files (see description below in _PyPclose).
	  * Since if _PyPclose later tried to wait on a process when all
	  * handles weren't closed, it could create a deadlock with the
	  * child, we spend some energy here to try to ensure that we
	  * either insert all file handles into the dictionary or none
	  * at all.  It's a little clumsy with the various popen modes
	  * and variable number of files involved.
	  */</comment>
	 <if>if <condition>(<expr>!<name>_PyPopenProcs</name></expr>)</condition><then> <block>{
		 <expr_stmt><expr><name>_PyPopenProcs</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	 }</block></then></if>

	 <if>if <condition>(<expr><name>_PyPopenProcs</name></expr>)</condition><then> <block>{
		 <decl_stmt><decl><type><name>PyObject</name> *</type><name>procObj</name></decl>, *<decl><type ref="prev"/><name>hProcessObj</name></decl>, *<decl><type ref="prev"/><name>intObj</name></decl>, *<decl><type ref="prev"/><name><name>fileObj</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
		 <decl_stmt><decl><type><name>int</name></type> <name><name>ins_rc</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>

		 <expr_stmt><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name> = <name><name>fileObj</name><index>[<expr>1</expr>]</index></name> = <name><name>fileObj</name><index>[<expr>2</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
		 <expr_stmt><expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name>  = <name><name>ins_rc</name><index>[<expr>1</expr>]</index></name>  = <name><name>ins_rc</name><index>[<expr>2</expr>]</index></name>  = 0</expr>;</expr_stmt>

		 <expr_stmt><expr><name>procObj</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>hProcessObj</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name>intObj</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>file_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		 <if>if <condition>(<expr><name>procObj</name> &amp;&amp; <name>hProcessObj</name> &amp;&amp; <name>intObj</name></expr>)</condition><then> <block>{
			 <expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>hProcessObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>,<argument><expr><name>intObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			 <expr_stmt><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
						       <argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>,
						       <argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 }</block></then></if>
			 <if>if <condition>(<expr><name>file_count</name> &gt;= 2</expr>)</condition><then> <block>{
				 <expr_stmt><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 <if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
				    <expr_stmt><expr><name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
							       <argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>,
							       <argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 }</block></then></if>
			 }</block></then></if>
			 <if>if <condition>(<expr><name>file_count</name> &gt;= 3</expr>)</condition><then> <block>{
				 <expr_stmt><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>f3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 <if>if <condition>(<expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
				    <expr_stmt><expr><name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
							       <argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>,
							       <argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 }</block></then></if>
			 }</block></then></if>

			 <if>if <condition>(<expr><name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> &lt; 0 || !<name><name>fileObj</name><index>[<expr>0</expr>]</index></name> ||
			     <name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> &lt; 0 || (<name>file_count</name> &gt; 1 &amp;&amp; !<name><name>fileObj</name><index>[<expr>1</expr>]</index></name>) ||
			     <name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> &lt; 0 || (<name>file_count</name> &gt; 2 &amp;&amp; !<name><name>fileObj</name><index>[<expr>2</expr>]</index></name>)</expr>)</condition><then> <block>{
				 <comment type="block">/* Something failed - remove any dictionary
				  * entries that did make it.
				  */</comment>
				 <if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
					 <expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
							<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 }</block></then></if>
				 <if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
					 <expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
							<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 }</block></then></if>
				 <if>if <condition>(<expr>!<name><name>ins_rc</name><index>[<expr>2</expr>]</index></name> &amp;&amp; <name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
					 <expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
							<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 }</block></then></if>
			 }</block></then></if>
		 }</block></then></if>

		 <comment type="block">/*
		  * Clean up our localized references for the dictionary keys
		  * and value since PyDict_SetItem will Py_INCREF any copies
		  * that got placed in the dictionary.
		  */</comment>
		 <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fileObj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 }</block></then></if>

	 <comment type="block">/* Child is launched. Close the parents copy of those pipe
	  * handles that only the child should have open.  You need to
	  * make sure that no handles to the write end of the output pipe
	  * are maintained in this process or else the pipe will not close
	  * when the child process exits and the ReadFile will hang. */</comment>

	 <if>if <condition>(<expr>!<call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdinRd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		 <return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CloseHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	 <if>if <condition>(<expr>!<call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStdoutWr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		 <return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CloseHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	 <if>if <condition>(<expr>(<name>n</name> != 4) &amp;&amp; (!<call><name>CloseHandle</name><argument_list>(<argument><expr><name>hChildStderrWr</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
		 <return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CloseHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	 <return>return <expr><name>f</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Wrapper for fclose() to use for popen* files, so we can retrieve the
 * exit code for the child process and return as a result of the close.
 *
 * This function uses the _PyPopenProcs dictionary in order to map the
 * input file pointer to information about the process that was
 * originally created by the popen* call that created the file pointer.
 * The dictionary uses the file pointer as a key (with one entry
 * inserted for each file returned by the original popen* call) and a
 * single list object as the value for all files from a single call.
 * The list object contains the Win32 process handle at [0], and a file
 * count at [1], which is initialized to the total number of file
 * handles using that list.
 *
 * This function closes whichever handle it is passed, and decrements
 * the file count in the dictionary for the process handle pointed to
 * by this file.  On the last close (when the file count reaches zero),
 * this function will wait for the child process and then return its
 * exit code as the result of the close() operation.  This permits the
 * files to be closed in any order - it is always the close() of the
 * final handle that will return the exit code.
 *
 * NOTE: This function is currently called with the GIL released.
 * hence we use the GILState API to manage our state.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>_PyPclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>exit_code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>hProcess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>procObj</name></decl>, *<decl><type ref="prev"/><name>hProcessObj</name></decl>, *<decl><type ref="prev"/><name>intObj</name></decl>, *<decl><type ref="prev"/><name>fileObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>file_count</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyGILState_STATE</name></type> <name>state</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Close the file handle first, to ensure it can't block the
	 * child from exiting if it's the last handle.
	 */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><name>state</name> = <call><name>PyGILState_Ensure</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>_PyPopenProcs</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>fileObj</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
		    (<name>procObj</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>,
					      <argument><expr><name>fileObj</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
		    (<name>hProcessObj</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
		    (<name>intObj</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{

			<expr_stmt><expr><name>hProcess</name> = <call><name>PyLong_AsVoidPtr</name><argument_list>(<argument><expr><name>hProcessObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>file_count</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>intObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><name>file_count</name> &gt; 1</expr>)</condition><then> <block>{
				<comment type="block">/* Still other files referencing process */</comment>
				<expr_stmt><expr><name>file_count</name>--</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>procObj</name></expr></argument>,<argument><expr>1</expr></argument>,
					       <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>file_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<comment type="block">/* Last file for this process */</comment>
				<if>if <condition>(<expr><name>result</name> != <name>EOF</name> &amp;&amp;
				    <call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call> != <name>WAIT_FAILED</name> &amp;&amp;
				    <call><name>GetExitCodeProcess</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>, <argument><expr>&amp;<name>exit_code</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<comment type="block">/* Possible truncation here in 16-bit environments, but
					 * real exit codes are just the lower byte in any event.
					 */</comment>
					<expr_stmt><expr><name>result</name> = <name>exit_code</name></expr>;</expr_stmt>
				}</block></then> <else>else <block>{
					<comment type="block">/* Indicate failure - this will cause the file object
					 * to raise an I/O error and translate the last Win32
					 * error code from errno.  We do have a problem with
					 * last errors that overlap the normal errno table,
					 * but that's a consistent problem with the file object.
					 */</comment>
					<if>if <condition>(<expr><name>result</name> != <name>EOF</name></expr>)</condition><then> <block>{
						<comment type="block">/* If the error wasn't from the fclose(), then
						 * set errno for the file object error handling.
						 */</comment>
						<expr_stmt><expr><name>errno</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					}</block></then></if>
					<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
				}</block></else></if>

				<comment type="block">/* Free up the native handle at this point */</comment>
				<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>

			<comment type="block">/* Remove this file pointer from dictionary */</comment>
			<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>, <argument><expr><name>fileObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>_PyPopenProcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>_PyPopenProcs</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></then></if>

		}</block></then></if> <comment type="block">/* if object retrieval ok */</comment>

		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>fileObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if> <comment type="block">/* if _PyPopenProcs */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyGILState_Release</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* which OS? */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_popen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|si:popen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* Strip mode of binary or text modifiers */</comment>
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call> == 0 || <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"rt"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>mode</name> = "r"</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call> == 0 || <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"wt"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>mode</name> = "w"</expr>;</expr_stmt></then></if></else></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fp</name> <init>= <expr><call><name>popen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PYOS_??? */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_POPEN */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETUID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setuid__doc__</name></expr></argument>,
<argument><expr>"setuid(uid)\n\n\
Set the current process's user id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setuid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>uid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:setuid"</expr></argument>, <argument><expr>&amp;<name>uid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>setuid</name><argument_list>(<argument><expr><name>uid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETUID */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETEUID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_seteuid__doc__</name></expr></argument>,
<argument><expr>"seteuid(uid)\n\n\
Set the current process's effective user id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_seteuid</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>euid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>&amp;<name>euid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>seteuid</name><argument_list>(<argument><expr><name>euid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETEUID */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETEGID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setegid__doc__</name></expr></argument>,
<argument><expr>"setegid(gid)\n\n\
Set the current process's effective group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setegid</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>egid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>&amp;<name>egid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>setegid</name><argument_list>(<argument><expr><name>egid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETEGID */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETREUID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setreuid__doc__</name></expr></argument>,
<argument><expr>"setreuid(ruid, euid)\n\n\
Set the current process's real and effective user ids."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setreuid</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ruid</name></decl>, <decl><type ref="prev"/><name>euid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii"</expr></argument>, <argument><expr>&amp;<name>ruid</name></expr></argument>, <argument><expr>&amp;<name>euid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>setreuid</name><argument_list>(<argument><expr><name>ruid</name></expr></argument>, <argument><expr><name>euid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETREUID */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETREGID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setregid__doc__</name></expr></argument>,
<argument><expr>"setregid(rgid, egid)\n\n\
Set the current process's real and effective group ids."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setregid</name> <parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>rgid</name></decl>, <decl><type ref="prev"/><name>egid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii"</expr></argument>, <argument><expr>&amp;<name>rgid</name></expr></argument>, <argument><expr>&amp;<name>egid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>setregid</name><argument_list>(<argument><expr><name>rgid</name></expr></argument>, <argument><expr><name>egid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETREGID */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETGID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setgid__doc__</name></expr></argument>,
<argument><expr>"setgid(gid)\n\n\
Set the current process's group id."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setgid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>gid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:setgid"</expr></argument>, <argument><expr>&amp;<name>gid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>setgid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETGID */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETGROUPS</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setgroups__doc__</name></expr></argument>,
<argument><expr>"setgroups(list)\n\n\
Set the groups of the current process to list."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setgroups</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>groups</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gid_t</name></type> <name><name>grouplist</name><index>[<expr><name>MAX_GROUPS</name></expr>]</index></name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PySequence_Check</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"setgroups argument must be a sequence"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>len</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> &gt; <name>MAX_GROUPS</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"too many groups"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<for>for(<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>elem</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>elem</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>elem</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
						<argument><expr>"groups must be integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then> <else>else <block>{
				<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name> <init>= <expr><call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, 
							<argument><expr>"group id too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name> = <name>x</name></expr>;</expr_stmt>
				<comment type="block">/* read back the value to see if it fitted in gid_t */</comment>
				<if>if <condition>(<expr><name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name> != <name>x</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
							<argument><expr>"group id too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				}</block></then></if>
			}</block></else></if>
		}</block></then> <else>else <block>{
			<decl_stmt><decl><type><name>long</name></type> <name>x</name>  <init>= <expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name> = <name>x</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>grouplist</name><index>[<expr><name>i</name></expr>]</index></name> != <name>x</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
						<argument><expr>"group id too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<if>if <condition>(<expr><call><name>setgroups</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>grouplist</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETGROUPS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT3</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAIT4</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wait_helper</name><parameter_list>(<param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>, <param><decl><type><name>int</name></type> <name>status</name></decl></param>, <param><decl><type>struct <name>rusage</name> *</type><name>ru</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
   	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>struct_rusage</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name>struct_rusage</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name> <init>= <expr><call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"resource"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>struct_rusage</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"struct_rusage"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>struct_rusage</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<comment type="block">/* XXX(nnorwitz): Copied (w/mods) from resource.c, there should be only one. */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>PyStructSequence_New</name><argument_list>(<argument><expr>(<name>PyTypeObject</name>*) <name>struct_rusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>doubletime</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>doubletime</name><parameter_list>(<param><type><name>TV</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((double)(TV).tv_sec + (TV).tv_usec * 0.000001)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>,
			<argument><expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>doubletime</name><argument_list>(<argument><expr><name><name>ru</name>-&gt;<name>ru_utime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>1</expr></argument>,
			<argument><expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>doubletime</name><argument_list>(<argument><expr><name><name>ru</name>-&gt;<name>ru_stime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_INT</name><parameter_list>(<param><type><name>result</name></type></param>, <param><type><name>index</name></type></param>, <param><type><name>value</name></type></param>)</parameter_list></cpp:macro>\
		<cpp:value>PyStructSequence_SET_ITEM(result, index, PyInt_FromLong(value))</cpp:value></cpp:define>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_maxrss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_ixrss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_idrss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_isrss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>6</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_minflt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>7</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_majflt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_nswap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>9</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_inblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_oublock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>11</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_msgsnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>12</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_msgrcv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>13</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_nsignals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>14</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_nvcsw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INT</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>15</expr></argument>, <argument><expr><name><name>ru</name>-&gt;<name>ru_nivcsw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_INT</name></cpp:undef>

	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiN"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAIT3 || HAVE_WAIT4 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WAIT3</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_wait3__doc__</name></expr></argument>,
<argument><expr>"wait3(options) -&gt; (pid, status, rusage)\n\n\
Wait for completion of a child process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_wait3</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>rusage</name></type> <name>ru</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:wait3"</expr></argument>, <argument><expr>&amp;<name>options</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>pid</name> <init>= <expr><call><name>wait3</name><argument_list>(<argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr>&amp;<name>ru</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<return>return <expr><call><name>wait_helper</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>ru</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAIT3 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WAIT4</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_wait4__doc__</name></expr></argument>,
<argument><expr>"wait4(pid, options) -&gt; (pid, status, rusage)\n\n\
Wait for completion of a given child process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_wait4</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>rusage</name></type> <name>ru</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:wait4"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>options</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>pid</name> <init>= <expr><call><name>wait4</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr>&amp;<name>ru</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<return>return <expr><call><name>wait_helper</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>ru</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAIT4 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WAITPID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_waitpid__doc__</name></expr></argument>,
<argument><expr>"waitpid(pid, options) -&gt; (pid, status)\n\n\
Wait for completion of a given child process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_waitpid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:waitpid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>options</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>pid</name> <init>= <expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ii"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CWAIT</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<comment type="block">/* MS C has a variant of waitpid() that's usable for most purposes. */</comment>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_waitpid__doc__</name></expr></argument>,
<argument><expr>"waitpid(pid, options) -&gt; (pid, status &lt;&lt; 8)\n\n"
"Wait for completion of a given process.  options is ignored on Windows."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_waitpid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>options</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:waitpid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>options</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>pid</name> <init>= <expr><call><name>_cwait</name><argument_list>(<argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* shift the status left a byte so this is more like the POSIX waitpid */</comment>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ii"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>status</name> &lt;&lt; 8</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAITPID || HAVE_CWAIT */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WAIT</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_wait__doc__</name></expr></argument>,
<argument><expr>"wait() -&gt; (pid, status)\n\n\
Wait for completion of a child process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_wait</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>pid</name> <init>= <expr><call><name>wait</name><argument_list>(<argument><expr>&amp;<name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ii"</expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lstat__doc__</name></expr></argument>,
<argument><expr>"lstat(path) -&gt; stat result\n\n\
Like stat(path), but do not follow symbolic links."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lstat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LSTAT</name></cpp:ifdef>
	<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:lstat"</expr></argument>, <argument><expr><name>lstat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !HAVE_LSTAT */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:lstat"</expr></argument>, <argument><expr><name>STAT</name></expr></argument>, <argument><expr>"U:lstat"</expr></argument>, <argument><expr><name>win32_wstat</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>posix_do_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>"et:lstat"</expr></argument>, <argument><expr><name>STAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_LSTAT */</comment>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_READLINK</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_readlink__doc__</name></expr></argument>,
<argument><expr>"readlink(path) -&gt; path\n\n\
Return a string representing the path to which the symbolic link points."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_readlink</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>arg_is_unicode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:readlink"</expr></argument>, 
				<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr_stmt><expr><name>v</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>arg_is_unicode</name> = 1</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>n</name> <init>= <expr><call><name>readlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>int</name>) sizeof <name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<if>if <condition>(<expr><name>arg_is_unicode</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>w</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>,
				<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
				<argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>w</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <name>w</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* fall back to the original byte string, as
			   discussed in patch #683592 */</comment>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_READLINK */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_symlink__doc__</name></expr></argument>,
<argument><expr>"symlink(src, dst)\n\n\
Create a symbolic link pointing to src named dst."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_symlink</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>posix_2str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"etet:symlink"</expr></argument>, <argument><expr><name>symlink</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYMLINK */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TIMES</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HZ</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HZ</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define> <comment type="block">/* Universal constant :-) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HZ */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>system_uptime</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ULONG</name></type>     <name>value</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
    <name>DosQuerySysInfo</name><argument_list>(<argument><expr><name>QSV_MS_COUNT</name></expr></argument>, <argument><expr><name>QSV_MS_COUNT</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></decl>;</decl_stmt>
    <macro><name>Py_END_ALLOW_THREADS</name></macro>

    <return>return <expr><name>value</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_times</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Currently Only Uptime is Provided -- Others Later */</comment>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ddddd"</expr></argument>,
			     <argument><expr>(<name>double</name>)0</expr></argument> <comment type="block">/* t.tms_utime / HZ */</comment>,
			     <argument><expr>(<name>double</name>)0</expr></argument> <comment type="block">/* t.tms_stime / HZ */</comment>,
			     <argument><expr>(<name>double</name>)0</expr></argument> <comment type="block">/* t.tms_cutime / HZ */</comment>,
			     <argument><expr>(<name>double</name>)0</expr></argument> <comment type="block">/* t.tms_cstime / HZ */</comment>,
			     <argument><expr>(<name>double</name>)<call><name>system_uptime</name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* not OS2 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_times</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>tms</name></type> <name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>clock_t</name></type> <name>c</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> = <call><name>times</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>c</name> == (<name>clock_t</name>) -1</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ddddd"</expr></argument>,
			     <argument><expr>(<name>double</name>)<name><name>t</name>.<name>tms_utime</name></name> / <name>HZ</name></expr></argument>,
			     <argument><expr>(<name>double</name>)<name><name>t</name>.<name>tms_stime</name></name> / <name>HZ</name></expr></argument>,
			     <argument><expr>(<name>double</name>)<name><name>t</name>.<name>tms_cutime</name></name> / <name>HZ</name></expr></argument>,
			     <argument><expr>(<name>double</name>)<name><name>t</name>.<name>tms_cstime</name></name> / <name>HZ</name></expr></argument>,
			     <argument><expr>(<name>double</name>)<name>c</name> / <name>HZ</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* not OS2 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_TIMES */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_TIMES</name></cpp:macro></cpp:define>	<comment type="block">/* so the method table will pick it up */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_times</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FILETIME</name></type> <name>create</name></decl>, <decl><type ref="prev"/><name>exit</name></decl>, <decl><type ref="prev"/><name>kernel</name></decl>, <decl><type ref="prev"/><name>user</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>hProc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>hProc</name> = <call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GetProcessTimes</name><argument_list>(<argument><expr><name>hProc</name></expr></argument>, <argument><expr>&amp;<name>create</name></expr></argument>, <argument><expr>&amp;<name>exit</name></expr></argument>, <argument><expr>&amp;<name>kernel</name></expr></argument>, <argument><expr>&amp;<name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The fields of a FILETIME structure are the hi and lo part
	   of a 64-bit value expressed in 100 nanosecond units.
	   1e7 is one second in such units; 1e-7 the inverse.
	   429.4967296 is 2**32 / 1e7 or 2**32 * 1e-7.
	*/</comment>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(
		<argument><expr>"ddddd"</expr></argument>,
		<argument><expr><call>(<name>double</name>)<argument_list>(<argument><expr><name><name>user</name>.<name>dwHighDateTime</name></name>*429.4967296 +
		         <name><name>user</name>.<name>dwLowDateTime</name></name>*1e-7</expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><call>(<name>double</name>)<argument_list>(<argument><expr><name><name>kernel</name>.<name>dwHighDateTime</name></name>*429.4967296 +
		         <name><name>kernel</name>.<name>dwLowDateTime</name></name>*1e-7</expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr>(<name>double</name>)0</expr></argument>,
		<argument><expr>(<name>double</name>)0</expr></argument>,
		<argument><expr>(<name>double</name>)0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TIMES</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_times__doc__</name></expr></argument>,
<argument><expr>"times() -&gt; (utime, stime, cutime, cstime, elapsed_time)\n\n\
Return a tuple of floating point numbers indicating process times."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETSID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getsid__doc__</name></expr></argument>,
<argument><expr>"getsid(pid) -&gt; sid\n\n\
Call the system call getsid()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getsid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:getsid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>sid</name> = <call><name>getsid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>sid</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>sid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETSID */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETSID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setsid__doc__</name></expr></argument>,
<argument><expr>"setsid()\n\n\
Call the system call setsid()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setsid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>setsid</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETSID */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETPGID</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_setpgid__doc__</name></expr></argument>,
<argument><expr>"setpgid(pid, pgrp)\n\n\
Call the system call setpgid()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_setpgid</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pgrp</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:setpgid"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>pgrp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>setpgid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>pgrp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETPGID */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TCGETPGRP</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tcgetpgrp__doc__</name></expr></argument>,
<argument><expr>"tcgetpgrp(fd) -&gt; pgid\n\n\
Return the process group associated with the terminal given by a fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tcgetpgrp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pgid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:tcgetpgrp"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>pgid</name> = <call><name>tcgetpgrp</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pgid</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>pgid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_TCGETPGRP */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TCSETPGRP</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tcsetpgrp__doc__</name></expr></argument>,
<argument><expr>"tcsetpgrp(fd, pgid)\n\n\
Set the process group associated with the terminal given by a fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tcsetpgrp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>pgid</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:tcsetpgrp"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>pgid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>tcsetpgrp</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pgid</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_TCSETPGRP */</comment>

<comment type="block">/* Functions acting on file descriptors */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_open__doc__</name></expr></argument>,
<argument><expr>"open(filename, flag [, mode=0777]) -&gt; fd\n\n\
Open a file (for low level IO)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_open</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>0777</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>po</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Ui|i:mkdir"</expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>flag</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
			<comment type="block">/* PyUnicode_AS_UNICODE OK without thread
			   lock as it is a simple dereference. */</comment>
			<name>fd</name> <init>= <expr><call><name>_wopen</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>Py_END_ALLOW_THREADS</name></macro>
			<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
				<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
			<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Drop the argument parsing error as narrow strings
		   are also valid. */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti|i"</expr></argument>,
	                      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>file</name></expr></argument>,
	                      <argument><expr>&amp;<name>flag</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_allocated_filename</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_close__doc__</name></expr></argument>,
<argument><expr>"close(fd)\n\n\
Close a file descriptor (for low level IO)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_close</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:close"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_closerange__doc__</name></expr></argument>, 
<argument><expr>"closerange(fd_low, fd_high)\n\n\
Closes all file descriptors in [fd_low, fd_high), ignoring errors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_closerange</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd_from</name></decl>, <decl><type ref="prev"/><name>fd_to</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:closerange"</expr></argument>, <argument><expr>&amp;<name>fd_from</name></expr></argument>, <argument><expr>&amp;<name>fd_to</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
	<for>for (<init><expr><name>i</name> = <name>fd_from</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>fd_to</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>Py_RETURN_NONE</name></decl>;</decl_stmt>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_dup__doc__</name></expr></argument>,
<argument><expr>"dup(fd) -&gt; fd2\n\n\
Return a duplicate of a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_dup</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:dup"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fd</name> <init>= <expr><call><name>dup</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_dup2__doc__</name></expr></argument>,
<argument><expr>"dup2(old_fd, new_fd)\n\n\
Duplicate file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_dup2</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>fd2</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:dup2"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>fd2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>fd2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_lseek__doc__</name></expr></argument>,
<argument><expr>"lseek(fd, pos, how) -&gt; newpos\n\n\
Set the current position of a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_lseek</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>how</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>off_t</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>posobj</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iOi:lseek"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>posobj</name></expr></argument>, <argument><expr>&amp;<name>how</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SEEK_SET</name></cpp:ifdef>
	<comment type="block">/* Turn 0, 1, 2 into SEEK_{SET,CUR,END} */</comment>
	<switch>switch <condition>(<expr><name>how</name></expr>)</condition> <block>{
	<case>case <expr>0</expr>: <expr_stmt><expr><name>how</name> = <name>SEEK_SET</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr>1</expr>: <expr_stmt><expr><name>how</name> = <name>SEEK_CUR</name></expr>;</expr_stmt> <break>break;</break>
	</case><case>case <expr>2</expr>: <expr_stmt><expr><name>how</name> = <name>SEEK_END</name></expr>;</expr_stmt> <break>break;</break>
	</case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SEEK_END */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>pos</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>pos</name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call> ?
		<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call> : <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>posobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN64</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<name>res</name> <init>= <expr><call><name>_lseeki64</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>res</name> = <call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_read__doc__</name></expr></argument>,
<argument><expr>"read(fd, buffersize) -&gt; string\n\n\
Read a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_read</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>buffer</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:read"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>errno</name> = <name>EINVAL</name></expr>;</expr_stmt>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>buffer</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>n</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>n</name> != <name>size</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>buffer</name></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_write__doc__</name></expr></argument>,
<argument><expr>"write(fd, string) -&gt; byteswritten\n\n\
Write a string to a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_write</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"is*:write"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>size</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>pbuf</name>.<name>buf</name></name></expr></argument>, <argument><expr>(<name>size_t</name>)<name><name>pbuf</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
		<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fstat__doc__</name></expr></argument>,
<argument><expr>"fstat(fd) -&gt; stat result\n\n\
Like stat(), but for an open file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fstat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>STRUCT_STAT</name></type> <name>st</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:fstat"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
        <comment type="block">/* on OpenVMS we must ensure that all bytes are written to the file */</comment>
        <expr_stmt><expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>FSTAT</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
		<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"fstat"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>

	<return>return <expr><call><name>_pystat_fromstructstat</name><argument_list>(<argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fdopen__doc__</name></expr></argument>,
<argument><expr>"fdopen(fd [, mode='r' [, bufsize]]) -&gt; file_object\n\n\
Return an open file object connected to a file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fdopen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>orgmode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i|si"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>orgmode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Sanitize mode.  See fileobject.c */</comment>
	<expr_stmt><expr><name>mode</name> = <call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>orgmode</name></expr></argument>)</argument_list></call>+3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>mode</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>orgmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>_PyFile_SanitizeMode</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><name><name>mode</name><index>[<expr>0</expr>]</index></name> == 'a'</expr>)</condition><then> <block>{
		<comment type="block">/* try to make sure the O_APPEND flag is set */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>flags</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>flags</name> != -1</expr>)</condition><then>
			<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>flags</name> | <name>O_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>fp</name> == <name>NULL</name> &amp;&amp; <name>flags</name> != -1</expr>)</condition><then>
			<comment type="block">/* restore old mode if fdopen failed */</comment>
			<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>PyMem_FREE</name><parameter_list>(<param><decl><type><name>mode</name></type></decl></param>)</parameter_list>;</function_decl>
	<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"&lt;fdopen&gt;"</expr></argument>, <argument><expr><name>orgmode</name></expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_isatty__doc__</name></expr></argument>,
<argument><expr>"isatty(fd) -&gt; bool\n\n\
Return True if the file descriptor 'fd' is an open file descriptor\n\
connected to the slave end of a terminal."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_isatty</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:isatty"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>isatty</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PIPE</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_pipe__doc__</name></expr></argument>,
<argument><expr>"pipe() -&gt; (read_end, write_end)\n\n\
Create a pipe."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_pipe</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>HFILE</name></type> <name>read</name></decl>, <decl><type ref="prev"/><name>write</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
    <name>rc</name> <init>= <expr><call><name>DosCreatePipe</name><argument_list>( <argument><expr>&amp;<name>read</name></expr></argument>, <argument><expr>&amp;<name>write</name></expr></argument>, <argument><expr>4096</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
    <if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then>
        <return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>, <argument><expr><name>read</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name><name>fds</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>pipe</name><argument_list>(<argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>, <argument><expr><name><name>fds</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>fds</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* MS_WINDOWS */</comment>
	<decl_stmt><decl><type><name>HANDLE</name></type> <name>read</name></decl>, <decl><type ref="prev"/><name>write</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>read_fd</name></decl>, <decl><type ref="prev"/><name>write_fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOOL</name></type> <name>ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>ok</name> <init>= <expr><call><name>CreatePipe</name><argument_list>(<argument><expr>&amp;<name>read</name></expr></argument>, <argument><expr>&amp;<name>write</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
		<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CreatePipe"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>read_fd</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>read</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_fd</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>write</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>, <argument><expr><name>read_fd</name></expr></argument>, <argument><expr><name>write_fd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* HAVE_PIPE */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MKFIFO</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_mkfifo__doc__</name></expr></argument>,
<argument><expr>"mkfifo(filename [, mode=0666])\n\n\
Create a FIFO (a POSIX named pipe)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_mkfifo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>0666</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|i:mkfifo"</expr></argument>, <argument><expr>&amp;<name>filename</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>mkfifo</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKNOD</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MAKEDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_mknod__doc__</name></expr></argument>,
<argument><expr>"mknod(filename [, mode=0600, device])\n\n\
Create a filesystem node (file, device special file or named pipe)\n\
named filename. mode specifies both the permissions to use and the\n\
type of node to be created, being combined (bitwise OR) with one of\n\
S_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO. For S_IFCHR and S_IFBLK,\n\
device defines the newly created device special file (probably using\n\
os.makedev()), otherwise it is ignored."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_mknod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>0600</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>device</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|ii:mknod"</expr></argument>, <argument><expr>&amp;<name>filename</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>device</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>mknod</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>device</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DEVICE_MACROS</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_major__doc__</name></expr></argument>,
<argument><expr>"major(device) -&gt; major number\n\
Extracts a device major number from a raw device number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_major</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>device</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:major"</expr></argument>, <argument><expr>&amp;<name>device</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>major</name><argument_list>(<argument><expr><name>device</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_minor__doc__</name></expr></argument>,
<argument><expr>"minor(device) -&gt; minor number\n\
Extracts a device minor number from a raw device number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_minor</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>device</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:minor"</expr></argument>, <argument><expr>&amp;<name>device</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>minor</name><argument_list>(<argument><expr><name>device</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_makedev__doc__</name></expr></argument>,
<argument><expr>"makedev(major, minor) -&gt; device number\n\
Composes a raw device number from the major and minor device numbers."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_makedev</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>major</name></decl>, <decl><type ref="prev"/><name>minor</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii:makedev"</expr></argument>, <argument><expr>&amp;<name>major</name></expr></argument>, <argument><expr>&amp;<name>minor</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>makedev</name><argument_list>(<argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* device macros */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FTRUNCATE</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_ftruncate__doc__</name></expr></argument>,
<argument><expr>"ftruncate(fd, length)\n\n\
Truncate a file to a specified length."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_ftruncate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type> <name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>lenobj</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iO:ftruncate"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>lenobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>length</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>length</name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call> ?
		<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call> : <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PUTENV</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_putenv__doc__</name></expr></argument>,
<argument><expr>"putenv(key, value)\n\n\
Change or add an environment variable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Save putenv() parameters as values here, so we can collect them when they
 * get re-set with another call for the same key. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>posix_putenv_garbage</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_putenv</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>s1</name></decl>, *<decl><type ref="prev"/><name>s2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>newenv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss:putenv"</expr></argument>, <argument><expr>&amp;<name>s1</name></expr></argument>, <argument><expr>&amp;<name>s2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr>"BEGINLIBPATH"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rc</name> = <call><name>DosSetExtLIBPATH</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>BEGIN_LIBPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then>
            <return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    }</block></then> <else>else <if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr>"ENDLIBPATH"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rc</name> = <call><name>DosSetExtLIBPATH</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>END_LIBPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then>
            <return>return <expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then> <else>else <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* XXX This can leak memory -- not easy to fix :-( */</comment>
	<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call> + 2</expr>;</expr_stmt>
	<comment type="block">/* len includes space for a trailing \0; the size arg to
	   PyString_FromStringAndSize does not count that */</comment>
	<expr_stmt><expr><name>newstr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>(<name>int</name>)<name>len</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newstr</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>newenv</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>newenv</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>putenv</name><argument_list>(<argument><expr><name>newenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* Install the first arg and newstr in posix_putenv_garbage;
	 * this will cause previous value to be collected.  This has to
	 * happen after the real putenv() call because the old value
	 * was still accessible until then. */</comment>
	<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>posix_putenv_garbage</name></expr></argument>,
			   <argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* really not much we can do; just leak */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
    }</block></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* putenv */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNSETENV</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_unsetenv__doc__</name></expr></argument>,
<argument><expr>"unsetenv(key)\n\n\
Delete an environment variable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_unsetenv</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>s1</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:unsetenv"</expr></argument>, <argument><expr>&amp;<name>s1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove the key from posix_putenv_garbage;
	 * this will cause it to be collected.  This has to
	 * happen after the real unsetenv() call because the
	 * old value was still accessible until then.
	 */</comment>
	<if>if <condition>(<expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>posix_putenv_garbage</name></expr></argument>,
		<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* really not much we can do; just leak */</comment>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* unsetenv */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_strerror__doc__</name></expr></argument>,
<argument><expr>"strerror(code) -&gt; string\n\n\
Translate an error code to a message string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_strerror</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>message</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:strerror"</expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>message</name> = <call><name>strerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>message</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"strerror() argument out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_WAIT_H</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WCOREDUMP</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WCOREDUMP__doc__</name></expr></argument>,
<argument><expr>"WCOREDUMP(status) -&gt; bool\n\n\
Return True if the process returning 'status' was dumped to a core file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WCOREDUMP</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WCOREDUMP"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WCOREDUMP</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WCOREDUMP */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIFCONTINUED</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WIFCONTINUED__doc__</name></expr></argument>,
<argument><expr>"WIFCONTINUED(status) -&gt; bool\n\n\
Return True if the process returning 'status' was continued from a\n\
job control stop."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WIFCONTINUED</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WCONTINUED"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WIFCONTINUED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIFCONTINUED */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIFSTOPPED</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WIFSTOPPED__doc__</name></expr></argument>,
<argument><expr>"WIFSTOPPED(status) -&gt; bool\n\n\
Return True if the process returning 'status' was stopped."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WIFSTOPPED</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WIFSTOPPED"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WIFSTOPPED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIFSTOPPED */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIFSIGNALED</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WIFSIGNALED__doc__</name></expr></argument>,
<argument><expr>"WIFSIGNALED(status) -&gt; bool\n\n\
Return True if the process returning 'status' was terminated by a signal."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WIFSIGNALED</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WIFSIGNALED"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIFSIGNALED */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIFEXITED</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WIFEXITED__doc__</name></expr></argument>,
<argument><expr>"WIFEXITED(status) -&gt; bool\n\n\
Return true if the process returning 'status' exited using the exit()\n\
system call."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WIFEXITED</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WIFEXITED"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIFEXITED */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WEXITSTATUS</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WEXITSTATUS__doc__</name></expr></argument>,
<argument><expr>"WEXITSTATUS(status) -&gt; integer\n\n\
Return the process return code from 'status'."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WEXITSTATUS</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WEXITSTATUS"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WEXITSTATUS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WTERMSIG</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WTERMSIG__doc__</name></expr></argument>,
<argument><expr>"WTERMSIG(status) -&gt; integer\n\n\
Return the signal that terminated the process that provided the 'status'\n\
value."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WTERMSIG</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WTERMSIG"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WTERMSIG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WSTOPSIG</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_WSTOPSIG__doc__</name></expr></argument>,
<argument><expr>"WSTOPSIG(status) -&gt; integer\n\n\
Return the signal that stopped the process that provided\n\
the 'status' value."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_WSTOPSIG</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WAIT_TYPE</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:WSTOPSIG"</expr></argument>, <argument><expr>&amp;<call><name>WAIT_STATUS_INT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><call><name>WSTOPSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WSTOPSIG */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_WAIT_H */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTATVFS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_STATVFS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SCO_DS</name></cpp:ifdef>
<comment type="block">/* SCO OpenServer 5.0 and later requires _SVID3 before it reveals the
   needed definitions in sys/statvfs.h */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SVID3</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/statvfs.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>_pystatvfs_fromstructstatvfs</name><parameter_list>(<param><decl><type>struct <name>statvfs</name></type> <name>st</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyStructSequence_New</name><argument_list>(<argument><expr>&amp;<name>StatVFSResultType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_bsize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_frsize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_blocks</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_bfree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_bavail</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_files</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>6</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_ffree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>7</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_favail</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_flag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>9</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_namemax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_bsize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_frsize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>2</expr></argument>,
			       <argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_blocks</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>3</expr></argument>,
			       <argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_bfree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>4</expr></argument>,
			       <argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_bavail</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>5</expr></argument>,
			       <argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_files</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>6</expr></argument>,
			       <argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_ffree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>7</expr></argument>,
			       <argument><expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>) <name><name>st</name>.<name>f_favail</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_flag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyStructSequence_SET_ITEM</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>9</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>st</name>.<name>f_namemax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fstatvfs__doc__</name></expr></argument>,
<argument><expr>"fstatvfs(fd) -&gt; statvfs result\n\n\
Perform an fstatvfs system call on the given fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fstatvfs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>statvfs</name></type> <name>st</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:fstatvfs"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>fstatvfs</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <return>return <expr><call><name>_pystatvfs_fromstructstatvfs</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FSTATVFS &amp;&amp; HAVE_SYS_STATVFS_H */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STATVFS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_STATVFS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/statvfs.h&gt;</cpp:file></cpp:include>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_statvfs__doc__</name></expr></argument>,
<argument><expr>"statvfs(path) -&gt; statvfs result\n\n\
Perform a statvfs system call on the given path."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_statvfs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>statvfs</name></type> <name>st</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:statvfs"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>statvfs</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
		<return>return <expr><call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

        <return>return <expr><call><name>_pystatvfs_fromstructstatvfs</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_STATVFS */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TEMPNAM</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tempnam__doc__</name></expr></argument>,
<argument><expr>"tempnam([dir[, prefix]]) -&gt; string\n\n\
Return a unique name for a temporary file.\n\
The directory and a prefix may be specified as strings; they may be omitted\n\
or None if not needed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tempnam</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>pfx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|zz:tempnam"</expr></argument>, <argument><expr>&amp;<name>dir</name></expr></argument>, <argument><expr>&amp;<name>pfx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
		  <argument><expr>"tempnam is a potential security risk to your program"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
    <expr_stmt><expr><name>name</name> = <call><name>_tempnam</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pfx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>name</name> = <call><name>tempnam</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pfx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TMPFILE</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tmpfile__doc__</name></expr></argument>,
<argument><expr>"tmpfile() -&gt; file object\n\n\
Create a temporary file with no directory entries."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tmpfile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fp</name> = <call><name>tmpfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
    <return>return <expr><call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"&lt;tmpfile&gt;"</expr></argument>, <argument><expr>"w+b"</expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TMPNAM</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_tmpnam__doc__</name></expr></argument>,
<argument><expr>"tmpnam() -&gt; string\n\n\
Return a unique name for a temporary file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_tmpnam</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>L_tmpnam</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
		  <argument><expr>"tmpnam is a potential security risk to your program"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TMPNAM_R</name></cpp:ifdef>
    <expr_stmt><expr><name>name</name> = <call><name>tmpnam_r</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>name</name> = <call><name>tmpnam</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>err</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"is"</expr></argument>, <argument><expr>0</expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TMPNAM_R</name></cpp:ifdef>
                                      <argument><expr>"unexpected NULL from tmpnam_r"
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                      "unexpected NULL from tmpnam"</expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                      )</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* This is used for fpathconf(), pathconf(), confstr() and sysconf().
 * It maps strings representing configuration variable names to
 * integer values, allowing those functions to be called with the
 * magic names instead of polluting the module's namespace with tons of
 * rarely-used constants.  There are three separate tables that use
 * these definitions.
 *
 * This code is always included, even if none of the interfaces that
 * need it are included.  The #if hackery needed to avoid it would be
 * sufficiently pervasive that it's not worth the loss of readability.
 */</comment>
<struct>struct <name>constdef</name> <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>value</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>conv_confname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>valuep</name></decl></param>, <param><decl><type>struct <name>constdef</name> *</type><name>table</name></decl></param>,
	      <param><decl><type><name>size_t</name></type> <name>tablesize</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>valuep</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* look up the value in the table using a binary search */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>lo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>mid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>hi</name> <init>= <expr><name>tablesize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>confname</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>lo</name> &lt; <name>hi</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>mid</name> = (<name>lo</name> + <name>hi</name>) / 2</expr>;</expr_stmt>
            <expr_stmt><expr><name>cmp</name> = <call><name>strcmp</name><argument_list>(<argument><expr><name>confname</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>mid</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then>
                <expr_stmt><expr><name>hi</name> = <name>mid</name></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
                <expr_stmt><expr><name>lo</name> = <name>mid</name> + 1</expr>;</expr_stmt></then>
            <else>else <block>{
                <expr_stmt><expr>*<name>valuep</name> = <name><name>table</name><index>[<expr><name>mid</name></expr>]</index></name>.<name>value</name></expr>;</expr_stmt>
                <return>return <expr>1</expr>;</return>
            }</block></else></if></else></if>
        }</block></while>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"unrecognized configuration name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                        <argument><expr>"configuration names must be strings or integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <return>return <expr>0</expr>;</return>
}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FPATHCONF</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PATHCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>constdef</name></type>  <name><name>posix_constants_pathconf</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_ABI_AIO_XFER_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"PC_ABI_AIO_XFER_MAX"</expr>,	<expr><name>_PC_ABI_AIO_XFER_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_ABI_ASYNC_IO</name></cpp:ifdef>
    <expr><block>{<expr>"PC_ABI_ASYNC_IO"</expr>,	<expr><name>_PC_ABI_ASYNC_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_ASYNC_IO</name></cpp:ifdef>
    <expr><block>{<expr>"PC_ASYNC_IO"</expr>,	<expr><name>_PC_ASYNC_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_CHOWN_RESTRICTED</name></cpp:ifdef>
    <expr><block>{<expr>"PC_CHOWN_RESTRICTED"</expr>,	<expr><name>_PC_CHOWN_RESTRICTED</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_FILESIZEBITS</name></cpp:ifdef>
    <expr><block>{<expr>"PC_FILESIZEBITS"</expr>,	<expr><name>_PC_FILESIZEBITS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_LAST</name></cpp:ifdef>
    <expr><block>{<expr>"PC_LAST"</expr>,	<expr><name>_PC_LAST</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_LINK_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"PC_LINK_MAX"</expr>,	<expr><name>_PC_LINK_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_MAX_CANON</name></cpp:ifdef>
    <expr><block>{<expr>"PC_MAX_CANON"</expr>,	<expr><name>_PC_MAX_CANON</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_MAX_INPUT</name></cpp:ifdef>
    <expr><block>{<expr>"PC_MAX_INPUT"</expr>,	<expr><name>_PC_MAX_INPUT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_NAME_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"PC_NAME_MAX"</expr>,	<expr><name>_PC_NAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_NO_TRUNC</name></cpp:ifdef>
    <expr><block>{<expr>"PC_NO_TRUNC"</expr>,	<expr><name>_PC_NO_TRUNC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_PATH_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"PC_PATH_MAX"</expr>,	<expr><name>_PC_PATH_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_PIPE_BUF</name></cpp:ifdef>
    <expr><block>{<expr>"PC_PIPE_BUF"</expr>,	<expr><name>_PC_PIPE_BUF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_PRIO_IO</name></cpp:ifdef>
    <expr><block>{<expr>"PC_PRIO_IO"</expr>,	<expr><name>_PC_PRIO_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_SOCK_MAXBUF</name></cpp:ifdef>
    <expr><block>{<expr>"PC_SOCK_MAXBUF"</expr>,	<expr><name>_PC_SOCK_MAXBUF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_SYNC_IO</name></cpp:ifdef>
    <expr><block>{<expr>"PC_SYNC_IO"</expr>,	<expr><name>_PC_SYNC_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PC_VDISABLE</name></cpp:ifdef>
    <expr><block>{<expr>"PC_VDISABLE"</expr>,	<expr><name>_PC_VDISABLE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>conv_path_confname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>valuep</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>conv_confname</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>valuep</name></expr></argument>, <argument><expr><name>posix_constants_pathconf</name></expr></argument>,
                         <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_pathconf</name></expr></argument>)</argument_list></sizeof>
                           / <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FPATHCONF</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_fpathconf__doc__</name></expr></argument>,
<argument><expr>"fpathconf(fd, name) -&gt; integer\n\n\
Return the configuration limit name for the file descriptor fd.\n\
If there is no limit, return -1."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_fpathconf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>, <decl><type ref="prev"/><name>fd</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iO&amp;:fpathconf"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>,
                         <argument><expr><name>conv_path_confname</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>limit</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>limit</name> = <call><name>fpathconf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>limit</name> == -1 &amp;&amp; <name>errno</name> != 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>result</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PATHCONF</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_pathconf__doc__</name></expr></argument>,
<argument><expr>"pathconf(path, name) -&gt; integer\n\n\
Return the configuration limit name for the file or directory path.\n\
If there is no limit, return -1."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_pathconf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"sO&amp;:pathconf"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>,
                         <argument><expr><name>conv_path_confname</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>limit</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>limit</name> = <call><name>pathconf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>limit</name> == -1 &amp;&amp; <name>errno</name> != 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>errno</name> == <name>EINVAL</name></expr>)</condition><then>
                <comment type="block">/* could be a path or name problem */</comment>
                <expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name>posix_error_with_filename</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><name>result</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFSTR</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>constdef</name></type> <name><name>posix_constants_confstr</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_ARCHITECTURE</name></cpp:ifdef>
    <expr><block>{<expr>"CS_ARCHITECTURE"</expr>,	<expr><name>_CS_ARCHITECTURE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_HOSTNAME</name></cpp:ifdef>
    <expr><block>{<expr>"CS_HOSTNAME"</expr>,	<expr><name>_CS_HOSTNAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_HW_PROVIDER</name></cpp:ifdef>
    <expr><block>{<expr>"CS_HW_PROVIDER"</expr>,	<expr><name>_CS_HW_PROVIDER</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_HW_SERIAL</name></cpp:ifdef>
    <expr><block>{<expr>"CS_HW_SERIAL"</expr>,	<expr><name>_CS_HW_SERIAL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_INITTAB_NAME</name></cpp:ifdef>
    <expr><block>{<expr>"CS_INITTAB_NAME"</expr>,	<expr><name>_CS_INITTAB_NAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_LFS64_CFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_LFS64_CFLAGS"</expr>,	<expr><name>_CS_LFS64_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_LFS64_LDFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_LFS64_LDFLAGS"</expr>,	<expr><name>_CS_LFS64_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_LFS64_LIBS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_LFS64_LIBS"</expr>,	<expr><name>_CS_LFS64_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_LFS64_LINTFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_LFS64_LINTFLAGS"</expr>,	<expr><name>_CS_LFS64_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_LFS_CFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_LFS_CFLAGS"</expr>,	<expr><name>_CS_LFS_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_LFS_LDFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_LFS_LDFLAGS"</expr>,	<expr><name>_CS_LFS_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_LFS_LIBS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_LFS_LIBS"</expr>,	<expr><name>_CS_LFS_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_LFS_LINTFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_LFS_LINTFLAGS"</expr>,	<expr><name>_CS_LFS_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_MACHINE</name></cpp:ifdef>
    <expr><block>{<expr>"CS_MACHINE"</expr>,	<expr><name>_CS_MACHINE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_PATH</name></cpp:ifdef>
    <expr><block>{<expr>"CS_PATH"</expr>,	<expr><name>_CS_PATH</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_RELEASE</name></cpp:ifdef>
    <expr><block>{<expr>"CS_RELEASE"</expr>,	<expr><name>_CS_RELEASE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_SRPC_DOMAIN</name></cpp:ifdef>
    <expr><block>{<expr>"CS_SRPC_DOMAIN"</expr>,	<expr><name>_CS_SRPC_DOMAIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_SYSNAME</name></cpp:ifdef>
    <expr><block>{<expr>"CS_SYSNAME"</expr>,	<expr><name>_CS_SYSNAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_VERSION</name></cpp:ifdef>
    <expr><block>{<expr>"CS_VERSION"</expr>,	<expr><name>_CS_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_ILP32_OFF32_CFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_ILP32_OFF32_CFLAGS"</expr>,	<expr><name>_CS_XBS5_ILP32_OFF32_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_ILP32_OFF32_LDFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_ILP32_OFF32_LDFLAGS"</expr>,	<expr><name>_CS_XBS5_ILP32_OFF32_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_ILP32_OFF32_LIBS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_ILP32_OFF32_LIBS"</expr>,	<expr><name>_CS_XBS5_ILP32_OFF32_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_ILP32_OFF32_LINTFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_ILP32_OFF32_LINTFLAGS"</expr>,	<expr><name>_CS_XBS5_ILP32_OFF32_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_ILP32_OFFBIG_CFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_ILP32_OFFBIG_CFLAGS"</expr>,	<expr><name>_CS_XBS5_ILP32_OFFBIG_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_ILP32_OFFBIG_LDFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_ILP32_OFFBIG_LDFLAGS"</expr>,	<expr><name>_CS_XBS5_ILP32_OFFBIG_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_ILP32_OFFBIG_LIBS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_ILP32_OFFBIG_LIBS"</expr>,	<expr><name>_CS_XBS5_ILP32_OFFBIG_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_ILP32_OFFBIG_LINTFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_ILP32_OFFBIG_LINTFLAGS"</expr>,	<expr><name>_CS_XBS5_ILP32_OFFBIG_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_LP64_OFF64_CFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_LP64_OFF64_CFLAGS"</expr>,	<expr><name>_CS_XBS5_LP64_OFF64_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_LP64_OFF64_LDFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_LP64_OFF64_LDFLAGS"</expr>,	<expr><name>_CS_XBS5_LP64_OFF64_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_LP64_OFF64_LIBS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_LP64_OFF64_LIBS"</expr>,	<expr><name>_CS_XBS5_LP64_OFF64_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_LP64_OFF64_LINTFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_LP64_OFF64_LINTFLAGS"</expr>,	<expr><name>_CS_XBS5_LP64_OFF64_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_LPBIG_OFFBIG_CFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_LPBIG_OFFBIG_CFLAGS"</expr>,	<expr><name>_CS_XBS5_LPBIG_OFFBIG_CFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_LPBIG_OFFBIG_LDFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_LPBIG_OFFBIG_LDFLAGS"</expr>,	<expr><name>_CS_XBS5_LPBIG_OFFBIG_LDFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_LPBIG_OFFBIG_LIBS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_LPBIG_OFFBIG_LIBS"</expr>,	<expr><name>_CS_XBS5_LPBIG_OFFBIG_LIBS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS</name></cpp:ifdef>
    <expr><block>{<expr>"CS_XBS5_LPBIG_OFFBIG_LINTFLAGS"</expr>,	<expr><name>_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_AVAIL_PROCESSORS</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_AVAIL_PROCESSORS"</expr>,	<expr><name>_MIPS_CS_AVAIL_PROCESSORS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_BASE</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_BASE"</expr>,	<expr><name>_MIPS_CS_BASE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_HOSTID</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_HOSTID"</expr>,	<expr><name>_MIPS_CS_HOSTID</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_HW_NAME</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_HW_NAME"</expr>,	<expr><name>_MIPS_CS_HW_NAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_NUM_PROCESSORS</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_NUM_PROCESSORS"</expr>,	<expr><name>_MIPS_CS_NUM_PROCESSORS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_OSREL_MAJ</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_OSREL_MAJ"</expr>,	<expr><name>_MIPS_CS_OSREL_MAJ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_OSREL_MIN</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_OSREL_MIN"</expr>,	<expr><name>_MIPS_CS_OSREL_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_OSREL_PATCH</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_OSREL_PATCH"</expr>,	<expr><name>_MIPS_CS_OSREL_PATCH</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_OS_NAME</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_OS_NAME"</expr>,	<expr><name>_MIPS_CS_OS_NAME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_OS_PROVIDER</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_OS_PROVIDER"</expr>,	<expr><name>_MIPS_CS_OS_PROVIDER</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_PROCESSORS</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_PROCESSORS"</expr>,	<expr><name>_MIPS_CS_PROCESSORS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_SERIAL</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_SERIAL"</expr>,	<expr><name>_MIPS_CS_SERIAL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIPS_CS_VENDOR</name></cpp:ifdef>
    <expr><block>{<expr>"MIPS_CS_VENDOR"</expr>,	<expr><name>_MIPS_CS_VENDOR</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>conv_confstr_confname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>valuep</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>conv_confname</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>valuep</name></expr></argument>, <argument><expr><name>posix_constants_confstr</name></expr></argument>,
                         <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_confstr</name></expr></argument>)</argument_list></sizeof>
                           / <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_confstr__doc__</name></expr></argument>,
<argument><expr>"confstr(name) -&gt; string\n\n\
Return a string-valued system configuration variable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_confstr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;:confstr"</expr></argument>, <argument><expr><name>conv_confstr_confname</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> = <call><name>confstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>errno</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    }</block></then>
	    <else>else <block>{
		<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
        }</block></then>
        <else>else <block>{
	    <if>if <condition>(<expr>(<name>unsigned</name> <name>int</name>)<name>len</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>confstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then>
            <else>else
                <expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></else></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSCONF</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>constdef</name></type> <name><name>posix_constants_sysconf</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_CHAR_TERM</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_CHAR_TERM"</expr>,	<expr><name>_SC_2_CHAR_TERM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_C_BIND</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_C_BIND"</expr>,	<expr><name>_SC_2_C_BIND</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_C_DEV</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_C_DEV"</expr>,	<expr><name>_SC_2_C_DEV</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_C_VERSION</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_C_VERSION"</expr>,	<expr><name>_SC_2_C_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_FORT_DEV</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_FORT_DEV"</expr>,	<expr><name>_SC_2_FORT_DEV</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_FORT_RUN</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_FORT_RUN"</expr>,	<expr><name>_SC_2_FORT_RUN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_LOCALEDEF</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_LOCALEDEF"</expr>,	<expr><name>_SC_2_LOCALEDEF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_SW_DEV</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_SW_DEV"</expr>,	<expr><name>_SC_2_SW_DEV</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_UPE</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_UPE"</expr>,	<expr><name>_SC_2_UPE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_2_VERSION</name></cpp:ifdef>
    <expr><block>{<expr>"SC_2_VERSION"</expr>,	<expr><name>_SC_2_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ABI_ASYNCHRONOUS_IO</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ABI_ASYNCHRONOUS_IO"</expr>,	<expr><name>_SC_ABI_ASYNCHRONOUS_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ACL</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ACL"</expr>,	<expr><name>_SC_ACL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_AIO_LISTIO_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_AIO_LISTIO_MAX"</expr>,	<expr><name>_SC_AIO_LISTIO_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_AIO_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_AIO_MAX"</expr>,	<expr><name>_SC_AIO_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_AIO_PRIO_DELTA_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_AIO_PRIO_DELTA_MAX"</expr>,	<expr><name>_SC_AIO_PRIO_DELTA_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ARG_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ARG_MAX"</expr>,	<expr><name>_SC_ARG_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ASYNCHRONOUS_IO</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ASYNCHRONOUS_IO"</expr>,	<expr><name>_SC_ASYNCHRONOUS_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ATEXIT_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ATEXIT_MAX"</expr>,	<expr><name>_SC_ATEXIT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_AUDIT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_AUDIT"</expr>,	<expr><name>_SC_AUDIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_AVPHYS_PAGES</name></cpp:ifdef>
    <expr><block>{<expr>"SC_AVPHYS_PAGES"</expr>,	<expr><name>_SC_AVPHYS_PAGES</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_BC_BASE_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_BC_BASE_MAX"</expr>,	<expr><name>_SC_BC_BASE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_BC_DIM_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_BC_DIM_MAX"</expr>,	<expr><name>_SC_BC_DIM_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_BC_SCALE_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_BC_SCALE_MAX"</expr>,	<expr><name>_SC_BC_SCALE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_BC_STRING_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_BC_STRING_MAX"</expr>,	<expr><name>_SC_BC_STRING_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_CAP</name></cpp:ifdef>
    <expr><block>{<expr>"SC_CAP"</expr>,	<expr><name>_SC_CAP</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_CHARCLASS_NAME_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_CHARCLASS_NAME_MAX"</expr>,	<expr><name>_SC_CHARCLASS_NAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_CHAR_BIT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_CHAR_BIT"</expr>,	<expr><name>_SC_CHAR_BIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_CHAR_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_CHAR_MAX"</expr>,	<expr><name>_SC_CHAR_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_CHAR_MIN</name></cpp:ifdef>
    <expr><block>{<expr>"SC_CHAR_MIN"</expr>,	<expr><name>_SC_CHAR_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_CHILD_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_CHILD_MAX"</expr>,	<expr><name>_SC_CHILD_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_CLK_TCK</name></cpp:ifdef>
    <expr><block>{<expr>"SC_CLK_TCK"</expr>,	<expr><name>_SC_CLK_TCK</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_COHER_BLKSZ</name></cpp:ifdef>
    <expr><block>{<expr>"SC_COHER_BLKSZ"</expr>,	<expr><name>_SC_COHER_BLKSZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_COLL_WEIGHTS_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_COLL_WEIGHTS_MAX"</expr>,	<expr><name>_SC_COLL_WEIGHTS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_DCACHE_ASSOC</name></cpp:ifdef>
    <expr><block>{<expr>"SC_DCACHE_ASSOC"</expr>,	<expr><name>_SC_DCACHE_ASSOC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_DCACHE_BLKSZ</name></cpp:ifdef>
    <expr><block>{<expr>"SC_DCACHE_BLKSZ"</expr>,	<expr><name>_SC_DCACHE_BLKSZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_DCACHE_LINESZ</name></cpp:ifdef>
    <expr><block>{<expr>"SC_DCACHE_LINESZ"</expr>,	<expr><name>_SC_DCACHE_LINESZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_DCACHE_SZ</name></cpp:ifdef>
    <expr><block>{<expr>"SC_DCACHE_SZ"</expr>,	<expr><name>_SC_DCACHE_SZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_DCACHE_TBLKSZ</name></cpp:ifdef>
    <expr><block>{<expr>"SC_DCACHE_TBLKSZ"</expr>,	<expr><name>_SC_DCACHE_TBLKSZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_DELAYTIMER_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_DELAYTIMER_MAX"</expr>,	<expr><name>_SC_DELAYTIMER_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_EQUIV_CLASS_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_EQUIV_CLASS_MAX"</expr>,	<expr><name>_SC_EQUIV_CLASS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_EXPR_NEST_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_EXPR_NEST_MAX"</expr>,	<expr><name>_SC_EXPR_NEST_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_FSYNC</name></cpp:ifdef>
    <expr><block>{<expr>"SC_FSYNC"</expr>,	<expr><name>_SC_FSYNC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_GETGR_R_SIZE_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_GETGR_R_SIZE_MAX"</expr>,	<expr><name>_SC_GETGR_R_SIZE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_GETPW_R_SIZE_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_GETPW_R_SIZE_MAX"</expr>,	<expr><name>_SC_GETPW_R_SIZE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ICACHE_ASSOC</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ICACHE_ASSOC"</expr>,	<expr><name>_SC_ICACHE_ASSOC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ICACHE_BLKSZ</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ICACHE_BLKSZ"</expr>,	<expr><name>_SC_ICACHE_BLKSZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ICACHE_LINESZ</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ICACHE_LINESZ"</expr>,	<expr><name>_SC_ICACHE_LINESZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ICACHE_SZ</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ICACHE_SZ"</expr>,	<expr><name>_SC_ICACHE_SZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_INF</name></cpp:ifdef>
    <expr><block>{<expr>"SC_INF"</expr>,	<expr><name>_SC_INF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_INT_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_INT_MAX"</expr>,	<expr><name>_SC_INT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_INT_MIN</name></cpp:ifdef>
    <expr><block>{<expr>"SC_INT_MIN"</expr>,	<expr><name>_SC_INT_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_IOV_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_IOV_MAX"</expr>,	<expr><name>_SC_IOV_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_IP_SECOPTS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_IP_SECOPTS"</expr>,	<expr><name>_SC_IP_SECOPTS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_JOB_CONTROL</name></cpp:ifdef>
    <expr><block>{<expr>"SC_JOB_CONTROL"</expr>,	<expr><name>_SC_JOB_CONTROL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_KERN_POINTERS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_KERN_POINTERS"</expr>,	<expr><name>_SC_KERN_POINTERS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_KERN_SIM</name></cpp:ifdef>
    <expr><block>{<expr>"SC_KERN_SIM"</expr>,	<expr><name>_SC_KERN_SIM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_LINE_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_LINE_MAX"</expr>,	<expr><name>_SC_LINE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_LOGIN_NAME_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_LOGIN_NAME_MAX"</expr>,	<expr><name>_SC_LOGIN_NAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_LOGNAME_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_LOGNAME_MAX"</expr>,	<expr><name>_SC_LOGNAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_LONG_BIT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_LONG_BIT"</expr>,	<expr><name>_SC_LONG_BIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MAC</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MAC"</expr>,	<expr><name>_SC_MAC</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MAPPED_FILES</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MAPPED_FILES"</expr>,	<expr><name>_SC_MAPPED_FILES</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MAXPID</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MAXPID"</expr>,	<expr><name>_SC_MAXPID</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MB_LEN_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MB_LEN_MAX"</expr>,	<expr><name>_SC_MB_LEN_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MEMLOCK</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MEMLOCK"</expr>,	<expr><name>_SC_MEMLOCK</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MEMLOCK_RANGE</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MEMLOCK_RANGE"</expr>,	<expr><name>_SC_MEMLOCK_RANGE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MEMORY_PROTECTION</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MEMORY_PROTECTION"</expr>,	<expr><name>_SC_MEMORY_PROTECTION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MESSAGE_PASSING</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MESSAGE_PASSING"</expr>,	<expr><name>_SC_MESSAGE_PASSING</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MMAP_FIXED_ALIGNMENT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MMAP_FIXED_ALIGNMENT"</expr>,	<expr><name>_SC_MMAP_FIXED_ALIGNMENT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MQ_OPEN_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MQ_OPEN_MAX"</expr>,	<expr><name>_SC_MQ_OPEN_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_MQ_PRIO_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_MQ_PRIO_MAX"</expr>,	<expr><name>_SC_MQ_PRIO_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NACLS_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NACLS_MAX"</expr>,	<expr><name>_SC_NACLS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NGROUPS_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NGROUPS_MAX"</expr>,	<expr><name>_SC_NGROUPS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NL_ARGMAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NL_ARGMAX"</expr>,	<expr><name>_SC_NL_ARGMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NL_LANGMAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NL_LANGMAX"</expr>,	<expr><name>_SC_NL_LANGMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NL_MSGMAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NL_MSGMAX"</expr>,	<expr><name>_SC_NL_MSGMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NL_NMAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NL_NMAX"</expr>,	<expr><name>_SC_NL_NMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NL_SETMAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NL_SETMAX"</expr>,	<expr><name>_SC_NL_SETMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NL_TEXTMAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NL_TEXTMAX"</expr>,	<expr><name>_SC_NL_TEXTMAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NPROCESSORS_CONF</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NPROCESSORS_CONF"</expr>,	<expr><name>_SC_NPROCESSORS_CONF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NPROCESSORS_ONLN</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NPROCESSORS_ONLN"</expr>,	<expr><name>_SC_NPROCESSORS_ONLN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NPROC_CONF</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NPROC_CONF"</expr>,	<expr><name>_SC_NPROC_CONF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NPROC_ONLN</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NPROC_ONLN"</expr>,	<expr><name>_SC_NPROC_ONLN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_NZERO</name></cpp:ifdef>
    <expr><block>{<expr>"SC_NZERO"</expr>,	<expr><name>_SC_NZERO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_OPEN_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_OPEN_MAX"</expr>,	<expr><name>_SC_OPEN_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PAGESIZE</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PAGESIZE"</expr>,	<expr><name>_SC_PAGESIZE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PAGE_SIZE</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PAGE_SIZE"</expr>,	<expr><name>_SC_PAGE_SIZE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PASS_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PASS_MAX"</expr>,	<expr><name>_SC_PASS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PHYS_PAGES</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PHYS_PAGES"</expr>,	<expr><name>_SC_PHYS_PAGES</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII"</expr>,	<expr><name>_SC_PII</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII_INTERNET</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII_INTERNET"</expr>,	<expr><name>_SC_PII_INTERNET</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII_INTERNET_DGRAM</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII_INTERNET_DGRAM"</expr>,	<expr><name>_SC_PII_INTERNET_DGRAM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII_INTERNET_STREAM</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII_INTERNET_STREAM"</expr>,	<expr><name>_SC_PII_INTERNET_STREAM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII_OSI</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII_OSI"</expr>,	<expr><name>_SC_PII_OSI</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII_OSI_CLTS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII_OSI_CLTS"</expr>,	<expr><name>_SC_PII_OSI_CLTS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII_OSI_COTS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII_OSI_COTS"</expr>,	<expr><name>_SC_PII_OSI_COTS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII_OSI_M</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII_OSI_M"</expr>,	<expr><name>_SC_PII_OSI_M</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII_SOCKET</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII_SOCKET"</expr>,	<expr><name>_SC_PII_SOCKET</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PII_XTI</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PII_XTI"</expr>,	<expr><name>_SC_PII_XTI</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_POLL</name></cpp:ifdef>
    <expr><block>{<expr>"SC_POLL"</expr>,	<expr><name>_SC_POLL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PRIORITIZED_IO</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PRIORITIZED_IO"</expr>,	<expr><name>_SC_PRIORITIZED_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_PRIORITY_SCHEDULING</name></cpp:ifdef>
    <expr><block>{<expr>"SC_PRIORITY_SCHEDULING"</expr>,	<expr><name>_SC_PRIORITY_SCHEDULING</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_REALTIME_SIGNALS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_REALTIME_SIGNALS"</expr>,	<expr><name>_SC_REALTIME_SIGNALS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_RE_DUP_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_RE_DUP_MAX"</expr>,	<expr><name>_SC_RE_DUP_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_RTSIG_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_RTSIG_MAX"</expr>,	<expr><name>_SC_RTSIG_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SAVED_IDS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SAVED_IDS"</expr>,	<expr><name>_SC_SAVED_IDS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SCHAR_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SCHAR_MAX"</expr>,	<expr><name>_SC_SCHAR_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SCHAR_MIN</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SCHAR_MIN"</expr>,	<expr><name>_SC_SCHAR_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SELECT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SELECT"</expr>,	<expr><name>_SC_SELECT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SEMAPHORES</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SEMAPHORES"</expr>,	<expr><name>_SC_SEMAPHORES</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SEM_NSEMS_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SEM_NSEMS_MAX"</expr>,	<expr><name>_SC_SEM_NSEMS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SEM_VALUE_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SEM_VALUE_MAX"</expr>,	<expr><name>_SC_SEM_VALUE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SHARED_MEMORY_OBJECTS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SHARED_MEMORY_OBJECTS"</expr>,	<expr><name>_SC_SHARED_MEMORY_OBJECTS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SHRT_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SHRT_MAX"</expr>,	<expr><name>_SC_SHRT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SHRT_MIN</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SHRT_MIN"</expr>,	<expr><name>_SC_SHRT_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SIGQUEUE_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SIGQUEUE_MAX"</expr>,	<expr><name>_SC_SIGQUEUE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SIGRT_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SIGRT_MAX"</expr>,	<expr><name>_SC_SIGRT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SIGRT_MIN</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SIGRT_MIN"</expr>,	<expr><name>_SC_SIGRT_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SOFTPOWER</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SOFTPOWER"</expr>,	<expr><name>_SC_SOFTPOWER</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SPLIT_CACHE</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SPLIT_CACHE"</expr>,	<expr><name>_SC_SPLIT_CACHE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SSIZE_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SSIZE_MAX"</expr>,	<expr><name>_SC_SSIZE_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_STACK_PROT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_STACK_PROT"</expr>,	<expr><name>_SC_STACK_PROT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_STREAM_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_STREAM_MAX"</expr>,	<expr><name>_SC_STREAM_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_SYNCHRONIZED_IO</name></cpp:ifdef>
    <expr><block>{<expr>"SC_SYNCHRONIZED_IO"</expr>,	<expr><name>_SC_SYNCHRONIZED_IO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREADS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREADS"</expr>,	<expr><name>_SC_THREADS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_ATTR_STACKADDR</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_ATTR_STACKADDR"</expr>,	<expr><name>_SC_THREAD_ATTR_STACKADDR</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_ATTR_STACKSIZE</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_ATTR_STACKSIZE"</expr>,	<expr><name>_SC_THREAD_ATTR_STACKSIZE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_DESTRUCTOR_ITERATIONS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_DESTRUCTOR_ITERATIONS"</expr>,	<expr><name>_SC_THREAD_DESTRUCTOR_ITERATIONS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_KEYS_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_KEYS_MAX"</expr>,	<expr><name>_SC_THREAD_KEYS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_PRIORITY_SCHEDULING</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_PRIORITY_SCHEDULING"</expr>,	<expr><name>_SC_THREAD_PRIORITY_SCHEDULING</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_PRIO_INHERIT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_PRIO_INHERIT"</expr>,	<expr><name>_SC_THREAD_PRIO_INHERIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_PRIO_PROTECT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_PRIO_PROTECT"</expr>,	<expr><name>_SC_THREAD_PRIO_PROTECT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_PROCESS_SHARED</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_PROCESS_SHARED"</expr>,	<expr><name>_SC_THREAD_PROCESS_SHARED</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_SAFE_FUNCTIONS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_SAFE_FUNCTIONS"</expr>,	<expr><name>_SC_THREAD_SAFE_FUNCTIONS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_STACK_MIN</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_STACK_MIN"</expr>,	<expr><name>_SC_THREAD_STACK_MIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_THREAD_THREADS_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_THREAD_THREADS_MAX"</expr>,	<expr><name>_SC_THREAD_THREADS_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_TIMERS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_TIMERS"</expr>,	<expr><name>_SC_TIMERS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_TIMER_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_TIMER_MAX"</expr>,	<expr><name>_SC_TIMER_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_TTY_NAME_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_TTY_NAME_MAX"</expr>,	<expr><name>_SC_TTY_NAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_TZNAME_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_TZNAME_MAX"</expr>,	<expr><name>_SC_TZNAME_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_T_IOV_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_T_IOV_MAX"</expr>,	<expr><name>_SC_T_IOV_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_UCHAR_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_UCHAR_MAX"</expr>,	<expr><name>_SC_UCHAR_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_UINT_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_UINT_MAX"</expr>,	<expr><name>_SC_UINT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_UIO_MAXIOV</name></cpp:ifdef>
    <expr><block>{<expr>"SC_UIO_MAXIOV"</expr>,	<expr><name>_SC_UIO_MAXIOV</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_ULONG_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_ULONG_MAX"</expr>,	<expr><name>_SC_ULONG_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_USHRT_MAX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_USHRT_MAX"</expr>,	<expr><name>_SC_USHRT_MAX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_VERSION</name></cpp:ifdef>
    <expr><block>{<expr>"SC_VERSION"</expr>,	<expr><name>_SC_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_WORD_BIT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_WORD_BIT"</expr>,	<expr><name>_SC_WORD_BIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XBS5_ILP32_OFF32</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XBS5_ILP32_OFF32"</expr>,	<expr><name>_SC_XBS5_ILP32_OFF32</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XBS5_ILP32_OFFBIG</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XBS5_ILP32_OFFBIG"</expr>,	<expr><name>_SC_XBS5_ILP32_OFFBIG</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XBS5_LP64_OFF64</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XBS5_LP64_OFF64"</expr>,	<expr><name>_SC_XBS5_LP64_OFF64</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XBS5_LPBIG_OFFBIG</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XBS5_LPBIG_OFFBIG"</expr>,	<expr><name>_SC_XBS5_LPBIG_OFFBIG</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_CRYPT</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_CRYPT"</expr>,	<expr><name>_SC_XOPEN_CRYPT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_ENH_I18N</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_ENH_I18N"</expr>,	<expr><name>_SC_XOPEN_ENH_I18N</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_LEGACY</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_LEGACY"</expr>,	<expr><name>_SC_XOPEN_LEGACY</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_REALTIME</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_REALTIME"</expr>,	<expr><name>_SC_XOPEN_REALTIME</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_REALTIME_THREADS</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_REALTIME_THREADS"</expr>,	<expr><name>_SC_XOPEN_REALTIME_THREADS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_SHM</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_SHM"</expr>,	<expr><name>_SC_XOPEN_SHM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_UNIX</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_UNIX"</expr>,	<expr><name>_SC_XOPEN_UNIX</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_VERSION</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_VERSION"</expr>,	<expr><name>_SC_XOPEN_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_XCU_VERSION</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_XCU_VERSION"</expr>,	<expr><name>_SC_XOPEN_XCU_VERSION</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_XPG2</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_XPG2"</expr>,	<expr><name>_SC_XOPEN_XPG2</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_XPG3</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_XPG3"</expr>,	<expr><name>_SC_XOPEN_XPG3</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SC_XOPEN_XPG4</name></cpp:ifdef>
    <expr><block>{<expr>"SC_XOPEN_XPG4"</expr>,	<expr><name>_SC_XOPEN_XPG4</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>conv_sysconf_confname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>valuep</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>conv_confname</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>valuep</name></expr></argument>, <argument><expr><name>posix_constants_sysconf</name></expr></argument>,
                         <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_sysconf</name></expr></argument>)</argument_list></sizeof>
                           / <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_sysconf__doc__</name></expr></argument>,
<argument><expr>"sysconf(name) -&gt; integer\n\n\
Return an integer-valued system configuration variable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_sysconf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;:sysconf"</expr></argument>, <argument><expr><name>conv_sysconf_confname</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> = <call><name>sysconf</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>value</name> == -1 &amp;&amp; <name>errno</name> != 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>posix_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>result</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* This code is used to ensure that the tables of configuration value names
 * are in sorted order as required by conv_confname(), and also to build the
 * the exported dictionaries that are used to publish information about the
 * names available on the host platform.
 *
 * Sorting the table at runtime ensures that the table is properly ordered
 * when used, even for platforms we're not able to test on.  It also makes
 * it easier to add additional entries to the tables.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_constdefs</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>v1</name></decl></param>,  <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>v2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> struct <name>constdef</name> *</type><name>c1</name> <init>=
        <expr>(const struct <name>constdef</name> *) <name>v1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> struct <name>constdef</name> *</type><name>c2</name> <init>=
        <expr>(const struct <name>constdef</name> *) <name>v2</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c1</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>c2</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setup_confname_table</name><parameter_list>(<param><decl><type>struct <name>constdef</name> *</type><name>table</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>tablesize</name></decl></param>,
		     <param><decl><type><name>char</name> *</type><name>tablename</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>tablesize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_constdefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
	    <return>return <expr>-1</expr>;</return></then></if>

    <for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>tablesize</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>o</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return <expr>-1</expr>;</return>
            }</block></then></if>
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Return -1 on failure, 0 on success. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setup_confname_tables</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FPATHCONF</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PATHCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if>if <condition>(<expr><call><name>setup_confname_table</name><argument_list>(<argument><expr><name>posix_constants_pathconf</name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_pathconf</name></expr></argument>)</argument_list></sizeof>
                               / <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                             <argument><expr>"pathconf_names"</expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFSTR</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>setup_confname_table</name><argument_list>(<argument><expr><name>posix_constants_confstr</name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_confstr</name></expr></argument>)</argument_list></sizeof>
                               / <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                             <argument><expr>"confstr_names"</expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSCONF</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>setup_confname_table</name><argument_list>(<argument><expr><name>posix_constants_sysconf</name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>posix_constants_sysconf</name></expr></argument>)</argument_list></sizeof>
                               / <sizeof>sizeof<argument_list>(<argument>struct <expr><name>constdef</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                             <argument><expr>"sysconf_names"</expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>0</expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_abort__doc__</name></expr></argument>,
<argument><expr>"abort() -&gt; does not return!\n\n\
Abort the interpreter immediately.  This 'dumps core' or otherwise fails\n\
in the hardest way possible on the hosting operating system."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_abort</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*NOTREACHED*/</comment>
    <expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"abort() called from Python code didn't abort!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>win32_startfile__doc__</name></expr></argument>,
<argument><expr>"startfile(filepath [, operation]) - Start a file with its associated\n\
application.\n\
\n\
When \"operation\" is not specified or \"open\", this acts like\n\
double-clicking the file in Explorer, or giving the file name as an\n\
argument to the DOS \"start\" command: the file is opened with whatever\n\
application (if any) its extension is associated.\n\
When another \"operation\" is given, it specifies what should be done with\n\
the file.  A typical operation is \"print\".\n\
\n\
startfile returns as soon as the associated application is launched.\n\
There is no option to wait for the application to close, and no way\n\
to retrieve the application's exit status.\n\
\n\
The filepath is relative to the current directory.  If you want to use\n\
an absolute path, make sure the first character is not a slash (\"/\");\n\
the underlying Win32 ShellExecute function doesn't work if it is."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>win32_startfile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>filepath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>operation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HINSTANCE</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_WIN_WIDE_FILENAMES</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>unicode_file_names</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>unipath</name></decl>, *<decl><type ref="prev"/><name>woperation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"U|s:startfile"</expr></argument>,
				      <argument><expr>&amp;<name>unipath</name></expr></argument>, <argument><expr>&amp;<name>operation</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>normal</name>;</goto>
		}</block></then></if>
		

		<if>if <condition>(<expr><name>operation</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>woperation</name> = <call><name>PyUnicode_DecodeASCII</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, 
						       <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr>!<name>woperation</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><name>operation</name> = <name>NULL</name></expr>;</expr_stmt>
			    <goto>goto <name>normal</name>;</goto>
		    }</block></then></if>
		}</block></then></if>
			
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>rc</name> <init>= <expr><call><name>ShellExecuteW</name><argument_list>(<argument><expr>(<name>HWND</name>)0</expr></argument>, <argument><expr><name>woperation</name> ? <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>woperation</name></expr></argument>)</argument_list></call> : 0</expr></argument>,
			<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unipath</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SW_SHOWNORMAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>

		<name>Py_XDECREF</name><parameter_list>(<param><decl><type><name>woperation</name></type></decl></param>)</parameter_list>;</function_decl>
		<if>if <condition>(<expr><name>rc</name> &lt;= (<name>HINSTANCE</name>)32</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>errval</name> <init>= <expr><call><name>win32_error_unicode</name><argument_list>(<argument><expr>"startfile"</expr></argument>,
						<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unipath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<return>return <expr><name>errval</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>normal</name>:</label>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et|s:startfile"</expr></argument>, 
			      <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr>&amp;<name>filepath</name></expr></argument>, 
			      <argument><expr>&amp;<name>operation</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>rc</name> <init>= <expr><call><name>ShellExecute</name><argument_list>(<argument><expr>(<name>HWND</name>)0</expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name>filepath</name></expr></argument>, 
			  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SW_SHOWNORMAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>rc</name> &lt;= (<name>HINSTANCE</name>)32</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>errval</name> <init>= <expr><call><name>win32_error</name><argument_list>(<argument><expr>"startfile"</expr></argument>, <argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>errval</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETLOADAVG</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>posix_getloadavg__doc__</name></expr></argument>,
<argument><expr>"getloadavg() -&gt; (float, float, float)\n\n\
Return the number of processes in the system run queue averaged over\n\
the last 1, 5, and 15 minutes or raises OSError if the load average\n\
was unobtainable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>posix_getloadavg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>double</name></type> <name><name>loadavg</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>getloadavg</name><argument_list>(<argument><expr><name>loadavg</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call>!=3</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>, <argument><expr>"Load averages are unobtainable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then> <else>else
        <return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ddd"</expr></argument>, <argument><expr><name><name>loadavg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>loadavg</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>loadavg</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>win32_urandom__doc__</name></expr></argument>,
<argument><expr>"urandom(n) -&gt; str\n\n\
Return a string of n random bytes suitable for cryptographic use."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> *<name>CRYPTACQUIRECONTEXTA</name>)<parameter_list>(<param><decl><type><name>HCRYPTPROV</name> *</type><name>phProv</name></decl></param>,\
              <param><decl><type><name>LPCSTR</name></type> <name>pszContainer</name></decl></param>, <param><decl><type><name>LPCSTR</name></type> <name>pszProvider</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>dwProvType</name></decl></param>,\
              <param><decl><type><name>DWORD</name></type> <name>dwFlags</name></decl></param> )</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> *<name>CRYPTGENRANDOM</name>)<parameter_list>(<param><decl><type><name>HCRYPTPROV</name></type> <name>hProv</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>dwLen</name></decl></param>,\
              <param><decl><type><name>BYTE</name> *</type><name>pbBuffer</name></decl></param> )</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>CRYPTGENRANDOM</name></type> <name>pCryptGenRandom</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* This handle is never explicitly released. Instead, the operating
   system will release it when the process terminates. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HCRYPTPROV</name></type> <name>hCryptProv</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>win32_urandom</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>howMany</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Read arguments */</comment>
	<if>if <condition>(<expr>! <call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:urandom"</expr></argument>, <argument><expr>&amp;<name>howMany</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>howMany</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				    <argument><expr>"negative argument not allowed"</expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr><name>hCryptProv</name> == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>HINSTANCE</name></type> <name>hAdvAPI32</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CRYPTACQUIRECONTEXTA</name></type> <name>pCryptAcquireContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Obtain handle to the DLL containing CryptoAPI
		   This should not fail	*/</comment>
		<expr_stmt><expr><name>hAdvAPI32</name> = <call><name>GetModuleHandle</name><argument_list>(<argument><expr>"advapi32.dll"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if<condition>(<expr><name>hAdvAPI32</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"GetModuleHandle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

		<comment type="block">/* Obtain pointers to the CryptoAPI functions
		   This will fail on some early versions of Win95 */</comment>
		<expr_stmt><expr><name>pCryptAcquireContext</name> = (<name>CRYPTACQUIRECONTEXTA</name>)<call><name>GetProcAddress</name><argument_list>(
						<argument><expr><name>hAdvAPI32</name></expr></argument>,
						<argument><expr>"CryptAcquireContextA"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pCryptAcquireContext</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_NotImplementedError</name></expr></argument>,
					    <argument><expr>"CryptAcquireContextA not found"</expr></argument>)</argument_list></call></expr>;</return></then></if>

		<expr_stmt><expr><name>pCryptGenRandom</name> = (<name>CRYPTGENRANDOM</name>)<call><name>GetProcAddress</name><argument_list>(
						<argument><expr><name>hAdvAPI32</name></expr></argument>, <argument><expr>"CryptGenRandom"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pCryptGenRandom</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_NotImplementedError</name></expr></argument>,
					    <argument><expr>"CryptGenRandom not found"</expr></argument>)</argument_list></call></expr>;</return></then></if>

		<comment type="block">/* Acquire context */</comment>
		<if>if <condition>(<expr>! <call><name>pCryptAcquireContext</name><argument_list>(<argument><expr>&amp;<name>hCryptProv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>PROV_RSA_FULL</name></expr></argument>, <argument><expr><name>CRYPT_VERIFYCONTEXT</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CryptAcquireContext"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></then></if>

	<comment type="block">/* Allocate bytes */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>howMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Get random data */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>howMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* zero seed */</comment>
		<if>if <condition>(<expr>! <call><name>pCryptGenRandom</name><argument_list>(<argument><expr><name>hCryptProv</name></expr></argument>, <argument><expr><name>howMany</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>*)
				      <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>win32_error</name><argument_list>(<argument><expr>"CryptGenRandom"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
<comment type="block">/* Use openssl random routine */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/rand.h&gt;</cpp:file></cpp:include>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>vms_urandom__doc__</name></expr></argument>,
<argument><expr>"urandom(n) -&gt; str\n\n\
Return a string of n random bytes suitable for cryptographic use."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>vms_urandom</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>howMany</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Read arguments */</comment>
	<if>if <condition>(<expr>! <call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:urandom"</expr></argument>, <argument><expr>&amp;<name>howMany</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>howMany</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				    <argument><expr>"negative argument not allowed"</expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* Allocate bytes */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>howMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Get random data */</comment>
		<if>if <condition>(<expr><call><name>RAND_pseudo_bytes</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>*)
				      <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
				      <argument><expr><name>howMany</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					    <argument><expr>"RAND_pseudo_bytes"</expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>posix_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"access"</expr>,	<expr><name>posix_access</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_access__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TTYNAME</name></cpp:ifdef>
	<expr><block>{<expr>"ttyname"</expr>,	<expr><name>posix_ttyname</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_ttyname__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"chdir"</expr>,	<expr><name>posix_chdir</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chdir__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CHFLAGS</name></cpp:ifdef>
	<expr><block>{<expr>"chflags"</expr>,	<expr><name>posix_chflags</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chflags__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CHFLAGS */</comment>
	<expr><block>{<expr>"chmod"</expr>,	<expr><name>posix_chmod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chmod__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FCHMOD</name></cpp:ifdef>
	<expr><block>{<expr>"fchmod"</expr>,	<expr><name>posix_fchmod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fchmod__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FCHMOD */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CHOWN</name></cpp:ifdef>
	<expr><block>{<expr>"chown"</expr>,	<expr><name>posix_chown</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chown__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CHOWN */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LCHMOD</name></cpp:ifdef>
	<expr><block>{<expr>"lchmod"</expr>,	<expr><name>posix_lchmod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lchmod__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LCHMOD */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FCHOWN</name></cpp:ifdef>
	<expr><block>{<expr>"fchown"</expr>,	<expr><name>posix_fchown</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fchown__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FCHOWN */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LCHFLAGS</name></cpp:ifdef>
	<expr><block>{<expr>"lchflags"</expr>,	<expr><name>posix_lchflags</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lchflags__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LCHFLAGS */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LCHOWN</name></cpp:ifdef>
	<expr><block>{<expr>"lchown"</expr>,	<expr><name>posix_lchown</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lchown__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LCHOWN */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CHROOT</name></cpp:ifdef>
	<expr><block>{<expr>"chroot"</expr>,	<expr><name>posix_chroot</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_chroot__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CTERMID</name></cpp:ifdef>
	<expr><block>{<expr>"ctermid"</expr>,	<expr><name>posix_ctermid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_ctermid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETCWD</name></cpp:ifdef>
	<expr><block>{<expr>"getcwd"</expr>,	<expr><name>posix_getcwd</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getcwd__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr><block>{<expr>"getcwdu"</expr>,	<expr><name>posix_getcwdu</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getcwdu__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINK</name></cpp:ifdef>
	<expr><block>{<expr>"link"</expr>,	<expr><name>posix_link</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_link__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LINK */</comment>
	<expr><block>{<expr>"listdir"</expr>,	<expr><name>posix_listdir</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_listdir__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"lstat"</expr>,	<expr><name>posix_lstat</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lstat__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"mkdir"</expr>,	<expr><name>posix_mkdir</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_mkdir__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NICE</name></cpp:ifdef>
	<expr><block>{<expr>"nice"</expr>,	<expr><name>posix_nice</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_nice__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_NICE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_READLINK</name></cpp:ifdef>
	<expr><block>{<expr>"readlink"</expr>,	<expr><name>posix_readlink</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_readlink__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_READLINK */</comment>
	<expr><block>{<expr>"rename"</expr>,	<expr><name>posix_rename</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_rename__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"rmdir"</expr>,	<expr><name>posix_rmdir</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_rmdir__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"stat"</expr>,	<expr><name>posix_stat</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_stat__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"stat_float_times"</expr>, <expr><name>stat_float_times</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>stat_float_times__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
	<expr><block>{<expr>"symlink"</expr>,	<expr><name>posix_symlink</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_symlink__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYMLINK */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSTEM</name></cpp:ifdef>
	<expr><block>{<expr>"system"</expr>,	<expr><name>posix_system</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_system__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"umask"</expr>,	<expr><name>posix_umask</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_umask__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNAME</name></cpp:ifdef>
	<expr><block>{<expr>"uname"</expr>,	<expr><name>posix_uname</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_uname__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_UNAME */</comment>
	<expr><block>{<expr>"unlink"</expr>,	<expr><name>posix_unlink</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_unlink__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"remove"</expr>,	<expr><name>posix_unlink</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_remove__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"utime"</expr>,	<expr><name>posix_utime</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_utime__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TIMES</name></cpp:ifdef>
	<expr><block>{<expr>"times"</expr>,	<expr><name>posix_times</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_times__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_TIMES */</comment>
	<expr><block>{<expr>"_exit"</expr>,	<expr><name>posix__exit</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix__exit__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_EXECV</name></cpp:ifdef>
	<expr><block>{<expr>"execv"</expr>,	<expr><name>posix_execv</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_execv__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"execve"</expr>,	<expr><name>posix_execve</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_execve__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_EXECV */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SPAWNV</name></cpp:ifdef>
	<expr><block>{<expr>"spawnv"</expr>,	<expr><name>posix_spawnv</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_spawnv__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"spawnve"</expr>,	<expr><name>posix_spawnve</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_spawnve__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr><block>{<expr>"spawnvp"</expr>,	<expr><name>posix_spawnvp</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_spawnvp__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"spawnvpe"</expr>,	<expr><name>posix_spawnvpe</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_spawnvpe__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PYOS_OS2 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SPAWNV */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FORK1</name></cpp:ifdef>
	<expr><block>{<expr>"fork1"</expr>,       <expr><name>posix_fork1</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_fork1__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FORK1 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FORK</name></cpp:ifdef>
	<expr><block>{<expr>"fork"</expr>,	<expr><name>posix_fork</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_fork__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FORK */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__GETPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DEV_PTMX</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr><block>{<expr>"openpty"</expr>,	<expr><name>posix_openpty</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_openpty__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_OPENPTY || HAVE__GETPTY || HAVE_DEV_PTMX */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FORKPTY</name></cpp:ifdef>
	<expr><block>{<expr>"forkpty"</expr>,	<expr><name>posix_forkpty</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_forkpty__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FORKPTY */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETEGID</name></cpp:ifdef>
	<expr><block>{<expr>"getegid"</expr>,	<expr><name>posix_getegid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getegid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETEGID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETEUID</name></cpp:ifdef>
	<expr><block>{<expr>"geteuid"</expr>,	<expr><name>posix_geteuid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_geteuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETEUID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETGID</name></cpp:ifdef>
	<expr><block>{<expr>"getgid"</expr>,	<expr><name>posix_getgid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getgid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETGID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETGROUPS</name></cpp:ifdef>
	<expr><block>{<expr>"getgroups"</expr>,	<expr><name>posix_getgroups</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getgroups__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"getpid"</expr>,	<expr><name>posix_getpid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getpid__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETPGRP</name></cpp:ifdef>
	<expr><block>{<expr>"getpgrp"</expr>,	<expr><name>posix_getpgrp</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getpgrp__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETPGRP */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETPPID</name></cpp:ifdef>
	<expr><block>{<expr>"getppid"</expr>,	<expr><name>posix_getppid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getppid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETPPID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETUID</name></cpp:ifdef>
	<expr><block>{<expr>"getuid"</expr>,	<expr><name>posix_getuid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETUID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETLOGIN</name></cpp:ifdef>
	<expr><block>{<expr>"getlogin"</expr>,	<expr><name>posix_getlogin</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getlogin__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_KILL</name></cpp:ifdef>
	<expr><block>{<expr>"kill"</expr>,	<expr><name>posix_kill</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_kill__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_KILL */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_KILLPG</name></cpp:ifdef>
	<expr><block>{<expr>"killpg"</expr>,	<expr><name>posix_killpg</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_killpg__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_KILLPG */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PLOCK</name></cpp:ifdef>
	<expr><block>{<expr>"plock"</expr>,	<expr><name>posix_plock</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_plock__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_PLOCK */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POPEN</name></cpp:ifdef>
	<expr><block>{<expr>"popen"</expr>,	<expr><name>posix_popen</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_popen__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<expr><block>{<expr>"popen2"</expr>,	<expr><name>win32_popen2</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"popen3"</expr>,	<expr><name>win32_popen3</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"popen4"</expr>,	<expr><name>win32_popen4</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"startfile"</expr>,	<expr><name>win32_startfile</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>win32_startfile__doc__</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr><block>{<expr>"popen2"</expr>,	<expr><name>os2emx_popen2</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"popen3"</expr>,	<expr><name>os2emx_popen3</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"popen4"</expr>,	<expr><name>os2emx_popen4</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_POPEN */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETUID</name></cpp:ifdef>
	<expr><block>{<expr>"setuid"</expr>,	<expr><name>posix_setuid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETUID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETEUID</name></cpp:ifdef>
	<expr><block>{<expr>"seteuid"</expr>,	<expr><name>posix_seteuid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_seteuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETEUID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETEGID</name></cpp:ifdef>
	<expr><block>{<expr>"setegid"</expr>,	<expr><name>posix_setegid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setegid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETEGID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETREUID</name></cpp:ifdef>
	<expr><block>{<expr>"setreuid"</expr>,	<expr><name>posix_setreuid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setreuid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETREUID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETREGID</name></cpp:ifdef>
	<expr><block>{<expr>"setregid"</expr>,	<expr><name>posix_setregid</name></expr>,	<expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setregid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETREGID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETGID</name></cpp:ifdef>
	<expr><block>{<expr>"setgid"</expr>,	<expr><name>posix_setgid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setgid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETGID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETGROUPS</name></cpp:ifdef>
	<expr><block>{<expr>"setgroups"</expr>,	<expr><name>posix_setgroups</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>posix_setgroups__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETGROUPS */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETPGID</name></cpp:ifdef>
	<expr><block>{<expr>"getpgid"</expr>,	<expr><name>posix_getpgid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_getpgid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETPGID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETPGRP</name></cpp:ifdef>
	<expr><block>{<expr>"setpgrp"</expr>,	<expr><name>posix_setpgrp</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_setpgrp__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETPGRP */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WAIT</name></cpp:ifdef>
	<expr><block>{<expr>"wait"</expr>,	<expr><name>posix_wait</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_wait__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAIT */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WAIT3</name></cpp:ifdef>
        <expr><block>{<expr>"wait3"</expr>,	<expr><name>posix_wait3</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_wait3__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAIT3 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WAIT4</name></cpp:ifdef>
        <expr><block>{<expr>"wait4"</expr>,	<expr><name>posix_wait4</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_wait4__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAIT4 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WAITPID</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CWAIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr><block>{<expr>"waitpid"</expr>,	<expr><name>posix_waitpid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_waitpid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAITPID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETSID</name></cpp:ifdef>
	<expr><block>{<expr>"getsid"</expr>,	<expr><name>posix_getsid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_getsid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETSID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETSID</name></cpp:ifdef>
	<expr><block>{<expr>"setsid"</expr>,	<expr><name>posix_setsid</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_setsid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETSID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETPGID</name></cpp:ifdef>
	<expr><block>{<expr>"setpgid"</expr>,	<expr><name>posix_setpgid</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_setpgid__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SETPGID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TCGETPGRP</name></cpp:ifdef>
	<expr><block>{<expr>"tcgetpgrp"</expr>,	<expr><name>posix_tcgetpgrp</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_tcgetpgrp__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_TCGETPGRP */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TCSETPGRP</name></cpp:ifdef>
	<expr><block>{<expr>"tcsetpgrp"</expr>,	<expr><name>posix_tcsetpgrp</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_tcsetpgrp__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_TCSETPGRP */</comment>
	<expr><block>{<expr>"open"</expr>,	<expr><name>posix_open</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_open__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"close"</expr>,	<expr><name>posix_close</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_close__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"closerange"</expr>,	<expr><name>posix_closerange</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_closerange__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"dup"</expr>,		<expr><name>posix_dup</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_dup__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"dup2"</expr>,	<expr><name>posix_dup2</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_dup2__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"lseek"</expr>,	<expr><name>posix_lseek</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_lseek__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"read"</expr>,	<expr><name>posix_read</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_read__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"write"</expr>,	<expr><name>posix_write</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_write__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"fstat"</expr>,	<expr><name>posix_fstat</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fstat__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"fdopen"</expr>,	<expr><name>posix_fdopen</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fdopen__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"isatty"</expr>,	<expr><name>posix_isatty</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_isatty__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PIPE</name></cpp:ifdef>
	<expr><block>{<expr>"pipe"</expr>,	<expr><name>posix_pipe</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_pipe__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MKFIFO</name></cpp:ifdef>
	<expr><block>{<expr>"mkfifo"</expr>,	<expr><name>posix_mkfifo</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_mkfifo__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKNOD</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MAKEDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr><block>{<expr>"mknod"</expr>,	<expr><name>posix_mknod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_mknod__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DEVICE_MACROS</name></cpp:ifdef>
	<expr><block>{<expr>"major"</expr>,	<expr><name>posix_major</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_major__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"minor"</expr>,	<expr><name>posix_minor</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_minor__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"makedev"</expr>,	<expr><name>posix_makedev</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_makedev__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FTRUNCATE</name></cpp:ifdef>
	<expr><block>{<expr>"ftruncate"</expr>,	<expr><name>posix_ftruncate</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_ftruncate__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PUTENV</name></cpp:ifdef>
	<expr><block>{<expr>"putenv"</expr>,	<expr><name>posix_putenv</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_putenv__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNSETENV</name></cpp:ifdef>
	<expr><block>{<expr>"unsetenv"</expr>,	<expr><name>posix_unsetenv</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_unsetenv__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"strerror"</expr>,	<expr><name>posix_strerror</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_strerror__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FCHDIR</name></cpp:ifdef>
	<expr><block>{<expr>"fchdir"</expr>,	<expr><name>posix_fchdir</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>posix_fchdir__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FSYNC</name></cpp:ifdef>
	<expr><block>{<expr>"fsync"</expr>,       <expr><name>posix_fsync</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>posix_fsync__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FDATASYNC</name></cpp:ifdef>
	<expr><block>{<expr>"fdatasync"</expr>,   <expr><name>posix_fdatasync</name></expr>,  <expr><name>METH_O</name></expr>, <expr><name>posix_fdatasync__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_WAIT_H</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WCOREDUMP</name></cpp:ifdef>
        <expr><block>{<expr>"WCOREDUMP"</expr>,	<expr><name>posix_WCOREDUMP</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WCOREDUMP__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WCOREDUMP */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIFCONTINUED</name></cpp:ifdef>
        <expr><block>{<expr>"WIFCONTINUED"</expr>,<expr><name>posix_WIFCONTINUED</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WIFCONTINUED__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIFCONTINUED */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIFSTOPPED</name></cpp:ifdef>
        <expr><block>{<expr>"WIFSTOPPED"</expr>,	<expr><name>posix_WIFSTOPPED</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WIFSTOPPED__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIFSTOPPED */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIFSIGNALED</name></cpp:ifdef>
        <expr><block>{<expr>"WIFSIGNALED"</expr>,	<expr><name>posix_WIFSIGNALED</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WIFSIGNALED__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIFSIGNALED */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIFEXITED</name></cpp:ifdef>
        <expr><block>{<expr>"WIFEXITED"</expr>,	<expr><name>posix_WIFEXITED</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WIFEXITED__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIFEXITED */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WEXITSTATUS</name></cpp:ifdef>
        <expr><block>{<expr>"WEXITSTATUS"</expr>,	<expr><name>posix_WEXITSTATUS</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WEXITSTATUS__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WEXITSTATUS */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WTERMSIG</name></cpp:ifdef>
        <expr><block>{<expr>"WTERMSIG"</expr>,	<expr><name>posix_WTERMSIG</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WTERMSIG__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WTERMSIG */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WSTOPSIG</name></cpp:ifdef>
        <expr><block>{<expr>"WSTOPSIG"</expr>,	<expr><name>posix_WSTOPSIG</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_WSTOPSIG__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WSTOPSIG */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYS_WAIT_H */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTATVFS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_STATVFS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr><block>{<expr>"fstatvfs"</expr>,	<expr><name>posix_fstatvfs</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fstatvfs__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STATVFS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_STATVFS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr><block>{<expr>"statvfs"</expr>,	<expr><name>posix_statvfs</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_statvfs__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TMPFILE</name></cpp:ifdef>
	<expr><block>{<expr>"tmpfile"</expr>,	<expr><name>posix_tmpfile</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_tmpfile__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TEMPNAM</name></cpp:ifdef>
	<expr><block>{<expr>"tempnam"</expr>,	<expr><name>posix_tempnam</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_tempnam__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TMPNAM</name></cpp:ifdef>
	<expr><block>{<expr>"tmpnam"</expr>,	<expr><name>posix_tmpnam</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_tmpnam__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFSTR</name></cpp:ifdef>
	<expr><block>{<expr>"confstr"</expr>,	<expr><name>posix_confstr</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_confstr__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSCONF</name></cpp:ifdef>
	<expr><block>{<expr>"sysconf"</expr>,	<expr><name>posix_sysconf</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_sysconf__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FPATHCONF</name></cpp:ifdef>
	<expr><block>{<expr>"fpathconf"</expr>,	<expr><name>posix_fpathconf</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_fpathconf__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PATHCONF</name></cpp:ifdef>
	<expr><block>{<expr>"pathconf"</expr>,	<expr><name>posix_pathconf</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>posix_pathconf__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"abort"</expr>,	<expr><name>posix_abort</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_abort__doc__</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<expr><block>{<expr>"_getfullpathname"</expr>,	<expr><name>posix__getfullpathname</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETLOADAVG</name></cpp:ifdef>
	<expr><block>{<expr>"getloadavg"</expr>,	<expr><name>posix_getloadavg</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>posix_getloadavg__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
 <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
 	<expr><block>{<expr>"urandom"</expr>, <expr><name>win32_urandom</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>win32_urandom__doc__</name></expr>}</block></expr>,
 <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
 <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
 	<expr><block>{<expr>"urandom"</expr>, <expr><name>vms_urandom</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>vms_urandom__doc__</name></expr>}</block></expr>,
 <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		 <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>ins</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>, <param><decl><type><name>char</name> *</type><name>symbol</name></decl></param>, <param><decl><type><name>long</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
        <return>return <expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>symbol</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Insert Platform-Specific Constant Values (Strings &amp; Numbers) of Common Use */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>insertvalues</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>APIRET</name></type>    <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ULONG</name></type>     <name><name>values</name><index>[<expr><name>QSV_MAX</name>+1</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>     *</type><name>ver</name></decl>, <decl><type ref="prev"/><name><name>tmp</name><index>[<expr>50</expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
    <name>rc</name> <init>= <expr><call><name>DosQuerySysInfo</name><argument_list>(<argument><expr>1L</expr></argument>, <argument><expr><name>QSV_MAX</name></expr></argument>, <argument><expr>&amp;<name><name>values</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ULONG</name></expr></argument>)</argument_list></sizeof> * <name>QSV_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <macro><name>Py_END_ALLOW_THREADS</name></macro>

    <if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>os2_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"meminstalled"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_TOTPHYSMEM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"memkernel"</expr></argument>,    <argument><expr><name><name>values</name><index>[<expr><name>QSV_TOTRESMEM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"memvirtual"</expr></argument>,   <argument><expr><name><name>values</name><index>[<expr><name>QSV_TOTAVAILMEM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"maxpathlen"</expr></argument>,   <argument><expr><name><name>values</name><index>[<expr><name>QSV_MAX_PATH_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"maxnamelen"</expr></argument>,   <argument><expr><name><name>values</name><index>[<expr><name>QSV_MAX_COMP_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"revision"</expr></argument>,     <argument><expr><name><name>values</name><index>[<expr><name>QSV_VERSION_REVISION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"timeslice"</expr></argument>,    <argument><expr><name><name>values</name><index>[<expr><name>QSV_MIN_SLICE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>

    <switch>switch <condition>(<expr><name><name>values</name><index>[<expr><name>QSV_VERSION_MINOR</name></expr>]</index></name></expr>)</condition> <block>{
    <case>case <expr>0</expr>:  <expr_stmt><expr><name>ver</name> = "2.00"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr>10</expr>: <expr_stmt><expr><name>ver</name> = "2.10"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr>11</expr>: <expr_stmt><expr><name>ver</name> = "2.11"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr>30</expr>: <expr_stmt><expr><name>ver</name> = "3.00"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr>40</expr>: <expr_stmt><expr><name>ver</name> = "4.00"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr>50</expr>: <expr_stmt><expr><name>ver</name> = "5.00"</expr>;</expr_stmt> <break>break;</break>
    </case><default>default:
        <expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
        	      <argument><expr>"%d-%d"</expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>QSV_VERSION_MAJOR</name></expr>]</index></name></expr></argument>,
                      <argument><expr><name><name>values</name><index>[<expr><name>QSV_VERSION_MINOR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ver</name> = &amp;<name><name>tmp</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    </default>}</block></switch>

    <comment type="block">/* Add Indicator of the Version of the Operating System */</comment>
    <if>if <condition>(<expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"version"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <comment type="block">/* Add Indicator of Which Drive was Used to Boot the System */</comment>
    <expr_stmt><expr><name><name>tmp</name><index>[<expr>0</expr>]</index></name> = 'A' + <name><name>values</name><index>[<expr><name>QSV_BOOT_DRIVE</name></expr>]</index></name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmp</name><index>[<expr>1</expr>]</index></name> = ':'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmp</name><index>[<expr>2</expr>]</index></name> = '\0'</expr>;</expr_stmt>

    <return>return <expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"bootdrive"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>all_ins</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>d</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_OK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>R_OK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"R_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>R_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>W_OK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"W_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>W_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>X_OK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"X_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>X_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NGROUPS_MAX</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"NGROUPS_MAX"</expr></argument>, <argument><expr>(<name>long</name>)<name>NGROUPS_MAX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TMP_MAX</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"TMP_MAX"</expr></argument>, <argument><expr>(<name>long</name>)<name>TMP_MAX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WCONTINUED</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"WCONTINUED"</expr></argument>, <argument><expr>(<name>long</name>)<name>WCONTINUED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WNOHANG</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"WNOHANG"</expr></argument>, <argument><expr>(<name>long</name>)<name>WNOHANG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WUNTRACED</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"WUNTRACED"</expr></argument>, <argument><expr>(<name>long</name>)<name>WUNTRACED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_RDONLY</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_RDONLY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_WRONLY</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_WRONLY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_WRONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_RDWR</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_RDWR"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_RDWR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_NDELAY</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NDELAY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NDELAY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_NONBLOCK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NONBLOCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_APPEND</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_APPEND"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_APPEND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_DSYNC</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_DSYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_DSYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_RSYNC</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_RSYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_RSYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_SYNC</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_SYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_SYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_NOCTTY</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NOCTTY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_CREAT</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_CREAT"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_CREAT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_EXCL</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_EXCL"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_EXCL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_TRUNC</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_TRUNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_TRUNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_BINARY</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_BINARY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_BINARY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_TEXT</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_TEXT"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_TEXT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_LARGEFILE</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_LARGEFILE"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_LARGEFILE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_SHLOCK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_SHLOCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_SHLOCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_EXLOCK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_EXLOCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_EXLOCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* MS Windows */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_NOINHERIT</name></cpp:ifdef>
	<comment type="block">/* Don't inherit in child processes. */</comment>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NOINHERIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NOINHERIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_O_SHORT_LIVED</name></cpp:ifdef>
	<comment type="block">/* Optimize for short life (keep in memory). */</comment>
	<comment type="block">/* MS forgot to define this one with a non-underscore form too. */</comment>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_SHORT_LIVED"</expr></argument>, <argument><expr>(<name>long</name>)<name>_O_SHORT_LIVED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_TEMPORARY</name></cpp:ifdef>
	<comment type="block">/* Automatically delete when last handle is closed. */</comment>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_TEMPORARY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_TEMPORARY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_RANDOM</name></cpp:ifdef>
	<comment type="block">/* Optimize for random access. */</comment>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_RANDOM"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_RANDOM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_SEQUENTIAL</name></cpp:ifdef>
	<comment type="block">/* Optimize for sequential access. */</comment>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_SEQUENTIAL"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_SEQUENTIAL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* GNU extensions. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_ASYNC</name></cpp:ifdef>
        <comment type="block">/* Send a SIGIO signal whenever input or output 
           becomes available on file descriptor */</comment>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_ASYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_ASYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_DIRECT</name></cpp:ifdef>
        <comment type="block">/* Direct disk access. */</comment>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_DIRECT"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_DIRECT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_DIRECTORY</name></cpp:ifdef>
        <comment type="block">/* Must be a directory.	 */</comment>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_DIRECTORY"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_DIRECTORY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_NOFOLLOW</name></cpp:ifdef>
        <comment type="block">/* Do not follow links.	 */</comment>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NOFOLLOW"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NOFOLLOW</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_NOATIME</name></cpp:ifdef>
	<comment type="block">/* Do not update the access time. */</comment>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"O_NOATIME"</expr></argument>, <argument><expr>(<name>long</name>)<name>O_NOATIME</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* These come from sysexits.h */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_OK</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_OK"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_OK */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_USAGE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_USAGE"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_USAGE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_USAGE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_DATAERR</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_DATAERR"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_DATAERR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_DATAERR */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_NOINPUT</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOINPUT"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOINPUT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_NOINPUT */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_NOUSER</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOUSER"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOUSER</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_NOUSER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_NOHOST</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOHOST"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOHOST</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_NOHOST */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_UNAVAILABLE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_UNAVAILABLE"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_UNAVAILABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_UNAVAILABLE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_SOFTWARE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_SOFTWARE"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_SOFTWARE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_SOFTWARE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_OSERR</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_OSERR"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_OSERR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_OSERR */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_OSFILE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_OSFILE"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_OSFILE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_OSFILE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_CANTCREAT</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_CANTCREAT"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_CANTCREAT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_CANTCREAT */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_IOERR</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_IOERR"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_IOERR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_IOERR */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_TEMPFAIL</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_TEMPFAIL"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_TEMPFAIL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_TEMPFAIL */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_PROTOCOL</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_PROTOCOL"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_PROTOCOL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_PROTOCOL */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_NOPERM</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOPERM"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOPERM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_NOPERM */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_CONFIG</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_CONFIG"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_CONFIG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_CONFIG */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EX_NOTFOUND</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EX_NOTFOUND"</expr></argument>, <argument><expr>(<name>long</name>)<name>EX_NOTFOUND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EX_NOTFOUND */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SPAWNV</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_WAIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_WAIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOWAIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_NOWAIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_OVERLAY"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_OVERLAY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DEBUG"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_DEBUG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_SESSION"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_SESSION</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DETACH"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_DETACH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_PM"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_PM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DEFAULT"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_DEFAULT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_MINIMIZE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_MINIMIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_MAXIMIZE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_MAXIMIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_FULLSCREEN"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_FULLSCREEN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_WINDOWED"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_WINDOWED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_FOREGROUND"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_FOREGROUND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_BACKGROUND"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_BACKGROUND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOCLOSE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_NOCLOSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOSESSION"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_NOSESSION</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_QUOTE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_QUOTE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_TILDE"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_TILDE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_UNRELATED"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_UNRELATED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DEBUGDESC"</expr></argument>, <argument><expr>(<name>long</name>)<name>P_DEBUGDESC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_WAIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>_P_WAIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOWAIT"</expr></argument>, <argument><expr>(<name>long</name>)<name>_P_NOWAIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_OVERLAY"</expr></argument>, <argument><expr>(<name>long</name>)<name>_OLD_P_OVERLAY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_NOWAITO"</expr></argument>, <argument><expr>(<name>long</name>)<name>_P_NOWAITO</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"P_DETACH"</expr></argument>, <argument><expr>(<name>long</name>)<name>_P_DETACH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if>if <condition>(<expr><call><name>insertvalues</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr>0</expr>;</return>
}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call>) &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITFUNC</name></cpp:macro> <cpp:value>initnt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODNAME</name></cpp:macro> <cpp:value>"nt"</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITFUNC</name></cpp:macro> <cpp:value>initos2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODNAME</name></cpp:macro> <cpp:value>"os2"</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITFUNC</name></cpp:macro> <cpp:value>initposix</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODNAME</name></cpp:macro> <cpp:value>"posix"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>INITFUNC</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr><name>MODNAME</name></expr></argument>,
			   <argument><expr><name>posix_methods</name></expr></argument>,
			   <argument><expr><name>posix__doc__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
    		<return>return;</return></then></if>

	<comment type="block">/* Initialize environ dictionary */</comment>
	<expr_stmt><expr><name>v</name> = <call><name>convertenviron</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"environ"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>all_ins</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return;</return></then></if>

        <if>if <condition>(<expr><call><name>setup_confname_tables</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>PyExc_OSError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PUTENV</name></cpp:ifdef>
	<if>if <condition>(<expr><name>posix_putenv_garbage</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>posix_putenv_garbage</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>stat_result_desc</name>.<name>name</name></name> = <name>MODNAME</name> ".stat_result"</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat_result_desc</name>.<name>fields</name><index>[<expr>7</expr>]</index></name>.<name>name</name> = <name>PyStructSequence_UnnamedField</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat_result_desc</name>.<name>fields</name><index>[<expr>8</expr>]</index></name>.<name>name</name> = <name>PyStructSequence_UnnamedField</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat_result_desc</name>.<name>fields</name><index>[<expr>9</expr>]</index></name>.<name>name</name> = <name>PyStructSequence_UnnamedField</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>StatResultType</name></expr></argument>, <argument><expr>&amp;<name>stat_result_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>structseq_new</name> = <name><name>StatResultType</name>.<name>tp_new</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>StatResultType</name>.<name>tp_new</name></name> = <name>statresult_new</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>statvfs_result_desc</name>.<name>name</name></name> = <name>MODNAME</name> ".statvfs_result"</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>StatVFSResultType</name></expr></argument>, <argument><expr>&amp;<name>statvfs_result_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"stat_result"</expr></argument>, <argument><expr>(<name>PyObject</name>*) &amp;<name>StatResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatVFSResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"statvfs_result"</expr></argument>,
			   <argument><expr>(<name>PyObject</name>*) &amp;<name>StatVFSResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
	<comment type="block">/*
	 * Step 2 of weak-linking support on Mac OS X.
	 *
	 * The code below removes functions that are not available on the
	 * currently active platform. 
	 *
	 * This block allow one to use a python binary that was build on
	 * OSX 10.4 on OSX 10.3, without loosing access to new APIs on 
	 * OSX 10.4.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FSTATVFS</name></cpp:ifdef>
	<if>if <condition>(<expr><name>fstatvfs</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyObject_DelAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"fstatvfs"</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<return>return;</return>
		}</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FSTATVFS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STATVFS</name></cpp:ifdef>
	<if>if <condition>(<expr><name>statvfs</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyObject_DelAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"statvfs"</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<return>return;</return>
		}</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_STATVFS */</comment>

<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>HAVE_LCHOWN</name></cpp:ifdef>
	<if>if <condition>(<expr><name>lchown</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyObject_DelAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"lchown"</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<return>return;</return>
		}</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LCHOWN */</comment>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __APPLE__ */</comment>

}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


</unit>
