<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_tkinter.c"><comment type="block">/***********************************************************
Copyright (C) 1994 Steen Lumholt.

                        All Rights Reserved

******************************************************************/</comment>

<comment type="block">/* _tkinter.c -- Interface to libtk.a and libtcl.a. */</comment>

<comment type="block">/* TCL/TK VERSION INFO:

	Only Tcl/Tk 8.2 and later are supported.  Older versions are not
	supported.  (Use Python 2.2 if you cannot upgrade your Tcl/Tk
	libraries.)
*/</comment>

<comment type="block">/* XXX Further speed-up ideas, involving Tcl 8.0 features:

   - Register a new Tcl type, "Python callable", which can be called more
   efficiently and passed to Tcl_EvalObj() directly (if this is possible).

*/</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Allow using this code in Python 2.[12] */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyDoc_STRVAR</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDoc_STRVAR</name><parameter_list>(<param><type><name>name</name></type></param>,<param><type><name>str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static char name[] = str</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyMODINIT_FUNC</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>void</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyBool_Check</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyBool_Check</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyBool_FromLong</name></cpp:macro>       <cpp:value>PyInt_FromLong</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Starting with Tcl 8.4, many APIs offer const-correctness.  Unfortunately,
   making _tkinter correct for this API means to break earlier
   versions. USE_COMPAT_CONST allows to make _tkinter work with both 8.4 and
   earlier versions. Once Tcl releases before 8.4 don't need to be supported
   anymore, this should go. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_COMPAT_CONST</name></cpp:macro></cpp:define>

<comment type="block">/* If Tcl is compiled for threads, we must also define TCL_THREAD. We define
   it always; if Tcl is not threaded, the thread functions in
   Tcl are empty.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCL_THREADS</name></cpp:macro></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TK_FRAMEWORK</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Tcl/tcl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Tk/tk.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tk.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* For Tcl 8.2 and 8.3, CONST* is not defined (except on Cygwin). */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CONST84_RETURN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONST84_RETURN</name></cpp:macro></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONST</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONST</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TKMAJORMINOR</name></cpp:macro> <cpp:value>(TK_MAJOR_VERSION*1000 + TK_MINOR_VERSION)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TKMAJORMINOR</name> &lt; 8002</expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "Tk older than 8.2 not supported"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Unicode conversion assumes that Tcl_UniChar is two bytes.
   We cannot test this directly, so we test UTF-8 size instead,
   expecting that TCL_UTF_MAX is changed if Tcl ever supports
   either UTF-16 or UCS-4.  
   Redhat 8 sets TCL_UTF_MAX to 6, and uses wchar_t for 
   Tcl_Unichar. This is also ok as long as Python uses UCS-4,
   as well.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TCL_UTF_MAX</name> != 3 &amp;&amp; !(<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TCL_UTF_MAX</name>==6)</expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "unsupported Tcl configuration"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!(<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call>)</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_CREATEFILEHANDLER</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CREATEFILEHANDLER</name></cpp:ifdef>

<comment type="block">/* This bit is to ensure that TCL_UNIX_FD is defined and doesn't interfere
   with the proper calculation of FHANDLETYPE == TCL_UNIX_FD below. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TCL_UNIX_FD</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>TCL_WIN_SOCKET</name></cpp:ifdef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>TCL_UNIX_FD</name></cpp:macro> <cpp:value>(! TCL_WIN_SOCKET)</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>TCL_UNIX_FD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Tcl_CreateFileHandler() changed several times; these macros deal with the
   messiness.  In Tcl 8.0 and later, it is not available on Windows (and on
   Unix, only because Jack added it back); when available on Windows, it only
   applies to sockets. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FHANDLETYPE</name></cpp:macro> <cpp:value>TCL_WIN_SOCKET</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FHANDLETYPE</name></cpp:macro> <cpp:value>TCL_UNIX_FD</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If Tcl can wait for a Unix file descriptor, define the EventHook() routine
   which uses this to handle Tcl events while the user is typing commands. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FHANDLETYPE</name> == <name>TCL_UNIX_FD</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_FOR_STDIN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CREATEFILEHANDLER */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;conio.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_FOR_STDIN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>

<comment type="block">/* The threading situation is complicated.  Tcl is not thread-safe, except
   when configured with --enable-threads.
   So we need to use a lock around all uses of Tcl.  Previously, the Python
   interpreter lock was used for this.  However, this causes problems when
   other Python threads need to run while Tcl is blocked waiting for events.

   To solve this problem, a separate lock for Tcl is introduced.  Holding it
   is incompatible with holding Python's interpreter lock.  The following four
   macros manipulate both locks together.

   ENTER_TCL and LEAVE_TCL are brackets, just like Py_BEGIN_ALLOW_THREADS and
   Py_END_ALLOW_THREADS.  They should be used whenever a call into Tcl is made
   that could call an event handler, or otherwise affect the state of a Tcl
   interpreter.  These assume that the surrounding code has the Python
   interpreter lock; inside the brackets, the Python interpreter lock has been
   released and the lock for Tcl has been acquired.

   Sometimes, it is necessary to have both the Python lock and the Tcl lock.
   (For example, when transferring data from the Tcl interpreter result to a
   Python string object.)  This can be done by using different macros to close
   the ENTER_TCL block: ENTER_OVERLAP reacquires the Python lock (and restores
   the thread state) but doesn't release the Tcl lock; LEAVE_OVERLAP_TCL
   releases the Tcl lock.

   By contrast, ENTER_PYTHON and LEAVE_PYTHON are used in Tcl event
   handlers when the handler needs to use Python.  Such event handlers are
   entered while the lock for Tcl is held; the event handler presumably needs
   to use Python.  ENTER_PYTHON releases the lock for Tcl and acquires
   the Python interpreter lock, restoring the appropriate thread state, and
   LEAVE_PYTHON releases the Python interpreter lock and re-acquires the lock
   for Tcl.  It is okay for ENTER_TCL/LEAVE_TCL pairs to be contained inside
   the code between ENTER_PYTHON and LEAVE_PYTHON.

   These locks expand to several statements and brackets; they should not be
   used in branches of if statements and the like.

   If Tcl is threaded, this approach won't work anymore. The Tcl interpreter is
   only valid in the thread that created it, and all Tk activity must happen in this
   thread, also. That means that the mainloop must be invoked in the thread that
   created the interpreter. Invoking commands from other threads is possible;
   _tkinter will queue an event for the interpreter thread, which will then
   execute the command and pass back the result. If the main thread is not in the
   mainloop, and invoking commands causes an exception; if the main loop is running
   but not processing events, the command invocation will block.

   In addition, for a threaded Tcl, a single global tcl_tstate won't be sufficient
   anymore, since multiple Tcl interpreters may simultaneously dispatch in different
   threads. So we use the Tcl TLS API.

*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyThread_type_lock</name></type> <name>tcl_lock</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TCL_THREADS</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>Tcl_ThreadDataKey</name></type> <name>state_key</name></decl>;</decl_stmt>
<typedef>typedef <type><name>PyThreadState</name> *</type><name>ThreadSpecificData</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tcl_tstate</name></cpp:macro> <cpp:value>(*(PyThreadState**)Tcl_GetThreadData(&amp;state_key, sizeof(PyThreadState*)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyThreadState</name> *</type><name>tcl_tstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTER_TCL</name></cpp:macro> \
	<cpp:value>{ PyThreadState *tstate = PyThreadState_Get(); Py_BEGIN_ALLOW_THREADS \
	    if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1); tcl_tstate = tstate;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAVE_TCL</name></cpp:macro> \
    <cpp:value>tcl_tstate = NULL; if(tcl_lock)PyThread_release_lock(tcl_lock); Py_END_ALLOW_THREADS}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTER_OVERLAP</name></cpp:macro> \
	<cpp:value>Py_END_ALLOW_THREADS</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAVE_OVERLAP_TCL</name></cpp:macro> \
	<cpp:value>tcl_tstate = NULL; if(tcl_lock)PyThread_release_lock(tcl_lock); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTER_PYTHON</name></cpp:macro> \
	<cpp:value>{ PyThreadState *tstate = tcl_tstate; tcl_tstate = NULL; \
	    if(tcl_lock)PyThread_release_lock(tcl_lock); PyEval_RestoreThread((tstate)); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAVE_PYTHON</name></cpp:macro> \
	<cpp:value>{ PyThreadState *tstate = PyEval_SaveThread(); \
	    if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1); tcl_tstate = tstate; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_TCL_APPARTMENT</name></cpp:macro> \
	<cpp:value>if (((TkappObject *)self)-&gt;threaded &amp;&amp; \
	    ((TkappObject *)self)-&gt;thread_id != Tcl_GetCurrentThread()) { \
		PyErr_SetString(PyExc_RuntimeError, "Calling Tcl from different appartment"); \
		return 0; \
	}</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTER_TCL</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAVE_TCL</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTER_OVERLAP</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAVE_OVERLAP_TCL</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTER_PYTHON</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAVE_PYTHON</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_TCL_APPARTMENT</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FREECAST</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREECAST</name></cpp:macro> <cpp:value>(char *)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**** Tkapp Object Declaration ****/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Tkapp_Type</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wantobjects</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>threaded</name></decl>;</decl_stmt> <comment type="block">/* True if tcl_platform[threaded] */</comment>
	<decl_stmt><decl><type><name>Tcl_ThreadId</name></type> <name>thread_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>dispatching</name></decl>;</decl_stmt>
	<comment type="block">/* We cannot include tclInt.h, as this is internal.
	   So we cache interesting types here. */</comment>
	<decl_stmt><decl><type><name>Tcl_ObjType</name> *</type><name>BooleanType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_ObjType</name> *</type><name>ByteArrayType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_ObjType</name> *</type><name>DoubleType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_ObjType</name> *</type><name>IntType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_ObjType</name> *</type><name>ListType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_ObjType</name> *</type><name>ProcBodyType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_ObjType</name> *</type><name>StringType</name></decl>;</decl_stmt>
}</block></struct></type> <name>TkappObject</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Tkapp_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(v) == &amp;Tkapp_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Tkapp_Interp</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((TkappObject *) (v))-&gt;interp)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Tkapp_Result</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Tcl_GetStringResult(Tkapp_Interp(v))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_REFCNT</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(printf("DEBUG: id=%p, refcnt=%i\n", \
(void *) v, Py_REFCNT(v)))</cpp:value></cpp:define>


<escape char="0xc"/>
<comment type="block">/**** Error Handling ****/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>Tkinter_TclError</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>quitMainLoop</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>errorInCmd</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>excInCmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>valInCmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>trbInCmd</name></decl>;</decl_stmt>


<escape char="0xc"/>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkinter_Error</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Tkinter_TclError</name></expr></argument>, <argument><expr><call><name>Tkapp_Result</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/**** Utils ****/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>Tkinter_busywaitinterval</name> <init>= <expr>20</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>

<comment type="block">/* Millisecond sleep() for Unix platforms. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Sleep</name><parameter_list>(<param><decl><type><name>int</name></type> <name>milli</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX Too bad if you don't have select(). */</comment>
	<decl_stmt><decl><type>struct <name>timeval</name></type> <name>t</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>t</name>.<name>tv_sec</name></name> = <name>milli</name>/1000</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name>.<name>tv_usec</name></name> = (<name>milli</name>%1000) * 1000</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>select</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>(<name>fd_set</name> *)0</expr></argument>, <argument><expr>(<name>fd_set</name> *)0</expr></argument>, <argument><expr>(<name>fd_set</name> *)0</expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<comment type="block">/* Wait up to 1s for the mainloop to come up. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>WaitForMainloop</name><parameter_list>(<param><decl><type><name>TkappObject</name>*</type> <name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 10</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>self</name>-&gt;<name>dispatching</name></name></expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>Sleep</name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></decl>;</decl_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
	}</block></for>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>dispatching</name></name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"main thread is not in main loop"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WITH_THREAD */</comment>

<escape char="0xc"/>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>AsString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tmp</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyObject_Str</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if></else></if>
}</block></function>


<escape char="0xc"/>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGSZ</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>Merge</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name><name>argvStore</name><index>[<expr><name>ARGSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>fvStore</name><index>[<expr><name>ARGSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> *</type><name>fv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr>0</expr></init>, <name>fvc</name> <init>= <expr>0</expr></init>, <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!(<name>tmp</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>)</expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>argv</name> = <name>argvStore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fv</name> = <name>fvStore</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>argc</name> = 0</expr>;</expr_stmt></then>

	<else>else <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>argc</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fv</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr>!(<name><name>argv</name><index>[<expr>0</expr>]</index></name> = <call><name>AsString</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
			<goto>goto <name>finally</name>;</goto></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>argc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>argc</name> &gt; <name>ARGSZ</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>argv</name> = (<name>char</name> **)<call><name>ckalloc</name><argument_list>(<argument><expr><name>argc</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fv</name> = (<name>int</name> *)<call><name>ckalloc</name><argument_list>(<argument><expr><name>argc</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>argv</name> == <name>NULL</name> || <name>fv</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>finally</name>;</goto>
			}</block></then></if>
		}</block></then></if>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>fv</name><index>[<expr><name>i</name></expr>]</index></name> = 1</expr>;</expr_stmt>
				<if>if <condition>(<expr>!(<name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>Merge</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
					<goto>goto <name>finally</name>;</goto></then></if>
				<expr_stmt><expr><name>fvc</name>++</expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>v</name> == <name>Py_None</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>argc</name> = <name>i</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name><name>fv</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
				<if>if <condition>(<expr>!(<name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
					<goto>goto <name>finally</name>;</goto></then></if>
				<expr_stmt><expr><name>fvc</name>++</expr>;</expr_stmt>
			}</block></else></if></else></if>
		}</block></for>
	}</block></else></if></else></if>
	<expr_stmt><expr><name>res</name> = <call><name>Tcl_Merge</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Tkinter_TclError</name></expr></argument>, <argument><expr>"merge failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <label><name>finally</name>:</label>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>fvc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<if>if <condition>(<expr><name><name>fv</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></for>
	<if>if <condition>(<expr><name>argv</name> != <name>argvStore</name></expr>)</condition><then>
		<macro><name>ckfree</name><argument_list>(<argument>FREECAST argv</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></then></if>
	<if>if <condition>(<expr><name>fv</name> != <name>fvStore</name></expr>)</condition><then>
		<macro><name>ckfree</name><argument_list>(<argument>FREECAST fv</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></then></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Split</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>list</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>argv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>Tcl_SplitList</name><argument_list>(<argument><expr>(<name>Tcl_Interp</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr>&amp;<name>argc</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>)</argument_list></call> != <name>TCL_OK</name></expr>)</condition><then> <block>{
		<comment type="block">/* Not a list.
		 * Could be a quoted string containing funnies, e.g. {"}.
		 * Return the string itself.
		 */</comment>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>argc</name> == 1</expr>)</condition><then>
		<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr>(<name>v</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr>(<name>w</name> = <call><name>Split</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></then></if></else></if></else></if>
	<macro><name>Tcl_Free</name><argument_list>(<argument>FREECAST argv</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* In some cases, Tcl will still return strings that are supposed to be
   lists. SplitObj walks through a nested tuple, finding string objects that
   need to be split. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SplitObj</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>elem</name></decl>, *<decl><type ref="prev"/><name>newelem</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>size</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
		<comment type="block">/* Recursively invoke SplitObj for all tuple items.
		   If this does not return a new object, no action is
		   needed. */</comment>
		<for>for(<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newelem</name> = <call><name>SplitObj</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>newelem</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>newelem</name> == <name>elem</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				}</block></then></if>
				<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
					<return>return <expr><name>NULL</name></expr>;</return></then></if>
				<for>for(<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
					<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></for>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>newelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
			<return>return <expr><name>result</name></expr>;</return></then></if>
		<comment type="block">/* Fall through, returning arg. */</comment>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> **</type><name>argv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>list</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>Tcl_SplitList</name><argument_list>(<argument><expr>(<name>Tcl_Interp</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr>&amp;<name>argc</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>)</argument_list></call> != <name>TCL_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>arg</name></expr>;</return>
		}</block></then></if>
		<macro><name>Tcl_Free</name><argument_list>(<argument>FREECAST argv</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<if>if <condition>(<expr><name>argc</name> &gt; 1</expr>)</condition><then>
			<return>return <expr><call><name>Split</name><argument_list>(<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<comment type="block">/* Fall through, returning arg. */</comment>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>arg</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/**** Tkapp Object ****/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITH_APPINIT</name></cpp:ifndef>
<function><type><name>int</name></type>
<name>Tcl_AppInit</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Tk_Window</name></type> main</decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>_tkinter_skip_tk_init</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Tcl_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call> == <name>TCL_ERROR</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"Tcl_Init error: %s\n"</expr></argument>, <argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>_tkinter_skip_tk_init</name> =	<call><name>Tcl_GetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"_tkinter_skip_tk_init"</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>_tkinter_skip_tk_init</name> == <name>NULL</name> || <call><name>strcmp</name><argument_list>(<argument><expr><name>_tkinter_skip_tk_init</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call>	!= 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>main = <call><name>Tk_MainWindow</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>Tk_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call> == <name>TCL_ERROR</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"Tk_Init error: %s\n"</expr></argument>, <argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>TCL_ERROR</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !WITH_APPINIT */</comment>


<escape char="0xc"/>

<comment type="block">/* Initialize the Tk application; see the `main' function in
 * `tkMain.c'.
 */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnableEventHook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DisableEventHook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* Forward */</comment>

<function><type><specifier>static</specifier> <name>TkappObject</name> *</type>
<name>Tkapp_New</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>screenName</name></decl></param>, <param><decl><type><name>char</name> *</type><name>baseName</name></decl></param>, <param><decl><type><name>char</name> *</type><name>className</name></decl></param>,
	  <param><decl><type><name>int</name></type> <name>interactive</name></decl></param>, <param><decl><type><name>int</name></type> <name>wantobjects</name></decl></param>, <param><decl><type><name>int</name></type>	<name>wantTk</name></decl></param>, <param><decl><type><name>int</name></type> <name>sync</name></decl></param>, <param><decl><type><name>char</name> *</type><name>use</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>TkappObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>argv0</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>TkappObject</name></expr></argument>, <argument><expr>&amp;<name>Tkapp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>v</name>-&gt;<name>interp</name></name> = <call><name>Tcl_CreateInterp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>wantobjects</name></name> = <name>wantobjects</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>threaded</name></name> = <call><name>Tcl_GetVar2Ex</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr>"tcl_platform"</expr></argument>, <argument><expr>"threaded"</expr></argument>,
				    <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>thread_id</name></name> = <call><name>Tcl_GetCurrentThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>dispatching</name></name> = 0</expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TCL_THREADS</name></cpp:ifndef>
	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>threaded</name></name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"Tcl is threaded but _tkinter is not"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>0</expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>threaded</name></name> &amp;&amp; <name>tcl_lock</name></expr>)</condition><then> <block>{
	    <comment type="block">/* If Tcl is threaded, we don't need the lock. */</comment>
	    <expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name>tcl_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>tcl_lock</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>v</name>-&gt;<name>BooleanType</name></name> = <call><name>Tcl_GetObjType</name><argument_list>(<argument><expr>"boolean"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>ByteArrayType</name></name> = <call><name>Tcl_GetObjType</name><argument_list>(<argument><expr>"bytearray"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>DoubleType</name></name> = <call><name>Tcl_GetObjType</name><argument_list>(<argument><expr>"double"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>IntType</name></name> = <call><name>Tcl_GetObjType</name><argument_list>(<argument><expr>"int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>ListType</name></name> = <call><name>Tcl_GetObjType</name><argument_list>(<argument><expr>"list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>ProcBodyType</name></name> = <call><name>Tcl_GetObjType</name><argument_list>(<argument><expr>"procbody"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>StringType</name></name> = <call><name>Tcl_GetObjType</name><argument_list>(<argument><expr>"string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete the 'exit' command, which can screw things up */</comment>
	<expr_stmt><expr><call><name>Tcl_DeleteCommand</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr>"exit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screenName</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Tcl_SetVar2</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr>"env"</expr></argument>, <argument><expr>"DISPLAY"</expr></argument>,
			    <argument><expr><name>screenName</name></expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>interactive</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr>"tcl_interactive"</expr></argument>, <argument><expr>"1"</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr>"tcl_interactive"</expr></argument>, <argument><expr>"0"</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<comment type="block">/* This is used to get the application class for Tk 4.1 and up */</comment>
	<expr_stmt><expr><name>argv0</name> = (<name>char</name>*)<call><name>ckalloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>argv0</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>argv0</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name><name>argv0</name><index>[<expr>0</expr>]</index></name> = <call><name>tolower</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>argv0</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr>"argv0"</expr></argument>, <argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>! <name>wantTk</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr>"_tkinter_skip_tk_init"</expr></argument>, <argument><expr>"1"</expr></argument>,	<argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* some initial arguments need to be in argv */</comment>
	<if>if <condition>(<expr><name>sync</name> || <name>use</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>args</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>sync</name></expr>)</condition><then>
			<expr_stmt><expr><name>len</name> += sizeof "-sync"</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>use</name></expr>)</condition><then>
			<expr_stmt><expr><name>len</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>use</name></expr></argument>)</argument_list></call> + sizeof "-use "</expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>args</name> = (<name>char</name>*)<call><name>ckalloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>args</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>

		<expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>sync</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"-sync"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>use</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>sync</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"-use "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>use</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr>"argv"</expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>Tcl_AppInit</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>interp</name></name></expr></argument>)</argument_list></call> != <name>TCL_OK</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>TkappObject</name> *)<name>result</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>EnableEventHook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>v</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>Tkapp_ThreadSend</name><parameter_list>(<param><decl><type><name>TkappObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Tcl_Event</name> *</type><name>ev</name></decl></param>,
		 <param><decl><type><name>Tcl_Condition</name> *</type><name>cond</name></decl></param>, <param><decl><type><name>Tcl_Mutex</name> *</type><name>mutex</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_MutexLock</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ThreadQueueEvent</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>thread_id</name></name></expr></argument>, <argument><expr><name>ev</name></expr></argument>, <argument><expr><name>TCL_QUEUE_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ThreadAlert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>thread_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ConditionWait</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_MutexUnlock</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></function>

<escape char="0xc"/>
<comment type="block">/** Tcl Eval **/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>Tcl_Obj</name> *</type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>string</name></decl>;</decl_stmt> <comment type="block">/* This cannot cause cycles. */</comment>
}</block></struct></type> <name>PyTclObject</name>;</typedef>

<decl_stmt><decl><type><name>staticforward</name> <name>PyTypeObject</name></type> <name>PyTclObject_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyTclObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((v)-&gt;ob_type == &amp;PyTclObject_Type)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>newPyTclObject</name><parameter_list>(<param><decl><type><name>Tcl_Obj</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTclObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>PyTclObject</name></expr></argument>, <argument><expr>&amp;<name>PyTclObject_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>value</name></name> = <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>string</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>PyTclObject_dealloc</name><parameter_list>(<param><decl><type><name>PyTclObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PyTclObject_str</name><parameter_list>(<param><decl><type><name>PyTclObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>string</name></name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>string</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>self</name>-&gt;<name>string</name></name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* XXX Could cache value if it is an ASCII string. */</comment>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name>*</type>
<name>PyTclObject_TclString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr>((<name>PyTclObject</name>*)<name>self</name>)-&gt;<name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Like _str, but create Unicode if necessary. */</comment>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PyTclObject_string__doc__</name></expr></argument>, 
<argument><expr>"the string representation of this object, either as string or Unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PyTclObject_string</name><parameter_list>(<param><decl><type><name>PyTclObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ignored</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>string</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>s</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0x80</expr>)</condition><then>
				<break>break;</break></then></if></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><name>i</name> == <name>len</name></expr>)</condition><then>
			<comment type="block">/* It is an ASCII string. */</comment>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>string</name></name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name><name>self</name>-&gt;<name>string</name></name> = <call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>string</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>self</name>-&gt;<name>string</name></name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>string</name></name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>string</name></name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>self</name>-&gt;<name>string</name></name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>PyTclObject_unicode__doc__</name></expr></argument>, <argument><expr>"convert argument to unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PyTclObject_unicode</name><parameter_list>(<param><decl><type><name>PyTclObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ignored</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>string</name></name> &amp;&amp; <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>string</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>self</name>-&gt;<name>string</name></name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* XXX Could chache result if it is non-ASCII. */</comment>
	<expr_stmt><expr><name>s</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PyTclObject_repr</name><parameter_list>(<param><decl><type><name>PyTclObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>50</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>50</expr></argument>, <argument><expr>"&lt;%s object at %p&gt;"</expr></argument>,
		      <argument><expr><name><name>self</name>-&gt;<name>value</name>-&gt;<name>typePtr</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>PyTclObject_cmp</name><parameter_list>(<param><decl><type><name>PyTclObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyTclObject</name> *</type><name>other</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>strcmp</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>other</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>res</name> &gt; 0</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>get_typename__doc__</name></expr></argument>, <argument><expr>"name of the Tcl type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>get_typename</name><parameter_list>(<param><decl><type><name>PyTclObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>ignored</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>value</name>-&gt;<name>typePtr</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>PyTclObject_getsetlist</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"typename"</expr>, <expr>(<name>getter</name>)<name>get_typename</name></expr>, <expr><name>NULL</name></expr>, <expr><name>get_typename__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"string"</expr>, <expr>(<name>getter</name>)<name>PyTclObject_string</name></expr>, <expr><name>NULL</name></expr>, 
	 <expr><name>PyTclObject_string__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>PyTclObject_methods</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<expr><block>{<expr>"__unicode__"</expr>,	<expr>(<name>PyCFunction</name>)<name>PyTclObject_unicode</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	<expr><name>PyTclObject_unicode__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>statichere</name> <name>PyTypeObject</name></type> <name>PyTclObject_Type</name> <init>= <expr><block>{
	<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
	0</expr>,			<comment type="block">/*ob_size*/</comment>
	<expr>"_tkinter.Tcl_Obj"</expr>,		<comment type="block">/*tp_name*/</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyTclObject</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/*tp_basicsize*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_itemsize*/</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>PyTclObject_dealloc</name></expr>, <comment type="block">/*tp_dealloc*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_print*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_getattr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_setattr*/</comment>
	<expr>(<name>cmpfunc</name>)<name>PyTclObject_cmp</name></expr>,	<comment type="block">/*tp_compare*/</comment>
	<expr>(<name>reprfunc</name>)<name>PyTclObject_repr</name></expr>,	<comment type="block">/*tp_repr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_number*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_sequence*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_mapping*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_hash*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_call*/</comment>
        <expr>(<name>reprfunc</name>)<name>PyTclObject_str</name></expr>,        <comment type="block">/*tp_str*/</comment>
        <expr><name>PyObject_GenericGetAttr</name></expr>,<comment type="block">/*tp_getattro*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_setattro*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_as_buffer*/</comment>
        <expr><name>Py_TPFLAGS_DEFAULT</name></expr>,     <comment type="block">/*tp_flags*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_doc*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_traverse*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_clear*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_richcompare*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_weaklistoffset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_iter*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_iternext*/</comment>
        <expr><name>PyTclObject_methods</name></expr>,    <comment type="block">/*tp_methods*/</comment>
        <expr>0</expr>,			<comment type="block">/*tp_members*/</comment>
        <expr><name>PyTclObject_getsetlist</name></expr>, <comment type="block">/*tp_getset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_base*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dict*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_get*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_set*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dictoffset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_init*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_alloc*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_new*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_free*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_is_gc*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Tcl_Obj</name>*</type>
<name>AsObj</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyBool_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>Tcl_NewBooleanObj</name><argument_list>(<argument><expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>Tcl_NewLongObj</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>Tcl_NewDoubleObj</name><argument_list>(<argument><expr><call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Tcl_Obj</name> **</type><name>argv</name> <init>= <expr>(<name>Tcl_Obj</name>**)
			<call><name>ckalloc</name><argument_list>(<argument><expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>*<sizeof>sizeof<argument_list>(<argument><expr><name>Tcl_Obj</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<if>if<condition>(<expr>!<name>argv</name></expr>)</condition><then>
		  <return>return <expr>0</expr>;</return></then></if>
		<for>for(<init><expr><name>i</name>=0</expr>;</init><condition><expr><name>i</name>&lt;<call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</condition><incr><expr><name>i</name>++</expr></incr>)
		  <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>AsObj</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
		<expr_stmt><expr><name>result</name> = <call><name>Tcl_NewListObj</name><argument_list>(<argument><expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>ckfree</name><argument_list>(<argument>FREECAST argv</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>inbuf</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* This #ifdef assumes that Tcl uses UCS-2.
		   See TCL_UTF_MAX test above. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TCL_UTF_MAX</name> == 3</expr></cpp:if>
		<decl_stmt><decl><type><name>Tcl_UniChar</name> *</type><name>outbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>allocsize</name> <init>= <expr>((<name>size_t</name>)<name>size</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>Tcl_UniChar</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>allocsize</name> &gt;= <name>size</name></expr>)</condition><then>
			<expr_stmt><expr><name>outbuf</name> = (<name>Tcl_UniChar</name>*)<call><name>ckalloc</name><argument_list>(<argument><expr><name>allocsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<comment type="block">/* Else overflow occurred, and we take the next exit */</comment>
		<if>if <condition>(<expr>!<name>outbuf</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><name><name>inbuf</name><index>[<expr><name>i</name></expr>]</index></name> &gt;= 0x10000</expr>)</condition><then> <block>{
				<comment type="block">/* Tcl doesn't do UTF-16, yet. */</comment>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"unsupported character"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>ckfree</name><argument_list>(<argument>FREECAST outbuf</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name><name>outbuf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>inbuf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><name>result</name> = <call><name>Tcl_NewUnicodeObj</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>ckfree</name><argument_list>(<argument>FREECAST outbuf</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<return>return <expr><call><name>Tcl_NewUnicodeObj</name><argument_list>(<argument><expr><name>inbuf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <if>if<condition>(<expr><call><name>PyTclObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>v</name> <init>= <expr>((<name>PyTclObject</name>*)<name>value</name>)-&gt;<name>value</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then> 
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyObject_Str</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>AsObj</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>FromObj</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>tkapp</name></decl></param>, <param><decl><type><name>Tcl_Obj</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TkappObject</name> *</type><name>app</name> <init>= <expr>(<name>TkappObject</name>*)<name>tkapp</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>value</name>-&gt;<name>typePtr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* If the result contains any bytes with the top bit set,
		   it's UTF-8 and we should decode it to Unicode */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><name><name>value</name>-&gt;<name>bytes</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>value</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><name><name>value</name>-&gt;<name>bytes</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0x80</expr>)</condition><then>
				<break>break;</break></then></if>
		}</block></for>

		<if>if <condition>(<expr><name>i</name> == <name><name>value</name>-&gt;<name>length</name></name></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<comment type="block">/* Convert UTF-8 to Unicode string */</comment>
			<expr_stmt><expr><name>result</name> = <call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>value</name>-&gt;<name>bytes</name></name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>value</name>-&gt;<name>typePtr</name></name> == <name><name>app</name>-&gt;<name>BooleanType</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name><name>value</name>-&gt;<name>internalRep</name>.<name>longValue</name></name> ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>value</name>-&gt;<name>typePtr</name></name> == <name><name>app</name>-&gt;<name>ByteArrayType</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>data</name> <init>= <expr>(<name>char</name>*)<call><name>Tcl_GetByteArrayFromObj</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>value</name>-&gt;<name>typePtr</name></name> == <name><name>app</name>-&gt;<name>DoubleType</name></name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name><name>value</name>-&gt;<name>internalRep</name>.<name>doubleValue</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>value</name>-&gt;<name>typePtr</name></name> == <name><name>app</name>-&gt;<name>IntType</name></name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>value</name>-&gt;<name>internalRep</name>.<name>longValue</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>value</name>-&gt;<name>typePtr</name></name> == <name><name>app</name>-&gt;<name>ListType</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>elem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>tcl_elem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>status</name> = <call><name>Tcl_ListObjLength</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>tkapp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>status</name> == <name>TCL_ERROR</name></expr>)</condition><then>
			<return>return <expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>tkapp</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>status</name> = <call><name>Tcl_ListObjIndex</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>tkapp</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>tcl_elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>status</name> == <name>TCL_ERROR</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>tkapp</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>elem</name> = <call><name>FromObj</name><argument_list>(<argument><expr><name>tkapp</name></expr></argument>, <argument><expr><name>tcl_elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>elem</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>value</name>-&gt;<name>typePtr</name></name> == <name><name>app</name>-&gt;<name>ProcBodyType</name></name></expr>)</condition><then> <block>{
	  <comment type="block">/* fall through: return tcl object. */</comment>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>value</name>-&gt;<name>typePtr</name></name> == <name><name>app</name>-&gt;<name>StringType</name></name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TCL_UTF_MAX</name>==3</expr></cpp:if>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Tcl_UniChar</name> *</type><name>input</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>output</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>size</name> = <call><name>Tcl_GetCharLength</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>input</name> = <call><name>Tcl_GetUnicode</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>output</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>size</name>--</expr>)</condition>
			<expr_stmt><expr>*<name>output</name>++ = *<name>input</name>++</expr>;</expr_stmt></while>
		<return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><call><name>Tcl_GetUnicode</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call><name>Tcl_GetCharLength</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>c</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>c</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>

	<return>return <expr><call><name>newPyTclObject</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* This mutex synchronizes inter-thread command calls. */</comment>

<macro><name>TCL_DECLARE_MUTEX</name><argument_list>(<argument>call_mutex</argument>)</argument_list></macro>

<typedef>typedef <type><struct>struct <name>Tkapp_CallEvent</name> <block>{
	<decl_stmt><decl><type><name>Tcl_Event</name></type> <name>ev</name></decl>;</decl_stmt>	     <comment type="block">/* Must be first */</comment>
	<decl_stmt><decl><type><name>TkappObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>exc_type</name></decl>, **<name>exc_value</name>, **<name>exc_tb</name>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Condition</name></type> <name>done</name></decl>;</decl_stmt>
}</block></struct></type> <name>Tkapp_CallEvent</name>;</typedef>

<function><type><name>void</name></type>
<name>Tkapp_CallDeallocArgs</name><parameter_list>(<param><decl><type><name>Tcl_Obj</name>**</type> <name>objv</name></decl></param>, <param><decl><type><name>Tcl_Obj</name>**</type> <name>objStore</name></decl></param>, <param><decl><type><name>int</name></type> <name>objc</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>objc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<if>if <condition>(<expr><name>objv</name> != <name>objStore</name></expr>)</condition><then>
		<macro><name>ckfree</name><argument_list>(<argument>FREECAST objv</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></then></if>
}</block></function>

<comment type="block">/* Convert Python objects to Tcl objects. This must happen in the
   interpreter thread, which may or may not be the calling thread. */</comment>

<function><type><specifier>static</specifier> <name>Tcl_Obj</name>**</type>
<name>Tkapp_CallArgs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>Tcl_Obj</name>**</type> <name>objStore</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pobjc</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Tcl_Obj</name> **</type><name>objv</name> <init>= <expr><name>objStore</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>objc</name> <init>= <expr>0</expr></init>, <name>i</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<comment type="block">/* do nothing */</comment><empty_stmt>;</empty_stmt></then>

	<else>else <if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>objv</name><index>[<expr>0</expr>]</index></name> = <call><name>AsObj</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>objv</name><index>[<expr>0</expr>]</index></name> == 0</expr>)</condition><then>
			<goto>goto <name>finally</name>;</goto></then></if>
		<expr_stmt><expr><name>objc</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>objc</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>objc</name> &gt; <name>ARGSZ</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>objv</name> = (<name>Tcl_Obj</name> **)<call><name>ckalloc</name><argument_list>(<argument><expr><name>objc</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>objv</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objc</name> = 0</expr>;</expr_stmt>
				<goto>goto <name>finally</name>;</goto>
			}</block></then></if>
		}</block></then></if>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>objc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>v</name> == <name>Py_None</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>objc</name> = <name>i</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>AsObj</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
				<comment type="block">/* Reset objc, so it attempts to clear
				   objects only up to i. */</comment>
				<expr_stmt><expr><name>objc</name> = <name>i</name></expr>;</expr_stmt>
				<goto>goto <name>finally</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	}</block></else></if></else></if>
	<expr_stmt><expr>*<name>pobjc</name> = <name>objc</name></expr>;</expr_stmt>
	<return>return <expr><name>objv</name></expr>;</return>
<label><name>finally</name>:</label>
	<expr_stmt><expr><call><name>Tkapp_CallDeallocArgs</name><argument_list>(<argument><expr><name>objv</name></expr></argument>, <argument><expr><name>objStore</name></expr></argument>, <argument><expr><name>objc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Convert the results of a command call into a Python objects. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>Tkapp_CallResult</name><parameter_list>(<param><decl><type><name>TkappObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if<condition>(<expr><name><name>self</name>-&gt;<name>wantobjects</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>value</name> <init>= <expr><call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>interp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Not sure whether the IncrRef is necessary, but something
		   may overwrite the interpreter result while we are
		   converting it. */</comment>
		<expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = <call><name>FromObj</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>interp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If the result contains any bytes with the top bit set,
		   it's UTF-8 and we should decode it to Unicode */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
		<while>while <condition>(<expr>*<name>p</name> != '\0'</expr>)</condition> <block>{
			<if>if <condition>(<expr>*<name>p</name> &amp; 0x80</expr>)</condition><then>
				<break>break;</break></then></if>
			<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
		}</block></while>

		<if>if <condition>(<expr>*<name>p</name> == '\0'</expr>)</condition><then>
			<expr_stmt><expr><name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>p</name>-<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<comment type="block">/* Convert UTF-8 to Unicode string */</comment>
			<expr_stmt><expr><name>p</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>p</name>-<name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>p</name>-<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>p</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>p</name>-<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></else></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* Tkapp_CallProc is the event procedure that is executed in the context of
   the Tcl interpreter thread. Initially, it holds the Tcl lock, and doesn't
   hold the Python lock. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Tkapp_CallProc</name><parameter_list>(<param><decl><type><name>Tkapp_CallEvent</name> *</type><name>e</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name><name>objStore</name><index>[<expr><name>ARGSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name> **</type><name>objv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>objc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ENTER_PYTHON</name></type>
	<name>objv</name> <init>= <expr><call><name>Tkapp_CallArgs</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>objStore</name></expr></argument>, <argument><expr>&amp;<name>objc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>objv</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>exc_type</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>exc_value</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>exc_tb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*(<name><name>e</name>-&gt;<name>res</name></name>) = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<macro><name>LEAVE_PYTHON</name></macro>
	<if>if <condition>(<expr>!<name>objv</name></expr>)</condition><then>
		<goto>goto <name>done</name>;</goto></then></if>
	<expr_stmt><expr><name>i</name> = <call><name>Tcl_EvalObjv</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>self</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr><name>objc</name></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ENTER_PYTHON</name></macro>
	<if>if <condition>(<expr><name>i</name> == <name>TCL_ERROR</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*(<name><name>e</name>-&gt;<name>res</name></name>) = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr>*(<name><name>e</name>-&gt;<name>exc_type</name></name>) = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr>*(<name><name>e</name>-&gt;<name>exc_tb</name></name>) = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr>*(<name><name>e</name>-&gt;<name>exc_value</name></name>) = <call><name>PyObject_CallFunction</name><argument_list>(
			<argument><expr><name>Tkinter_TclError</name></expr></argument>, <argument><expr>"s"</expr></argument>,
			<argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>self</name>-&gt;<name>interp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr>*(<name><name>e</name>-&gt;<name>res</name></name>) = <call><name>Tkapp_CallResult</name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>LEAVE_PYTHON</name>
  <name>done</name>:
	<comment type="block">/* Wake up calling thread. */</comment>
	<call><name>Tcl_MutexLock</name><argument_list>(<argument><expr>&amp;<name>call_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ConditionNotify</name><argument_list>(<argument><expr>&amp;<name><name>e</name>-&gt;<name>done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_MutexUnlock</name><argument_list>(<argument><expr>&amp;<name>call_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* This is the main entry point for calling a Tcl command.
   It supports three cases, with regard to threading:
   1. Tcl is not threaded: Must have the Tcl lock, then can invoke command in
      the context of the calling thread.
   2. Tcl is threaded, caller of the command is in the interpreter thread:
      Execute the command in the calling thread. Since the Tcl lock will
      not be used, we can merge that with case 1.
   3. Tcl is threaded, caller is in a different thread: Must queue an event to
      the interpreter thread. Allocation of Tcl objects needs to occur in the
      interpreter thread, so we ship the PyObject* args to the target thread,
      and perform processing there. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_Call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>selfptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name><name>objStore</name><index>[<expr><name>ARGSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name> **</type><name>objv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>objc</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TkappObject</name> *</type><name>self</name> <init>= <expr>(<name>TkappObject</name>*)<name>selfptr</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Could add TCL_EVAL_GLOBAL if wrapped by GlobalCall... */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>TCL_EVAL_DIRECT</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If args is a single tuple, replace with contents of tuple */</comment>
	<if>if <condition>(<expr>1 == <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
		<decl_stmt><decl><type><name>PyObject</name>*</type> <name>item</name> <init>= <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>args</name> = <name>item</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>threaded</name></name> &amp;&amp; <name><name>self</name>-&gt;<name>thread_id</name></name> != <call><name>Tcl_GetCurrentThread</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* We cannot call the command directly. Instead, we must
		   marshal the parameters to the interpreter thread. */</comment>
		<decl_stmt><decl><type><name>Tkapp_CallEvent</name> *</type><name>ev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc_type</name></decl>, *<decl><type ref="prev"/><name>exc_value</name></decl>, *<decl><type ref="prev"/><name>exc_tb</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>WaitForMainloop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>ev</name> = (<name>Tkapp_CallEvent</name>*)<call><name>ckalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tkapp_CallEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>ev</name>.<name>proc</name></name> = (<name>Tcl_EventProc</name>*)<name>Tkapp_CallProc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>self</name></name> = <name>self</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>args</name></name> = <name>args</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>res</name></name> = &amp;<name>res</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>exc_type</name></name> = &amp;<name>exc_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>exc_value</name></name> = &amp;<name>exc_value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>exc_tb</name></name> = &amp;<name>exc_tb</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>done</name></name> = (<name>Tcl_Condition</name>)0</expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Tkapp_ThreadSend</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>Tcl_Event</name>*)<name>ev</name></expr></argument>, <argument><expr>&amp;<name><name>ev</name>-&gt;<name>done</name></name></expr></argument>, <argument><expr>&amp;<name>call_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>exc_type</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>exc_type</name></expr></argument>, <argument><expr><name>exc_value</name></expr></argument>, <argument><expr><name>exc_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>Tkinter_TclError</name></expr></argument>, <argument><expr><name>exc_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		}</block></then></if>
	}</block></then>
	<else>else 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{

		<expr_stmt><expr><name>objv</name> = <call><name>Tkapp_CallArgs</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>objStore</name></expr></argument>, <argument><expr>&amp;<name>objc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>objv</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<decl_stmt><decl><type><name>ENTER_TCL</name></type>

		<name>i</name> <init>= <expr><call><name>Tcl_EvalObjv</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr><name>objc</name></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>ENTER_OVERLAP</name></macro>

		<if>if <condition>(<expr><name>i</name> == <name>TCL_ERROR</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>selfptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>res</name> = <call><name>Tkapp_CallResult</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

		<function_decl><type><name>LEAVE_OVERLAP_TCL</name></type>

		<name>Tkapp_CallDeallocArgs</name><parameter_list>(<param><decl><type><name>objv</name></type></decl></param>, <param><decl><type><name>objStore</name></type></decl></param>, <param><decl><type><name>objc</name></type></decl></param>)</parameter_list>;</function_decl>
	}</block></else></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GlobalCall</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Could do the same here as for Tkapp_Call(), but this is not used
	   much, so I can't be bothered.  Unfortunately Tcl doesn't export a
	   way for the user to do what all its Global* variants do (save and
	   reset the scope pointer, call the local version, restore the saved
	   scope pointer). */</comment>

	<decl_stmt><decl><type><name>char</name> *</type><name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmd</name>  = <call><name>Merge</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cmd</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ENTER_TCL</name></type>
		<name>err</name> <init>= <expr><call><name>Tcl_GlobalEval</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>ENTER_OVERLAP</name></macro>
		<if>if <condition>(<expr><name>err</name> == <name>TCL_ERROR</name></expr>)</condition><then>
			<expr_stmt><expr><name>res</name> = <call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>res</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Tkapp_Result</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<function_decl><type><name>LEAVE_OVERLAP_TCL</name></type>
		<name>ckfree</name><parameter_list>(<param><decl><type><name>cmd</name></type></decl></param>)</parameter_list>;</function_decl>
	}</block></then></if>

	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_Eval</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>script</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:eval"</expr></argument>, <argument><expr>&amp;<name>script</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>err</name> <init>= <expr><call><name>Tcl_Eval</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>err</name> == <name>TCL_ERROR</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Tkapp_Result</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GlobalEval</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>script</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:globaleval"</expr></argument>, <argument><expr>&amp;<name>script</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>err</name> <init>= <expr><call><name>Tcl_GlobalEval</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>err</name> == <name>TCL_ERROR</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Tkapp_Result</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_EvalFile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>fileName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:evalfile"</expr></argument>, <argument><expr>&amp;<name>fileName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>err</name> <init>= <expr><call><name>Tcl_EvalFile</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>err</name> == <name>TCL_ERROR</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Tkapp_Result</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_Record</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>script</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s"</expr></argument>, <argument><expr>&amp;<name>script</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>err</name> <init>= <expr><call><name>Tcl_RecordAndEval</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>TCL_NO_EVAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>err</name> == <name>TCL_ERROR</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Tkapp_Result</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_AddErrorInfo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>msg</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:adderrorinfo"</expr></argument>, <argument><expr>&amp;<name>msg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>Tcl_AddErrorInfo</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<function_decl><type><name>LEAVE_TCL</name></type>

	<name>Py_INCREF</name><parameter_list>(<param><decl><type><name>Py_None</name></type></decl></param>)</parameter_list>;</function_decl>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/** Tcl Variable **/</comment>

<macro><name>TCL_DECLARE_MUTEX</name><argument_list>(<argument>var_mutex</argument>)</argument_list></macro>

<typedef>typedef <function_decl><type><name>PyObject</name>*</type> (*<name>EventFunc</name>)<parameter_list>(<param><decl><type><name>PyObject</name>*</type></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <type><struct>struct <name>VarEvent</name> <block>{
	<decl_stmt><decl><type><name>Tcl_Event</name></type> <name>ev</name></decl>;</decl_stmt> <comment type="block">/* must be first */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EventFunc</name></type> <name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>exc_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>exc_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Condition</name></type> <name>cond</name></decl>;</decl_stmt>
}</block></struct></type> <name>VarEvent</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>varname_converter</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>in</name></decl></param>, <param><decl><type><name>void</name> *</type><name>_out</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> **</type><name>out</name> <init>= <expr>(<name>char</name>**)<name>_out</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>out</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyTclObject_Check</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>out</name> = <call><name>PyTclObject_TclString</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<comment type="block">/* XXX: Should give diagnostics. */</comment>
	<return>return <expr>0</expr>;</return>
}</block></function>	

<function><type><specifier>static</specifier> <name>void</name></type>
<name>var_perform</name><parameter_list>(<param><decl><type><name>VarEvent</name> *</type><name>ev</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr>*(<name><name>ev</name>-&gt;<name>res</name></name>) = <call><name><name>ev</name>-&gt;<name>func</name></name><argument_list>(<argument><expr><name><name>ev</name>-&gt;<name>self</name></name></expr></argument>, <argument><expr><name><name>ev</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name><name>ev</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!*(<name><name>ev</name>-&gt;<name>res</name></name>)</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>, *<decl><type ref="prev"/><name>tb</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_NormalizeException</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>&amp;<name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*(<name><name>ev</name>-&gt;<name>exc_type</name></name>) = <name>exc</name></expr>;</expr_stmt>
		<expr_stmt><expr>*(<name><name>ev</name>-&gt;<name>exc_val</name></name>) = <name>val</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
		
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>var_proc</name><parameter_list>(<param><decl><type><name>VarEvent</name>*</type> <name>ev</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<function_decl><type><name>ENTER_PYTHON</name></type>
        <name>var_perform</name><parameter_list>(<param><decl><type><name>ev</name></type></decl></param>)</parameter_list>;</function_decl>
	<expr_stmt><expr><call><name>Tcl_MutexLock</name><argument_list>(<argument><expr>&amp;<name>var_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ConditionNotify</name><argument_list>(<argument><expr>&amp;<name><name>ev</name>-&gt;<name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_MutexUnlock</name><argument_list>(<argument><expr>&amp;<name>var_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>LEAVE_PYTHON</name></macro>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>var_invoke</name><parameter_list>(<param><decl><type><name>EventFunc</name></type> <name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>selfptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>TkappObject</name> *</type><name>self</name> <init>= <expr>(<name>TkappObject</name>*)<name>selfptr</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>threaded</name></name> &amp;&amp; <name><name>self</name>-&gt;<name>thread_id</name></name> != <call><name>Tcl_GetCurrentThread</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>TkappObject</name> *</type><name>self</name> <init>= <expr>(<name>TkappObject</name>*)<name>selfptr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VarEvent</name> *</type><name>ev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>, *<decl><type ref="prev"/><name>exc_type</name></decl>, *<decl><type ref="prev"/><name>exc_val</name></decl>;</decl_stmt>
		
		<comment type="block">/* The current thread is not the interpreter thread.  Marshal
		   the call to the interpreter thread, then wait for
		   completion. */</comment>
		<if>if <condition>(<expr>!<call><name>WaitForMainloop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<expr_stmt><expr><name>ev</name> = (<name>VarEvent</name>*)<call><name>ckalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VarEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ev</name>-&gt;<name>self</name></name> = <name>selfptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>args</name></name> = <name>args</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>res</name></name> = &amp;<name>res</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>exc_type</name></name> = &amp;<name>exc_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>exc_val</name></name> = &amp;<name>exc_val</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>cond</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>ev</name>.<name>proc</name></name> = (<name>Tcl_EventProc</name>*)<name>var_proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tkapp_ThreadSend</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>Tcl_Event</name>*)<name>ev</name></expr></argument>, <argument><expr>&amp;<name><name>ev</name>-&gt;<name>cond</name></name></expr></argument>, <argument><expr>&amp;<name>var_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>res</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>exc_type</name></expr></argument>, <argument><expr><name>exc_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>exc_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>exc_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Tcl is not threaded, or this is the interpreter thread. */</comment>
	<return>return <expr><call><name>func</name><argument_list>(<argument><expr><name>selfptr</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SetVar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name1</name></decl>, *<decl><type ref="prev"/><name>name2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>newval</name></decl>, *<decl><type ref="prev"/><name>ok</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;O:setvar"</expr></argument>, 
			     <argument><expr><name>varname_converter</name></expr></argument>, <argument><expr>&amp;<name>name1</name></expr></argument>, <argument><expr>&amp;<name>newValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* XXX Acquire tcl lock??? */</comment>
		<expr_stmt><expr><name>newval</name> = <call><name>AsObj</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newval</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<decl_stmt><decl><type><name>ENTER_TCL</name></type>
		<name>ok</name> <init>= <expr><call><name>Tcl_SetVar2Ex</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, 
				   <argument><expr><name>newval</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>ENTER_OVERLAP</name></macro>
		<if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><name>res</name> = <name>Py_None</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name>LEAVE_OVERLAP_TCL</name></expr></expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ssO:setvar"</expr></argument>,
				     <argument><expr>&amp;<name>name1</name></expr></argument>, <argument><expr>&amp;<name>name2</name></expr></argument>, <argument><expr>&amp;<name>newValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* XXX must hold tcl lock already??? */</comment>
			<expr_stmt><expr><name>newval</name> = <call><name>AsObj</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>ENTER_TCL</name></type>
			<name>ok</name> <init>= <expr><call><name>Tcl_SetVar2Ex</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>ENTER_OVERLAP</name></macro>
			<if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <block>{
				<expr_stmt><expr><name>res</name> = <name>Py_None</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><name>LEAVE_OVERLAP_TCL</name></expr></expr_stmt>
		}</block></then>
		<else>else <block>{
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></else></if>
	}</block></else></if>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_SetVar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>var_invoke</name><argument_list>(<argument><expr><name>SetVar</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>TCL_LEAVE_ERR_MSG</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GlobalSetVar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>var_invoke</name><argument_list>(<argument><expr><name>SetVar</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>TCL_LEAVE_ERR_MSG</name> | <name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>GetVar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name1</name></decl>, *<decl><type ref="prev"/><name>name2</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>tres</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;|s:getvar"</expr></argument>, 
			      <argument><expr><name>varname_converter</name></expr></argument>, <argument><expr>&amp;<name>name1</name></expr></argument>, <argument><expr>&amp;<name>name2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>tres</name> <init>= <expr><call><name>Tcl_GetVar2Ex</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>tres</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Tkinter_TclError</name></expr></argument>, <argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<if>if <condition>(<expr>((<name>TkappObject</name>*)<name>self</name>)-&gt;<name>wantobjects</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>res</name> = <call><name>FromObj</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>tres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>res</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name>tres</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GetVar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>var_invoke</name><argument_list>(<argument><expr><name>GetVar</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>TCL_LEAVE_ERR_MSG</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GlobalGetVar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>var_invoke</name><argument_list>(<argument><expr><name>GetVar</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>TCL_LEAVE_ERR_MSG</name> | <name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>UnsetVar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name1</name></decl>, *<decl><type ref="prev"/><name>name2</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|s:unsetvar"</expr></argument>, <argument><expr>&amp;<name>name1</name></expr></argument>, <argument><expr>&amp;<name>name2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>code</name> <init>= <expr><call><name>Tcl_UnsetVar2</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>code</name> == <name>TCL_ERROR</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> = <name>Py_None</name></expr>;</expr_stmt>
	}</block></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_UnsetVar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>var_invoke</name><argument_list>(<argument><expr><name>UnsetVar</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>TCL_LEAVE_ERR_MSG</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GlobalUnsetVar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>var_invoke</name><argument_list>(<argument><expr><name>UnsetVar</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>TCL_LEAVE_ERR_MSG</name> | <name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/** Tcl to Python **/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GetInt</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name>*</type> <name>o</name> <init>= <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>o</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:getint"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>Tcl_GetInt</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call> == <name>TCL_ERROR</name></expr>)</condition><then>
		<return>return <expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GetDouble</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>o</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:getdouble"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>Tcl_GetDouble</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call> == <name>TCL_ERROR</name></expr>)</condition><then>
		<return>return <expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"d"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GetBoolean</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>o</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:getboolean"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>Tcl_GetBoolean</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call> == <name>TCL_ERROR</name></expr>)</condition><then>
		<return>return <expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_ExprString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:exprstring"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	
	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>retval</name> <init>= <expr><call><name>Tcl_ExprString</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>retval</name> == <name>TCL_ERROR</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"s"</expr></argument>, <argument><expr><call><name>Tkapp_Result</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_ExprLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:exprlong"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>retval</name> <init>= <expr><call><name>Tcl_ExprLong</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>retval</name> == <name>TCL_ERROR</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"l"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_ExprDouble</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:exprdouble"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"Tkapp_ExprDouble"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>retval</name> <init>= <expr><call><name>Tcl_ExprDouble</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ENTER_OVERLAP</name></type>
	<name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list>
	if <argument_list>(<argument><expr><name>retval</name> == <name>TCL_ERROR</name></expr></argument>)</argument_list>
		<name>res</name> <init>= <expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"d"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_ExprBoolean</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:exprboolean"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>retval</name> <init>= <expr><call><name>Tcl_ExprBoolean</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>retval</name> == <name>TCL_ERROR</name></expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>res</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_SplitList</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>argv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>v</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:splitlist"</expr></argument>, <argument><expr>"utf-8"</expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>Tcl_SplitList</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>list</name></expr></argument>, 
			  <argument><expr>&amp;<name>argc</name></expr></argument>, <argument><expr>&amp;<name>argv</name></expr></argument>)</argument_list></call> == <name>TCL_ERROR</name></expr>)</condition><then>  <block>{
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!(<name>v</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
		<goto>goto <name>finally</name>;</goto></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>s</name> || <call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>
			<goto>goto <name>finally</name>;</goto>
		}</block></then></if>
	}</block></for>

  <label><name>finally</name>:</label>
	<macro><name>ckfree</name><argument_list>(<argument>FREECAST argv</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_Split</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>list</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name>*</type> <name>o</name> <init>= <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>o</name> = <call><name>SplitObj</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>o</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"et:split"</expr></argument>, <argument><expr>"utf-8"</expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>Split</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_Merge</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>Merge</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>s</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>res</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/** Tcl Command **/</comment>

<comment type="block">/* Client data struct */</comment>
<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
}</block></struct></type> <name>PythonCmd_ClientData</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>PythonCmd_Error</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name>errorInCmd</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>excInCmd</name></expr></argument>, <argument><expr>&amp;<name>valInCmd</name></expr></argument>, <argument><expr>&amp;<name>trbInCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>LEAVE_PYTHON</name></macro>
	<return>return <expr><name>TCL_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This is the Tcl command that acts as a wrapper for Python
 * function or method.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>PythonCmd</name><parameter_list>(<param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>, <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> *</type><name><name>argv</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PythonCmd_ClientData</name> *</type><name>data</name> <init>= <expr>(<name>PythonCmd_ClientData</name> *)<name>clientData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>, *<decl><type ref="prev"/><name>func</name></decl>, *<decl><type ref="prev"/><name>arg</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>obj_res</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ENTER_PYTHON</name></type>

	<comment type="block">/* TBD: no error checking here since we know, via the
	 * Tkapp_CreateCommand() that the client data is a two-tuple
	 */</comment>
	<name>self</name> <init>= <expr><name><name>data</name>-&gt;<name>self</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>func</name> = <name><name>data</name>-&gt;<name>func</name></name></expr>;</expr_stmt>

	<comment type="block">/* Create argument list (argv1, ..., argvN) */</comment>
	<if>if <condition>(<expr>!(<name>arg</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>argc</name> - 1</expr></argument>)</argument_list></call>)</expr>)</condition><then>
		<return>return <expr><call><name>PythonCmd_Error</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<name>argc</name> - 1)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>s</name> || <call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>PythonCmd_Error</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PythonCmd_Error</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>obj_res</name> = <call><name>AsObj</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>obj_res</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PythonCmd_Error</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> = <name>TCL_OK</name></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>LEAVE_PYTHON</name></macro>

	<return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>PythonCmdDelete</name><parameter_list>(<param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PythonCmd_ClientData</name> *</type><name>data</name> <init>= <expr>(<name>PythonCmd_ClientData</name> *)<name>clientData</name></expr></init></decl>;</decl_stmt>

	<function_decl><type><name>ENTER_PYTHON</name></type>
	<name>Py_XDECREF</name><parameter_list>(<param><decl><type><name><name>data</name>-&gt;<name>self</name></name></type></decl></param>)</parameter_list>;</function_decl>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>data</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LEAVE_PYTHON</name></expr></expr_stmt>
}</block></function>


<escape char="0xc"/>

<macro><name>TCL_DECLARE_MUTEX</name><argument_list>(<argument>command_mutex</argument>)</argument_list></macro>

<typedef>typedef <type><struct>struct <name>CommandEvent</name><block>{
	<decl_stmt><decl><type><name>Tcl_Event</name></type> <name>ev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Interp</name>*</type> <name>interp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>create</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> *</type><name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ClientData</name> *</type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Condition</name></type> <name>done</name></decl>;</decl_stmt>
}</block></struct></type> <name>CommandEvent</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Tkapp_CommandProc</name><parameter_list>(<param><decl><type><name>CommandEvent</name> *</type><name>ev</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>ev</name>-&gt;<name>create</name></name></expr>)</condition><then>
		<expr_stmt><expr>*<name><name>ev</name>-&gt;<name>status</name></name> = <call><name>Tcl_CreateCommand</name><argument_list>(
			<argument><expr><name><name>ev</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr><name><name>ev</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>PythonCmd</name></expr></argument>,
			<argument><expr><name><name>ev</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>PythonCmdDelete</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr>*<name><name>ev</name>-&gt;<name>status</name></name> = <call><name>Tcl_DeleteCommand</name><argument_list>(<argument><expr><name><name>ev</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr><name><name>ev</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Tcl_MutexLock</name><argument_list>(<argument><expr>&amp;<name>command_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ConditionNotify</name><argument_list>(<argument><expr>&amp;<name><name>ev</name>-&gt;<name>done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_MutexUnlock</name><argument_list>(<argument><expr>&amp;<name>command_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_CreateCommand</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>selfptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>TkappObject</name> *</type><name>self</name> <init>= <expr>(<name>TkappObject</name>*)<name>selfptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PythonCmd_ClientData</name> *</type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>cmdName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"sO:createcommand"</expr></argument>, <argument><expr>&amp;<name>cmdName</name></expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"command not callable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>threaded</name></name> &amp;&amp; <name><name>self</name>-&gt;<name>thread_id</name></name> != <call><name>Tcl_GetCurrentThread</name><argument_list>()</argument_list></call> &amp;&amp;
	    !<call><name>WaitForMainloop</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>data</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>PythonCmd_ClientData</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>data</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name>-&gt;<name>self</name></name> = <name>selfptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
	
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>threaded</name></name> &amp;&amp; <name><name>self</name>-&gt;<name>thread_id</name></name> != <call><name>Tcl_GetCurrentThread</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>CommandEvent</name> *</type><name>ev</name> <init>= <expr>(<name>CommandEvent</name>*)<call><name>ckalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CommandEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>ev</name>.<name>proc</name></name> = (<name>Tcl_EventProc</name>*)<name>Tkapp_CommandProc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>interp</name></name> = <name><name>self</name>-&gt;<name>interp</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>create</name></name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>name</name></name> = <name>cmdName</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>data</name></name> = (<name>ClientData</name>)<name>data</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>status</name></name> = &amp;<name>err</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>done</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tkapp_ThreadSend</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>Tcl_Event</name>*)<name>ev</name></expr></argument>, <argument><expr>&amp;<name><name>ev</name>-&gt;<name>done</name></name></expr></argument>, <argument><expr>&amp;<name>command_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>ENTER_TCL</name></type>
		<name>err</name> <init>= <expr><call><name>Tcl_CreateCommand</name><argument_list>(
			<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmdName</name></expr></argument>, <argument><expr><name>PythonCmd</name></expr></argument>,
			<argument><expr>(<name>ClientData</name>)<name>data</name></expr></argument>, <argument><expr><name>PythonCmdDelete</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>LEAVE_TCL</name></expr></expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Tkinter_TclError</name></expr></argument>, <argument><expr>"can't create Tcl command"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_DeleteCommand</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>selfptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>TkappObject</name> *</type><name>self</name> <init>= <expr>(<name>TkappObject</name>*)<name>selfptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>cmdName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:deletecommand"</expr></argument>, <argument><expr>&amp;<name>cmdName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>threaded</name></name> &amp;&amp; <name><name>self</name>-&gt;<name>thread_id</name></name> != <call><name>Tcl_GetCurrentThread</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>CommandEvent</name> *</type><name>ev</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>ev</name> = (<name>CommandEvent</name>*)<call><name>ckalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CommandEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>ev</name>.<name>proc</name></name> = (<name>Tcl_EventProc</name>*)<name>Tkapp_CommandProc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>interp</name></name> = <name><name>self</name>-&gt;<name>interp</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>create</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>name</name></name> = <name>cmdName</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>status</name></name> = &amp;<name>err</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ev</name>-&gt;<name>done</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tkapp_ThreadSend</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>Tcl_Event</name>*)<name>ev</name></expr></argument>, <argument><expr>&amp;<name><name>ev</name>-&gt;<name>done</name></name></expr></argument>, 
				 <argument><expr>&amp;<name>command_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>ENTER_TCL</name></type>
		<name>err</name> <init>= <expr><call><name>Tcl_DeleteCommand</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>interp</name></name></expr></argument>, <argument><expr><name>cmdName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>LEAVE_TCL</name></expr></expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>err</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Tkinter_TclError</name></expr></argument>, <argument><expr>"can't delete Tcl command"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CREATEFILEHANDLER</name></cpp:ifdef>
<comment type="block">/** File Handler **/</comment>

<typedef>typedef <type><struct>struct <name>_fhcdata</name> <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>_fhcdata</name> *</type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>FileHandler_ClientData</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>FileHandler_ClientData</name> *</type><name>HeadFHCD</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>FileHandler_ClientData</name> *</type>
<name>NewFHCD</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>file</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FileHandler_ClientData</name> *</type><name>p</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>p</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>FileHandler_ClientData</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name>-&gt;<name>file</name></name> = <name>file</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name>-&gt;<name>id</name></name> = <name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name>-&gt;<name>next</name></name> = <name>HeadFHCD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>HeadFHCD</name> = <name>p</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>p</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeleteFHCD</name><parameter_list>(<param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FileHandler_ClientData</name> *</type><name>p</name></decl>, **<decl><type ref="prev"/><name>pp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pp</name> = &amp;<name>HeadFHCD</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>p</name> = *<name>pp</name>) != <name>NULL</name></expr>)</condition> <block>{
		<if>if <condition>(<expr><name><name>p</name>-&gt;<name>id</name></name> == <name>id</name></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>pp</name> = <name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>pp</name> = &amp;<name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt></else></if>
	}</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FileHandler</name><parameter_list>(<param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>, <param><decl><type><name>int</name></type> <name>mask</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FileHandler_ClientData</name> *</type><name>data</name> <init>= <expr>(<name>FileHandler_ClientData</name> *)<name>clientData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>file</name></decl>, *<decl><type ref="prev"/><name>arg</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ENTER_PYTHON</name></type>
	<name>func</name> <init>= <expr><name><name>data</name>-&gt;<name>func</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>file</name> = <name><name>data</name>-&gt;<name>file</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>arg</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(Oi)"</expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr>(<name>long</name>) <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>errorInCmd</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>excInCmd</name></expr></argument>, <argument><expr>&amp;<name>valInCmd</name></expr></argument>, <argument><expr>&amp;<name>trbInCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LEAVE_PYTHON</name></expr></expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_CreateFileHandler</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
     <comment type="block">/* args is (file, mask, func) */</comment>
<block>{
	<decl_stmt><decl><type><name>FileHandler_ClientData</name> *</type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>file</name></decl>, *<decl><type ref="prev"/><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mask</name></decl>, <decl><type ref="prev"/><name>tfile</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OiO:createfilehandler"</expr></argument>,
			      <argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr>&amp;<name>mask</name></expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr>!<name>self</name> &amp;&amp; !<name>tcl_lock</name></expr>)</condition><then> <block>{
		<comment type="block">/* We don't have the Tcl lock since Tcl is threaded. */</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"_tkinter.createfilehandler not supported "
				"for threaded Tcl"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>tfile</name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tfile</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"bad argument list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>data</name> = <call><name>NewFHCD</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>tfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>data</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Ought to check for null Tcl_File object... */</comment>
	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>Tcl_CreateFileHandler</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>FileHandler</name></expr></argument>, <argument><expr>(<name>ClientData</name>) <name>data</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<function_decl><type><name>LEAVE_TCL</name></type>
	<name>Py_INCREF</name><parameter_list>(<param><decl><type><name>Py_None</name></type></decl></param>)</parameter_list>;</function_decl>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_DeleteFileHandler</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tfile</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:deletefilehandler"</expr></argument>, <argument><expr>&amp;<name>file</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr>!<name>self</name> &amp;&amp; !<name>tcl_lock</name></expr>)</condition><then> <block>{
		<comment type="block">/* We don't have the Tcl lock since Tcl is threaded. */</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"_tkinter.deletefilehandler not supported "
				"for threaded Tcl"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>tfile</name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tfile</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>DeleteFHCD</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ought to check for null Tcl_File object... */</comment>
	<function_decl><type><name>ENTER_TCL</name></type>
	<name>Tcl_DeleteFileHandler</name><parameter_list>(<param><decl><type><name>tfile</name></type></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>LEAVE_TCL</name></type>
	<name>Py_INCREF</name><parameter_list>(<param><decl><type><name>Py_None</name></type></decl></param>)</parameter_list>;</function_decl>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CREATEFILEHANDLER */</comment>

<escape char="0xc"/>
<comment type="block">/**** Tktt Object (timer token) ****/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Tktt_Type</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>Tcl_TimerToken</name></type> <name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
}</block></struct></type> <name>TkttObject</name>;</typedef>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tktt_DeleteTimerHandler</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>TkttObject</name> *</type><name>v</name> <init>= <expr>(<name>TkttObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr><name><name>v</name>-&gt;<name>func</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>":deletetimerhandler"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>v</name>-&gt;<name>token</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Tcl_DeleteTimerHandler</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>v</name>-&gt;<name>token</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>func</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>v</name>-&gt;<name>func</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* See Tktt_New() */</comment>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>Tktt_methods</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr>"deletetimerhandler"</expr>, <expr><name>Tktt_DeleteTimerHandler</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>TkttObject</name> *</type>
<name>Tktt_New</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>func</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>TkttObject</name> *</type><name>v</name></decl>;</decl_stmt>
  
	<expr_stmt><expr><name>v</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>TkttObject</name></expr></argument>, <argument><expr>&amp;<name>Tktt_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>token</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>

	<comment type="block">/* Extra reference, deleted when called or when handler is deleted */</comment>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Tktt_Dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>TkttObject</name> *</type><name>v</name> <init>= <expr>(<name>TkttObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr><name><name>v</name>-&gt;<name>func</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tktt_Repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>TkttObject</name> *</type><name>v</name> <init>= <expr>(<name>TkttObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"&lt;tktimertoken at %p%s&gt;"</expr></argument>, <argument><expr><name>v</name></expr></argument>,
	                <argument><expr><name><name>v</name>-&gt;<name>func</name></name> == <name>NULL</name> ? ", handler deleted" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tktt_GetAttr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_FindMethod</name><argument_list>(<argument><expr><name>Tktt_methods</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Tktt_Type</name> <init>=
<expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"tktimertoken"</expr>,			     <comment type="block">/*tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>TkttObject</name></expr></argument>)</argument_list></sizeof></expr>,		     <comment type="block">/*tp_basicsize */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_itemsize */</comment>
	<expr><name>Tktt_Dealloc</name></expr>,			     <comment type="block">/*tp_dealloc */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_print */</comment>
	<expr><name>Tktt_GetAttr</name></expr>,			     <comment type="block">/*tp_getattr */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_setattr */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_compare */</comment>
	<expr><name>Tktt_Repr</name></expr>,			     <comment type="block">/*tp_repr */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_as_number */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_as_sequence */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_as_mapping */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_hash */</comment>
}</block></expr></init></decl>;</decl_stmt>


<escape char="0xc"/>
<comment type="block">/** Timer Handler **/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>TimerHandler</name><parameter_list>(<param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>TkttObject</name> *</type><name>v</name> <init>= <expr>(<name>TkttObject</name> *)<name>clientData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr><name><name>v</name>-&gt;<name>func</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name><name>v</name>-&gt;<name>func</name></name> = <name>NULL</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ENTER_PYTHON</name></type>

	<name>res</name>  <init>= <expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* See Tktt_New() */</comment>

	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>errorInCmd</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>excInCmd</name></expr></argument>, <argument><expr>&amp;<name>valInCmd</name></expr></argument>, <argument><expr>&amp;<name>trbInCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<expr_stmt><expr><name>LEAVE_PYTHON</name></expr></expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_CreateTimerHandler</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>milliseconds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TkttObject</name> *</type><name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iO:createtimerhandler"</expr></argument>,
			      <argument><expr>&amp;<name>milliseconds</name></expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"bad argument list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr>!<name>self</name> &amp;&amp; !<name>tcl_lock</name></expr>)</condition><then> <block>{
		<comment type="block">/* We don't have the Tcl lock since Tcl is threaded. */</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"_tkinter.createtimerhandler not supported "
				"for threaded Tcl"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>v</name> = <call><name>Tktt_New</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>v</name>-&gt;<name>token</name></name> = <call><name>Tcl_CreateTimerHandler</name><argument_list>(<argument><expr><name>milliseconds</name></expr></argument>, <argument><expr><name>TimerHandler</name></expr></argument>,
						  <argument><expr>(<name>ClientData</name>)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr>(<name>PyObject</name> *) <name>v</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/** Event Loop **/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_MainLoop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>selfptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>threshold</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TkappObject</name> *</type><name>self</name> <init>= <expr>(<name>TkappObject</name>*)<name>selfptr</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_Get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:mainloop"</expr></argument>, <argument><expr>&amp;<name>threshold</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr>!<name>self</name> &amp;&amp; !<name>tcl_lock</name></expr>)</condition><then> <block>{
		<comment type="block">/* We don't have the Tcl lock since Tcl is threaded. */</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
				<argument><expr>"_tkinter.mainloop not supported "
				"for threaded Tcl"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>dispatching</name></name> = 1</expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>quitMainLoop</name> = 0</expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>Tk_GetNumMainWindows</name><argument_list>()</argument_list></call> &gt; <name>threshold</name> &amp;&amp;
	       !<name>quitMainLoop</name> &amp;&amp;
	       !<name>errorInCmd</name></expr>)</condition>
	<block>{
		<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
		<if>if <condition>(<expr><name>self</name> &amp;&amp; <name><name>self</name>-&gt;<name>threaded</name></name></expr>)</condition><then> <block>{
			<comment type="block">/* Allow other Python threads to run. */</comment>
			<decl_stmt><decl><type><name>ENTER_TCL</name></type>
			<name>result</name> <init>= <expr><call><name>Tcl_DoOneEvent</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>LEAVE_TCL</name></expr></expr_stmt>
		}</block></then>
		<else>else <block>{
			<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
			<if>if<condition>(<expr><name>tcl_lock</name></expr>)</condition><then><expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>tcl_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>tcl_tstate</name> = <name>tstate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> = <call><name>Tcl_DoOneEvent</name><argument_list>(<argument><expr><name>TCL_DONT_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tcl_tstate</name> = <name>NULL</name></expr>;</expr_stmt>
			<if>if<condition>(<expr><name>tcl_lock</name></expr>)</condition><then><expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>tcl_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><name>Tkinter_busywaitinterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
		}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>result</name> = <call><name>Tcl_DoOneEvent</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if>if <condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>self</name></expr>)</condition><then>
				<expr_stmt><expr><name><name>self</name>-&gt;<name>dispatching</name></name> = 0</expr>;</expr_stmt></then></if>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></while>
	<if>if <condition>(<expr><name>self</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>dispatching</name></name> = 0</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>quitMainLoop</name> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr><name>errorInCmd</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>errorInCmd</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>excInCmd</name></expr></argument>, <argument><expr><name>valInCmd</name></expr></argument>, <argument><expr><name>trbInCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>excInCmd</name> = <name>valInCmd</name> = <name>trbInCmd</name> = <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_DoOneEvent</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:dooneevent"</expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>rv</name> <init>= <expr><call><name>Tcl_DoOneEvent</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>LEAVE_TCL</name></macro>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_Quit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>":quit"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>quitMainLoop</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_InterpAddr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>":interpaddr"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>	*</type>
<name>Tkapp_TkInit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>has_failed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name> <init>= <expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tk_Window</name></type> <name>main_window</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>_tk_exists</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>main_window</name> = <call><name>Tk_MainWindow</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* In all current versions of Tk (including 8.4.13), Tk_Init
	   deadlocks on the second call when the first call failed.
	   To avoid the deadlock, we just refuse the second call through
	   a static variable. */</comment>
	<if>if <condition>(<expr><name>has_failed</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Tkinter_TclError</name></expr></argument>, 
				<argument><expr>"Calling Tk_Init again after a previous call failed might deadlock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	   
	<comment type="block">/* We want to guard against calling Tk_Init() multiple times */</comment>
	<expr_stmt><expr><name>CHECK_TCL_APPARTMENT</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>err</name> <init>= <expr><call><name>Tcl_Eval</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"info exists	tk_version"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ENTER_OVERLAP</name></macro>
	<if>if <condition>(<expr><name>err</name> == <name>TCL_ERROR</name></expr>)</condition><then> <block>{
		<comment type="block">/* This sets an exception, but we cannot return right
		   away because we need to exit the overlap first. */</comment>
		<expr_stmt><expr><call><name>Tkinter_Error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>_tk_exists</name> = <call><name>Tkapp_Result</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<macro><name>LEAVE_OVERLAP_TCL</name></macro>
	<if>if <condition>(<expr><name>err</name> == <name>TCL_ERROR</name></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>_tk_exists</name> == <name>NULL</name> || <call><name>strcmp</name><argument_list>(<argument><expr><name>_tk_exists</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>	<block>{
		<if>if <condition>(<expr><call><name>Tk_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call>	== <name>TCL_ERROR</name></expr>)</condition><then> <block>{
		        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>Tkinter_TclError</name></expr></argument>, <argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>has_failed</name> = 1</expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_WantObjects</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{

	<decl_stmt><decl><type><name>int</name></type> <name>wantobjects</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:wantobjects"</expr></argument>, <argument><expr>&amp;<name>wantobjects</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>wantobjects</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>((<name>TkappObject</name>*)<name>self</name>)-&gt;<name>wantobjects</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr>((<name>TkappObject</name>*)<name>self</name>)-&gt;<name>wantobjects</name> = <name>wantobjects</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_WillDispatch</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{

	<expr_stmt><expr>((<name>TkappObject</name>*)<name>self</name>)-&gt;<name>dispatching</name> = 1</expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/**** Tkapp Method List ****/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>Tkapp_methods</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr>"willdispatch"</expr>,       <expr><name>Tkapp_WillDispatch</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"wantobjects"</expr>,	       <expr><name>Tkapp_WantObjects</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"call"</expr>, 	       <expr><name>Tkapp_Call</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"globalcall"</expr>, 	       <expr><name>Tkapp_GlobalCall</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"eval"</expr>, 	       <expr><name>Tkapp_Eval</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"globaleval"</expr>, 	       <expr><name>Tkapp_GlobalEval</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"evalfile"</expr>, 	       <expr><name>Tkapp_EvalFile</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"record"</expr>, 	       <expr><name>Tkapp_Record</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"adderrorinfo"</expr>,       <expr><name>Tkapp_AddErrorInfo</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"setvar"</expr>, 	       <expr><name>Tkapp_SetVar</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"globalsetvar"</expr>,       <expr><name>Tkapp_GlobalSetVar</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"getvar"</expr>, 	       <expr><name>Tkapp_GetVar</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"globalgetvar"</expr>,       <expr><name>Tkapp_GlobalGetVar</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"unsetvar"</expr>, 	       <expr><name>Tkapp_UnsetVar</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"globalunsetvar"</expr>,     <expr><name>Tkapp_GlobalUnsetVar</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"getint"</expr>, 	       <expr><name>Tkapp_GetInt</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"getdouble"</expr>, 	       <expr><name>Tkapp_GetDouble</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"getboolean"</expr>, 	       <expr><name>Tkapp_GetBoolean</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"exprstring"</expr>, 	       <expr><name>Tkapp_ExprString</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"exprlong"</expr>, 	       <expr><name>Tkapp_ExprLong</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"exprdouble"</expr>, 	       <expr><name>Tkapp_ExprDouble</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"exprboolean"</expr>,        <expr><name>Tkapp_ExprBoolean</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"splitlist"</expr>, 	       <expr><name>Tkapp_SplitList</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"split"</expr>, 	       <expr><name>Tkapp_Split</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"merge"</expr>, 	       <expr><name>Tkapp_Merge</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"createcommand"</expr>,      <expr><name>Tkapp_CreateCommand</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"deletecommand"</expr>,      <expr><name>Tkapp_DeleteCommand</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CREATEFILEHANDLER</name></cpp:ifdef>
	<expr><block>{<expr>"createfilehandler"</expr>,  <expr><name>Tkapp_CreateFileHandler</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"deletefilehandler"</expr>,  <expr><name>Tkapp_DeleteFileHandler</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"createtimerhandler"</expr>, <expr><name>Tkapp_CreateTimerHandler</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"mainloop"</expr>, 	       <expr><name>Tkapp_MainLoop</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"dooneevent"</expr>, 	       <expr><name>Tkapp_DoOneEvent</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"quit"</expr>, 	       <expr><name>Tkapp_Quit</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"interpaddr"</expr>,         <expr><name>Tkapp_InterpAddr</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"loadtk"</expr>,	       <expr><name>Tkapp_TkInit</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, 		       <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<escape char="0xc"/>
<comment type="block">/**** Tkapp Type Methods ****/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Tkapp_Dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/*CHECK_TCL_APPARTMENT;*/</comment>
	<decl_stmt><decl><type><name>ENTER_TCL</name></type>
	<name>Tcl_DeleteInterp</name><argument_list>(<argument><expr><call><name>Tkapp_Interp</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
	<function_decl><type><name>LEAVE_TCL</name></type>
	<name>PyObject_Del</name><parameter_list>(<param><decl><type><name>self</name></type></decl></param>)</parameter_list>;</function_decl>
	<expr_stmt><expr><call><name>DisableEventHook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkapp_GetAttr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_FindMethod</name><argument_list>(<argument><expr><name>Tkapp_methods</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Tkapp_Type</name> <init>=
<expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"tkapp"</expr>,			     <comment type="block">/*tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>TkappObject</name></expr></argument>)</argument_list></sizeof></expr>,		     <comment type="block">/*tp_basicsize */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_itemsize */</comment>
	<expr><name>Tkapp_Dealloc</name></expr>,			     <comment type="block">/*tp_dealloc */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_print */</comment>
	<expr><name>Tkapp_GetAttr</name></expr>,			     <comment type="block">/*tp_getattr */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_setattr */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_compare */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_repr */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_as_number */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_as_sequence */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_as_mapping */</comment>
	<expr>0</expr>,				     <comment type="block">/*tp_hash */</comment>
}</block></expr></init></decl>;</decl_stmt>


<escape char="0xc"/>
<comment type="block">/**** Tkinter Module ****/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt> <comment type="block">/* current size */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>maxsize</name></decl>;</decl_stmt> <comment type="block">/* allocated size */</comment>
}</block></struct></type> <name>FlattenContext</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_bump</name><parameter_list>(<param><decl><type><name>FlattenContext</name>*</type> <name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* expand tuple to hold (at least) size new items.
	   return true if successful, false if an exception was raised */</comment>

	<decl_stmt><decl><type><name>int</name></type> <name>maxsize</name> <init>= <expr><name><name>context</name>-&gt;<name>maxsize</name></name> * 2</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>maxsize</name> &lt; <name><name>context</name>-&gt;<name>size</name></name> + <name>size</name></expr>)</condition><then>
		<expr_stmt><expr><name>maxsize</name> = <name><name>context</name>-&gt;<name>size</name></name> + <name>size</name></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name><name>context</name>-&gt;<name>maxsize</name></name> = <name>maxsize</name></expr>;</expr_stmt>

	<return>return <expr><call><name>_PyTuple_Resize</name><argument_list>(<argument><expr>&amp;<name><name>context</name>-&gt;<name>tuple</name></name></expr></argument>, <argument><expr><name>maxsize</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_flatten1</name><parameter_list>(<param><decl><type><name>FlattenContext</name>*</type> <name>context</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>item</name></decl></param>, <param><decl><type><name>int</name></type> <name>depth</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* add tuple or list to argument tuple (recursively) */</comment>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>depth</name> &gt; 1000</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"nesting too deep in _flatten"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>size</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* preallocate (assume no nesting) */</comment>
		<if>if <condition>(<expr><name><name>context</name>-&gt;<name>size</name></name> + <name>size</name> &gt; <name><name>context</name>-&gt;<name>maxsize</name></name> &amp;&amp;
		    !<call><name>_bump</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<comment type="block">/* copy items to output tuple */</comment>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>!<call><name>_flatten1</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>depth</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then>
					<return>return <expr>0</expr>;</return></then></if>
			}</block></then> <else>else <if>if <condition>(<expr><name>o</name> != <name>Py_None</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name><name>context</name>-&gt;<name>size</name></name> + 1 &gt; <name><name>context</name>-&gt;<name>maxsize</name></name> &amp;&amp;
				    !<call><name>_bump</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
					<return>return <expr>0</expr>;</return></then></if>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name><name>context</name>-&gt;<name>tuple</name></name></expr></argument>,
						 <argument><expr><name><name>context</name>-&gt;<name>size</name></name>++</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if></else></if>
		}</block></for>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* same, for tuples */</comment>
		<expr_stmt><expr><name>size</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>context</name>-&gt;<name>size</name></name> + <name>size</name> &gt; <name><name>context</name>-&gt;<name>maxsize</name></name> &amp;&amp;
		    !<call><name>_bump</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>!<call><name>_flatten1</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>depth</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then>
					<return>return <expr>0</expr>;</return></then></if>
			}</block></then> <else>else <if>if <condition>(<expr><name>o</name> != <name>Py_None</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name><name>context</name>-&gt;<name>size</name></name> + 1 &gt; <name><name>context</name>-&gt;<name>maxsize</name></name> &amp;&amp;
				    !<call><name>_bump</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
					<return>return <expr>0</expr>;</return></then></if>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name><name>context</name>-&gt;<name>tuple</name></name></expr></argument>,
						 <argument><expr><name><name>context</name>-&gt;<name>size</name></name>++</expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if></else></if>
		}</block></for>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"argument must be sequence"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></else></if></else></if></else></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkinter_Flatten</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FlattenContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>item</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:_flatten"</expr></argument>, <argument><expr>&amp;<name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>context</name>.<name>maxsize</name></name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>context</name>.<name>maxsize</name></name> &lt;= 0</expr>)</condition><then>
		<return>return <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	
	<expr_stmt><expr><name><name>context</name>.<name>tuple</name></name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name><name>context</name>.<name>maxsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>context</name>.<name>tuple</name></name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	
	<expr_stmt><expr><name><name>context</name>.<name>size</name></name> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>_flatten1</name><argument_list>(<argument><expr>&amp;<name>context</name></expr></argument>, <argument><expr><name>item</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>_PyTuple_Resize</name><argument_list>(<argument><expr>&amp;<name><name>context</name>.<name>tuple</name></name></expr></argument>, <argument><expr><name><name>context</name>.<name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr><name><name>context</name>.<name>tuple</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkinter_Create</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>screenName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>baseName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>className</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>interactive</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wantobjects</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wantTk</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>	<comment type="block">/* If false, then Tk_Init() doesn't get	called */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>sync</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* pass -sync to wish */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>use</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* pass -use to wish */</comment>

	<expr_stmt><expr><name>baseName</name> = <call><name>strrchr</name><argument_list>(<argument><expr><call><name>Py_GetProgramName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>baseName</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><name>baseName</name>++</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>baseName</name> = <call><name>Py_GetProgramName</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>className</name> = "Tk"</expr>;</expr_stmt>
  
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|zssiiiiz:create"</expr></argument>,
			      <argument><expr>&amp;<name>screenName</name></expr></argument>, <argument><expr>&amp;<name>baseName</name></expr></argument>, <argument><expr>&amp;<name>className</name></expr></argument>,
			      <argument><expr>&amp;<name>interactive</name></expr></argument>, <argument><expr>&amp;<name>wantobjects</name></expr></argument>, <argument><expr>&amp;<name>wantTk</name></expr></argument>,
			      <argument><expr>&amp;<name>sync</name></expr></argument>, <argument><expr>&amp;<name>use</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<return>return <expr>(<name>PyObject</name> *) <call><name>Tkapp_New</name><argument_list>(<argument><expr><name>screenName</name></expr></argument>, <argument><expr><name>baseName</name></expr></argument>, <argument><expr><name>className</name></expr></argument>, 
				      <argument><expr><name>interactive</name></expr></argument>, <argument><expr><name>wantobjects</name></expr></argument>,	<argument><expr><name>wantTk</name></expr></argument>,
				      <argument><expr><name>sync</name></expr></argument>, <argument><expr><name>use</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkinter_setbusywaitinterval</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>new_val</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:setbusywaitinterval"</expr></argument>, <argument><expr>&amp;<name>new_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>new_val</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"busywaitinterval must be &gt;= 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>Tkinter_busywaitinterval</name> = <name>new_val</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>setbusywaitinterval_doc</name><index>[]</index></name> <init>=
<expr>"setbusywaitinterval(n) -&gt; None\n\
\n\
Set the busy-wait interval in milliseconds between successive\n\
calls to Tcl_DoOneEvent in a threaded Python interpreter.\n\
It should be set to a divisor of the maximum time between\n\
frames in an animation."</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Tkinter_getbusywaitinterval</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>Tkinter_busywaitinterval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>getbusywaitinterval_doc</name><index>[]</index></name> <init>=
<expr>"getbusywaitinterval() -&gt; int\n\
\n\
Return the current busy-wait interval between successive\n\
calls to Tcl_DoOneEvent in a threaded Python interpreter."</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>moduleMethods</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr>"_flatten"</expr>,           <expr><name>Tkinter_Flatten</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"create"</expr>,             <expr><name>Tkinter_Create</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CREATEFILEHANDLER</name></cpp:ifdef>
	<expr><block>{<expr>"createfilehandler"</expr>,  <expr><name>Tkapp_CreateFileHandler</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"deletefilehandler"</expr>,  <expr><name>Tkapp_DeleteFileHandler</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"createtimerhandler"</expr>, <expr><name>Tkapp_CreateTimerHandler</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"mainloop"</expr>,           <expr><name>Tkapp_MainLoop</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"dooneevent"</expr>,         <expr><name>Tkapp_DoOneEvent</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"quit"</expr>,               <expr><name>Tkapp_Quit</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
	<expr><block>{<expr>"setbusywaitinterval"</expr>,<expr><name>Tkinter_setbusywaitinterval</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	                       <expr><name>setbusywaitinterval_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getbusywaitinterval"</expr>,<expr>(<name>PyCFunction</name>)<name>Tkinter_getbusywaitinterval</name></expr>,
	                       <expr><name>METH_NOARGS</name></expr>, <expr><name>getbusywaitinterval_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,                 <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAIT_FOR_STDIN</name></cpp:ifdef>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>stdin_ready</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MyFileProc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>clientData</name></decl></param>, <param><decl><type><name>int</name></type> <name>mask</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name>stdin_ready</name> = 1</expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyThreadState</name> *</type><name>event_tstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>EventHook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
	<decl_stmt><decl><type><name>int</name></type> <name>tfile</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><name>event_tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>stdin_ready</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>errorInCmd</name> = 0</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
	<expr_stmt><expr><name>tfile</name> = <call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateFileHandler</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>, <argument><expr><name>TCL_READABLE</name></expr></argument>, <argument><expr><name>MyFileProc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<while>while <condition>(<expr>!<name>errorInCmd</name> &amp;&amp; !<name>stdin_ready</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
		<if>if <condition>(<expr><call><name>_kbhit</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>stdin_ready</name> = 1</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
		<if>if<condition>(<expr><name>tcl_lock</name></expr>)</condition><then><expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>tcl_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>tcl_tstate</name> = <name>event_tstate</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> = <call><name>Tcl_DoOneEvent</name><argument_list>(<argument><expr><name>TCL_DONT_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tcl_tstate</name> = <name>NULL</name></expr>;</expr_stmt>
		<if>if<condition>(<expr><name>tcl_lock</name></expr>)</condition><then><expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>tcl_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><name>Tkinter_busywaitinterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>result</name> = <call><name>Tcl_DoOneEvent</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></while>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
	<expr_stmt><expr><call><name>Tcl_DeleteFileHandler</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>errorInCmd</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>errorInCmd</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>excInCmd</name></expr></argument>, <argument><expr><name>valInCmd</name></expr></argument>, <argument><expr><name>trbInCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>excInCmd</name> = <name>valInCmd</name> = <name>trbInCmd</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnableEventHook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAIT_FOR_STDIN</name></cpp:ifdef>
	<if>if <condition>(<expr><name>PyOS_InputHook</name> == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
		<expr_stmt><expr><name>event_tstate</name> = <call><name>PyThreadState_Get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>PyOS_InputHook</name> = <name>EventHook</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DisableEventHook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAIT_FOR_STDIN</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>Tk_GetNumMainWindows</name><argument_list>()</argument_list></call> == 0 &amp;&amp; <name>PyOS_InputHook</name> == <name>EventHook</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>PyOS_InputHook</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="block">/* all errors will be checked in one fell swoop in init_tkinter() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ins_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>d</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>long</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ins_string</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>d</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>v</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>


<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_tkinter</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Tkapp_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><name>tcl_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule</name><argument_list>(<argument><expr>"_tkinter"</expr></argument>, <argument><expr><name>moduleMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Tkinter_TclError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"_tkinter.TclError"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"TclError"</expr></argument>, <argument><expr><name>Tkinter_TclError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ins_long</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"READABLE"</expr></argument>, <argument><expr><name>TCL_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_long</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"WRITABLE"</expr></argument>, <argument><expr><name>TCL_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_long</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"EXCEPTION"</expr></argument>, <argument><expr><name>TCL_EXCEPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_long</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"WINDOW_EVENTS"</expr></argument>, <argument><expr><name>TCL_WINDOW_EVENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_long</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"FILE_EVENTS"</expr></argument>, <argument><expr><name>TCL_FILE_EVENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_long</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"TIMER_EVENTS"</expr></argument>, <argument><expr><name>TCL_TIMER_EVENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_long</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"IDLE_EVENTS"</expr></argument>, <argument><expr><name>TCL_IDLE_EVENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_long</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"ALL_EVENTS"</expr></argument>, <argument><expr><name>TCL_ALL_EVENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_long</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"DONT_WAIT"</expr></argument>, <argument><expr><name>TCL_DONT_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_string</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"TK_VERSION"</expr></argument>, <argument><expr><name>TK_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ins_string</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"TCL_VERSION"</expr></argument>, <argument><expr><name>TCL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"TkappType"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>Tkapp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Tktt_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"TkttType"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>Tktt_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>PyTclObject_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"Tcl_Obj"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>PyTclObject_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TK_AQUA</name></cpp:ifdef>
	<comment type="block">/* Tk_MacOSXSetupTkNotifier must be called before Tcl's subsystems
	 * start waking up.  Note that Tcl_FindExecutable will do this, this
	 * code must be above it! The original warning from
	 * tkMacOSXAppInit.c is copied below.
	 *
	 * NB - You have to swap in the Tk Notifier BEFORE you start up the
	 * Tcl interpreter for now.  It probably should work to do this
	 * in the other order, but for now it doesn't seem to.
	 *
	 */</comment>
	<expr_stmt><expr><call><name>Tk_MacOSXSetupTkNotifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


	<comment type="block">/* This helps the dynamic loader; in Unicode aware Tcl versions
	   it also helps Tcl find its encodings. */</comment>
	<expr_stmt><expr><call><name>Tcl_FindExecutable</name><argument_list>(<argument><expr><call><name>Py_GetProgramName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
	<comment type="block">/* This was not a good idea; through &lt;Destroy&gt; bindings,
	   Tcl_Finalize() may invoke Python code but at that point the
	   interpreter and thread state have already been destroyed! */</comment>
	Py_AtExit(Tcl_Finalize);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></function>
</unit>
