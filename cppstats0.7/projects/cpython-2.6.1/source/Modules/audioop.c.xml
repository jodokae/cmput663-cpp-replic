<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/audioop.c">
<comment type="block">/* audioopmodule - Module to detect peak values in arrays */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> == 4</expr></cpp:if>
<typedef>typedef <type><name>int</name></type> <name>Py_Int32</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>Py_UInt32</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> == 4</expr></cpp:if>
<typedef>typedef <type><name>long</name></type> <name>Py_Int32</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>long</name></type> <name>Py_UInt32</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "No 4-byte integral type"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>short</name></type> <name>PyInt16</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CHAR_UNSIGNED__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>signed</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* This module currently does not work on systems where only unsigned
   characters are available.  Take it out of Setup.  Sorry. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Code shamelessly stolen from sox, 12.17.7, g711.c
** (c) Craig Reese, Joe Campbell and Jeff Poskanzer 1989 */</comment>

<comment type="block">/* From g711.c:
 *
 * December 30, 1994:
 * Functions linear2alaw, linear2ulaw have been updated to correctly
 * convert unquantized 16 bit values.
 * Tables for direct u- to A-law and A- to u-law conversions have been
 * corrected.
 * Borge Lindberg, Center for PersonKommunikation, Aalborg University.
 * bli@cpk.auc.dk
 *
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIAS</name></cpp:macro> <cpp:value>0x84</cpp:value></cpp:define>   <comment type="block">/* define the add-in bias for 16 bit samples */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLIP</name></cpp:macro> <cpp:value>32635</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGN_BIT</name></cpp:macro>        <cpp:value>(0x80)</cpp:value></cpp:define>          <comment type="block">/* Sign bit for a A-law byte. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUANT_MASK</name></cpp:macro>      <cpp:value>(0xf)</cpp:value></cpp:define>           <comment type="block">/* Quantization field mask. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEG_SHIFT</name></cpp:macro>       <cpp:value>(4)</cpp:value></cpp:define>             <comment type="block">/* Left shift for segment number. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEG_MASK</name></cpp:macro>        <cpp:value>(0x70)</cpp:value></cpp:define>          <comment type="block">/* Segment field mask. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyInt16</name></type> <name><name>seg_aend</name><index>[<expr>8</expr>]</index></name> <init>= <expr><block>{<expr>0x1F</expr>, <expr>0x3F</expr>, <expr>0x7F</expr>, <expr>0xFF</expr>,
                              <expr>0x1FF</expr>, <expr>0x3FF</expr>, <expr>0x7FF</expr>, <expr>0xFFF</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyInt16</name></type> <name><name>seg_uend</name><index>[<expr>8</expr>]</index></name> <init>= <expr><block>{<expr>0x3F</expr>, <expr>0x7F</expr>, <expr>0xFF</expr>, <expr>0x1FF</expr>,
                              <expr>0x3FF</expr>, <expr>0x7FF</expr>, <expr>0xFFF</expr>, <expr>0x1FFF</expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyInt16</name></type>
<name>search</name><parameter_list>(<param><decl><type><name>PyInt16</name></type> <name>val</name></decl></param>, <param><decl><type><name>PyInt16</name> *</type><name>table</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name>val</name> &lt;= *<name>table</name>++</expr>)</condition><then>
                        <return>return <expr>(<name>i</name>)</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>(<name>size</name>)</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>st_ulaw2linear16</name><parameter_list>(<param><type><name>uc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(_st_ulaw2linear16[uc])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>st_alaw2linear16</name><parameter_list>(<param><type><name>uc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(_st_alaw2linear16[uc])</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyInt16</name></type> <name><name>_st_ulaw2linear16</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
    <expr>-32124</expr>,  <expr>-31100</expr>,  <expr>-30076</expr>,  <expr>-29052</expr>,  <expr>-28028</expr>,  <expr>-27004</expr>,  <expr>-25980</expr>,
    <expr>-24956</expr>,  <expr>-23932</expr>,  <expr>-22908</expr>,  <expr>-21884</expr>,  <expr>-20860</expr>,  <expr>-19836</expr>,  <expr>-18812</expr>,
    <expr>-17788</expr>,  <expr>-16764</expr>,  <expr>-15996</expr>,  <expr>-15484</expr>,  <expr>-14972</expr>,  <expr>-14460</expr>,  <expr>-13948</expr>,
    <expr>-13436</expr>,  <expr>-12924</expr>,  <expr>-12412</expr>,  <expr>-11900</expr>,  <expr>-11388</expr>,  <expr>-10876</expr>,  <expr>-10364</expr>,
     <expr>-9852</expr>,   <expr>-9340</expr>,   <expr>-8828</expr>,   <expr>-8316</expr>,   <expr>-7932</expr>,   <expr>-7676</expr>,   <expr>-7420</expr>,
     <expr>-7164</expr>,   <expr>-6908</expr>,   <expr>-6652</expr>,   <expr>-6396</expr>,   <expr>-6140</expr>,   <expr>-5884</expr>,   <expr>-5628</expr>,
     <expr>-5372</expr>,   <expr>-5116</expr>,   <expr>-4860</expr>,   <expr>-4604</expr>,   <expr>-4348</expr>,   <expr>-4092</expr>,   <expr>-3900</expr>,
     <expr>-3772</expr>,   <expr>-3644</expr>,   <expr>-3516</expr>,   <expr>-3388</expr>,   <expr>-3260</expr>,   <expr>-3132</expr>,   <expr>-3004</expr>,
     <expr>-2876</expr>,   <expr>-2748</expr>,   <expr>-2620</expr>,   <expr>-2492</expr>,   <expr>-2364</expr>,   <expr>-2236</expr>,   <expr>-2108</expr>,
     <expr>-1980</expr>,   <expr>-1884</expr>,   <expr>-1820</expr>,   <expr>-1756</expr>,   <expr>-1692</expr>,   <expr>-1628</expr>,   <expr>-1564</expr>,
     <expr>-1500</expr>,   <expr>-1436</expr>,   <expr>-1372</expr>,   <expr>-1308</expr>,   <expr>-1244</expr>,   <expr>-1180</expr>,   <expr>-1116</expr>,
     <expr>-1052</expr>,    <expr>-988</expr>,    <expr>-924</expr>,    <expr>-876</expr>,    <expr>-844</expr>,    <expr>-812</expr>,    <expr>-780</expr>,
      <expr>-748</expr>,    <expr>-716</expr>,    <expr>-684</expr>,    <expr>-652</expr>,    <expr>-620</expr>,    <expr>-588</expr>,    <expr>-556</expr>,
      <expr>-524</expr>,    <expr>-492</expr>,    <expr>-460</expr>,    <expr>-428</expr>,    <expr>-396</expr>,    <expr>-372</expr>,    <expr>-356</expr>,
      <expr>-340</expr>,    <expr>-324</expr>,    <expr>-308</expr>,    <expr>-292</expr>,    <expr>-276</expr>,    <expr>-260</expr>,    <expr>-244</expr>,
      <expr>-228</expr>,    <expr>-212</expr>,    <expr>-196</expr>,    <expr>-180</expr>,    <expr>-164</expr>,    <expr>-148</expr>,    <expr>-132</expr>,
      <expr>-120</expr>,    <expr>-112</expr>,    <expr>-104</expr>,     <expr>-96</expr>,     <expr>-88</expr>,     <expr>-80</expr>,     <expr>-72</expr>,
       <expr>-64</expr>,     <expr>-56</expr>,     <expr>-48</expr>,     <expr>-40</expr>,     <expr>-32</expr>,     <expr>-24</expr>,     <expr>-16</expr>,
        <expr>-8</expr>,       <expr>0</expr>,   <expr>32124</expr>,   <expr>31100</expr>,   <expr>30076</expr>,   <expr>29052</expr>,   <expr>28028</expr>,
     <expr>27004</expr>,   <expr>25980</expr>,   <expr>24956</expr>,   <expr>23932</expr>,   <expr>22908</expr>,   <expr>21884</expr>,   <expr>20860</expr>,
     <expr>19836</expr>,   <expr>18812</expr>,   <expr>17788</expr>,   <expr>16764</expr>,   <expr>15996</expr>,   <expr>15484</expr>,   <expr>14972</expr>,
     <expr>14460</expr>,   <expr>13948</expr>,   <expr>13436</expr>,   <expr>12924</expr>,   <expr>12412</expr>,   <expr>11900</expr>,   <expr>11388</expr>,
     <expr>10876</expr>,   <expr>10364</expr>,    <expr>9852</expr>,    <expr>9340</expr>,    <expr>8828</expr>,    <expr>8316</expr>,    <expr>7932</expr>,
      <expr>7676</expr>,    <expr>7420</expr>,    <expr>7164</expr>,    <expr>6908</expr>,    <expr>6652</expr>,    <expr>6396</expr>,    <expr>6140</expr>,
      <expr>5884</expr>,    <expr>5628</expr>,    <expr>5372</expr>,    <expr>5116</expr>,    <expr>4860</expr>,    <expr>4604</expr>,    <expr>4348</expr>,
      <expr>4092</expr>,    <expr>3900</expr>,    <expr>3772</expr>,    <expr>3644</expr>,    <expr>3516</expr>,    <expr>3388</expr>,    <expr>3260</expr>,
      <expr>3132</expr>,    <expr>3004</expr>,    <expr>2876</expr>,    <expr>2748</expr>,    <expr>2620</expr>,    <expr>2492</expr>,    <expr>2364</expr>,
      <expr>2236</expr>,    <expr>2108</expr>,    <expr>1980</expr>,    <expr>1884</expr>,    <expr>1820</expr>,    <expr>1756</expr>,    <expr>1692</expr>,
      <expr>1628</expr>,    <expr>1564</expr>,    <expr>1500</expr>,    <expr>1436</expr>,    <expr>1372</expr>,    <expr>1308</expr>,    <expr>1244</expr>,
      <expr>1180</expr>,    <expr>1116</expr>,    <expr>1052</expr>,     <expr>988</expr>,     <expr>924</expr>,     <expr>876</expr>,     <expr>844</expr>,
       <expr>812</expr>,     <expr>780</expr>,     <expr>748</expr>,     <expr>716</expr>,     <expr>684</expr>,     <expr>652</expr>,     <expr>620</expr>,
       <expr>588</expr>,     <expr>556</expr>,     <expr>524</expr>,     <expr>492</expr>,     <expr>460</expr>,     <expr>428</expr>,     <expr>396</expr>,
       <expr>372</expr>,     <expr>356</expr>,     <expr>340</expr>,     <expr>324</expr>,     <expr>308</expr>,     <expr>292</expr>,     <expr>276</expr>,
       <expr>260</expr>,     <expr>244</expr>,     <expr>228</expr>,     <expr>212</expr>,     <expr>196</expr>,     <expr>180</expr>,     <expr>164</expr>,
       <expr>148</expr>,     <expr>132</expr>,     <expr>120</expr>,     <expr>112</expr>,     <expr>104</expr>,      <expr>96</expr>,      <expr>88</expr>,
        <expr>80</expr>,      <expr>72</expr>,      <expr>64</expr>,      <expr>56</expr>,      <expr>48</expr>,      <expr>40</expr>,      <expr>32</expr>,
        <expr>24</expr>,      <expr>16</expr>,       <expr>8</expr>,       <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * linear2ulaw() accepts a 14-bit signed integer and encodes it as u-law data
 * stored in a unsigned char.  This function should only be called with
 * the data shifted such that it only contains information in the lower
 * 14-bits.
 *
 * In order to simplify the encoding process, the original linear magnitude
 * is biased by adding 33 which shifts the encoding range from (0 - 8158) to
 * (33 - 8191). The result can be seen in the following encoding table:
 *
 *      Biased Linear Input Code        Compressed Code
 *      ------------------------        ---------------
 *      00000001wxyza                   000wxyz
 *      0000001wxyzab                   001wxyz
 *      000001wxyzabc                   010wxyz
 *      00001wxyzabcd                   011wxyz
 *      0001wxyzabcde                   100wxyz
 *      001wxyzabcdef                   101wxyz
 *      01wxyzabcdefg                   110wxyz
 *      1wxyzabcdefgh                   111wxyz
 *
 * Each biased linear code has a leading 1 which identifies the segment
 * number. The value of the segment number is equal to 7 minus the number
 * of leading 0's. The quantization interval is directly available as the
 * four bits wxyz.  * The trailing bits (a - h) are ignored.
 *
 * Ordinarily the complement of the resulting code word is used for
 * transmission, and so the code word is complemented before it is returned.
 *
 * For further information see John C. Bellamy's Digital Telephony, 1982,
 * John Wiley &amp; Sons, pps 98-111 and 472-476.
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type>
<name>st_14linear2ulaw</name><parameter_list>(<param><decl><type><name>PyInt16</name></type> <name>pcm_val</name></decl></param>)</parameter_list>	<comment type="block">/* 2's complement (14-bit range) */</comment>
<block>{
        <decl_stmt><decl><type><name>PyInt16</name></type>         <name>mask</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyInt16</name></type>         <name>seg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>   <name>uval</name></decl>;</decl_stmt>

        <comment type="block">/* The original sox code does this in the calling function, not here */</comment>
        <expr_stmt><expr><name>pcm_val</name> = <name>pcm_val</name> &gt;&gt; 2</expr>;</expr_stmt>

        <comment type="block">/* u-law inverts all bits */</comment>
        <comment type="block">/* Get the sign and the magnitude of the value. */</comment>
        <if>if <condition>(<expr><name>pcm_val</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pcm_val</name> = -<name>pcm_val</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mask</name> = 0x7F</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
                <expr_stmt><expr><name>mask</name> = 0xFF</expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>( <expr><name>pcm_val</name> &gt; <name>CLIP</name></expr> )</condition><then> <expr_stmt><expr><name>pcm_val</name> = <name>CLIP</name></expr>;</expr_stmt></then></if>           <comment type="block">/* clip the magnitude */</comment>
        <expr_stmt><expr><name>pcm_val</name> += (<name>BIAS</name> &gt;&gt; 2)</expr>;</expr_stmt>

        <comment type="block">/* Convert the scaled magnitude to segment number. */</comment>
        <expr_stmt><expr><name>seg</name> = <call><name>search</name><argument_list>(<argument><expr><name>pcm_val</name></expr></argument>, <argument><expr><name>seg_uend</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Combine the sign, segment, quantization bits;
         * and complement the code word.
         */</comment>
        <if>if <condition>(<expr><name>seg</name> &gt;= 8</expr>)</condition><then>           <comment type="block">/* out of range, return maximum value. */</comment>
                <return>return <expr><call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>0x7F ^ <name>mask</name></expr></argument>)</argument_list></call></expr>;</return></then>
        <else>else <block>{
                <expr_stmt><expr><name>uval</name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr><name>seg</name> &lt;&lt; 4</expr></argument>)</argument_list></call> | ((<name>pcm_val</name> &gt;&gt; (<name>seg</name> + 1)) &amp; 0xF)</expr>;</expr_stmt>
                <return>return <expr>(<name>uval</name> ^ <name>mask</name>)</expr>;</return>
        }</block></else></if>

}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyInt16</name></type> <name><name>_st_alaw2linear16</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
     <expr>-5504</expr>,   <expr>-5248</expr>,   <expr>-6016</expr>,   <expr>-5760</expr>,   <expr>-4480</expr>,   <expr>-4224</expr>,   <expr>-4992</expr>,
     <expr>-4736</expr>,   <expr>-7552</expr>,   <expr>-7296</expr>,   <expr>-8064</expr>,   <expr>-7808</expr>,   <expr>-6528</expr>,   <expr>-6272</expr>,
     <expr>-7040</expr>,   <expr>-6784</expr>,   <expr>-2752</expr>,   <expr>-2624</expr>,   <expr>-3008</expr>,   <expr>-2880</expr>,   <expr>-2240</expr>,
     <expr>-2112</expr>,   <expr>-2496</expr>,   <expr>-2368</expr>,   <expr>-3776</expr>,   <expr>-3648</expr>,   <expr>-4032</expr>,   <expr>-3904</expr>,
     <expr>-3264</expr>,   <expr>-3136</expr>,   <expr>-3520</expr>,   <expr>-3392</expr>,  <expr>-22016</expr>,  <expr>-20992</expr>,  <expr>-24064</expr>,
    <expr>-23040</expr>,  <expr>-17920</expr>,  <expr>-16896</expr>,  <expr>-19968</expr>,  <expr>-18944</expr>,  <expr>-30208</expr>,  <expr>-29184</expr>,
    <expr>-32256</expr>,  <expr>-31232</expr>,  <expr>-26112</expr>,  <expr>-25088</expr>,  <expr>-28160</expr>,  <expr>-27136</expr>,  <expr>-11008</expr>,
    <expr>-10496</expr>,  <expr>-12032</expr>,  <expr>-11520</expr>,   <expr>-8960</expr>,   <expr>-8448</expr>,   <expr>-9984</expr>,   <expr>-9472</expr>,
    <expr>-15104</expr>,  <expr>-14592</expr>,  <expr>-16128</expr>,  <expr>-15616</expr>,  <expr>-13056</expr>,  <expr>-12544</expr>,  <expr>-14080</expr>,
    <expr>-13568</expr>,    <expr>-344</expr>,    <expr>-328</expr>,    <expr>-376</expr>,    <expr>-360</expr>,    <expr>-280</expr>,    <expr>-264</expr>,
      <expr>-312</expr>,    <expr>-296</expr>,    <expr>-472</expr>,    <expr>-456</expr>,    <expr>-504</expr>,    <expr>-488</expr>,    <expr>-408</expr>,
      <expr>-392</expr>,    <expr>-440</expr>,    <expr>-424</expr>,     <expr>-88</expr>,     <expr>-72</expr>,    <expr>-120</expr>,    <expr>-104</expr>,
       <expr>-24</expr>,      <expr>-8</expr>,     <expr>-56</expr>,     <expr>-40</expr>,    <expr>-216</expr>,    <expr>-200</expr>,    <expr>-248</expr>,
      <expr>-232</expr>,    <expr>-152</expr>,    <expr>-136</expr>,    <expr>-184</expr>,    <expr>-168</expr>,   <expr>-1376</expr>,   <expr>-1312</expr>,
     <expr>-1504</expr>,   <expr>-1440</expr>,   <expr>-1120</expr>,   <expr>-1056</expr>,   <expr>-1248</expr>,   <expr>-1184</expr>,   <expr>-1888</expr>,
     <expr>-1824</expr>,   <expr>-2016</expr>,   <expr>-1952</expr>,   <expr>-1632</expr>,   <expr>-1568</expr>,   <expr>-1760</expr>,   <expr>-1696</expr>,
      <expr>-688</expr>,    <expr>-656</expr>,    <expr>-752</expr>,    <expr>-720</expr>,    <expr>-560</expr>,    <expr>-528</expr>,    <expr>-624</expr>,
      <expr>-592</expr>,    <expr>-944</expr>,    <expr>-912</expr>,   <expr>-1008</expr>,    <expr>-976</expr>,    <expr>-816</expr>,    <expr>-784</expr>,
      <expr>-880</expr>,    <expr>-848</expr>,    <expr>5504</expr>,    <expr>5248</expr>,    <expr>6016</expr>,    <expr>5760</expr>,    <expr>4480</expr>,
      <expr>4224</expr>,    <expr>4992</expr>,    <expr>4736</expr>,    <expr>7552</expr>,    <expr>7296</expr>,    <expr>8064</expr>,    <expr>7808</expr>,
      <expr>6528</expr>,    <expr>6272</expr>,    <expr>7040</expr>,    <expr>6784</expr>,    <expr>2752</expr>,    <expr>2624</expr>,    <expr>3008</expr>,
      <expr>2880</expr>,    <expr>2240</expr>,    <expr>2112</expr>,    <expr>2496</expr>,    <expr>2368</expr>,    <expr>3776</expr>,    <expr>3648</expr>,
      <expr>4032</expr>,    <expr>3904</expr>,    <expr>3264</expr>,    <expr>3136</expr>,    <expr>3520</expr>,    <expr>3392</expr>,   <expr>22016</expr>,
     <expr>20992</expr>,   <expr>24064</expr>,   <expr>23040</expr>,   <expr>17920</expr>,   <expr>16896</expr>,   <expr>19968</expr>,   <expr>18944</expr>,
     <expr>30208</expr>,   <expr>29184</expr>,   <expr>32256</expr>,   <expr>31232</expr>,   <expr>26112</expr>,   <expr>25088</expr>,   <expr>28160</expr>,
     <expr>27136</expr>,   <expr>11008</expr>,   <expr>10496</expr>,   <expr>12032</expr>,   <expr>11520</expr>,    <expr>8960</expr>,    <expr>8448</expr>,
      <expr>9984</expr>,    <expr>9472</expr>,   <expr>15104</expr>,   <expr>14592</expr>,   <expr>16128</expr>,   <expr>15616</expr>,   <expr>13056</expr>,
     <expr>12544</expr>,   <expr>14080</expr>,   <expr>13568</expr>,     <expr>344</expr>,     <expr>328</expr>,     <expr>376</expr>,     <expr>360</expr>,
       <expr>280</expr>,     <expr>264</expr>,     <expr>312</expr>,     <expr>296</expr>,     <expr>472</expr>,     <expr>456</expr>,     <expr>504</expr>,
       <expr>488</expr>,     <expr>408</expr>,     <expr>392</expr>,     <expr>440</expr>,     <expr>424</expr>,      <expr>88</expr>,      <expr>72</expr>,
       <expr>120</expr>,     <expr>104</expr>,      <expr>24</expr>,       <expr>8</expr>,      <expr>56</expr>,      <expr>40</expr>,     <expr>216</expr>,
       <expr>200</expr>,     <expr>248</expr>,     <expr>232</expr>,     <expr>152</expr>,     <expr>136</expr>,     <expr>184</expr>,     <expr>168</expr>,
      <expr>1376</expr>,    <expr>1312</expr>,    <expr>1504</expr>,    <expr>1440</expr>,    <expr>1120</expr>,    <expr>1056</expr>,    <expr>1248</expr>,
      <expr>1184</expr>,    <expr>1888</expr>,    <expr>1824</expr>,    <expr>2016</expr>,    <expr>1952</expr>,    <expr>1632</expr>,    <expr>1568</expr>,
      <expr>1760</expr>,    <expr>1696</expr>,     <expr>688</expr>,     <expr>656</expr>,     <expr>752</expr>,     <expr>720</expr>,     <expr>560</expr>,
       <expr>528</expr>,     <expr>624</expr>,     <expr>592</expr>,     <expr>944</expr>,     <expr>912</expr>,    <expr>1008</expr>,     <expr>976</expr>,
       <expr>816</expr>,     <expr>784</expr>,     <expr>880</expr>,     <expr>848</expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * linear2alaw() accepts an 13-bit signed integer and encodes it as A-law data
 * stored in a unsigned char.  This function should only be called with
 * the data shifted such that it only contains information in the lower
 * 13-bits.
 *
 *              Linear Input Code       Compressed Code
 *      ------------------------        ---------------
 *      0000000wxyza                    000wxyz
 *      0000001wxyza                    001wxyz
 *      000001wxyzab                    010wxyz
 *      00001wxyzabc                    011wxyz
 *      0001wxyzabcd                    100wxyz
 *      001wxyzabcde                    101wxyz
 *      01wxyzabcdef                    110wxyz
 *      1wxyzabcdefg                    111wxyz
 *
 * For further information see John C. Bellamy's Digital Telephony, 1982,
 * John Wiley &amp; Sons, pps 98-111 and 472-476.
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type>
<name>st_linear2alaw</name><parameter_list>(<param><decl><type><name>PyInt16</name></type> <name>pcm_val</name></decl></param>)</parameter_list>	<comment type="block">/* 2's complement (13-bit range) */</comment>
<block>{
        <decl_stmt><decl><type><name>PyInt16</name></type>         <name>mask</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>short</name></type>           <name>seg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>   <name>aval</name></decl>;</decl_stmt>

        <comment type="block">/* The original sox code does this in the calling function, not here */</comment>
        <expr_stmt><expr><name>pcm_val</name> = <name>pcm_val</name> &gt;&gt; 3</expr>;</expr_stmt>

        <comment type="block">/* A-law using even bit inversion */</comment>
        <if>if <condition>(<expr><name>pcm_val</name> &gt;= 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>mask</name> = 0xD5</expr>;</expr_stmt>            <comment type="block">/* sign (7th) bit = 1 */</comment>
        }</block></then> <else>else <block>{
                <expr_stmt><expr><name>mask</name> = 0x55</expr>;</expr_stmt>            <comment type="block">/* sign bit = 0 */</comment>
                <expr_stmt><expr><name>pcm_val</name> = -<name>pcm_val</name> - 1</expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/* Convert the scaled magnitude to segment number. */</comment>
        <expr_stmt><expr><name>seg</name> = <call><name>search</name><argument_list>(<argument><expr><name>pcm_val</name></expr></argument>, <argument><expr><name>seg_aend</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Combine the sign, segment, and quantization bits. */</comment>

        <if>if <condition>(<expr><name>seg</name> &gt;= 8</expr>)</condition><then>           <comment type="block">/* out of range, return maximum value. */</comment>
                <return>return <expr><call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>0x7F ^ <name>mask</name></expr></argument>)</argument_list></call></expr>;</return></then>
        <else>else <block>{
                <expr_stmt><expr><name>aval</name> = (<name>unsigned</name> <name>char</name>) <name>seg</name> &lt;&lt; <name>SEG_SHIFT</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>seg</name> &lt; 2</expr>)</condition><then>
                        <expr_stmt><expr><name>aval</name> |= (<name>pcm_val</name> &gt;&gt; 1) &amp; <name>QUANT_MASK</name></expr>;</expr_stmt></then>
                <else>else
                        <expr_stmt><expr><name>aval</name> |= (<name>pcm_val</name> &gt;&gt; <name>seg</name>) &amp; <name>QUANT_MASK</name></expr>;</expr_stmt></else></if>
                <return>return <expr>(<name>aval</name> ^ <name>mask</name>)</expr>;</return>
        }</block></else></if>
}</block></function>
<comment type="block">/* End of code taken from sox */</comment>

<comment type="block">/* Intel ADPCM step variation table */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>indexTable</name><index>[<expr>16</expr>]</index></name> <init>= <expr><block>{
        <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>2</expr>, <expr>4</expr>, <expr>6</expr>, <expr>8</expr>,
        <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>2</expr>, <expr>4</expr>, <expr>6</expr>, <expr>8</expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>stepsizeTable</name><index>[<expr>89</expr>]</index></name> <init>= <expr><block>{
        <expr>7</expr>, <expr>8</expr>, <expr>9</expr>, <expr>10</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>, <expr>16</expr>, <expr>17</expr>,
        <expr>19</expr>, <expr>21</expr>, <expr>23</expr>, <expr>25</expr>, <expr>28</expr>, <expr>31</expr>, <expr>34</expr>, <expr>37</expr>, <expr>41</expr>, <expr>45</expr>,
        <expr>50</expr>, <expr>55</expr>, <expr>60</expr>, <expr>66</expr>, <expr>73</expr>, <expr>80</expr>, <expr>88</expr>, <expr>97</expr>, <expr>107</expr>, <expr>118</expr>,
        <expr>130</expr>, <expr>143</expr>, <expr>157</expr>, <expr>173</expr>, <expr>190</expr>, <expr>209</expr>, <expr>230</expr>, <expr>253</expr>, <expr>279</expr>, <expr>307</expr>,
        <expr>337</expr>, <expr>371</expr>, <expr>408</expr>, <expr>449</expr>, <expr>494</expr>, <expr>544</expr>, <expr>598</expr>, <expr>658</expr>, <expr>724</expr>, <expr>796</expr>,
        <expr>876</expr>, <expr>963</expr>, <expr>1060</expr>, <expr>1166</expr>, <expr>1282</expr>, <expr>1411</expr>, <expr>1552</expr>, <expr>1707</expr>, <expr>1878</expr>, <expr>2066</expr>,
        <expr>2272</expr>, <expr>2499</expr>, <expr>2749</expr>, <expr>3024</expr>, <expr>3327</expr>, <expr>3660</expr>, <expr>4026</expr>, <expr>4428</expr>, <expr>4871</expr>, <expr>5358</expr>,
        <expr>5894</expr>, <expr>6484</expr>, <expr>7132</expr>, <expr>7845</expr>, <expr>8630</expr>, <expr>9493</expr>, <expr>10442</expr>, <expr>11487</expr>, <expr>12635</expr>, <expr>13899</expr>,
        <expr>15289</expr>, <expr>16818</expr>, <expr>18500</expr>, <expr>20350</expr>, <expr>22385</expr>, <expr>24623</expr>, <expr>27086</expr>, <expr>29794</expr>, <expr>32767</expr>
}</block></expr></init></decl>;</decl_stmt>
    
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARP</name><parameter_list>(<param><type><name>cp</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((signed char *)(cp+i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHORTP</name><parameter_list>(<param><type><name>cp</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((short *)(cp+i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONGP</name><parameter_list>(<param><type><name>cp</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((Py_Int32 *)(cp+i))</cpp:value></cpp:define>



<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>AudioopError</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_getsample</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#ii:getsample"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <if>if <condition>( <expr><name>i</name> &lt; 0 || <name>i</name> &gt;= <name>len</name>/<name>size</name></expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name>*2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name>*4</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_max</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:max"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>i</name>+= <name>size</name></expr></incr>) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                <if>if <condition>( <expr><name>val</name> &lt; 0</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (-<name>val</name>)</expr>;</expr_stmt></then></if>
                <if>if <condition>( <expr><name>val</name> &gt; <name>max</name></expr> )</condition><then> <expr_stmt><expr><name>max</name> = <name>val</name></expr>;</expr_stmt></then></if>
        }</block></for>
        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_minmax</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr>0x7fffffff</expr></init>, <name>max</name> <init>= <expr>-0x7fffffff</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:minmax"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr>) <block>{
                <if>if <condition>(<expr><name>size</name> == 1</expr>)</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>) *<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>size</name> == 2</expr>)</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>) *<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>size</name> == 4</expr>)</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>) *<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                <if>if <condition>(<expr><name>val</name> &gt; <name>max</name></expr>)</condition><then> <expr_stmt><expr><name>max</name> = <name>val</name></expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><name>val</name> &lt; <name>min</name></expr>)</condition><then> <expr_stmt><expr><name>min</name> = <name>val</name></expr>;</expr_stmt></then></if>
        }</block></for>
        <return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_avg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>avg</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:avg"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>i</name>+= <name>size</name></expr></incr>) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                <expr_stmt><expr><name>avg</name> += <name>val</name></expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>( <expr><name>len</name> == 0</expr> )</condition><then>
                <expr_stmt><expr><name>val</name> = 0</expr>;</expr_stmt></then>
        <else>else
                <expr_stmt><expr><name>val</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>avg</name> / <call>(<name>double</name>)<argument_list>(<argument><expr><name>len</name>/<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_rms</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>sum_squares</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:rms"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>i</name>+= <name>size</name></expr></incr>) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                <expr_stmt><expr><name>sum_squares</name> += (<name>double</name>)<macro><name>val</name></macro>*(<name>double</name>)<name>val</name></expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>( <expr><name>len</name> == 0</expr> )</condition><then>
                <expr_stmt><expr><name>val</name> = 0</expr>;</expr_stmt></then>
        <else>else
                <expr_stmt><expr><name>val</name> = (<name>int</name>)<call><name>sqrt</name><argument_list>(<argument><expr><name>sum_squares</name> / <call>(<name>double</name>)<argument_list>(<argument><expr><name>len</name>/<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type> <name>_sum2</name><parameter_list>(<param><decl><type><name>short</name> *</type><name>a</name></decl></param>, <param><decl><type><name>short</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>sum</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>

        <for>for( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name>sum</name> = <name>sum</name> + (<name>double</name>)<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>*(<name>double</name>)<name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>sum</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Findfit tries to locate a sample within another sample. Its main use
** is in echo-cancellation (to find the feedback of the output signal in
** the input signal).
** The method used is as follows:
**
** let R be the reference signal (length n) and A the input signal (length N)
** with N &gt; n, and let all sums be over i from 0 to n-1.
**
** Now, for each j in {0..N-n} we compute a factor fj so that -fj*R matches A
** as good as possible, i.e. sum( (A[j+i]+fj*R[i])^2 ) is minimal. This
** equation gives fj = sum( A[j+i]R[i] ) / sum(R[i]^2).
**
** Next, we compute the relative distance between the original signal and
** the modified signal and minimize that over j:
** vj = sum( (A[j+i]-fj*R[i])^2 ) / sum( A[j+i]^2 )  =&gt;
** vj = ( sum(A[j+i]^2)*sum(R[i]^2) - sum(A[j+i]R[i])^2 ) / sum( A[j+i]^2 )
**
** In the code variables correspond as follows:
** cp1          A
** cp2          R
** len1         N
** len2         n
** aj_m1        A[j-1]
** aj_lm1       A[j+n-1]
** sum_ri_2     sum(R[i]^2)
** sum_aij_2    sum(A[i+j]^2)
** sum_aij_ri   sum(A[i+j]R[i])
**
** sum_ri is calculated once, sum_aij_2 is updated each step and sum_aij_ri
** is completely recalculated each step.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_findfit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>short</name> *</type><name>cp1</name></decl>, *<decl><type ref="prev"/><name>cp2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>best_j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>aj_m1</name></decl>, <decl><type ref="prev"/><name>aj_lm1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>sum_ri_2</name></decl>, <decl><type ref="prev"/><name>sum_aij_2</name></decl>, <decl><type ref="prev"/><name>sum_aij_ri</name></decl>, <decl><type ref="prev"/><name>result</name></decl>, <decl><type ref="prev"/><name>best_result</name></decl>, <decl><type ref="prev"/><name>factor</name></decl>;</decl_stmt>

	<comment type="block">/* Passing a short** for an 's' argument is correct only
	   if the string contents is aligned for interpretation
	   as short[]. Due to the definition of PyStringObject,
	   this is currently (Python 2.6) the case. */</comment>
        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#s#:findfit"</expr></argument>,
	                       <argument><expr>(<name>char</name>**)&amp;<name>cp1</name></expr></argument>, <argument><expr>&amp;<name>len1</name></expr></argument>, <argument><expr>(<name>char</name>**)&amp;<name>cp2</name></expr></argument>, <argument><expr>&amp;<name>len2</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>len1</name> &amp; 1 || <name>len2</name> &amp; 1</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Strings should be even-sized"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>len1</name> &gt;&gt;= 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>len2</name> &gt;&gt;= 1</expr>;</expr_stmt>
    
        <if>if <condition>( <expr><name>len1</name> &lt; <name>len2</name></expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"First sample should be longer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>sum_ri_2</name> = <call><name>_sum2</name><argument_list>(<argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sum_aij_2</name> = <call><name>_sum2</name><argument_list>(<argument><expr><name>cp1</name></expr></argument>, <argument><expr><name>cp1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sum_aij_ri</name> = <call><name>_sum2</name><argument_list>(<argument><expr><name>cp1</name></expr></argument>, <argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> = (<name>sum_ri_2</name>*<name>sum_aij_2</name> - <name>sum_aij_ri</name>*<name>sum_aij_ri</name>) / <name>sum_aij_2</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>best_result</name> = <name>result</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>best_j</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>

        <for>for ( <init><expr><name>j</name>=1</expr>;</init> <condition><expr><name>j</name>&lt;=<name>len1</name>-<name>len2</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name>aj_m1</name> = (<name>double</name>)<name><name>cp1</name><index>[<expr><name>j</name>-1</expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>aj_lm1</name> = (<name>double</name>)<name><name>cp1</name><index>[<expr><name>j</name>+<name>len2</name>-1</expr>]</index></name></expr>;</expr_stmt>

                <expr_stmt><expr><name>sum_aij_2</name> = <name>sum_aij_2</name> + <name>aj_lm1</name>*<name>aj_lm1</name> - <name>aj_m1</name>*<name>aj_m1</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>sum_aij_ri</name> = <call><name>_sum2</name><argument_list>(<argument><expr><name>cp1</name>+<name>j</name></expr></argument>, <argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> = (<name>sum_ri_2</name>*<name>sum_aij_2</name> - <name>sum_aij_ri</name>*<name>sum_aij_ri</name>)
                        / <name>sum_aij_2</name></expr>;</expr_stmt>

                <if>if <condition>( <expr><name>result</name> &lt; <name>best_result</name></expr> )</condition><then> <block>{
                        <expr_stmt><expr><name>best_result</name> = <name>result</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>best_j</name> = <name>j</name></expr>;</expr_stmt>
                }</block></then></if>
        
        }</block></for>

        <expr_stmt><expr><name>factor</name> = <call><name>_sum2</name><argument_list>(<argument><expr><name>cp1</name>+<name>best_j</name></expr></argument>, <argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call> / <name>sum_ri_2</name></expr>;</expr_stmt>
    
        <return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(if)"</expr></argument>, <argument><expr><name>best_j</name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** findfactor finds a factor f so that the energy in A-fB is minimal.
** See the comment for findfit for details.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_findfactor</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>short</name> *</type><name>cp1</name></decl>, *<decl><type ref="prev"/><name>cp2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>sum_ri_2</name></decl>, <decl><type ref="prev"/><name>sum_aij_ri</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#s#:findfactor"</expr></argument>,
	                       <argument><expr>(<name>char</name>**)&amp;<name>cp1</name></expr></argument>, <argument><expr>&amp;<name>len1</name></expr></argument>, <argument><expr>(<name>char</name>**)&amp;<name>cp2</name></expr></argument>, <argument><expr>&amp;<name>len2</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>len1</name> &amp; 1 || <name>len2</name> &amp; 1</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Strings should be even-sized"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <if>if <condition>( <expr><name>len1</name> != <name>len2</name></expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Samples should be same size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>len2</name> &gt;&gt;= 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>sum_ri_2</name> = <call><name>_sum2</name><argument_list>(<argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sum_aij_ri</name> = <call><name>_sum2</name><argument_list>(<argument><expr><name>cp1</name></expr></argument>, <argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> = <name>sum_aij_ri</name> / <name>sum_ri_2</name></expr>;</expr_stmt>

        <return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** findmax returns the index of the n-sized segment of the input sample
** that contains the most energy.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_findmax</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>short</name> *</type><name>cp1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>best_j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>aj_m1</name></decl>, <decl><type ref="prev"/><name>aj_lm1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>best_result</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:findmax"</expr></argument>, 
			       <argument><expr>(<name>char</name>**)&amp;<name>cp1</name></expr></argument>, <argument><expr>&amp;<name>len1</name></expr></argument>, <argument><expr>&amp;<name>len2</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>len1</name> &amp; 1</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Strings should be even-sized"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>len1</name> &gt;&gt;= 1</expr>;</expr_stmt>
    
        <if>if <condition>( <expr><name>len2</name> &lt; 0 || <name>len1</name> &lt; <name>len2</name></expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Input sample should be longer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>result</name> = <call><name>_sum2</name><argument_list>(<argument><expr><name>cp1</name></expr></argument>, <argument><expr><name>cp1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>best_result</name> = <name>result</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>best_j</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>

        <for>for ( <init><expr><name>j</name>=1</expr>;</init> <condition><expr><name>j</name>&lt;=<name>len1</name>-<name>len2</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name>aj_m1</name> = (<name>double</name>)<name><name>cp1</name><index>[<expr><name>j</name>-1</expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>aj_lm1</name> = (<name>double</name>)<name><name>cp1</name><index>[<expr><name>j</name>+<name>len2</name>-1</expr>]</index></name></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> = <name>result</name> + <name>aj_lm1</name>*<name>aj_lm1</name> - <name>aj_m1</name>*<name>aj_m1</name></expr>;</expr_stmt>

                <if>if <condition>( <expr><name>result</name> &gt; <name>best_result</name></expr> )</condition><then> <block>{
                        <expr_stmt><expr><name>best_result</name> = <name>result</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>best_j</name> = <name>j</name></expr>;</expr_stmt>
                }</block></then></if>
        
        }</block></for>

        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>best_j</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_avgpp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init>, <name>prevval</name> <init>= <expr>0</expr></init>, <name>prevextremevalid</name> <init>= <expr>0</expr></init>,
                <name>prevextreme</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>avg</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>, <decl><type ref="prev"/><name>prevdiff</name></decl>, <decl><type ref="prev"/><name>extremediff</name></decl>, <decl><type ref="prev"/><name>nextreme</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:avgpp"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <comment type="block">/* Compute first delta value ahead. Also automatically makes us
        ** skip the first extreme value
        */</comment>
        <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>prevval</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>prevval</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>prevval</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        <expr_stmt><expr><name>prevdiff</name> = <name>val</name> - <name>prevval</name></expr>;</expr_stmt>
    
        <for>for ( <init><expr><name>i</name>=<name>size</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>i</name>+= <name>size</name></expr></incr>) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                <expr_stmt><expr><name>diff</name> = <name>val</name> - <name>prevval</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>diff</name>*<name>prevdiff</name> &lt; 0</expr> )</condition><then> <block>{
                        <comment type="block">/* Derivative changed sign. Compute difference to last
                        ** extreme value and remember.
                        */</comment>
                        <if>if <condition>( <expr><name>prevextremevalid</name></expr> )</condition><then> <block>{
                                <expr_stmt><expr><name>extremediff</name> = <name>prevval</name> - <name>prevextreme</name></expr>;</expr_stmt>
                                <if>if <condition>( <expr><name>extremediff</name> &lt; 0</expr> )</condition><then>
                                        <expr_stmt><expr><name>extremediff</name> = -<name>extremediff</name></expr>;</expr_stmt></then></if>
                                <expr_stmt><expr><name>avg</name> += <name>extremediff</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>nextreme</name>++</expr>;</expr_stmt>
                        }</block></then></if>
                        <expr_stmt><expr><name>prevextremevalid</name> = 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name>prevextreme</name> = <name>prevval</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>prevval</name> = <name>val</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>diff</name> != 0</expr> )</condition><then>
                        <expr_stmt><expr><name>prevdiff</name> = <name>diff</name></expr>;</expr_stmt></then></if>        
        }</block></for>
        <if>if <condition>( <expr><name>nextreme</name> == 0</expr> )</condition><then>
                <expr_stmt><expr><name>val</name> = 0</expr>;</expr_stmt></then>
        <else>else
                <expr_stmt><expr><name>val</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>avg</name> / (<name>double</name>)<name>nextreme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_maxpp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init>, <name>prevval</name> <init>= <expr>0</expr></init>, <name>prevextremevalid</name> <init>= <expr>0</expr></init>,
                <name>prevextreme</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>, <decl><type ref="prev"/><name>prevdiff</name></decl>, <decl><type ref="prev"/><name>extremediff</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:maxpp"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <comment type="block">/* Compute first delta value ahead. Also automatically makes us
        ** skip the first extreme value
        */</comment>
        <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>prevval</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>prevval</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>prevval</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        <expr_stmt><expr><name>prevdiff</name> = <name>val</name> - <name>prevval</name></expr>;</expr_stmt>

        <for>for ( <init><expr><name>i</name>=<name>size</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>i</name>+= <name>size</name></expr></incr>) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                <expr_stmt><expr><name>diff</name> = <name>val</name> - <name>prevval</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>diff</name>*<name>prevdiff</name> &lt; 0</expr> )</condition><then> <block>{
                        <comment type="block">/* Derivative changed sign. Compute difference to
                        ** last extreme value and remember.
                        */</comment>
                        <if>if <condition>( <expr><name>prevextremevalid</name></expr> )</condition><then> <block>{
                                <expr_stmt><expr><name>extremediff</name> = <name>prevval</name> - <name>prevextreme</name></expr>;</expr_stmt>
                                <if>if <condition>( <expr><name>extremediff</name> &lt; 0</expr> )</condition><then>
                                        <expr_stmt><expr><name>extremediff</name> = -<name>extremediff</name></expr>;</expr_stmt></then></if>
                                <if>if <condition>( <expr><name>extremediff</name> &gt; <name>max</name></expr> )</condition><then>
                                        <expr_stmt><expr><name>max</name> = <name>extremediff</name></expr>;</expr_stmt></then></if>
                        }</block></then></if>
                        <expr_stmt><expr><name>prevextremevalid</name> = 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name>prevextreme</name> = <name>prevval</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>prevval</name> = <name>val</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>diff</name> != 0</expr> )</condition><then>
                        <expr_stmt><expr><name>prevdiff</name> = <name>diff</name></expr>;</expr_stmt></then></if>
        }</block></for>
        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_cross</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>prevval</name></decl>, <decl><type ref="prev"/><name>ncross</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:cross"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>ncross</name> = -1</expr>;</expr_stmt>
        <expr_stmt><expr><name>prevval</name> = 17</expr>;</expr_stmt> <comment type="block">/* Anything &lt;&gt; 0,1 */</comment>
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>i</name>+= <name>size</name></expr></incr>) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &gt;&gt; 7</expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &gt;&gt; 15</expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &gt;&gt; 31</expr>;</expr_stmt></then></if></else></if></else></if>
                <expr_stmt><expr><name>val</name> = <name>val</name> &amp; 1</expr>;</expr_stmt>
                <if>if <condition>( <expr><name>val</name> != <name>prevval</name></expr> )</condition><then> <expr_stmt><expr><name>ncross</name>++</expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>prevval</name> = <name>val</name></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ncross</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_mul</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>, *<decl><type ref="prev"/><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>factor</name></decl>, <decl><type ref="prev"/><name>fval</name></decl>, <decl><type ref="prev"/><name>maxval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#id:mul"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>factor</name></expr></argument> )</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
    
        <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = (<name>double</name>) 0x7f</expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = (<name>double</name>) 0x7fff</expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = (<name>double</name>) 0x7fffffff</expr>;</expr_stmt></then>
        <else>else <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></else></if></else></if></else></if>
    
        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>signed</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                <expr_stmt><expr><name>fval</name> = (<name>double</name>)<name>val</name>*<name>factor</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>fval</name> &gt; <name>maxval</name></expr> )</condition><then> <expr_stmt><expr><name>fval</name> = <name>maxval</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>fval</name> &lt; -<name>maxval</name></expr> )</condition><then> <expr_stmt><expr><name>fval</name> = -<name>maxval</name></expr>;</expr_stmt></then></if></else></if>
                <expr_stmt><expr><name>val</name> = (<name>int</name>)<name>fval</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = (<name>signed</name> <name>char</name>)<name>val</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = (<name>short</name>)<name>val</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = (<name>Py_Int32</name>)<name>val</name></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_tomono</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>, *<decl><type ref="prev"/><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val1</name> <init>= <expr>0</expr></init>, <name>val2</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>fac1</name></decl>, <decl><type ref="prev"/><name>fac2</name></decl>, <decl><type ref="prev"/><name>fval</name></decl>, <decl><type ref="prev"/><name>maxval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#idd:tomono"</expr></argument>,
	                       <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>fac1</name></expr></argument>, <argument><expr>&amp;<name>fac2</name></expr></argument> )</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
    
        <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = (<name>double</name>) 0x7f</expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = (<name>double</name>) 0x7fff</expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = (<name>double</name>) 0x7fffffff</expr>;</expr_stmt></then>
        <else>else <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></else></if></else></if></else></if>
    
        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name>/2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>signed</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name>*2</expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val1</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val1</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val1</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val2</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val2</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val2</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name>+4</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                <expr_stmt><expr><name>fval</name> = (<name>double</name>)<name>val1</name>*<name>fac1</name> + (<name>double</name>)<name>val2</name>*<name>fac2</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>fval</name> &gt; <name>maxval</name></expr> )</condition><then> <expr_stmt><expr><name>fval</name> = <name>maxval</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>fval</name> &lt; -<name>maxval</name></expr> )</condition><then> <expr_stmt><expr><name>fval</name> = -<name>maxval</name></expr>;</expr_stmt></then></if></else></if>
                <expr_stmt><expr><name>val1</name> = (<name>int</name>)<name>fval</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name>/2</expr></argument>)</argument_list></call> = (<name>signed</name> <name>char</name>)<name>val1</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name>/2</expr></argument>)</argument_list></call> = (<name>short</name>)<name>val1</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name>/2</expr></argument>)</argument_list></call>= (<name>Py_Int32</name>)<name>val1</name></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_tostereo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>, *<decl><type ref="prev"/><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>new_len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val1</name></decl>, <decl><type ref="prev"/><name>val2</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>fac1</name></decl>, <decl><type ref="prev"/><name>fac2</name></decl>, <decl><type ref="prev"/><name>fval</name></decl>, <decl><type ref="prev"/><name>maxval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#idd:tostereo"</expr></argument>,
	                       <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>fac1</name></expr></argument>, <argument><expr>&amp;<name>fac2</name></expr></argument> )</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
    
        <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = (<name>double</name>) 0x7f</expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = (<name>double</name>) 0x7fff</expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = (<name>double</name>) 0x7fffffff</expr>;</expr_stmt></then>
        <else>else <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></else></if></else></if></else></if>
    
        <expr_stmt><expr><name>new_len</name> = <name>len</name>*2</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_len</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
                                <argument><expr>"not enough memory for output buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>signed</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>

                <expr_stmt><expr><name>fval</name> = (<name>double</name>)<name>val</name>*<name>fac1</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>fval</name> &gt; <name>maxval</name></expr> )</condition><then> <expr_stmt><expr><name>fval</name> = <name>maxval</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>fval</name> &lt; -<name>maxval</name></expr> )</condition><then> <expr_stmt><expr><name>fval</name> = -<name>maxval</name></expr>;</expr_stmt></then></if></else></if>
                <expr_stmt><expr><name>val1</name> = (<name>int</name>)<name>fval</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>fval</name> = (<name>double</name>)<name>val</name>*<name>fac2</name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>fval</name> &gt; <name>maxval</name></expr> )</condition><then> <expr_stmt><expr><name>fval</name> = <name>maxval</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>fval</name> &lt; -<name>maxval</name></expr> )</condition><then> <expr_stmt><expr><name>fval</name> = -<name>maxval</name></expr>;</expr_stmt></then></if></else></if>
                <expr_stmt><expr><name>val2</name> = (<name>int</name>)<name>fval</name></expr>;</expr_stmt>

                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name>*2</expr></argument>)</argument_list></call> = (<name>signed</name> <name>char</name>)<name>val1</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name>*2</expr></argument>)</argument_list></call> = (<name>short</name>)<name>val1</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name>*2</expr></argument>)</argument_list></call> = (<name>Py_Int32</name>)<name>val1</name></expr>;</expr_stmt></then></if></else></if></else></if>

                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name>*2+1</expr></argument>)</argument_list></call> = (<name>signed</name> <name>char</name>)<name>val2</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name>*2+2</expr></argument>)</argument_list></call> = (<name>short</name>)<name>val2</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name>*2+4</expr></argument>)</argument_list></call> = (<name>Py_Int32</name>)<name>val2</name></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_add</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp1</name></decl>, *<decl><type ref="prev"/><name>cp2</name></decl>, *<decl><type ref="prev"/><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val1</name> <init>= <expr>0</expr></init>, <name>val2</name> <init>= <expr>0</expr></init>, <name>maxval</name></decl>, <decl><type ref="prev"/><name>newval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#s#i:add"</expr></argument>,
                          <argument><expr>&amp;<name>cp1</name></expr></argument>, <argument><expr>&amp;<name>len1</name></expr></argument>, <argument><expr>&amp;<name>cp2</name></expr></argument>, <argument><expr>&amp;<name>len2</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument> )</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>

        <if>if <condition>( <expr><name>len1</name> != <name>len2</name></expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Lengths should be the same"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = 0x7f</expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = 0x7fff</expr>;</expr_stmt></then>
        <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>maxval</name> = 0x7fffffff</expr>;</expr_stmt></then>
        <else>else <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></else></if></else></if></else></if>

        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>signed</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len1</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val1</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val1</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val1</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val2</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val2</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val2</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>

                <expr_stmt><expr><name>newval</name> = <name>val1</name> + <name>val2</name></expr>;</expr_stmt>
                <comment type="block">/* truncate in case of overflow */</comment>
                <if>if <condition>(<expr><name>newval</name> &gt; <name>maxval</name></expr>)</condition><then> <expr_stmt><expr><name>newval</name> = <name>maxval</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>newval</name> &lt; -<name>maxval</name></expr>)</condition><then> <expr_stmt><expr><name>newval</name> = -<name>maxval</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>size</name> == 4 &amp;&amp; (<name>newval</name>^<name>val1</name>) &lt; 0 &amp;&amp; (<name>newval</name>^<name>val2</name>) &lt; 0</expr>)</condition><then>
                        <expr_stmt><expr><name>newval</name> = <name>val1</name> &gt; 0 ? <name>maxval</name> : - <name>maxval</name></expr>;</expr_stmt></then></if></else></if></else></if>

                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = (<name>signed</name> <name>char</name>)<name>newval</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = (<name>short</name>)<name>newval</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = (<name>Py_Int32</name>)<name>newval</name></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_bias</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>, *<decl><type ref="prev"/><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bias</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#ii:bias"</expr></argument>,
                          <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument> , <argument><expr>&amp;<name>bias</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>

        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>signed</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>signed</name> <name>char</name>)<argument_list>(<argument><expr><name>val</name>+<name>bias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>short</name>)<argument_list>(<argument><expr><name>val</name>+<name>bias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>Py_Int32</name>)<argument_list>(<argument><expr><name>val</name>+<name>bias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_reverse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:reverse"</expr></argument>,
                          <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>

        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &lt;&lt; 8</expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &gt;&gt; 16</expr>;</expr_stmt></then></if></else></if></else></if>

                <expr_stmt><expr><name>j</name> = <name>len</name> - <name>i</name> - <name>size</name></expr>;</expr_stmt>
        
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> = <call>(<name>signed</name> <name>char</name>)<argument_list>(<argument><expr><name>val</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> = <call>(<name>short</name>)<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> = <call>(<name>Py_Int32</name>)<argument_list>(<argument><expr><name>val</name>&lt;&lt;16</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_lin2lin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>new_len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>size2</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#ii:lin2lin"</expr></argument>,
                          <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>size2</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>

        <if>if <condition>( <expr>(<name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4) ||
             (<name>size2</name> != 1 &amp;&amp; <name>size2</name> != 2 &amp;&amp; <name>size2</name> != 4)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <expr_stmt><expr><name>new_len</name> = (<name>len</name>/<name>size</name>)*<name>size2</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_len</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
                                <argument><expr>"not enough memory for output buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <for>for ( <init><expr><name>i</name>=0</expr>, <expr><name>j</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr>, <expr><name>j</name> += <name>size2</name></expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &lt;&lt; 8</expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &gt;&gt; 16</expr>;</expr_stmt></then></if></else></if></else></if>

                <if>if <condition>( <expr><name>size2</name> == 1</expr> )</condition><then>  <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> = <call>(<name>signed</name> <name>char</name>)<argument_list>(<argument><expr><name>val</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size2</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> = <call>(<name>short</name>)<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size2</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> = <call>(<name>Py_Int32</name>)<argument_list>(<argument><expr><name>val</name>&lt;&lt;16</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>gcd</name><parameter_list>(<param><decl><type><name>int</name></type> <name>a</name></decl></param>, <param><decl><type><name>int</name></type> <name>b</name></decl></param>)</parameter_list>
<block>{
        <while>while <condition>(<expr><name>b</name> &gt; 0</expr>)</condition> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>tmp</name> <init>= <expr><name>a</name> % <name>b</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>b</name> = <name>tmp</name></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><name>a</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_ratecv</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>, *<decl><type ref="prev"/><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>nchannels</name></decl>, <decl><type ref="prev"/><name>inrate</name></decl>, <decl><type ref="prev"/><name>outrate</name></decl>, <decl><type ref="prev"/><name>weightA</name></decl>, <decl><type ref="prev"/><name>weightB</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>chan</name></decl>, <decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>prev_i</name></decl>, *<decl><type ref="prev"/><name>cur_i</name></decl>, <decl><type ref="prev"/><name>cur_o</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>state</name></decl>, *<decl><type ref="prev"/><name>samps</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>, *<decl><type ref="prev"/><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bytes_per_frame</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>alloc_size</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>weightA</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>weightB</name> = 0</expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#iiiiO|ii:ratecv"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>,
	                      <argument><expr>&amp;<name>nchannels</name></expr></argument>, <argument><expr>&amp;<name>inrate</name></expr></argument>, <argument><expr>&amp;<name>outrate</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>,
			      <argument><expr>&amp;<name>weightA</name></expr></argument>, <argument><expr>&amp;<name>weightB</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>nchannels</name> &lt; 1</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"# of channels should be &gt;= 1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>bytes_per_frame</name> = <name>size</name> * <name>nchannels</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>bytes_per_frame</name> / <name>nchannels</name> != <name>size</name></expr>)</condition><then> <block>{
                <comment type="block">/* This overflow test is rigorously correct because
                   both multiplicands are &gt;= 1.  Use the argument names
                   from the docs for the error msg. */</comment>
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
                                <argument><expr>"width * nchannels too big for a C int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>weightA</name> &lt; 1 || <name>weightB</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>,
                        <argument><expr>"weightA should be &gt;= 1, weightB should be &gt;= 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>len</name> % <name>bytes_per_frame</name> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"not a whole number of frames"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>inrate</name> &lt;= 0 || <name>outrate</name> &lt;= 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"sampling rate not &gt; 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <comment type="block">/* divide inrate and outrate by their greatest common divisor */</comment>
        <expr_stmt><expr><name>d</name> = <call><name>gcd</name><argument_list>(<argument><expr><name>inrate</name></expr></argument>, <argument><expr><name>outrate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inrate</name> /= <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>outrate</name> /= <name>d</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>alloc_size</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * (<name>unsigned</name>)<name>nchannels</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>alloc_size</name> &lt; <name>nchannels</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
                                <argument><expr>"not enough memory for output buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>prev_i</name> = (<name>int</name> *) <call><name>malloc</name><argument_list>(<argument><expr><name>alloc_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur_i</name> = (<name>int</name> *) <call><name>malloc</name><argument_list>(<argument><expr><name>alloc_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>prev_i</name> == <name>NULL</name> || <name>cur_i</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>(<name>void</name>) <call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>exit</name>;</goto>
        }</block></then></if>

        <expr_stmt><expr><name>len</name> /= <name>bytes_per_frame</name></expr>;</expr_stmt> <comment type="block">/* # of frames */</comment>

        <if>if <condition>(<expr><name>state</name> == <name>Py_None</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>d</name> = -<name>outrate</name></expr>;</expr_stmt>
                <for>for (<init><expr><name>chan</name> = 0</expr>;</init> <condition><expr><name>chan</name> &lt; <name>nchannels</name></expr>;</condition> <incr><expr><name>chan</name>++</expr></incr>)
                        <expr_stmt><expr><name><name>prev_i</name><index>[<expr><name>chan</name></expr>]</index></name> = <name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
        }</block></then>
        <else>else <block>{
                <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                <argument><expr>"iO!;audioop.ratecv: illegal state argument"</expr></argument>,
                                <argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>PyTuple_Type</name></expr></argument>, <argument><expr>&amp;<name>samps</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <goto>goto <name>exit</name>;</goto></then></if>
                <if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>samps</name></expr></argument>)</argument_list></call> != <name>nchannels</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>,
                                        <argument><expr>"illegal state argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>exit</name>;</goto>
                }</block></then></if>
                <for>for (<init><expr><name>chan</name> = 0</expr>;</init> <condition><expr><name>chan</name> &lt; <name>nchannels</name></expr>;</condition> <incr><expr><name>chan</name>++</expr></incr>) <block>{
                        <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>samps</name></expr></argument>, <argument><expr><name>chan</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr>"ii:ratecv"</expr></argument>, <argument><expr>&amp;<name><name>prev_i</name><index>[<expr><name>chan</name></expr>]</index></name></expr></argument>, 
					                   <argument><expr>&amp;<name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                                <goto>goto <name>exit</name>;</goto></then></if>
                }</block></for>
        }</block></else></if>

        <comment type="block">/* str &lt;- Space for the output buffer. */</comment>
        <block>{
                <comment type="block">/* There are len input frames, so we need (mathematically)
                   ceiling(len*outrate/inrate) output frames, and each frame
                   requires bytes_per_frame bytes.  Computing this
                   without spurious overflow is the challenge; we can
                   settle for a reasonable upper bound, though. */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>ceiling</name></decl>;</decl_stmt>   <comment type="block">/* the number of output frames */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>nbytes</name></decl>;</decl_stmt>    <comment type="block">/* the number of output bytes needed */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>q</name> <init>= <expr><name>len</name> / <name>inrate</name></expr></init></decl>;</decl_stmt>
                <comment type="block">/* Now len = q * inrate + r exactly (with r = len % inrate),
                   and this is less than q * inrate + inrate = (q+1)*inrate.
                   So a reasonable upper bound on len*outrate/inrate is
                   ((q+1)*inrate)*outrate/inrate =
                   (q+1)*outrate.
                */</comment>
                <expr_stmt><expr><name>ceiling</name> = (<name>q</name>+1) * <name>outrate</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nbytes</name> = <name>ceiling</name> * <name>bytes_per_frame</name></expr>;</expr_stmt>
                <comment type="block">/* See whether anything overflowed; if not, get the space. */</comment>
                <if>if <condition>(<expr><name>q</name>+1 &lt; 0 ||
                    <name>ceiling</name> / <name>outrate</name> != <name>q</name>+1 ||
                    <name>nbytes</name> / <name>bytes_per_frame</name> != <name>ceiling</name></expr>)</condition><then>
                        <expr_stmt><expr><name>str</name> = <name>NULL</name></expr>;</expr_stmt></then>
                <else>else
                        <expr_stmt><expr><name>str</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

                <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
                                <argument><expr>"not enough memory for output buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>exit</name>;</goto>
                }</block></then></if>
        }</block>
        <expr_stmt><expr><name>ncp</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                <while>while <condition>(<expr><name>d</name> &lt; 0</expr>)</condition> <block>{
                        <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
                                <expr_stmt><expr><name>samps</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>nchannels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if>if <condition>(<expr><name>samps</name> == <name>NULL</name></expr>)</condition><then>
                                        <goto>goto <name>exit</name>;</goto></then></if>
                                <for>for (<init><expr><name>chan</name> = 0</expr>;</init> <condition><expr><name>chan</name> &lt; <name>nchannels</name></expr>;</condition> <incr><expr><name>chan</name>++</expr></incr>)
                                        <expr_stmt><expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>samps</name></expr></argument>, <argument><expr><name>chan</name></expr></argument>,
                                                <argument><expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ii)"</expr></argument>,
                                                              <argument><expr><name><name>prev_i</name><index>[<expr><name>chan</name></expr>]</index></name></expr></argument>,
                                                              <argument><expr><name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                                <if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
                                        <goto>goto <name>exit</name>;</goto></then></if>
                                <comment type="block">/* We have checked before that the length
                                 * of the string fits into int. */</comment>
                                <expr_stmt><expr><name>len</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>ncp</name> - <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
                                        <comment type="block">/*don't want to resize to zero length*/</comment>
                                        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <expr_stmt><expr><name>str</name> = <name>rv</name></expr>;</expr_stmt>
                                }</block></then> <else>else <if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                                        <goto>goto <name>exit</name>;</goto></then></if></else></if>
                                <expr_stmt><expr><name>rv</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(O(iO))"</expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>samps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>samps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <goto>goto <name>exit</name>;</goto> <comment type="block">/* return rv */</comment>
                        }</block></then></if>
                        <for>for (<init><expr><name>chan</name> = 0</expr>;</init> <condition><expr><name>chan</name> &lt; <name>nchannels</name></expr>;</condition> <incr><expr><name>chan</name>++</expr></incr>) <block>{
                                <expr_stmt><expr><name><name>prev_i</name><index>[<expr><name>chan</name></expr>]</index></name> = <name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name></expr>;</expr_stmt>
                                <if>if <condition>(<expr><name>size</name> == 1</expr>)</condition><then>
                                    <expr_stmt><expr><name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name> = ((<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) &lt;&lt; 8</expr>;</expr_stmt></then>
                                <else>else <if>if <condition>(<expr><name>size</name> == 2</expr>)</condition><then>
                                    <expr_stmt><expr><name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                                <else>else <if>if <condition>(<expr><name>size</name> == 4</expr>)</condition><then>
                                    <expr_stmt><expr><name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name> = ((<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) &gt;&gt; 16</expr>;</expr_stmt></then></if></else></if></else></if>
                                <expr_stmt><expr><name>cp</name> += <name>size</name></expr>;</expr_stmt>
                                <comment type="block">/* implements a simple digital filter */</comment>
                                <expr_stmt><expr><name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name> =
                                        (<name>weightA</name> * <name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name> +
                                         <name>weightB</name> * <name><name>prev_i</name><index>[<expr><name>chan</name></expr>]</index></name>) /
                                        (<name>weightA</name> + <name>weightB</name>)</expr>;</expr_stmt>
                        }</block></for>
                        <expr_stmt><expr><name>len</name>--</expr>;</expr_stmt>
                        <expr_stmt><expr><name>d</name> += <name>outrate</name></expr>;</expr_stmt>
                }</block></while>
                <while>while <condition>(<expr><name>d</name> &gt;= 0</expr>)</condition> <block>{
                        <for>for (<init><expr><name>chan</name> = 0</expr>;</init> <condition><expr><name>chan</name> &lt; <name>nchannels</name></expr>;</condition> <incr><expr><name>chan</name>++</expr></incr>) <block>{
                                <expr_stmt><expr><name>cur_o</name> = (<name><name>prev_i</name><index>[<expr><name>chan</name></expr>]</index></name> * <name>d</name> +
                                         <name><name>cur_i</name><index>[<expr><name>chan</name></expr>]</index></name> * (<name>outrate</name> - <name>d</name>)) /
                                        <name>outrate</name></expr>;</expr_stmt>
                                <if>if <condition>(<expr><name>size</name> == 1</expr>)</condition><then>
                                    <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> = <call>(<name>signed</name> <name>char</name>)<argument_list>(<argument><expr><name>cur_o</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                                <else>else <if>if <condition>(<expr><name>size</name> == 2</expr>)</condition><then>
                                    <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> = <call>(<name>short</name>)<argument_list>(<argument><expr><name>cur_o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                                <else>else <if>if <condition>(<expr><name>size</name> == 4</expr>)</condition><then>
                                    <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> = <call>(<name>Py_Int32</name>)<argument_list>(<argument><expr><name>cur_o</name>&lt;&lt;16</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
                                <expr_stmt><expr><name>ncp</name> += <name>size</name></expr>;</expr_stmt>
                        }</block></for>
                        <expr_stmt><expr><name>d</name> -= <name>inrate</name></expr>;</expr_stmt>
                }</block></while>
        }</block></for>
  <label><name>exit</name>:</label>
        <if>if <condition>(<expr><name>prev_i</name> != <name>NULL</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prev_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>cur_i</name> != <name>NULL</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cur_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_lin2ulaw</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:lin2ulaw"</expr></argument>,
                               <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr> ;</return></then></if>

        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name>/<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &lt;&lt; 8</expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &gt;&gt; 16</expr>;</expr_stmt></then></if></else></if></else></if>

                <expr_stmt><expr>*<name>ncp</name>++ = <call><name>st_14linear2ulaw</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_ulaw2lin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>new_len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:ulaw2lin"</expr></argument>,
                               <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>

        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <expr_stmt><expr><name>new_len</name> = <name>len</name>*<name>size</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_len</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
                                <argument><expr>"not enough memory for output buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>signed</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>new_len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <expr_stmt><expr><name>cval</name> = *<name>cp</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>val</name> = <call><name>st_ulaw2linear16</name><argument_list>(<argument><expr><name>cval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>signed</name> <name>char</name>)<argument_list>(<argument><expr><name>val</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>short</name>)<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>Py_Int32</name>)<argument_list>(<argument><expr><name>val</name>&lt;&lt;16</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_lin2alaw</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:lin2alaw"</expr></argument>,
                               <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>

        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name>/<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &lt;&lt; 8</expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &gt;&gt; 16</expr>;</expr_stmt></then></if></else></if></else></if>

                <expr_stmt><expr>*<name>ncp</name>++ = <call><name>st_linear2alaw</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_alaw2lin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>new_len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#i:alaw2lin"</expr></argument>,
                               <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>

        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <expr_stmt><expr><name>new_len</name> = <name>len</name>*<name>size</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_len</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
                                <argument><expr>"not enough memory for output buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>rv</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>signed</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>new_len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <expr_stmt><expr><name>cval</name> = *<name>cp</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>val</name> = <call><name>st_alaw2linear16</name><argument_list>(<argument><expr><name>cval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>signed</name> <name>char</name>)<argument_list>(<argument><expr><name>val</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>short</name>)<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>Py_Int32</name>)<argument_list>(<argument><expr><name>val</name>&lt;&lt;16</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_lin2adpcm</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr>0</expr></init>, <name>step</name></decl>, <decl><type ref="prev"/><name>valpred</name></decl>, <decl><type ref="prev"/><name>delta</name></decl>,
                <decl><type ref="prev"/><name>index</name></decl>, <decl><type ref="prev"/><name>sign</name></decl>, <decl><type ref="prev"/><name>vpdiff</name></decl>, <decl><type ref="prev"/><name>diff</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>, *<decl><type ref="prev"/><name>state</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>outputbuffer</name> <init>= <expr>0</expr></init>, <name>bufferstep</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#iO:lin2adpcm"</expr></argument>,
                               <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
    

        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <expr_stmt><expr><name>str</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name>/(<name>size</name>*2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>str</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>signed</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Decode state, should have (value, step) */</comment>
        <if>if <condition>( <expr><name>state</name> == <name>Py_None</name></expr> )</condition><then> <block>{
                <comment type="block">/* First time, it seems. Set defaults */</comment>
                <expr_stmt><expr><name>valpred</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>step</name> = 7</expr>;</expr_stmt>
                <expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr>"ii"</expr></argument>, <argument><expr>&amp;<name>valpred</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if></else></if>

        <expr_stmt><expr><name>step</name> = <name><name>stepsizeTable</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufferstep</name> = 1</expr>;</expr_stmt>

        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then>      <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>CHARP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &lt;&lt; 8</expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr><name>val</name> = (<name>int</name>)*<call><name>SHORTP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr><name>val</name> = ((<name>int</name>)*<call><name>LONGP</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) &gt;&gt; 16</expr>;</expr_stmt></then></if></else></if></else></if>

                <comment type="block">/* Step 1 - compute difference with previous value */</comment>
                <expr_stmt><expr><name>diff</name> = <name>val</name> - <name>valpred</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>sign</name> = (<name>diff</name> &lt; 0) ? 8 : 0</expr>;</expr_stmt>
                <if>if <condition>( <expr><name>sign</name></expr> )</condition><then> <expr_stmt><expr><name>diff</name> = (-<name>diff</name>)</expr>;</expr_stmt></then></if>

                <comment type="block">/* Step 2 - Divide and clamp */</comment>
                <comment type="block">/* Note:
                ** This code *approximately* computes:
                **    delta = diff*4/step;
                **    vpdiff = (delta+0.5)*step/4;
                ** but in shift step bits are dropped. The net result of this
                ** is that even if you have fast mul/div hardware you cannot
                ** put it to good use since the fixup would be too expensive.
                */</comment>
                <expr_stmt><expr><name>delta</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>vpdiff</name> = (<name>step</name> &gt;&gt; 3)</expr>;</expr_stmt>
        
                <if>if <condition>( <expr><name>diff</name> &gt;= <name>step</name></expr> )</condition><then> <block>{
                        <expr_stmt><expr><name>delta</name> = 4</expr>;</expr_stmt>
                        <expr_stmt><expr><name>diff</name> -= <name>step</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>vpdiff</name> += <name>step</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>step</name> &gt;&gt;= 1</expr>;</expr_stmt>
                <if>if <condition>( <expr><name>diff</name> &gt;= <name>step</name></expr>  )</condition><then> <block>{
                        <expr_stmt><expr><name>delta</name> |= 2</expr>;</expr_stmt>
                        <expr_stmt><expr><name>diff</name> -= <name>step</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>vpdiff</name> += <name>step</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>step</name> &gt;&gt;= 1</expr>;</expr_stmt>
                <if>if <condition>( <expr><name>diff</name> &gt;= <name>step</name></expr> )</condition><then> <block>{
                        <expr_stmt><expr><name>delta</name> |= 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name>vpdiff</name> += <name>step</name></expr>;</expr_stmt>
                }</block></then></if>

                <comment type="block">/* Step 3 - Update previous value */</comment>
                <if>if <condition>( <expr><name>sign</name></expr> )</condition><then>
                        <expr_stmt><expr><name>valpred</name> -= <name>vpdiff</name></expr>;</expr_stmt></then>
                <else>else
                        <expr_stmt><expr><name>valpred</name> += <name>vpdiff</name></expr>;</expr_stmt></else></if>

                <comment type="block">/* Step 4 - Clamp previous value to 16 bits */</comment>
                <if>if <condition>( <expr><name>valpred</name> &gt; 32767</expr> )</condition><then>
                        <expr_stmt><expr><name>valpred</name> = 32767</expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>valpred</name> &lt; -32768</expr> )</condition><then>
                        <expr_stmt><expr><name>valpred</name> = -32768</expr>;</expr_stmt></then></if></else></if>

                <comment type="block">/* Step 5 - Assemble value, update index and step values */</comment>
                <expr_stmt><expr><name>delta</name> |= <name>sign</name></expr>;</expr_stmt>
        
                <expr_stmt><expr><name>index</name> += <name><name>indexTable</name><index>[<expr><name>delta</name></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>index</name> &lt; 0</expr> )</condition><then> <expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt></then></if>
                <if>if <condition>( <expr><name>index</name> &gt; 88</expr> )</condition><then> <expr_stmt><expr><name>index</name> = 88</expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>step</name> = <name><name>stepsizeTable</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

                <comment type="block">/* Step 6 - Output value */</comment>
                <if>if <condition>( <expr><name>bufferstep</name></expr> )</condition><then> <block>{
                        <expr_stmt><expr><name>outputbuffer</name> = (<name>delta</name> &lt;&lt; 4) &amp; 0xf0</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                        <expr_stmt><expr>*<name>ncp</name>++ = (<name>delta</name> &amp; 0x0f) | <name>outputbuffer</name></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><name>bufferstep</name> = !<name>bufferstep</name></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>rv</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(O(ii))"</expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>valpred</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>audioop_adpcm2lin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>signed</name> <name>char</name> *</type><name>ncp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>new_len</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>valpred</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>delta</name></decl>, <decl><type ref="prev"/><name>index</name></decl>, <decl><type ref="prev"/><name>sign</name></decl>, <decl><type ref="prev"/><name>vpdiff</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>, *<decl><type ref="prev"/><name>state</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>inputbuffer</name> <init>= <expr>0</expr></init>, <name>bufferstep</name></decl>;</decl_stmt>

        <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#iO:adpcm2lin"</expr></argument>,
                               <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>

        <if>if <condition>( <expr><name>size</name> != 1 &amp;&amp; <name>size</name> != 2 &amp;&amp; <name>size</name> != 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AudioopError</name></expr></argument>, <argument><expr>"Size should be 1, 2 or 4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
    
        <comment type="block">/* Decode state, should have (value, step) */</comment>
        <if>if <condition>( <expr><name>state</name> == <name>Py_None</name></expr> )</condition><then> <block>{
                <comment type="block">/* First time, it seems. Set defaults */</comment>
                <expr_stmt><expr><name>valpred</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>step</name> = 7</expr>;</expr_stmt>
                <expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>( <expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr>"ii"</expr></argument>, <argument><expr>&amp;<name>valpred</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if></else></if>
    
        <expr_stmt><expr><name>new_len</name> = <name>len</name>*<name>size</name>*2</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_len</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
                                <argument><expr>"not enough memory for output buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>str</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name>str</name> == 0</expr> )</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>ncp</name> = (<name>signed</name> <name>char</name> *)<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>step</name> = <name><name>stepsizeTable</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufferstep</name> = 0</expr>;</expr_stmt>
    
        <for>for ( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>new_len</name></expr>;</condition> <incr><expr><name>i</name> += <name>size</name></expr></incr> ) <block>{
                <comment type="block">/* Step 1 - get the delta value and compute next index */</comment>
                <if>if <condition>( <expr><name>bufferstep</name></expr> )</condition><then> <block>{
                        <expr_stmt><expr><name>delta</name> = <name>inputbuffer</name> &amp; 0xf</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>inputbuffer</name> = *<name>cp</name>++</expr>;</expr_stmt>
                        <expr_stmt><expr><name>delta</name> = (<name>inputbuffer</name> &gt;&gt; 4) &amp; 0xf</expr>;</expr_stmt>
                }</block></else></if>

                <expr_stmt><expr><name>bufferstep</name> = !<name>bufferstep</name></expr>;</expr_stmt>

                <comment type="block">/* Step 2 - Find new index value (for later) */</comment>
                <expr_stmt><expr><name>index</name> += <name><name>indexTable</name><index>[<expr><name>delta</name></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>( <expr><name>index</name> &lt; 0</expr> )</condition><then> <expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt></then></if>
                <if>if <condition>( <expr><name>index</name> &gt; 88</expr> )</condition><then> <expr_stmt><expr><name>index</name> = 88</expr>;</expr_stmt></then></if>

                <comment type="block">/* Step 3 - Separate sign and magnitude */</comment>
                <expr_stmt><expr><name>sign</name> = <name>delta</name> &amp; 8</expr>;</expr_stmt>
                <expr_stmt><expr><name>delta</name> = <name>delta</name> &amp; 7</expr>;</expr_stmt>

                <comment type="block">/* Step 4 - Compute difference and new predicted value */</comment>
                <comment type="block">/*
                ** Computes 'vpdiff = (delta+0.5)*step/4', but see comment
                ** in adpcm_coder.
                */</comment>
                <expr_stmt><expr><name>vpdiff</name> = <name>step</name> &gt;&gt; 3</expr>;</expr_stmt>
                <if>if <condition>( <expr><name>delta</name> &amp; 4</expr> )</condition><then> <expr_stmt><expr><name>vpdiff</name> += <name>step</name></expr>;</expr_stmt></then></if>
                <if>if <condition>( <expr><name>delta</name> &amp; 2</expr> )</condition><then> <expr_stmt><expr><name>vpdiff</name> += <name>step</name>&gt;&gt;1</expr>;</expr_stmt></then></if>
                <if>if <condition>( <expr><name>delta</name> &amp; 1</expr> )</condition><then> <expr_stmt><expr><name>vpdiff</name> += <name>step</name>&gt;&gt;2</expr>;</expr_stmt></then></if>

                <if>if <condition>( <expr><name>sign</name></expr> )</condition><then>
                        <expr_stmt><expr><name>valpred</name> -= <name>vpdiff</name></expr>;</expr_stmt></then>
                <else>else
                        <expr_stmt><expr><name>valpred</name> += <name>vpdiff</name></expr>;</expr_stmt></else></if>

                <comment type="block">/* Step 5 - clamp output value */</comment>
                <if>if <condition>( <expr><name>valpred</name> &gt; 32767</expr> )</condition><then>
                        <expr_stmt><expr><name>valpred</name> = 32767</expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>valpred</name> &lt; -32768</expr> )</condition><then>
                        <expr_stmt><expr><name>valpred</name> = -32768</expr>;</expr_stmt></then></if></else></if>

                <comment type="block">/* Step 6 - Update step value */</comment>
                <expr_stmt><expr><name>step</name> = <name><name>stepsizeTable</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

                <comment type="block">/* Step 6 - Output value */</comment>
                <if>if <condition>( <expr><name>size</name> == 1</expr> )</condition><then> <expr_stmt><expr>*<call><name>CHARP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>signed</name> <name>char</name>)<argument_list>(<argument><expr><name>valpred</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 2</expr> )</condition><then> <expr_stmt><expr>*<call><name>SHORTP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>short</name>)<argument_list>(<argument><expr><name>valpred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>( <expr><name>size</name> == 4</expr> )</condition><then> <expr_stmt><expr>*<call><name>LONGP</name><argument_list>(<argument><expr><name>ncp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> = <call>(<name>Py_Int32</name>)<argument_list>(<argument><expr><name>valpred</name>&lt;&lt;16</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
        }</block></for>

        <expr_stmt><expr><name>rv</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(O(ii))"</expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>valpred</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>audioop_methods</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{ <expr>"max"</expr>, <expr><name>audioop_max</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"minmax"</expr>, <expr><name>audioop_minmax</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"avg"</expr>, <expr><name>audioop_avg</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"maxpp"</expr>, <expr><name>audioop_maxpp</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"avgpp"</expr>, <expr><name>audioop_avgpp</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"rms"</expr>, <expr><name>audioop_rms</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"findfit"</expr>, <expr><name>audioop_findfit</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"findmax"</expr>, <expr><name>audioop_findmax</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"findfactor"</expr>, <expr><name>audioop_findfactor</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"cross"</expr>, <expr><name>audioop_cross</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"mul"</expr>, <expr><name>audioop_mul</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"add"</expr>, <expr><name>audioop_add</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"bias"</expr>, <expr><name>audioop_bias</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"ulaw2lin"</expr>, <expr><name>audioop_ulaw2lin</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"lin2ulaw"</expr>, <expr><name>audioop_lin2ulaw</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"alaw2lin"</expr>, <expr><name>audioop_alaw2lin</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"lin2alaw"</expr>, <expr><name>audioop_lin2alaw</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"lin2lin"</expr>, <expr><name>audioop_lin2lin</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"adpcm2lin"</expr>, <expr><name>audioop_adpcm2lin</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"lin2adpcm"</expr>, <expr><name>audioop_lin2adpcm</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"tomono"</expr>, <expr><name>audioop_tomono</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"tostereo"</expr>, <expr><name>audioop_tostereo</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"getsample"</expr>, <expr><name>audioop_getsample</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"reverse"</expr>, <expr><name>audioop_reverse</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>"ratecv"</expr>, <expr><name>audioop_ratecv</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
        <expr><block>{ <expr>0</expr>,          <expr>0</expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>initaudioop</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>m</name> = <call><name>Py_InitModule</name><argument_list>(<argument><expr>"audioop"</expr></argument>, <argument><expr><name>audioop_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
                <return>return;</return></then></if>
        <expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
                <return>return;</return></then></if>
        <expr_stmt><expr><name>AudioopError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"audioop.error"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>AudioopError</name> != <name>NULL</name></expr>)</condition><then>
             <expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr>"error"</expr></argument>,<argument><expr><name>AudioopError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
</unit>
