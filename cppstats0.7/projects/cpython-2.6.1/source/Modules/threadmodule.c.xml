<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/threadmodule.c">
<comment type="block">/* Thread module */</comment>
<comment type="block">/* Interface to Sjoerd's portable C thread library */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITH_THREAD</name></cpp:ifndef>
<cpp:error>#<cpp:directive>error</cpp:directive> "Error!  The rest of Python is not compiled with thread support."</cpp:error>
<cpp:error>#<cpp:directive>error</cpp:directive> "Rerun configure, adding a --with-threads option."</cpp:error>
<cpp:error>#<cpp:directive>error</cpp:directive> "Then run `make clean' followed by `make'."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>ThreadError</name></decl>;</decl_stmt>


<comment type="block">/* Lock objects */</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyThread_type_lock</name></type> <name>lock_lock</name></decl>;</decl_stmt>
}</block></struct></type> <name>lockobject</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>lock_dealloc</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Unlock the lock so it's safe to free it */</comment>
	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lock_PyThread_acquire_lock</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:acquire"</expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>i</name> <init>= <expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>acquire_doc</name></expr></argument>,
<argument><expr>"acquire([wait]) -&gt; None or bool\n\
(acquire_lock() is an obsolete synonym)\n\
\n\
Lock the lock.  Without argument, this blocks if the lock is already\n\
locked (even by the same thread), waiting for another thread to release\n\
the lock, and return None once the lock is acquired.\n\
With an argument, this will only block if the argument is true,\n\
and the return value reflects whether the lock is acquired.\n\
The blocking operation is not interruptible."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lock_PyThread_release_lock</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Sanity check: the lock must be locked */</comment>
	<if>if <condition>(<expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>, <argument><expr>"release unlocked lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>release_doc</name></expr></argument>,
<argument><expr>"release()\n\
(release_lock() is an obsolete synonym)\n\
\n\
Release the lock, allowing another thread that is blocked waiting for\n\
the lock to acquire the lock.  The lock must be in the locked state,\n\
but it needn't be locked by the same thread that unlocks it."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lock_locked_lock</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>locked_doc</name></expr></argument>,
<argument><expr>"locked() -&gt; bool\n\
(locked_lock() is an obsolete synonym)\n\
\n\
Return whether the lock is in the locked state."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>lock_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"acquire_lock"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_PyThread_acquire_lock</name></expr>, 
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>acquire_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"acquire"</expr>,      <expr>(<name>PyCFunction</name>)<name>lock_PyThread_acquire_lock</name></expr>, 
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>acquire_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"release_lock"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_PyThread_release_lock</name></expr>, 
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>release_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"release"</expr>,      <expr>(<name>PyCFunction</name>)<name>lock_PyThread_release_lock</name></expr>, 
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>release_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"locked_lock"</expr>,  <expr>(<name>PyCFunction</name>)<name>lock_locked_lock</name></expr>,  
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>locked_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"locked"</expr>,       <expr>(<name>PyCFunction</name>)<name>lock_locked_lock</name></expr>,  
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>locked_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__enter__"</expr>,    <expr>(<name>PyCFunction</name>)<name>lock_PyThread_acquire_lock</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>acquire_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"__exit__"</expr>,    <expr>(<name>PyCFunction</name>)<name>lock_PyThread_release_lock</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>release_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,           <expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lock_getattr</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_FindMethod</name><argument_list>(<argument><expr><name>lock_methods</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Locktype</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"thread.lock"</expr>,			<comment type="block">/*tp_name*/</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>lockobject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/*tp_size*/</comment>
	<expr>0</expr>,				<comment type="block">/*tp_itemsize*/</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>lock_dealloc</name></expr>,	<comment type="block">/*tp_dealloc*/</comment>
	<expr>0</expr>,				<comment type="block">/*tp_print*/</comment>
	<expr>(<name>getattrfunc</name>)<name>lock_getattr</name></expr>,	<comment type="block">/*tp_getattr*/</comment>
	<expr>0</expr>,				<comment type="block">/*tp_setattr*/</comment>
	<expr>0</expr>,				<comment type="block">/*tp_compare*/</comment>
	<expr>0</expr>,				<comment type="block">/*tp_repr*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>lockobject</name> *</type>
<name>newlockobject</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>lockobject</name> *</type><name>self</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>lockobject</name></expr></argument>, <argument><expr>&amp;<name>Locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>lock_lock</name></name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock_lock</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>self</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>, <argument><expr>"can't allocate lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<comment type="block">/* Thread-local objects */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>kw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
}</block></struct></type> <name>localobject</name>;</typedef>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>local_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>localobject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tdict</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_init</name></name> == <name><name>PyBaseObject_Type</name>.<name>tp_init</name></name>
	    &amp;&amp; ((<name>args</name> &amp;&amp; <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>)
		|| (<name>kw</name> &amp;&amp; <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			  <argument><expr>"Initialization arguments are not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>self</name> = (<name>localobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>args</name></name> = <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>kw</name></name> = <name>kw</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* making sure */</comment>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>key</name></name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"thread.local.%p"</expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>key</name></name> == <name>NULL</name></expr>)</condition><then> 
		<goto>goto <name>err</name>;</goto></then></if>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>dict</name></name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>

	<expr_stmt><expr><name>tdict</name> = <call><name>PyThreadState_GetDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tdict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"Couldn't get thread-state dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>tdict</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>

	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>

  <label><name>err</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>local_traverse</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>kw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>local_clear</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>kw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>local_dealloc</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>key</name></name>
	    &amp;&amp; (<name>tstate</name> = <call><name>PyThreadState_Get</name><argument_list>()</argument_list></call>)
	    &amp;&amp; <name><name>tstate</name>-&gt;<name>interp</name></name></expr>)</condition><then> <block>{
		<for>for(<init><expr><name>tstate</name> = <call><name>PyInterpreterState_ThreadHead</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>interp</name></name></expr></argument>)</argument_list></call></expr>;</init>
		    <condition><expr><name>tstate</name></expr>;</condition>
		    <incr><expr><name>tstate</name> = <call><name>PyThreadState_Next</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr></incr>) 
			<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>dict</name></name> &amp;&amp;
			    <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
	}</block></then></if>

	<expr_stmt><expr><call><name>local_clear</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_ldict</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tdict</name></decl>, *<decl><type ref="prev"/><name>ldict</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tdict</name> = <call><name>PyThreadState_GetDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tdict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
				<argument><expr>"Couldn't get thread-state dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>ldict</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>tdict</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ldict</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ldict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* we own ldict */</comment>

		<if>if <condition>(<expr><name>ldict</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>tdict</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>ldict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ldict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* now ldict is borrowed */</comment>
			<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> 
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></else></if>

		<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ldict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <name>ldict</name></expr>;</expr_stmt> <comment type="block">/* still borrowed */</comment>

		<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_init</name> != <name><name>PyBaseObject_Type</name>.<name>tp_init</name></name> &amp;&amp;
		    <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_init</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>, 
					   <argument><expr><name><name>self</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>kw</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* we need to get rid of ldict from thread so
			   we create a new one the next time we do an attr
			   acces */</comment>
			<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>tdict</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		
	}</block></then></if>

	<comment type="block">/* The call to tp_init above may have caused another thread to run.
	   Install our ldict again. */</comment>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>dict</name></name> != <name>ldict</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ldict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <name>ldict</name></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>ldict</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>local_setattro</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ldict</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>ldict</name> = <call><name>_ldict</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ldict</name> == <name>NULL</name></expr>)</condition><then> 
		<return>return <expr>-1</expr>;</return></then></if>

	<return>return <expr><call><name>PyObject_GenericSetAttr</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>local_getdict</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>self</name>-&gt;<name>dict</name></name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>local_getset</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__dict__"</expr>, <expr>(<name>getter</name>)<name>local_getdict</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
	 <expr>"Local-data dictionary"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>  <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>local_getattro</name><parameter_list>(<param><decl><type><name>localobject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>localtype</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	<comment type="block">/* tp_name           */</comment> "thread._local"</expr>,
	<comment type="block">/* tp_basicsize      */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>localobject</name></expr></argument>)</argument_list></sizeof></expr>,
	<comment type="block">/* tp_itemsize       */</comment> <expr>0</expr>,
	<comment type="block">/* tp_dealloc        */</comment> <expr>(<name>destructor</name>)<name>local_dealloc</name></expr>,
	<comment type="block">/* tp_print          */</comment> <expr>0</expr>,
	<comment type="block">/* tp_getattr        */</comment> <expr>0</expr>,
	<comment type="block">/* tp_setattr        */</comment> <expr>0</expr>,
	<comment type="block">/* tp_compare        */</comment> <expr>0</expr>,
	<comment type="block">/* tp_repr           */</comment> <expr>0</expr>,
	<comment type="block">/* tp_as_number      */</comment> <expr>0</expr>,
	<comment type="block">/* tp_as_sequence    */</comment> <expr>0</expr>,
	<comment type="block">/* tp_as_mapping     */</comment> <expr>0</expr>,
	<comment type="block">/* tp_hash           */</comment> <expr>0</expr>,
	<comment type="block">/* tp_call           */</comment> <expr>0</expr>,
	<comment type="block">/* tp_str            */</comment> <expr>0</expr>,
	<comment type="block">/* tp_getattro       */</comment> <expr>(<name>getattrofunc</name>)<name>local_getattro</name></expr>,
	<comment type="block">/* tp_setattro       */</comment> <expr>(<name>setattrofunc</name>)<name>local_setattro</name></expr>,
	<comment type="block">/* tp_as_buffer      */</comment> <expr>0</expr>,
	<comment type="block">/* tp_flags          */</comment> <expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>,
	<comment type="block">/* tp_doc            */</comment> <expr>"Thread-local data"</expr>,
	<comment type="block">/* tp_traverse       */</comment> <expr>(<name>traverseproc</name>)<name>local_traverse</name></expr>,
	<comment type="block">/* tp_clear          */</comment> <expr>(<name>inquiry</name>)<name>local_clear</name></expr>,
	<comment type="block">/* tp_richcompare    */</comment> <expr>0</expr>,
	<comment type="block">/* tp_weaklistoffset */</comment> <expr>0</expr>,
	<comment type="block">/* tp_iter           */</comment> <expr>0</expr>,
	<comment type="block">/* tp_iternext       */</comment> <expr>0</expr>,
	<comment type="block">/* tp_methods        */</comment> <expr>0</expr>,
	<comment type="block">/* tp_members        */</comment> <expr>0</expr>,
	<comment type="block">/* tp_getset         */</comment> <expr><name>local_getset</name></expr>,
	<comment type="block">/* tp_base           */</comment> <expr>0</expr>,
	<comment type="block">/* tp_dict           */</comment> <expr>0</expr>, <comment type="block">/* internal use */</comment>
	<comment type="block">/* tp_descr_get      */</comment> <expr>0</expr>,
	<comment type="block">/* tp_descr_set      */</comment> <expr>0</expr>,
	<comment type="block">/* tp_dictoffset     */</comment> <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>localobject</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* tp_init           */</comment> <expr>0</expr>,
	<comment type="block">/* tp_alloc          */</comment> <expr>0</expr>,
	<comment type="block">/* tp_new            */</comment> <expr><name>local_new</name></expr>,
	<comment type="block">/* tp_free           */</comment> <expr>0</expr>, <comment type="block">/* Low-level free-mem routine */</comment>
	<comment type="block">/* tp_is_gc          */</comment> <expr>0</expr>, <comment type="block">/* For PyObject_IS_GC */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>local_getattro</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ldict</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ldict</name> = <call><name>_ldict</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ldict</name> == <name>NULL</name></expr>)</condition><then> 
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> != &amp;<name>localtype</name></expr>)</condition><then>
		<comment type="block">/* use generic lookup for subtypes */</comment>
		<return>return <expr><call><name>PyObject_GenericGetAttr</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<comment type="block">/* Optimization: just look in dict ourselves */</comment>
	<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>ldict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> 
		<comment type="block">/* Fall back on generic to get __class__ and __dict__ */</comment>
		<return>return <expr><call><name>PyObject_GenericGetAttr</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>value</name></expr>;</return>
}</block></function>

<comment type="block">/* Module functions */</comment>

<struct>struct <name>bootstate</name> <block>{
	<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>keyw</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>t_bootstrap</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>boot_raw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>bootstate</name> *</type><name>boot</name> <init>= <expr>(struct <name>bootstate</name> *) <name>boot_raw</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tstate</name> = <call><name>PyThreadState_New</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyEval_AcquireThread</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObjectWithKeywords</name><argument_list>(
		<argument><expr><name><name>boot</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name><name>boot</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name><name>boot</name>-&gt;<name>keyw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_SystemExit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>file</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
				<argument><expr>"Unhandled exception in thread started by "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>file</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stderr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>file</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_PrintEx</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>keyw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>boot_raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyThreadState_Clear</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyThreadState_DeleteCurrent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyThread_exit_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_start_new_thread</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>, *<decl><type ref="prev"/><name>keyw</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>bootstate</name> *</type><name>boot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>ident</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>, <argument><expr>"start_new_thread"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>3</expr></argument>,
		               <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr>&amp;<name>keyw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"first arg must be callable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"2nd arg must be a tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>keyw</name> != <name>NULL</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>keyw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"optional 3rd arg must be a dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>boot</name> = <call><name>PyMem_NEW</name><argument_list>(<argument>struct <expr><name>bootstate</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>boot</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name><name>boot</name>-&gt;<name>interp</name></name> = <call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boot</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boot</name>-&gt;<name>args</name></name> = <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boot</name>-&gt;<name>keyw</name></name> = <name>keyw</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>keyw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyEval_InitThreads</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Start the interpreter's thread-awareness */</comment>
	<expr_stmt><expr><name>ident</name> = <call><name>PyThread_start_new_thread</name><argument_list>(<argument><expr><name>t_bootstrap</name></expr></argument>, <argument><expr>(<name>void</name>*) <name>boot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ident</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>, <argument><expr>"can't start new thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keyw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>boot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>start_new_doc</name></expr></argument>,
<argument><expr>"start_new_thread(function, args[, kwargs])\n\
(start_new() is an obsolete synonym)\n\
\n\
Start a new thread and return its identifier.  The thread will call the\n\
function with positional arguments from the tuple args and keyword arguments\n\
taken from the optional dictionary kwargs.  The thread exits when the\n\
function returns; the return value is ignored.  The thread will also exit\n\
when the function raises an unhandled exception; a stack trace will be\n\
printed unless the exception is SystemExit.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_exit_thread</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetNone</name><argument_list>(<argument><expr><name>PyExc_SystemExit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>exit_doc</name></expr></argument>,
<argument><expr>"exit()\n\
(PyThread_exit_thread() is an obsolete synonym)\n\
\n\
This is synonymous to ``raise SystemExit''.  It will cause the current\n\
thread to exit silently unless the exception is caught."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_interrupt_main</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type> <name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>interrupt_doc</name></expr></argument>,
<argument><expr>"interrupt_main()\n\
\n\
Raise a KeyboardInterrupt in the main thread.\n\
A subthread can use this function to interrupt the main thread."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_EXIT_PROG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_exit_prog</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>sts</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:exit_prog"</expr></argument>, <argument><expr>&amp;<name>sts</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_Exit</name><argument_list>(<argument><expr><name>sts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Calls PyThread_exit_prog(sts) or _PyThread_exit_prog(sts) */</comment>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{ }</block></for> <comment type="block">/* Should not be reached */</comment>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>lockobject</name> *</type><name>newlockobject</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_allocate_lock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>(<name>PyObject</name> *) <call><name>newlockobject</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>allocate_doc</name></expr></argument>,
<argument><expr>"allocate_lock() -&gt; lock object\n\
(allocate() is an obsolete synonym)\n\
\n\
Create a new lock object.  See LockType.__doc__ for information about locks."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_get_ident</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>ident</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>ident</name> = <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ident</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>, <argument><expr>"no current thread ident"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>get_ident_doc</name></expr></argument>,
<argument><expr>"get_ident() -&gt; integer\n\
\n\
Return a non-zero integer that uniquely identifies the current thread\n\
amongst other threads that exist simultaneously.\n\
This may be used to identify per-thread resources.\n\
Even though on some platforms threads identities may appear to be\n\
allocated consecutive numbers starting at 1, this behavior should not\n\
be relied upon, and the number should be seen purely as a magic cookie.\n\
A thread's identity may be reused for another thread after it exits."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_stack_size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>old_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>new_size</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|n:stack_size"</expr></argument>, <argument><expr>&amp;<name>new_size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>new_size</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"size must be 0 or a positive value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>old_size</name> = <call><name>PyThread_get_stacksize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rc</name> = <call><name>PyThread_set_stacksize</name><argument_list>(<argument><expr>(<name>size_t</name>) <name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rc</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			     <argument><expr>"size not valid: %zd bytes"</expr></argument>,
			     <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>rc</name> == -2</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>,
				<argument><expr>"setting stack size not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr>(<name>Py_ssize_t</name>) <name>old_size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>stack_size_doc</name></expr></argument>,
<argument><expr>"stack_size([size]) -&gt; size\n\
\n\
Return the thread stack size used when creating new threads.  The\n\
optional size argument specifies the stack size (in bytes) to be used\n\
for subsequently created threads, and must be 0 (use platform or\n\
configured default) or a positive integer value of at least 32,768 (32k).\n\
If changing the thread stack size is unsupported, a ThreadError\n\
exception is raised.  If the specified size is invalid, a ValueError\n\
exception is raised, and the stack size is unmodified.  32k bytes\n\
 currently the minimum supported stack size value to guarantee\n\
sufficient stack space for the interpreter itself.\n\
\n\
Note that some platforms may have particular restrictions on values for\n\
the stack size, such as requiring a minimum stack size larger than 32kB or\n\
requiring allocation in multiples of the system memory page size\n\
- platform documentation should be referred to for more information\n\
(4kB pages are common; using multiples of 4096 for the stack size is\n\
the suggested approach in the absence of more specific information)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>thread_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"start_new_thread"</expr>,	<expr>(<name>PyCFunction</name>)<name>thread_PyThread_start_new_thread</name></expr>,
	                        <expr><name>METH_VARARGS</name></expr>,
				<expr><name>start_new_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"start_new"</expr>,		<expr>(<name>PyCFunction</name>)<name>thread_PyThread_start_new_thread</name></expr>, 
	                        <expr><name>METH_VARARGS</name></expr>,
				<expr><name>start_new_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"allocate_lock"</expr>,	<expr>(<name>PyCFunction</name>)<name>thread_PyThread_allocate_lock</name></expr>, 
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>allocate_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"allocate"</expr>,		<expr>(<name>PyCFunction</name>)<name>thread_PyThread_allocate_lock</name></expr>, 
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>allocate_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"exit_thread"</expr>,		<expr>(<name>PyCFunction</name>)<name>thread_PyThread_exit_thread</name></expr>, 
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>exit_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"exit"</expr>,		<expr>(<name>PyCFunction</name>)<name>thread_PyThread_exit_thread</name></expr>, 
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>exit_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"interrupt_main"</expr>,	<expr>(<name>PyCFunction</name>)<name>thread_PyThread_interrupt_main</name></expr>,
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>interrupt_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"get_ident"</expr>,		<expr>(<name>PyCFunction</name>)<name>thread_get_ident</name></expr>, 
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>get_ident_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"stack_size"</expr>,		<expr>(<name>PyCFunction</name>)<name>thread_stack_size</name></expr>,
				<expr><name>METH_VARARGS</name></expr>,
				<expr><name>stack_size_doc</name></expr>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_EXIT_PROG</name></cpp:ifndef>
	<expr><block>{<expr>"exit_prog"</expr>,		<expr>(<name>PyCFunction</name>)<name>thread_PyThread_exit_prog</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr><name>NULL</name></expr>,			<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Initialization function */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>thread_doc</name></expr></argument>,
<argument><expr>"This module provides primitive operations to write multi-threaded programs.\n\
The 'threading' module provides a more convenient interface."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lock_doc</name></expr></argument>,
<argument><expr>"A lock object is a synchronization primitive.  To create a lock,\n\
call the PyThread_allocate_lock() function.  Methods are:\n\
\n\
acquire() -- lock the lock, possibly blocking until it can be obtained\n\
release() -- unlock of the lock\n\
locked() -- test whether the lock is currently locked\n\
\n\
A lock is not owned by the thread that locked it; another thread may\n\
unlock it.  A thread attempting to lock a lock that it has already locked\n\
will block until another thread unlocks it.  Deadlocks may ensue."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>initthread</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
	
	<comment type="block">/* Initialize types: */</comment>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>localtype</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* Create the module and add the functions */</comment>
	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"thread"</expr></argument>, <argument><expr><name>thread_methods</name></expr></argument>, <argument><expr><name>thread_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* Add a symbolic constant */</comment>
	<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ThreadError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"thread.error"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>ThreadError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Locktype</name>.<name>tp_doc</name></name> = <name>lock_doc</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>Locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LockType"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>Locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>localtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_local"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>localtype</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* Initialize the C thread library */</comment>
	<expr_stmt><expr><call><name>PyThread_init_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
