<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/datetimemodule.c"><comment type="block">/*  C implementation for the date/time type documented at
 *  http://www.zope.org/Members/fdrake/DateTimeWiki/FrontPage
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"modsupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timefuncs.h"</cpp:file></cpp:include>

<comment type="block">/* Differentiate between building the core module and building extension
 * modules.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_BUILD_CORE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_BUILD_CORE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datetime.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Py_BUILD_CORE</name></cpp:undef>

<comment type="block">/* We require that C int be at least 32 bits, and use int virtually
 * everywhere.  In just a few cases we use a temp long, where a Python
 * API returns a C long.  In such cases, we have to ensure that the
 * final result fits in a C int (this can be an issue on 64-bit boxes).
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> &lt; 4</expr></cpp:if>
<cpp:error>#	<cpp:directive>error</cpp:directive> "datetime.c requires that C int have at least 32 bits"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINYEAR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXYEAR</name></cpp:macro> <cpp:value>9999</cpp:value></cpp:define>

<comment type="block">/* Nine decimal digits is easy to communicate, and leaves enough room
 * so that two delta days can be added w/o fear of overflowing a signed
 * 32-bit int, and with plenty of room left over to absorb any possible
 * carries from adding seconds.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DELTA_DAYS</name></cpp:macro> <cpp:value>999999999</cpp:value></cpp:define>

<comment type="block">/* Rename the long macros in datetime.h to more reasonable short names. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_YEAR</name></cpp:macro>		<cpp:value>PyDateTime_GET_YEAR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_MONTH</name></cpp:macro>		<cpp:value>PyDateTime_GET_MONTH</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_DAY</name></cpp:macro>			<cpp:value>PyDateTime_GET_DAY</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATE_GET_HOUR</name></cpp:macro>		<cpp:value>PyDateTime_DATE_GET_HOUR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATE_GET_MINUTE</name></cpp:macro>		<cpp:value>PyDateTime_DATE_GET_MINUTE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATE_GET_SECOND</name></cpp:macro>		<cpp:value>PyDateTime_DATE_GET_SECOND</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATE_GET_MICROSECOND</name></cpp:macro>	<cpp:value>PyDateTime_DATE_GET_MICROSECOND</cpp:value></cpp:define>

<comment type="block">/* Date accessors for date and datetime. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_YEAR</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>(((o)-&gt;data[0] = ((v) &amp; 0xff00) &gt;&gt; 8), \
                                 ((o)-&gt;data[1] = ((v) &amp; 0x00ff)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_MONTH</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>(PyDateTime_GET_MONTH(o) = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_DAY</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>(PyDateTime_GET_DAY(o) = (v))</cpp:value></cpp:define>

<comment type="block">/* Date/Time accessors for datetime. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATE_SET_HOUR</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(PyDateTime_DATE_GET_HOUR(o) = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATE_SET_MINUTE</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(PyDateTime_DATE_GET_MINUTE(o) = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATE_SET_SECOND</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(PyDateTime_DATE_GET_SECOND(o) = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATE_SET_MICROSECOND</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	\
	<cpp:value>(((o)-&gt;data[7] = ((v) &amp; 0xff0000) &gt;&gt; 16), \
         ((o)-&gt;data[8] = ((v) &amp; 0x00ff00) &gt;&gt; 8), \
         ((o)-&gt;data[9] = ((v) &amp; 0x0000ff)))</cpp:value></cpp:define>

<comment type="block">/* Time accessors for time. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_GET_HOUR</name></cpp:macro>		<cpp:value>PyDateTime_TIME_GET_HOUR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_GET_MINUTE</name></cpp:macro>		<cpp:value>PyDateTime_TIME_GET_MINUTE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_GET_SECOND</name></cpp:macro>		<cpp:value>PyDateTime_TIME_GET_SECOND</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_GET_MICROSECOND</name></cpp:macro>	<cpp:value>PyDateTime_TIME_GET_MICROSECOND</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_SET_HOUR</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(PyDateTime_TIME_GET_HOUR(o) = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_SET_MINUTE</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(PyDateTime_TIME_GET_MINUTE(o) = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_SET_SECOND</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(PyDateTime_TIME_GET_SECOND(o) = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_SET_MICROSECOND</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	\
	<cpp:value>(((o)-&gt;data[3] = ((v) &amp; 0xff0000) &gt;&gt; 16), \
         ((o)-&gt;data[4] = ((v) &amp; 0x00ff00) &gt;&gt; 8), \
         ((o)-&gt;data[5] = ((v) &amp; 0x0000ff)))</cpp:value></cpp:define>

<comment type="block">/* Delta accessors for timedelta. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_TD_DAYS</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>(((PyDateTime_Delta *)(o))-&gt;days)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_TD_SECONDS</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(((PyDateTime_Delta *)(o))-&gt;seconds)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_TD_MICROSECONDS</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(((PyDateTime_Delta *)(o))-&gt;microseconds)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_TD_DAYS</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((o)-&gt;days = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_TD_SECONDS</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((o)-&gt;seconds = (v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_TD_MICROSECONDS</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((o)-&gt;microseconds = (v))</cpp:value></cpp:define>

<comment type="block">/* p is a pointer to a time or a datetime object; HASTZINFO(p) returns
 * p-&gt;hastzinfo.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASTZINFO</name><parameter_list>(<param><type><name>p</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>(((_PyDateTime_BaseTZInfo *)(p))-&gt;hastzinfo)</cpp:value></cpp:define>

<comment type="block">/* M is a char or int claiming to be a valid month.  The macro is equivalent
 * to the two-sided Python test
 *	1 &lt;= M &lt;= 12
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MONTH_IS_SANE</name><parameter_list>(<param><type><name>M</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((unsigned int)(M) - 1 &lt; 12)</cpp:value></cpp:define>

<comment type="block">/* Forward declarations. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyDateTime_DateType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyDateTime_DateTimeType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyDateTime_DeltaType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyDateTime_TimeType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyDateTime_TZInfoType</name></decl>;</decl_stmt>

<comment type="block">/* ---------------------------------------------------------------------------
 * Math utilities.
 */</comment>

<comment type="block">/* k = i+j overflows iff k differs in sign from both inputs,
 * iff k^i has sign bit set and k^j has sign bit set,
 * iff (k^i)&amp;(k^j) has sign bit set.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGNED_ADD_OVERFLOWED</name><parameter_list>(<param><type><name>RESULT</name></type></param>, <param><type><name>I</name></type></param>, <param><type><name>J</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>((((RESULT) ^ (I)) &amp; ((RESULT) ^ (J))) &lt; 0)</cpp:value></cpp:define>

<comment type="block">/* Compute Python divmod(x, y), returning the quotient and storing the
 * remainder into *r.  The quotient is the floor of x/y, and that's
 * the real point of this.  C will probably truncate instead (C99
 * requires truncation; C89 left it implementation-defined).
 * Simplification:  we *require* that y &gt; 0 here.  That's appropriate
 * for all the uses made of it.  This simplifies the code and makes
 * the overflow case impossible (divmod(LONG_MIN, -1) is the only
 * overflow case).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>divmod</name><parameter_list>(<param><decl><type><name>int</name></type> <name>x</name></decl></param>, <param><decl><type><name>int</name></type> <name>y</name></decl></param>, <param><decl><type><name>int</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>quo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>y</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>quo</name> = <name>x</name> / <name>y</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>r</name> = <name>x</name> - <name>quo</name> * <name>y</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>r</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>--<name>quo</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>r</name> += <name>y</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= *<name>r</name> &amp;&amp; *<name>r</name> &lt; <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>quo</name></expr>;</return>
}</block></function>

<comment type="block">/* Round a double to the nearest long.  |x| must be small enough to fit
 * in a C long; this is not checked.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>round_to_long</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>x</name> &gt;= 0.0</expr>)</condition><then>
		<expr_stmt><expr><name>x</name> = <call><name>floor</name><argument_list>(<argument><expr><name>x</name> + 0.5</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>x</name> = <call><name>ceil</name><argument_list>(<argument><expr><name>x</name> - 0.5</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr>(<name>long</name>)<name>x</name></expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * General calendrical helper functions
 */</comment>

<comment type="block">/* For each month ordinal in 1..12, the number of days in that month,
 * and the number of days before that month in the same year.  These
 * are correct for non-leap years only.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>_days_in_month</name><index>[]</index></name> <init>= <expr><block>{
	<expr>0</expr>, <comment type="block">/* unused; this vector uses 1-based indexing */</comment>
	<expr>31</expr>, <expr>28</expr>, <expr>31</expr>, <expr>30</expr>, <expr>31</expr>, <expr>30</expr>, <expr>31</expr>, <expr>31</expr>, <expr>30</expr>, <expr>31</expr>, <expr>30</expr>, <expr>31</expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>_days_before_month</name><index>[]</index></name> <init>= <expr><block>{
	<expr>0</expr>, <comment type="block">/* unused; this vector uses 1-based indexing */</comment>
	<expr>0</expr>, <expr>31</expr>, <expr>59</expr>, <expr>90</expr>, <expr>120</expr>, <expr>151</expr>, <expr>181</expr>, <expr>212</expr>, <expr>243</expr>, <expr>273</expr>, <expr>304</expr>, <expr>334</expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* year -&gt; 1 if leap year, else 0. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_leap</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Cast year to unsigned.  The result is the same either way, but
	 * C can generate faster code for unsigned mod than for signed
	 * mod (especially for % 4 -- a good compiler should just grab
	 * the last 2 bits when the LHS is unsigned).
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>ayear</name> <init>= <expr>(<name>unsigned</name> <name>int</name>)<name>year</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>ayear</name> % 4 == 0 &amp;&amp; (<name>ayear</name> % 100 != 0 || <name>ayear</name> % 400 == 0)</expr>;</return>
}</block></function>

<comment type="block">/* year, month -&gt; number of days in that month in that year */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>days_in_month</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>, <param><decl><type><name>int</name></type> <name>month</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>month</name> &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>month</name> &lt;= 12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>month</name> == 2 &amp;&amp; <call><name>is_leap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>29</expr>;</return></then>
	<else>else
		<return>return <expr><name><name>_days_in_month</name><index>[<expr><name>month</name></expr>]</index></name></expr>;</return></else></if>
}</block></function>

<comment type="block">/* year, month -&gt; number of days in year preceeding first day of month */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>days_before_month</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>, <param><decl><type><name>int</name></type> <name>month</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>days</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>month</name> &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>month</name> &lt;= 12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>days</name> = <name><name>_days_before_month</name><index>[<expr><name>month</name></expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>month</name> &gt; 2 &amp;&amp; <call><name>is_leap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr>++<name>days</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>days</name></expr>;</return>
}</block></function>

<comment type="block">/* year -&gt; number of days before January 1st of year.  Remember that we
 * start with year 1, so days_before_year(1) == 0.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>days_before_year</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><name>year</name> - 1</expr></init></decl>;</decl_stmt>
	<comment type="block">/* This is incorrect if year &lt;= 0; we really want the floor
	 * here.  But so long as MINYEAR is 1, the smallest year this
	 * can see is 0 (this can happen in some normalization endcases),
	 * so we'll just special-case that.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>year</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>y</name> &gt;= 0</expr>)</condition><then>
		<return>return <expr><name>y</name>*365 + <name>y</name>/4 - <name>y</name>/100 + <name>y</name>/400</expr>;</return></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>y</name> == -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-366</expr>;</return>
	}</block></else></if>
}</block></function>

<comment type="block">/* Number of days in 4, 100, and 400 year cycles.  That these have
 * the correct values is asserted in the module init function.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI4Y</name></cpp:macro>	<cpp:value>1461</cpp:value></cpp:define>	<comment type="block">/* days_before_year(5); days in 4 years */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI100Y</name></cpp:macro>	<cpp:value>36524</cpp:value></cpp:define>	<comment type="block">/* days_before_year(101); days in 100 years */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI400Y</name></cpp:macro>	<cpp:value>146097</cpp:value></cpp:define>	<comment type="block">/* days_before_year(401); days in 400 years  */</comment>

<comment type="block">/* ordinal -&gt; year, month, day, considering 01-Jan-0001 as day 1. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ord_to_ymd</name><parameter_list>(<param><decl><type><name>int</name></type> <name>ordinal</name></decl></param>, <param><decl><type><name>int</name> *</type><name>year</name></decl></param>, <param><decl><type><name>int</name> *</type><name>month</name></decl></param>, <param><decl><type><name>int</name> *</type><name>day</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>n1</name></decl>, <decl><type ref="prev"/><name>n4</name></decl>, <decl><type ref="prev"/><name>n100</name></decl>, <decl><type ref="prev"/><name>n400</name></decl>, <decl><type ref="prev"/><name>leapyear</name></decl>, <decl><type ref="prev"/><name>preceding</name></decl>;</decl_stmt>

	<comment type="block">/* ordinal is a 1-based index, starting at 1-Jan-1.  The pattern of
	 * leap years repeats exactly every 400 years.  The basic strategy is
	 * to find the closest 400-year boundary at or before ordinal, then
	 * work with the offset from that boundary to ordinal.  Life is much
	 * clearer if we subtract 1 from ordinal first -- then the values
	 * of ordinal at 400-year boundaries are exactly those divisible
	 * by DI400Y:
	 *
	 *    D  M   Y            n              n-1
	 *    -- --- ----        ----------     ----------------
	 *    31 Dec -400        -DI400Y       -DI400Y -1
	 *     1 Jan -399         -DI400Y +1   -DI400Y      400-year boundary
	 *    ...
	 *    30 Dec  000        -1             -2
	 *    31 Dec  000         0             -1
	 *     1 Jan  001         1              0          400-year boundary
	 *     2 Jan  001         2              1
	 *     3 Jan  001         3              2
	 *    ...
	 *    31 Dec  400         DI400Y        DI400Y -1
	 *     1 Jan  401         DI400Y +1     DI400Y      400-year boundary
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ordinal</name> &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>--<name>ordinal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n400</name> = <name>ordinal</name> / <name>DI400Y</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <name>ordinal</name> % <name>DI400Y</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>year</name> = <name>n400</name> * 400 + 1</expr>;</expr_stmt>

	<comment type="block">/* Now n is the (non-negative) offset, in days, from January 1 of
	 * year, to the desired date.  Now compute how many 100-year cycles
	 * precede n.
	 * Note that it's possible for n100 to equal 4!  In that case 4 full
	 * 100-year cycles precede the desired day, which implies the
	 * desired day is December 31 at the end of a 400-year cycle.
	 */</comment>
	<expr_stmt><expr><name>n100</name> = <name>n</name> / <name>DI100Y</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <name>n</name> % <name>DI100Y</name></expr>;</expr_stmt>

	<comment type="block">/* Now compute how many 4-year cycles precede it. */</comment>
	<expr_stmt><expr><name>n4</name> = <name>n</name> / <name>DI4Y</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <name>n</name> % <name>DI4Y</name></expr>;</expr_stmt>

	<comment type="block">/* And now how many single years.  Again n1 can be 4, and again
	 * meaning that the desired day is December 31 at the end of the
	 * 4-year cycle.
	 */</comment>
	<expr_stmt><expr><name>n1</name> = <name>n</name> / 365</expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> = <name>n</name> % 365</expr>;</expr_stmt>

	<expr_stmt><expr>*<name>year</name> += <name>n100</name> * 100 + <name>n4</name> * 4 + <name>n1</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n1</name> == 4 || <name>n100</name> == 4</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>year</name> -= 1</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>month</name> = 12</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>day</name> = 31</expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>

	<comment type="block">/* Now the year is correct, and n is the offset from January 1.  We
	 * find the month via an estimate that's either exact or one too
	 * large.
	 */</comment>
	<expr_stmt><expr><name>leapyear</name> = <name>n1</name> == 3 &amp;&amp; (<name>n4</name> != 24 || <name>n100</name> == 3)</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>leapyear</name> == <call><name>is_leap</name><argument_list>(<argument><expr>*<name>year</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>month</name> = (<name>n</name> + 50) &gt;&gt; 5</expr>;</expr_stmt>
	<expr_stmt><expr><name>preceding</name> = (<name><name>_days_before_month</name><index>[<expr>*<name>month</name></expr>]</index></name> + (*<name>month</name> &gt; 2 &amp;&amp; <name>leapyear</name>))</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>preceding</name> &gt; <name>n</name></expr>)</condition><then> <block>{
		<comment type="block">/* estimate is too large */</comment>
		<expr_stmt><expr>*<name>month</name> -= 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>preceding</name> -= <call><name>days_in_month</name><argument_list>(<argument><expr>*<name>year</name></expr></argument>, <argument><expr>*<name>month</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>n</name> -= <name>preceding</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &lt; <call><name>days_in_month</name><argument_list>(<argument><expr>*<name>year</name></expr></argument>, <argument><expr>*<name>month</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr>*<name>day</name> = <name>n</name> + 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* year, month, day -&gt; ordinal, considering 01-Jan-0001 as day 1. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ymd_to_ord</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>, <param><decl><type><name>int</name></type> <name>month</name></decl></param>, <param><decl><type><name>int</name></type> <name>day</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>days_before_year</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call> + <call><name>days_before_month</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>)</argument_list></call> + <name>day</name></expr>;</return>
}</block></function>

<comment type="block">/* Day of week, where Monday==0, ..., Sunday==6.  1/1/1 was a Monday. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>weekday</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>, <param><decl><type><name>int</name></type> <name>month</name></decl></param>, <param><decl><type><name>int</name></type> <name>day</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>(<call><name>ymd_to_ord</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call> + 6) % 7</expr>;</return>
}</block></function>

<comment type="block">/* Ordinal of the Monday starting week 1 of the ISO year.  Week 1 is the
 * first calendar week containing a Thursday.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>iso_week1_monday</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>first_day</name> <init>= <expr><call><name>ymd_to_ord</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* ord of 1/1 */</comment>
	<comment type="block">/* 0 if 1/1 is a Monday, 1 if a Tue, etc. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>first_weekday</name> <init>= <expr>(<name>first_day</name> + 6) % 7</expr></init></decl>;</decl_stmt>
	<comment type="block">/* ordinal of closest Monday at or before 1/1 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>week1_monday</name>  <init>= <expr><name>first_day</name> - <name>first_weekday</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>first_weekday</name> &gt; 3</expr>)</condition><then>	<comment type="block">/* if 1/1 was Fri, Sat, Sun */</comment>
		<expr_stmt><expr><name>week1_monday</name> += 7</expr>;</expr_stmt></then></if>
	<return>return <expr><name>week1_monday</name></expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * Range checkers.
 */</comment>

<comment type="block">/* Check that -MAX_DELTA_DAYS &lt;= days &lt;= MAX_DELTA_DAYS.  If so, return 0.
 * If not, raise OverflowError and return -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_delta_day_range</name><parameter_list>(<param><decl><type><name>int</name></type> <name>days</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>-<name>MAX_DELTA_DAYS</name> &lt;= <name>days</name> &amp;&amp; <name>days</name> &lt;= <name>MAX_DELTA_DAYS</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
		     <argument><expr>"days=%d; must have magnitude &lt;= %d"</expr></argument>,
		     <argument><expr><name>days</name></expr></argument>, <argument><expr><name>MAX_DELTA_DAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* Check that date arguments are in range.  Return 0 if they are.  If they
 * aren't, raise ValueError and return -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_date_args</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>, <param><decl><type><name>int</name></type> <name>month</name></decl></param>, <param><decl><type><name>int</name></type> <name>day</name></decl></param>)</parameter_list>
<block>{

	<if>if <condition>(<expr><name>year</name> &lt; <name>MINYEAR</name> || <name>year</name> &gt; <name>MAXYEAR</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"year is out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>month</name> &lt; 1 || <name>month</name> &gt; 12</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"month must be in 1..12"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>day</name> &lt; 1 || <name>day</name> &gt; <call><name>days_in_month</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"day is out of range for month"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Check that time arguments are in range.  Return 0 if they are.  If they
 * aren't, raise ValueError and return -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_time_args</name><parameter_list>(<param><decl><type><name>int</name></type> <name>h</name></decl></param>, <param><decl><type><name>int</name></type> <name>m</name></decl></param>, <param><decl><type><name>int</name></type> <name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>us</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>h</name> &lt; 0 || <name>h</name> &gt; 23</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"hour must be in 0..23"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>m</name> &lt; 0 || <name>m</name> &gt; 59</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"minute must be in 0..59"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>s</name> &lt; 0 || <name>s</name> &gt; 59</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"second must be in 0..59"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>us</name> &lt; 0 || <name>us</name> &gt; 999999</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"microsecond must be in 0..999999"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * Normalization utilities.
 */</comment>

<comment type="block">/* One step of a mixed-radix conversion.  A "hi" unit is equivalent to
 * factor "lo" units.  factor must be &gt; 0.  If *lo is less than 0, or
 * at least factor, enough of *lo is converted into "hi" units so that
 * 0 &lt;= *lo &lt; factor.  The input values must be such that int overflow
 * is impossible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>normalize_pair</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>hi</name></decl></param>, <param><decl><type><name>int</name> *</type><name>lo</name></decl></param>, <param><decl><type><name>int</name></type> <name>factor</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>factor</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lo</name> != <name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>lo</name> &lt; 0 || *<name>lo</name> &gt;= <name>factor</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>num_hi</name> <init>= <expr><call><name>divmod</name><argument_list>(<argument><expr>*<name>lo</name></expr></argument>, <argument><expr><name>factor</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>new_hi</name> <init>= <expr>*<name>hi</name> + <name>num_hi</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>! <call><name>SIGNED_ADD_OVERFLOWED</name><argument_list>(<argument><expr><name>new_hi</name></expr></argument>, <argument><expr>*<name>hi</name></expr></argument>, <argument><expr><name>num_hi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>hi</name> = <name>new_hi</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= *<name>lo</name> &amp;&amp; *<name>lo</name> &lt; <name>factor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Fiddle days (d), seconds (s), and microseconds (us) so that
 * 	0 &lt;= *s &lt; 24*3600
 * 	0 &lt;= *us &lt; 1000000
 * The input values must be such that the internals don't overflow.
 * The way this routine is used, we don't get close.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>normalize_d_s_us</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>d</name></decl></param>, <param><decl><type><name>int</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name> *</type><name>us</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>*<name>us</name> &lt; 0 || *<name>us</name> &gt;= 1000000</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>normalize_pair</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>us</name></expr></argument>, <argument><expr>1000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* |s| can't be bigger than about
		 * |original s| + |original us|/1000000 now.
		 */</comment>

	}</block></then></if>
	<if>if <condition>(<expr>*<name>s</name> &lt; 0 || *<name>s</name> &gt;= 24*3600</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>normalize_pair</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>24*3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* |d| can't be bigger than about
		 * |original d| +
		 * (|original s| + |original us|/1000000) / (24*3600) now.
		 */</comment>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= *<name>s</name> &amp;&amp; *<name>s</name> &lt; 24*3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= *<name>us</name> &amp;&amp; *<name>us</name> &lt; 1000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Fiddle years (y), months (m), and days (d) so that
 * 	1 &lt;= *m &lt;= 12
 * 	1 &lt;= *d &lt;= days_in_month(*y, *m)
 * The input values must be such that the internals don't overflow.
 * The way this routine is used, we don't get close.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>normalize_y_m_d</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>y</name></decl></param>, <param><decl><type><name>int</name> *</type><name>m</name></decl></param>, <param><decl><type><name>int</name> *</type><name>d</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>dim</name></decl>;</decl_stmt>	<comment type="block">/* # of days in month */</comment>

	<comment type="block">/* This gets muddy:  the proper range for day can't be determined
	 * without knowing the correct month and year, but if day is, e.g.,
	 * plus or minus a million, the current month and year values make
	 * no sense (and may also be out of bounds themselves).
	 * Saying 12 months == 1 year should be non-controversial.
	 */</comment>
	<if>if <condition>(<expr>*<name>m</name> &lt; 1 || *<name>m</name> &gt; 12</expr>)</condition><then> <block>{
		<expr_stmt><expr>--*<name>m</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>normalize_pair</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr>12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>++*<name>m</name></expr>;</expr_stmt>
		<comment type="block">/* |y| can't be bigger than about
		 * |original y| + |original m|/12 now.
		 */</comment>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>1 &lt;= *<name>m</name> &amp;&amp; *<name>m</name> &lt;= 12</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now only day can be out of bounds (year may also be out of bounds
	 * for a datetime object, but we don't care about that here).
	 * If day is out of bounds, what to do is arguable, but at least the
	 * method here is principled and explainable.
	 */</comment>
	<expr_stmt><expr><name>dim</name> = <call><name>days_in_month</name><argument_list>(<argument><expr>*<name>y</name></expr></argument>, <argument><expr>*<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>d</name> &lt; 1 || *<name>d</name> &gt; <name>dim</name></expr>)</condition><then> <block>{
		<comment type="block">/* Move day-1 days from the first of the month.  First try to
		 * get off cheap if we're only one day out of range
		 * (adjustments for timezone alone can't be worse than that).
		 */</comment>
		<if>if <condition>(<expr>*<name>d</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr>--*<name>m</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>m</name> &gt; 0</expr>)</condition><then>
				<expr_stmt><expr>*<name>d</name> = <call><name>days_in_month</name><argument_list>(<argument><expr>*<name>y</name></expr></argument>, <argument><expr>*<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <block>{
				<expr_stmt><expr>--*<name>y</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>m</name> = 12</expr>;</expr_stmt>
				<expr_stmt><expr>*<name>d</name> = 31</expr>;</expr_stmt>
			}</block></else></if>
		}</block></then>
		<else>else <if>if <condition>(<expr>*<name>d</name> == <name>dim</name> + 1</expr>)</condition><then> <block>{
			<comment type="block">/* move forward a day */</comment>
			<expr_stmt><expr>++*<name>m</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>d</name> = 1</expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>m</name> &gt; 12</expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>m</name> = 1</expr>;</expr_stmt>
				<expr_stmt><expr>++*<name>y</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>ordinal</name> <init>= <expr><call><name>ymd_to_ord</name><argument_list>(<argument><expr>*<name>y</name></expr></argument>, <argument><expr>*<name>m</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> +
						  *<name>d</name> - 1</expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ord_to_ymd</name><argument_list>(<argument><expr><name>ordinal</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if></else></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>m</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>d</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Fiddle out-of-bounds months and days so that the result makes some kind
 * of sense.  The parameters are both inputs and outputs.  Returns &lt; 0 on
 * failure, where failure means the adjusted year is out of bounds.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>normalize_date</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>year</name></decl></param>, <param><decl><type><name>int</name> *</type><name>month</name></decl></param>, <param><decl><type><name>int</name> *</type><name>day</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>normalize_y_m_d</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>MINYEAR</name> &lt;= *<name>year</name> &amp;&amp; *<name>year</name> &lt;= <name>MAXYEAR</name></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"date value out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Force all the datetime fields into range.  The parameters are both
 * inputs and outputs.  Returns &lt; 0 on error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>normalize_datetime</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>year</name></decl></param>, <param><decl><type><name>int</name> *</type><name>month</name></decl></param>, <param><decl><type><name>int</name> *</type><name>day</name></decl></param>,
                   <param><decl><type><name>int</name> *</type><name>hour</name></decl></param>, <param><decl><type><name>int</name> *</type><name>minute</name></decl></param>, <param><decl><type><name>int</name> *</type><name>second</name></decl></param>,
                   <param><decl><type><name>int</name> *</type><name>microsecond</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>normalize_pair</name><argument_list>(<argument><expr><name>second</name></expr></argument>, <argument><expr><name>microsecond</name></expr></argument>, <argument><expr>1000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>normalize_pair</name><argument_list>(<argument><expr><name>minute</name></expr></argument>, <argument><expr><name>second</name></expr></argument>, <argument><expr>60</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>normalize_pair</name><argument_list>(<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>, <argument><expr>60</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>normalize_pair</name><argument_list>(<argument><expr><name>day</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr>24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>normalize_date</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * Basic object allocation:  tp_alloc implementations.  These allocate
 * Python objects of the right size and type, and do the Python object-
 * initialization bit.  If there's not enough memory, they return NULL after
 * setting MemoryError.  All data members remain uninitialized trash.
 *
 * We abuse the tp_alloc "nitems" argument to communicate whether a tzinfo
 * member is needed.  This is ugly, imprecise, and possibly insecure.
 * tp_basicsize for the time and datetime types is set to the size of the
 * struct that has room for the tzinfo member, so subclasses in Python will
 * allocate enough space for a tzinfo member whether or not one is actually
 * needed.  That's the "ugly and imprecise" parts.  The "possibly insecure"
 * part is that PyType_GenericAlloc() (which subclasses in Python end up
 * using) just happens today to effectively ignore the nitems argument
 * when tp_itemsize is 0, which it is for these type objects.  If that
 * changes, perhaps the callers of tp_alloc slots in this file should
 * be changed to force a 0 nitems argument unless the type being allocated
 * is a base type implemented in this file (so that tp_alloc is time_alloc
 * or datetime_alloc below, which know about the nitems abuse).
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_alloc</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>aware</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>self</name> = (<name>PyObject</name> *)
		<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>aware</name> ?
				<sizeof>sizeof<argument_list>(<argument><expr><name>PyDateTime_Time</name></expr></argument>)</argument_list></sizeof> :
				<sizeof>sizeof<argument_list>(<argument><expr><name>_PyDateTime_BaseTime</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(<name>PyObject</name> *)<call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_alloc</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>aware</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>self</name> = (<name>PyObject</name> *)
		<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>aware</name> ?
				<sizeof>sizeof<argument_list>(<argument><expr><name>PyDateTime_DateTime</name></expr></argument>)</argument_list></sizeof> :
				<sizeof>sizeof<argument_list>(<argument><expr><name>_PyDateTime_BaseDateTime</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>(<name>PyObject</name> *)<call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * Helpers for setting object fields.  These work on pointers to the
 * appropriate base class.
 */</comment>

<comment type="block">/* For date and datetime. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_date_fields</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>y</name></decl></param>, <param><decl><type><name>int</name></type> <name>m</name></decl></param>, <param><decl><type><name>int</name></type> <name>d</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name><name>self</name>-&gt;<name>hashcode</name></name> = -1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * Create various objects, mostly without range checking.
 */</comment>

<comment type="block">/* Create a date instance with no range checking. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>new_date_ex</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>, <param><decl><type><name>int</name></type> <name>month</name></decl></param>, <param><decl><type><name>int</name></type> <name>day</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>self</name> = <call>(<name>PyDateTime_Date</name> *) <argument_list>(<argument><expr><call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>set_date_fields</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>(<name>PyObject</name> *) <name>self</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>new_date</name><parameter_list>(<param><type><name>year</name></type></param>, <param><type><name>month</name></type></param>, <param><type><name>day</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>new_date_ex(year, month, day, &amp;PyDateTime_DateType)</cpp:value></cpp:define>

<comment type="block">/* Create a datetime instance with no range checking. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>new_datetime_ex</name><parameter_list>(<param><decl><type><name>int</name></type> <name>year</name></decl></param>, <param><decl><type><name>int</name></type> <name>month</name></decl></param>, <param><decl><type><name>int</name></type> <name>day</name></decl></param>, <param><decl><type><name>int</name></type> <name>hour</name></decl></param>, <param><decl><type><name>int</name></type> <name>minute</name></decl></param>,
	     <param><decl><type><name>int</name></type> <name>second</name></decl></param>, <param><decl><type><name>int</name></type> <name>usecond</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>aware</name> <init>= <expr><name>tzinfo</name> != <name>Py_None</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>self</name> = <call>(<name>PyDateTime_DateTime</name> *) <argument_list>(<argument><expr><call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>aware</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>self</name>-&gt;<name>hastzinfo</name></name> = <name>aware</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_date_fields</name><argument_list>(<argument><expr>(<name>PyDateTime_Date</name> *)<name>self</name></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DATE_SET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DATE_SET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DATE_SET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DATE_SET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>usecond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>aware</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>tzinfo</name></name> = <name>tzinfo</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>new_datetime</name><parameter_list>(<param><type><name>y</name></type></param>, <param><type><name>m</name></type></param>, <param><type><name>d</name></type></param>, <param><type><name>hh</name></type></param>, <param><type><name>mm</name></type></param>, <param><type><name>ss</name></type></param>, <param><type><name>us</name></type></param>, <param><type><name>tzinfo</name></type></param>)</parameter_list></cpp:macro>		\
	<cpp:value>new_datetime_ex(y, m, d, hh, mm, ss, us, tzinfo,	\
			&amp;PyDateTime_DateTimeType)</cpp:value></cpp:define>

<comment type="block">/* Create a time instance with no range checking. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>new_time_ex</name><parameter_list>(<param><decl><type><name>int</name></type> <name>hour</name></decl></param>, <param><decl><type><name>int</name></type> <name>minute</name></decl></param>, <param><decl><type><name>int</name></type> <name>second</name></decl></param>, <param><decl><type><name>int</name></type> <name>usecond</name></decl></param>,
	    <param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>aware</name> <init>= <expr><name>tzinfo</name> != <name>Py_None</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>self</name> = <call>(<name>PyDateTime_Time</name> *) <argument_list>(<argument><expr><call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>aware</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>self</name>-&gt;<name>hastzinfo</name></name> = <name>aware</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>hashcode</name></name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TIME_SET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TIME_SET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TIME_SET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TIME_SET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>usecond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>aware</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>tzinfo</name></name> = <name>tzinfo</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>new_time</name><parameter_list>(<param><type><name>hh</name></type></param>, <param><type><name>mm</name></type></param>, <param><type><name>ss</name></type></param>, <param><type><name>us</name></type></param>, <param><type><name>tzinfo</name></type></param>)</parameter_list></cpp:macro>		\
	<cpp:value>new_time_ex(hh, mm, ss, us, tzinfo, &amp;PyDateTime_TimeType)</cpp:value></cpp:define>

<comment type="block">/* Create a timedelta instance.  Normalize the members iff normalize is
 * true.  Passing false is a speed optimization, if you know for sure
 * that seconds and microseconds are already in their proper ranges.  In any
 * case, raises OverflowError and returns NULL if the normalized days is out
 * of range).
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>new_delta_ex</name><parameter_list>(<param><decl><type><name>int</name></type> <name>days</name></decl></param>, <param><decl><type><name>int</name></type> <name>seconds</name></decl></param>, <param><decl><type><name>int</name></type> <name>microseconds</name></decl></param>, <param><decl><type><name>int</name></type> <name>normalize</name></decl></param>,
	     <param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>normalize</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>normalize_d_s_us</name><argument_list>(<argument><expr>&amp;<name>days</name></expr></argument>, <argument><expr>&amp;<name>seconds</name></expr></argument>, <argument><expr>&amp;<name>microseconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <name>seconds</name> &amp;&amp; <name>seconds</name> &lt; 24*3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <name>microseconds</name> &amp;&amp; <name>microseconds</name> &lt; 1000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>

 	<if>if <condition>(<expr><call><name>check_delta_day_range</name><argument_list>(<argument><expr><name>days</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
 		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>self</name> = <call>(<name>PyDateTime_Delta</name> *) <argument_list>(<argument><expr><call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>self</name>-&gt;<name>hashcode</name></name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>days</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>microseconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *) <name>self</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>new_delta</name><parameter_list>(<param><type><name>d</name></type></param>, <param><type><name>s</name></type></param>, <param><type><name>us</name></type></param>, <param><type><name>normalize</name></type></param>)</parameter_list></cpp:macro>	\
	<cpp:value>new_delta_ex(d, s, us, normalize, &amp;PyDateTime_DeltaType)</cpp:value></cpp:define>

<comment type="block">/* ---------------------------------------------------------------------------
 * tzinfo helpers.
 */</comment>

<comment type="block">/* Ensure that p is None or of a tzinfo subclass.  Return 0 if OK; if not
 * raise TypeError and return -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_tzinfo_subclass</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>p</name> == <name>Py_None</name> || <call><name>PyTZInfo_Check</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"tzinfo argument must be None or of a tzinfo subclass, "
		     "not type '%s'"</expr></argument>,
		     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* Return tzinfo.methname(tzinfoarg), without any checking of results.
 * If tzinfo is None, returns None.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_tzinfo_method</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>, <param><decl><type><name>char</name> *</type><name>methname</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfoarg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfo</name> &amp;&amp; <name>methname</name> &amp;&amp; <name>tzinfoarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>check_tzinfo_subclass</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tzinfo</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr><name>methname</name></expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>tzinfoarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* If self has a tzinfo member, return a BORROWED reference to it.  Else
 * return NULL, which is NOT AN ERROR.  There are no error returns here,
 * and the caller must not decref the result.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_tzinfo_member</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>tzinfo</name> = ((<name>PyDateTime_DateTime</name> *)<name>self</name>)-&gt;<name>tzinfo</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyTime_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>tzinfo</name> = ((<name>PyDateTime_Time</name> *)<name>self</name>)-&gt;<name>tzinfo</name></expr>;</expr_stmt></then></if></else></if>

	<return>return <expr><name>tzinfo</name></expr>;</return>
}</block></function>

<comment type="block">/* Call getattr(tzinfo, name)(tzinfoarg), and extract an int from the
 * result.  tzinfo must be an instance of the tzinfo class.  If the method
 * returns None, this returns 0 and sets *none to 1.  If the method doesn't
 * return None or timedelta, TypeError is raised and this returns -1.  If it
 * returnsa timedelta and the value is out of range or isn't a whole number
 * of minutes, ValueError is raised and this returns -1.
 * Else *none is set to 0 and the integer method result is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>call_utc_tzinfo_method</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfoarg</name></decl></param>,
		       <param><decl><type><name>int</name> *</type><name>none</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfo</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTZInfo_Check</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfoarg</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr>*<name>none</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>u</name> = <call><name>call_tzinfo_method</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>tzinfoarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then>

	<else>else <if>if <condition>(<expr><name>u</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>none</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>days</name> <init>= <expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>days</name> &lt; -1 || <name>days</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = 24*60</expr>;</expr_stmt></then>	<comment type="block">/* trigger ValueError below */</comment>
		<else>else <block>{
			<comment type="block">/* next line can't overflow because we know days
			 * is -1 or 0 now
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>ss</name> <init>= <expr><name>days</name> * 24 * 3600 + <call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>result</name> = <call><name>divmod</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr>60</expr></argument>, <argument><expr>&amp;<name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ss</name> || <call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					     <argument><expr>"tzinfo.%s() must return a "
					     "whole number of minutes"</expr></argument>,
					     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
			}</block></then></if>
		}</block></else></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"tzinfo.%s() must return None or "
			     "timedelta, not '%s'"</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if></else></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> &lt; -1439 || <name>result</name> &gt; 1439</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			     <argument><expr>"tzinfo.%s() returned %d; must be in "
			     "-1439 .. 1439"</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Call tzinfo.utcoffset(tzinfoarg), and extract an integer from the
 * result.  tzinfo must be an instance of the tzinfo class.  If utcoffset()
 * returns None, call_utcoffset returns 0 and sets *none to 1.  If uctoffset()
 * doesn't return None or timedelta, TypeError is raised and this returns -1.
 * If utcoffset() returns an invalid timedelta (out of range, or not a whole
 * # of minutes), ValueError is raised and this returns -1.  Else *none is
 * set to 0 and the offset is returned (as int # of minutes east of UTC).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>call_utcoffset</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfoarg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>none</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>call_utc_tzinfo_method</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr>"utcoffset"</expr></argument>, <argument><expr><name>tzinfoarg</name></expr></argument>, <argument><expr><name>none</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Call tzinfo.name(tzinfoarg), and return the offset as a timedelta or None.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>offset_as_timedelta</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfoarg</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfo</name> &amp;&amp; <name>name</name> &amp;&amp; <name>tzinfoarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tzinfo</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>none</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name>call_utc_tzinfo_method</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>tzinfoarg</name></expr></argument>,
						    <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>offset</name> &lt; 0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name>none</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>result</name> = <call><name>new_delta</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>offset</name> * 60</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Call tzinfo.dst(tzinfoarg), and extract an integer from the
 * result.  tzinfo must be an instance of the tzinfo class.  If dst()
 * returns None, call_dst returns 0 and sets *none to 1.  If dst()
 &amp; doesn't return None or timedelta, TypeError is raised and this
 * returns -1.  If dst() returns an invalid timedelta for a UTC offset,
 * ValueError is raised and this returns -1.  Else *none is set to 0 and
 * the offset is returned (as an int # of minutes east of UTC).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>call_dst</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfoarg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>none</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>call_utc_tzinfo_method</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr>"dst"</expr></argument>, <argument><expr><name>tzinfoarg</name></expr></argument>, <argument><expr><name>none</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Call tzinfo.tzname(tzinfoarg), and return the result.  tzinfo must be
 * an instance of the tzinfo class or None.  If tzinfo isn't None, and
 * tzname() doesn't return None or a string, TypeError is raised and this
 * returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_tzname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfoarg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfo</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>check_tzinfo_subclass</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfoarg</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>tzinfo</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr>"tzname"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>tzinfoarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name>result</name> != <name>NULL</name> &amp;&amp; <name>result</name> != <name>Py_None</name> &amp;&amp; ! <call><name>PyString_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"tzinfo.tzname() must "
			     "return None or a string, not '%s'"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<typedef>typedef <type><enum>enum <block>{
	      <comment type="block">/* an exception has been set; the caller should pass it on */</comment>
	      <decl><name>OFFSET_ERROR</name></decl>,

	      <comment type="block">/* type isn't date, datetime, or time subclass */</comment>
	      <decl><name>OFFSET_UNKNOWN</name></decl>,

	      <comment type="block">/* date,
	       * datetime with !hastzinfo
	       * datetime with None tzinfo,
	       * datetime where utcoffset() returns None
	       * time with !hastzinfo
	       * time with None tzinfo,
	       * time where utcoffset() returns None
	       */</comment>
	      <decl><name>OFFSET_NAIVE</name></decl>,

	      <comment type="block">/* time or datetime where utcoffset() doesn't return None */</comment>
	      <decl><name>OFFSET_AWARE</name></decl>
}</block></enum></type> <name>naivety</name>;</typedef>

<comment type="block">/* Classify an object as to whether it's naive or offset-aware.  See
 * the "naivety" typedef for details.  If the type is aware, *offset is set
 * to minutes east of UTC (as returned by the tzinfo.utcoffset() method).
 * If the type is offset-naive (or unknown, or error), *offset is set to 0.
 * tzinfoarg is the argument to pass to the tzinfo.utcoffset() method.
 */</comment>
<function><type><specifier>static</specifier> <name>naivety</name></type>
<name>classify_utcoffset</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfoarg</name></decl></param>, <param><decl><type><name>int</name> *</type><name>offset</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>none</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfoarg</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>offset</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>tzinfo</name> = <call><name>get_tzinfo_member</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* NULL means no tzinfo, not error */</comment>
	<if>if <condition>(<expr><name>tzinfo</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr><name>OFFSET_NAIVE</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>tzinfo</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* note that a datetime passes the PyDate_Check test */</comment>
		<return>return <expr>(<call><name>PyTime_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> || <call><name>PyDate_Check</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>) ?
		       <name>OFFSET_NAIVE</name> : <name>OFFSET_UNKNOWN</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>*<name>offset</name> = <call><name>call_utcoffset</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr><name>tzinfoarg</name></expr></argument>, <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>offset</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>OFFSET_ERROR</name></expr>;</return></then></if>
	<return>return <expr><name>none</name> ? <name>OFFSET_NAIVE</name> : <name>OFFSET_AWARE</name></expr>;</return>
}</block></function>

<comment type="block">/* Classify two objects as to whether they're naive or offset-aware.
 * This isn't quite the same as calling classify_utcoffset() twice:  for
 * binary operations (comparison and subtraction), we generally want to
 * ignore the tzinfo members if they're identical.  This is by design,
 * so that results match "naive" expectations when mixing objects from a
 * single timezone.  So in that case, this sets both offsets to 0 and
 * both naiveties to OFFSET_NAIVE.
 * The function returns 0 if everything's OK, and -1 on error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>classify_two_utcoffsets</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o1</name></decl></param>, <param><decl><type><name>int</name> *</type><name>offset1</name></decl></param>, <param><decl><type><name>naivety</name> *</type><name>n1</name></decl></param>,
			<param><decl><type><name>PyObject</name> *</type><name>tzinfoarg1</name></decl></param>,
			<param><decl><type><name>PyObject</name> *</type><name>o2</name></decl></param>, <param><decl><type><name>int</name> *</type><name>offset2</name></decl></param>, <param><decl><type><name>naivety</name> *</type><name>n2</name></decl></param>,
			<param><decl><type><name>PyObject</name> *</type><name>tzinfoarg2</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>get_tzinfo_member</name><argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call> == <call><name>get_tzinfo_member</name><argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>offset1</name> = *<name>offset2</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>n1</name> = *<name>n2</name> = <name>OFFSET_NAIVE</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr>*<name>n1</name> = <call><name>classify_utcoffset</name><argument_list>(<argument><expr><name>o1</name></expr></argument>, <argument><expr><name>tzinfoarg1</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>n1</name> == <name>OFFSET_ERROR</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr>*<name>n2</name> = <call><name>classify_utcoffset</name><argument_list>(<argument><expr><name>o2</name></expr></argument>, <argument><expr><name>tzinfoarg2</name></expr></argument>, <argument><expr><name>offset2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>n2</name> == <name>OFFSET_ERROR</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* repr is like "someclass(arg1, arg2)".  If tzinfo isn't None,
 * stuff
 *     ", tzinfo=" + repr(tzinfo)
 * before the closing ")".
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>append_keyword_tzinfo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>repr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tzinfo</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr><name>repr</name></expr>;</return></then></if>
	<comment type="block">/* Get rid of the trailing ')'. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call><index>[<expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call>-1</expr>]</index> == ')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>repr</name> = <name>temp</name></expr>;</expr_stmt>

	<comment type="block">/* Append ", tzinfo=". */</comment>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>", tzinfo="</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Append repr(tzinfo). */</comment>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add a closing paren. */</comment>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>repr</name></expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * String format helpers.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>format_ctime</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>date</name></decl></param>, <param><decl><type><name>int</name></type> <name>hours</name></decl></param>, <param><decl><type><name>int</name></type> <name>minutes</name></decl></param>, <param><decl><type><name>int</name></type> <name>seconds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>DayNames</name><index>[]</index></name> <init>= <expr><block>{
		<expr>"Mon"</expr>, <expr>"Tue"</expr>, <expr>"Wed"</expr>, <expr>"Thu"</expr>, <expr>"Fri"</expr>, <expr>"Sat"</expr>, <expr>"Sun"</expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>MonthNames</name><index>[]</index></name> <init>= <expr><block>{
		<expr>"Jan"</expr>, <expr>"Feb"</expr>, <expr>"Mar"</expr>, <expr>"Apr"</expr>, <expr>"May"</expr>, <expr>"Jun"</expr>,
		<expr>"Jul"</expr>, <expr>"Aug"</expr>, <expr>"Sep"</expr>, <expr>"Oct"</expr>, <expr>"Nov"</expr>, <expr>"Dec"</expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wday</name> <init>= <expr><call><name>weekday</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%s %s %2d %02d:%02d:%02d %04d"</expr></argument>,
		      <argument><expr><name><name>DayNames</name><index>[<expr><name>wday</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>MonthNames</name><index>[<expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call> - 1</expr>]</index></name></expr></argument>,
		      <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hours</name></expr></argument>, <argument><expr><name>minutes</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>,
		      <argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Add an hours &amp; minutes UTC offset string to buf.  buf has no more than
 * buflen bytes remaining.  The UTC offset is gotten by calling
 * tzinfo.uctoffset(tzinfoarg).  If that returns None, \0 is stored into
 * *buf, and that's all.  Else the returned value is checked for sanity (an
 * integer in range), and if that's OK it's converted to an hours &amp; minutes
 * string of the form
 *   sign HH sep MM
 * Returns 0 if everything is OK.  If the return value from utcoffset() is
 * bogus, an appropriate exception is set and -1 is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>format_utcoffset</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl></param>,
		<param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfoarg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hours</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>minutes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>sign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>none</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buflen</name> &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>offset</name> = <call><name>call_utcoffset</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr><name>tzinfoarg</name></expr></argument>, <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>offset</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>none</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>sign</name> = '+'</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sign</name> = '-'</expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> = - <name>offset</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>hours</name> = <call><name>divmod</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr>60</expr></argument>, <argument><expr>&amp;<name>minutes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr>"%c%02d%s%02d"</expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>hours</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>minutes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>make_freplacement</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>object</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>freplacement</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyTime_Check</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>freplacement</name></expr></argument>, <argument><expr>"%06d"</expr></argument>, <argument><expr><call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>freplacement</name></expr></argument>, <argument><expr>"%06d"</expr></argument>, <argument><expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>freplacement</name></expr></argument>, <argument><expr>"%06d"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>freplacement</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>freplacement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* I sure don't want to reproduce the strftime code from the time module,
 * so this imports the module and calls it.  All the hair is due to
 * giving special meanings to the %z, %Z and %f format codes via a
 * preprocessing step on the format string.
 * tzinfoarg is the argument to pass to the object's tzinfo method, if
 * needed.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wrap_strftime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>object</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>format_len</name></decl></param>,
		<param><decl><type><name>PyObject</name> *</type><name>timetuple</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfoarg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* guilty until proved innocent */</comment>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>zreplacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* py string, replacement for %z */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>Zreplacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* py string, replacement for %Z */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>freplacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* py string, replacement for %f */</comment>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pin</name></decl>;</decl_stmt>	<comment type="block">/* pointer to next char in input format */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>		<comment type="block">/* next char in input format */</comment>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newfmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* py string, the output format */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>pnew</name></decl>;</decl_stmt>	<comment type="block">/* pointer to available byte in output format */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>totalnew</name></decl>;</decl_stmt>	<comment type="block">/* number bytes total in output format buffer,
				   exclusive of trailing \0 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>usednew</name></decl>;</decl_stmt>	<comment type="block">/* number bytes used so far in output format buffer */</comment>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptoappend</name></decl>;</decl_stmt>	<comment type="block">/* ptr to string to append to output buffer */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>ntoappend</name></decl>;</decl_stmt>	<comment type="block">/* # of bytes to append to output buffer */</comment>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>object</name> &amp;&amp; <name>format</name> &amp;&amp; <name>timetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Give up if the year is before 1900.
	 * Python strftime() plays games with the year, and different
	 * games depending on whether envar PYTHON2K is set.  This makes
	 * years before 1900 a nightmare, even if the platform strftime
	 * supports them (and not all do).
	 * We could get a lot farther here by avoiding Python's strftime
	 * wrapper and calling the C strftime() directly, but that isn't
	 * an option in the Python implementation of this module.
	 */</comment>
	<block>{
		<decl_stmt><decl><type><name>long</name></type> <name>year</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>pyyear</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>timetuple</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>pyyear</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>pyyear</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>year</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>pyyear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pyyear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>year</name> &lt; 1900</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"year=%ld is before "
				     "1900; the datetime strftime() "
	                             "methods require year &gt;= 1900"</expr></argument>,
	                             <argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	                <return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block>

	<comment type="block">/* Scan the input format, looking for %z/%Z/%f escapes, building
	 * a new format.  Since computing the replacements for those codes
	 * is expensive, don't unless they're actually used.
	 */</comment>
	<if>if <condition>(<expr><name>format_len</name> &gt; <name>INT_MAX</name> - 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>Done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>totalnew</name> = <name>format_len</name> + 1</expr>;</expr_stmt>	<comment type="block">/* realistic if no %z/%Z/%f */</comment>
	<expr_stmt><expr><name>newfmt</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>totalnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newfmt</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>pnew</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>newfmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>usednew</name> = 0</expr>;</expr_stmt>

	<expr_stmt><expr><name>pin</name> = <name>format</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>ch</name> = *<name>pin</name>++) != '\0'</expr>)</condition> <block>{
		<if>if <condition>(<expr><name>ch</name> != '%'</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>ptoappend</name> = <name>pin</name> - 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>ntoappend</name> = 1</expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr>(<name>ch</name> = *<name>pin</name>++) == '\0'</expr>)</condition><then> <block>{
			<comment type="block">/* There's a lone trailing %; doesn't make sense. */</comment>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"strftime format "
					"ends with raw %"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Done</name>;</goto>
		}</block></then>
		<comment type="block">/* A % has been seen and ch is the character after it. */</comment>
		<else>else <if>if <condition>(<expr><name>ch</name> == 'z'</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>zreplacement</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<comment type="block">/* format utcoffset */</comment>
				<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><call><name>get_tzinfo_member</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>zreplacement</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>zreplacement</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>Done</name>;</goto></then></if>
				<if>if <condition>(<expr><name>tzinfo</name> != <name>Py_None</name> &amp;&amp; <name>tzinfo</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfoarg</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><call><name>format_utcoffset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							     <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							     <argument><expr>""</expr></argument>,
							     <argument><expr><name>tzinfo</name></expr></argument>,
							     <argument><expr><name>tzinfoarg</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
						<goto>goto <name>Done</name>;</goto></then></if>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>zreplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>zreplacement</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>zreplacement</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>Done</name>;</goto></then></if>
				}</block></then></if>
			}</block></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zreplacement</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptoappend</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>zreplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ntoappend</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>zreplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>ch</name> == 'Z'</expr>)</condition><then> <block>{
			<comment type="block">/* format tzname */</comment>
			<if>if <condition>(<expr><name>Zreplacement</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><call><name>get_tzinfo_member</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>Zreplacement</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>Zreplacement</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>Done</name>;</goto></then></if>
				<if>if <condition>(<expr><name>tzinfo</name> != <name>Py_None</name> &amp;&amp; <name>tzinfo</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tzinfoarg</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>temp</name> = <call><name>call_tzname</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr><name>tzinfoarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>Done</name>;</goto></then></if>
					<if>if <condition>(<expr><name>temp</name> != <name>Py_None</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Since the tzname is getting
						 * stuffed into the format, we
						 * have to double any % signs
						 * so that strftime doesn't
						 * treat them as format codes.
						 */</comment>
						<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>Zreplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>Zreplacement</name> = <call><name>PyObject_CallMethod</name><argument_list>(
							<argument><expr><name>temp</name></expr></argument>, <argument><expr>"replace"</expr></argument>,
							<argument><expr>"ss"</expr></argument>, <argument><expr>"%"</expr></argument>, <argument><expr>"%%"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if>if <condition>(<expr><name>Zreplacement</name> == <name>NULL</name></expr>)</condition><then>
							<goto>goto <name>Done</name>;</goto></then></if>
						<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>Zreplacement</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
							<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"tzname.replace() did not return a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>Done</name>;</goto>
						}</block></then></if>
					}</block></then>
					<else>else
						<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
				}</block></then></if>
			}</block></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Zreplacement</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptoappend</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>Zreplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ntoappend</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>Zreplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>ch</name> == 'f'</expr>)</condition><then> <block>{
			<comment type="block">/* format microseconds */</comment>
			<if>if <condition>(<expr><name>freplacement</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>freplacement</name> = <call><name>make_freplacement</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>freplacement</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>Done</name>;</goto></then></if>
			}</block></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>freplacement</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>freplacement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptoappend</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>freplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ntoappend</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>freplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* percent followed by neither z nor Z */</comment>
			<expr_stmt><expr><name>ptoappend</name> = <name>pin</name> - 2</expr>;</expr_stmt>
			<expr_stmt><expr><name>ntoappend</name> = 2</expr>;</expr_stmt>
		}</block></else></if></else></if></else></if></else></if></else></if>

 		<comment type="block">/* Append the ntoappend chars starting at ptoappend to
 		 * the new format.
 		 */</comment>
 		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptoappend</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ntoappend</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		<if>if <condition>(<expr><name>ntoappend</name> == 0</expr>)</condition><then>
 			<continue>continue;</continue></then></if>
 		<while>while <condition>(<expr><name>usednew</name> + <name>ntoappend</name> &gt; <name>totalnew</name></expr>)</condition> <block>{
 			<decl_stmt><decl><type><name>size_t</name></type> <name>bigger</name> <init>= <expr><name>totalnew</name> &lt;&lt; 1</expr></init></decl>;</decl_stmt>
 			<if>if <condition>(<expr>(<name>bigger</name> &gt;&gt; 1) != <name>totalnew</name></expr>)</condition><then> <block>{ <comment type="block">/* overflow */</comment>
 				<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 				<goto>goto <name>Done</name>;</goto>
 			}</block></then></if>
 			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>newfmt</name></expr></argument>, <argument><expr><name>bigger</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
 				<goto>goto <name>Done</name>;</goto></then></if>
 			<expr_stmt><expr><name>totalnew</name> = <name>bigger</name></expr>;</expr_stmt>
 			<expr_stmt><expr><name>pnew</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>newfmt</name></expr></argument>)</argument_list></call> + <name>usednew</name></expr>;</expr_stmt>
 		}</block></while>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pnew</name></expr></argument>, <argument><expr><name>ptoappend</name></expr></argument>, <argument><expr><name>ntoappend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pnew</name> += <name>ntoappend</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>usednew</name> += <name>ntoappend</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>usednew</name> &lt;= <name>totalnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>  <comment type="block">/* end while() */</comment>

	<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>newfmt</name></expr></argument>, <argument><expr><name>usednew</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>time</name> <init>= <expr><call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"time"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>time</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>Done</name>;</goto></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr>"strftime"</expr></argument>, <argument><expr>"OO"</expr></argument>,
					     <argument><expr><name>newfmt</name></expr></argument>, <argument><expr><name>timetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    	}</block>
 <label><name>Done</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>freplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>zreplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>Zreplacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>newfmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>isoformat_date</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>dt</name></decl></param>, <param><decl><type><name>char</name></type> <name><name>buffer</name><index>[]</index></name></decl></param>, <param><decl><type><name>int</name></type> <name>bufflen</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufflen</name></expr></argument>,
			  <argument><expr>"%04d-%02d-%02d"</expr></argument>,
			  <argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buffer</name> + <name>x</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>isoformat_time</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>dt</name></decl></param>, <param><decl><type><name>char</name></type> <name><name>buffer</name><index>[]</index></name></decl></param>, <param><decl><type><name>int</name></type> <name>bufflen</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>us</name> <init>= <expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufflen</name></expr></argument>,
		      <argument><expr>"%02d:%02d:%02d"</expr></argument>,	<comment type="block">/* 8 characters */</comment>
		      <argument><expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>us</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name> + 8</expr></argument>, <argument><expr><name>bufflen</name> - 8</expr></argument>, <argument><expr>".%06d"</expr></argument>, <argument><expr><name>us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * Wrap functions from the time module.  These aren't directly available
 * from C.  Perhaps they should be.
 */</comment>

<comment type="block">/* Call time.time() and return its result (a Python float). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_time</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>time</name> <init>= <expr><call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"time"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>time</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr>"time"</expr></argument>, <argument><expr>"()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Build a time.struct_time.  The weekday and day number are automatically
 * computed from the y,m,d args.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>build_struct_time</name><parameter_list>(<param><decl><type><name>int</name></type> <name>y</name></decl></param>, <param><decl><type><name>int</name></type> <name>m</name></decl></param>, <param><decl><type><name>int</name></type> <name>d</name></decl></param>, <param><decl><type><name>int</name></type> <name>hh</name></decl></param>, <param><decl><type><name>int</name></type> <name>mm</name></decl></param>, <param><decl><type><name>int</name></type> <name>ss</name></decl></param>, <param><decl><type><name>int</name></type> <name>dstflag</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>time</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"time"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>time</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr>"struct_time"</expr></argument>,
					     <argument><expr>"((iiiiiiiii))"</expr></argument>,
					     <argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>d</name></expr></argument>,
					     <argument><expr><name>hh</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>,
				 	     <argument><expr><call><name>weekday</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>,
				 	     <argument><expr><call><name>days_before_month</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> + <name>d</name></expr></argument>,
				 	     <argument><expr><name>dstflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * Miscellaneous helpers.
 */</comment>

<comment type="block">/* For obscure reasons, we need to use tp_richcompare instead of tp_compare.
 * The comparisons here all most naturally compute a cmp()-like result.
 * This little helper turns that into a bool result for rich comparisons.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>diff_to_bool</name><parameter_list>(<param><decl><type><name>int</name></type> <name>diff</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>istrue</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
		<case>case <expr><name>Py_EQ</name></expr>: <expr_stmt><expr><name>istrue</name> = <name>diff</name> == 0</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_NE</name></expr>: <expr_stmt><expr><name>istrue</name> = <name>diff</name> != 0</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_LE</name></expr>: <expr_stmt><expr><name>istrue</name> = <name>diff</name> &lt;= 0</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_GE</name></expr>: <expr_stmt><expr><name>istrue</name> = <name>diff</name> &gt;= 0</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_LT</name></expr>: <expr_stmt><expr><name>istrue</name> = <name>diff</name> &lt; 0</expr>;</expr_stmt> <break>break;</break>
		</case><case>case <expr><name>Py_GT</name></expr>: <expr_stmt><expr><name>istrue</name> = <name>diff</name> &gt; 0</expr>;</expr_stmt> <break>break;</break>
		</case><default>default:
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>! "op unknown"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>istrue</name> = 0</expr>;</expr_stmt> <comment type="block">/* To shut up compiler */</comment>
	</default>}</block></switch>
	<expr_stmt><expr><name>result</name> = <name>istrue</name> ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Raises a "can't compare" TypeError and returns NULL. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cmperror</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"can't compare %s to %s"</expr></argument>,
		     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
 * Cached Python objects; these are set by the module init function.
 */</comment>

<comment type="block">/* Conversion factors. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>us_per_us</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>us_per_ms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1000 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>us_per_second</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1000000 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>us_per_minute</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1e6 * 60 as Python int */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>us_per_hour</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1e6 * 3600 as Python long */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>us_per_day</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1e6 * 3600 * 24 as Python long */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>us_per_week</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1e6*3600*24*7 as Python long */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>seconds_per_day</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* 3600*24 as Python int */</comment>

<comment type="block">/* ---------------------------------------------------------------------------
 * Class implementations.
 */</comment>

<comment type="block">/*
 * PyDateTime_Delta implementation.
 */</comment>

<comment type="block">/* Convert a timedelta to a number of us,
 * 	(24*3600*self.days + self.seconds)*1000000 + self.microseconds
 * as a Python int or long.
 * Doing mixed-radix arithmetic by hand instead is excruciating in C,
 * due to ubiquitous overflow possibilities.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_to_microseconds</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>x1</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x1</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>x2</name> = <call><name>PyNumber_Multiply</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>seconds_per_day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* days in seconds */</comment>
	<if>if <condition>(<expr><name>x2</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x1</name> = <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* x2 has days in seconds */</comment>
	<expr_stmt><expr><name>x1</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* seconds */</comment>
	<if>if <condition>(<expr><name>x1</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>x3</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* days and seconds in seconds */</comment>
	<if>if <condition>(<expr><name>x3</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x1</name> = <name>x2</name> = <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* x3 has days+seconds in seconds */</comment>
	<expr_stmt><expr><name>x1</name> = <call><name>PyNumber_Multiply</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>us_per_second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* us */</comment>
	<if>if <condition>(<expr><name>x1</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x3</name> = <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* x1 has days+seconds in us */</comment>
	<expr_stmt><expr><name>x2</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x2</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>Done</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Convert a number of us (as a Python int or long) to a timedelta.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>microseconds_to_delta_ex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>pyus</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>us</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>temp</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>num</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> = <call><name>PyNumber_Divmod</name><argument_list>(<argument><expr><name>pyus</name></expr></argument>, <argument><expr><name>us_per_second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<expr_stmt><expr><name>num</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* us */</comment>
	<if>if <condition>(<expr><name>num</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>temp</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>temp</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <name>temp</name> &amp;&amp; <name>temp</name> &lt; 1000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>us</name> = (<name>int</name>)<name>temp</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>us</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* The divisor was positive, so this must be an error. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>Done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>num</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* leftover seconds */</comment>
	<if>if <condition>(<expr><name>num</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> = <call><name>PyNumber_Divmod</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>seconds_per_day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> 	<comment type="block">/* seconds */</comment>
	<if>if <condition>(<expr><name>num</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>temp</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>temp</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <name>temp</name> &amp;&amp; <name>temp</name> &lt; 24*3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> = (<name>int</name>)<name>temp</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>s</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* The divisor was positive, so this must be an error. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>Done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>num</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* leftover days */</comment>
	<if>if <condition>(<expr><name>num</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>temp</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>
	<expr_stmt><expr><name>d</name> = (<name>int</name>)<name>temp</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>long</name>)<name>d</name> != <name>temp</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"normalized days too "
				"large to fit in a C int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>Done</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>new_delta_ex</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>us</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>Done</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>microseconds_to_delta</name><parameter_list>(<param><type><name>pymicros</name></type></param>)</parameter_list></cpp:macro>	\
	<cpp:value>microseconds_to_delta_ex(pymicros, &amp;PyDateTime_DeltaType)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>multiply_int_timedelta</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>intobj</name></decl></param>, <param><decl><type><name>PyDateTime_Delta</name> *</type><name>delta</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pyus_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pyus_out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pyus_in</name> = <call><name>delta_to_microseconds</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pyus_in</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>pyus_out</name> = <call><name>PyNumber_Multiply</name><argument_list>(<argument><expr><name>pyus_in</name></expr></argument>, <argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pyus_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pyus_out</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>microseconds_to_delta</name><argument_list>(<argument><expr><name>pyus_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pyus_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>divide_timedelta_int</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>delta</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>intobj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pyus_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pyus_out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pyus_in</name> = <call><name>delta_to_microseconds</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pyus_in</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>pyus_out</name> = <call><name>PyNumber_FloorDivide</name><argument_list>(<argument><expr><name>pyus_in</name></expr></argument>, <argument><expr><name>intobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pyus_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pyus_out</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>microseconds_to_delta</name><argument_list>(<argument><expr><name>pyus_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pyus_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_add</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>Py_NotImplemented</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* delta + delta */</comment>
		<comment type="block">/* The C-level additions can't overflow because of the
		 * invariant bounds.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>days</name> <init>= <expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> + <call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>seconds</name> <init>= <expr><call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> + <call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>microseconds</name> <init>= <expr><call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> +
				   <call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result</name> = <call><name>new_delta</name><argument_list>(<argument><expr><name>days</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>, <argument><expr><name>microseconds</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_negative</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>new_delta</name><argument_list>(<argument><expr>-<call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr>-<call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr>-<call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_positive</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Could optimize this (by returning self) if this isn't a
	 * subclass -- but who uses unary + ?  Approximately nobody.
	 */</comment>
	<return>return <expr><call><name>new_delta</name><argument_list>(<argument><expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_abs</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>delta_negative</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>result</name> = <call><name>delta_positive</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_subtract</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>Py_NotImplemented</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    	<comment type="block">/* delta - delta */</comment>
	    	<decl_stmt><decl><type><name>PyObject</name> *</type><name>minus_right</name> <init>= <expr><call><name>PyNumber_Negative</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    	<if>if <condition>(<expr><name>minus_right</name></expr>)</condition><then> <block>{
	    		<expr_stmt><expr><name>result</name> = <call><name>delta_add</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>minus_right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>minus_right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    	}</block></then>
	    	<else>else
	    		<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* This is more natural as a tp_compare, but doesn't work then:  for whatever
 * reason, Python's try_3way_compare ignores tp_compare unless
 * PyInstance_Check returns true, but these aren't old-style classes.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_richcompare</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr>42</expr></init></decl>;</decl_stmt>	<comment type="block">/* nonsense */</comment>

	<if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>diff</name> = <call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>diff</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>diff</name> = <call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>diff</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>diff</name> = <call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> -
				       <call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name> || <name>op</name> == <name>Py_NE</name></expr>)</condition><then>
		<expr_stmt><expr><name>diff</name> = 1</expr>;</expr_stmt></then>	<comment type="block">/* any non-zero value will do */</comment>

	<else>else <comment type="block">/* stop this from falling back to address comparison */</comment>
		<return>return <expr><call><name>cmperror</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>

	<return>return <expr><call><name>diff_to_bool</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>delta_getstate</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>delta_hash</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>hashcode</name></name> == -1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><call><name>delta_getstate</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>temp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>self</name>-&gt;<name>hashcode</name></name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name><name>self</name>-&gt;<name>hashcode</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_multiply</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>Py_NotImplemented</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* delta * ??? */</comment>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>multiply_int_timedelta</name><argument_list>(<argument><expr><name>right</name></expr></argument>,
					<argument><expr>(<name>PyDateTime_Delta</name> *) <name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>multiply_int_timedelta</name><argument_list>(<argument><expr><name>left</name></expr></argument>,
						<argument><expr>(<name>PyDateTime_Delta</name> *) <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_divide</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>Py_NotImplemented</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* delta * ??? */</comment>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>divide_timedelta_int</name><argument_list>(
					<argument><expr>(<name>PyDateTime_Delta</name> *)<name>left</name></expr></argument>,
					<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Fold in the value of the tag ("seconds", "weeks", etc) component of a
 * timedelta constructor.  sofar is the # of microseconds accounted for
 * so far, and there are factor microseconds per current unit, the number
 * of which is given by num.  num * factor is added to sofar in a
 * numerically careful way, and that's the result.  Any fractional
 * microseconds left over (this can happen if num is a float type) are
 * added into *leftover.
 * Note that there are many ways this can give an error (NULL) return.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>accum</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>tag</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sofar</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>num</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>factor</name></decl></param>,
      <param><decl><type><name>double</name> *</type><name>leftover</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>prod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>num</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>prod</name> = <call><name>PyNumber_Multiply</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>prod</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>sum</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>sofar</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>sum</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>double</name></type> <name>dnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>fracpart</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>intpart</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>y</name></decl>;</decl_stmt>

		<comment type="block">/* The Plan:  decompose num into an integer part and a
		 * fractional part, num = intpart + fracpart.
		 * Then num * factor ==
		 *      intpart * factor + fracpart * factor
		 * and the LHS can be computed exactly in long arithmetic.
		 * The RHS is again broken into an int part and frac part.
		 * and the frac part is added into *leftover.
		 */</comment>
		<expr_stmt><expr><name>dnum</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dnum</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>fracpart</name> = <call><name>modf</name><argument_list>(<argument><expr><name>dnum</name></expr></argument>, <argument><expr>&amp;<name>intpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> = <call><name>PyLong_FromDouble</name><argument_list>(<argument><expr><name>intpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<expr_stmt><expr><name>prod</name> = <call><name>PyNumber_Multiply</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>prod</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<expr_stmt><expr><name>sum</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>sofar</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>sum</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<if>if <condition>(<expr><name>fracpart</name> == 0.0</expr>)</condition><then>
			<return>return <expr><name>sum</name></expr>;</return></then></if>
		<comment type="block">/* So far we've lost no information.  Dealing with the
		 * fractional part requires float arithmetic, and may
		 * lose a little info.
		 */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>factor</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>dnum</name> = (<name>double</name>)<call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>dnum</name> = <call><name>PyLong_AsDouble</name><argument_list>(<argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

		<expr_stmt><expr><name>dnum</name> *= <name>fracpart</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fracpart</name> = <call><name>modf</name><argument_list>(<argument><expr><name>dnum</name></expr></argument>, <argument><expr>&amp;<name>intpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> = <call><name>PyLong_FromDouble</name><argument_list>(<argument><expr><name>intpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>

		<expr_stmt><expr><name>y</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>sum</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>leftover</name> += <name>fracpart</name></expr>;</expr_stmt>
		<return>return <expr><name>y</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"unsupported type for timedelta %s component: %s"</expr></argument>,
		     <argument><expr><name>tag</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Argument objects. */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>day</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>second</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>us</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>minute</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>hour</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>week</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* running sum of microseconds */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>y</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* temp sum of microseconds */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>leftover_us</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{
		<expr>"days"</expr>, <expr>"seconds"</expr>, <expr>"microseconds"</expr>, <expr>"milliseconds"</expr>,
		<expr>"minutes"</expr>, <expr>"hours"</expr>, <expr>"weeks"</expr>, <expr><name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|OOOOOOO:__new__"</expr></argument>,
					<argument><expr><name>keywords</name></expr></argument>,
					<argument><expr>&amp;<name>day</name></expr></argument>, <argument><expr>&amp;<name>second</name></expr></argument>, <argument><expr>&amp;<name>us</name></expr></argument>,
					<argument><expr>&amp;<name>ms</name></expr></argument>, <argument><expr>&amp;<name>minute</name></expr></argument>, <argument><expr>&amp;<name>hour</name></expr></argument>, <argument><expr>&amp;<name>week</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

	<expr_stmt><expr><name>x</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>Done</name>;</goto></then></if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEANUP</name></cpp:macro> 	\
	<cpp:value>Py_DECREF(x);	\
	x = y;		\
	if (x == NULL)	\
		goto Done</cpp:value></cpp:define>

	<if>if <condition>(<expr><name>us</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>y</name> = <call><name>accum</name><argument_list>(<argument><expr>"microseconds"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>us</name></expr></argument>, <argument><expr><name>us_per_us</name></expr></argument>, <argument><expr>&amp;<name>leftover_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CLEANUP</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>ms</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>y</name> = <call><name>accum</name><argument_list>(<argument><expr>"milliseconds"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>ms</name></expr></argument>, <argument><expr><name>us_per_ms</name></expr></argument>, <argument><expr>&amp;<name>leftover_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CLEANUP</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>second</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>y</name> = <call><name>accum</name><argument_list>(<argument><expr>"seconds"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>second</name></expr></argument>, <argument><expr><name>us_per_second</name></expr></argument>, <argument><expr>&amp;<name>leftover_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CLEANUP</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>minute</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>y</name> = <call><name>accum</name><argument_list>(<argument><expr>"minutes"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>, <argument><expr><name>us_per_minute</name></expr></argument>, <argument><expr>&amp;<name>leftover_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CLEANUP</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>hour</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>y</name> = <call><name>accum</name><argument_list>(<argument><expr>"hours"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><name>us_per_hour</name></expr></argument>, <argument><expr>&amp;<name>leftover_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CLEANUP</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>day</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>y</name> = <call><name>accum</name><argument_list>(<argument><expr>"days"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>day</name></expr></argument>, <argument><expr><name>us_per_day</name></expr></argument>, <argument><expr>&amp;<name>leftover_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CLEANUP</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>week</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>y</name> = <call><name>accum</name><argument_list>(<argument><expr>"weeks"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>week</name></expr></argument>, <argument><expr><name>us_per_week</name></expr></argument>, <argument><expr>&amp;<name>leftover_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CLEANUP</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>leftover_us</name></expr>)</condition><then> <block>{
		<comment type="block">/* Round to nearest whole # of us, and add into x. */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>round_to_long</name><argument_list>(<argument><expr><name>leftover_us</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Done</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>y</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CLEANUP</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>self</name> = <call><name>microseconds_to_delta_ex</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>Done</name>:</label>
	<return>return <expr><name>self</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CLEANUP</name></cpp:undef>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>delta_nonzero</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>(<call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> != 0
		|| <call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> != 0
		|| <call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> != 0)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_repr</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"%s(%d, %d, %d)"</expr></argument>,
					   <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
					   <argument><expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"%s(%d, %d)"</expr></argument>,
					   <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
					   <argument><expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"%s(%d)"</expr></argument>,
				   <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
				   <argument><expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_str</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>days</name> <init>= <expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>seconds</name> <init>= <expr><call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>us</name> <init>= <expr><call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hours</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>minutes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>pbuf</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>buflen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>minutes</name> = <call><name>divmod</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>, <argument><expr>60</expr></argument>, <argument><expr>&amp;<name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hours</name> = <call><name>divmod</name><argument_list>(<argument><expr><name>minutes</name></expr></argument>, <argument><expr>60</expr></argument>, <argument><expr>&amp;<name>minutes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>days</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>n</name> = <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr>"%d day%s, "</expr></argument>, <argument><expr><name>days</name></expr></argument>,
				  <argument><expr>(<name>days</name> == 1 || <name>days</name> == -1) ? "" : "s"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> &lt; 0 || (<name>size_t</name>)<name>n</name> &gt;= <name>buflen</name></expr>)</condition><then>
			<goto>goto <name>Fail</name>;</goto></then></if>
		<expr_stmt><expr><name>pbuf</name> += <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buflen</name> -= (<name>size_t</name>)<name>n</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>n</name> = <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr>"%d:%02d:%02d"</expr></argument>,
			  <argument><expr><name>hours</name></expr></argument>, <argument><expr><name>minutes</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &lt; 0 || (<name>size_t</name>)<name>n</name> &gt;= <name>buflen</name></expr>)</condition><then>
		<goto>goto <name>Fail</name>;</goto></then></if>
	<expr_stmt><expr><name>pbuf</name> += <name>n</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buflen</name> -= (<name>size_t</name>)<name>n</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>us</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>n</name> = <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr>".%06d"</expr></argument>, <argument><expr><name>us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> &lt; 0 || (<name>size_t</name>)<name>n</name> &gt;= <name>buflen</name></expr>)</condition><then>
			<goto>goto <name>Fail</name>;</goto></then></if>
		<expr_stmt><expr><name>pbuf</name> += <name>n</name></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pbuf</name> - <name>buf</name></expr></argument>)</argument_list></call></expr>;</return>

 <label><name>Fail</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, <argument><expr>"goofy result from PyOS_snprintf"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Pickle support, a simple use of __reduce__. */</comment>

<comment type="block">/* __getstate__ isn't exposed */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_getstate</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iii"</expr></argument>, <argument><expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>delta_reduce</name><parameter_list>(<param><decl><type><name>PyDateTime_Delta</name>*</type> <name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ON"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>delta_getstate</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<param><type><name>field</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>offsetof(PyDateTime_Delta, field)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>delta_members</name><index>[]</index></name> <init>= <expr><block>{

	<expr><block>{<expr>"days"</expr>,         <expr><name>T_INT</name></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>days</name></expr></argument>)</argument_list></call></expr>,         <expr><name>READONLY</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Number of days."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"seconds"</expr>,      <expr><name>T_INT</name></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>,      <expr><name>READONLY</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Number of seconds (&gt;= 0 and less than 1 day)."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"microseconds"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>microseconds</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Number of microseconds (&gt;= 0 and less than 1 second)."</argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>delta_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"__reduce__"</expr>, <expr>(<name>PyCFunction</name>)<name>delta_reduce</name></expr>,     <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"__reduce__() -&gt; (cls, state)"</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><name>NULL</name></expr>,	<expr><name>NULL</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>delta_doc</name><index>[]</index></name> <init>=
<expr><call><name>PyDoc_STR</name><argument_list>(<argument><expr>"Difference between two datetime values."</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>delta_as_number</name> <init>= <expr><block>{
	<expr><name>delta_add</name></expr>,				<comment type="block">/* nb_add */</comment>
	<expr><name>delta_subtract</name></expr>,				<comment type="block">/* nb_subtract */</comment>
	<expr><name>delta_multiply</name></expr>,				<comment type="block">/* nb_multiply */</comment>
	<expr><name>delta_divide</name></expr>,				<comment type="block">/* nb_divide */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_remainder */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_divmod */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_power */</comment>
	<expr>(<name>unaryfunc</name>)<name>delta_negative</name></expr>,		<comment type="block">/* nb_negative */</comment>
	<expr>(<name>unaryfunc</name>)<name>delta_positive</name></expr>,		<comment type="block">/* nb_positive */</comment>
	<expr>(<name>unaryfunc</name>)<name>delta_abs</name></expr>,			<comment type="block">/* nb_absolute */</comment>
	<expr>(<name>inquiry</name>)<name>delta_nonzero</name></expr>,			<comment type="block">/* nb_nonzero */</comment>
	<expr>0</expr>,					<comment type="block">/*nb_invert*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_lshift*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_rshift*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_and*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_xor*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_or*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_coerce*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_int*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_long*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_float*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_oct*/</comment>
	<expr>0</expr>, 					<comment type="block">/*nb_hex*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_add*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_subtract*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_multiply*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_divide*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_remainder*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_power*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_lshift*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_rshift*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_and*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_xor*/</comment>
	<expr>0</expr>,					<comment type="block">/*nb_inplace_or*/</comment>
	<expr><name>delta_divide</name></expr>,				<comment type="block">/* nb_floor_divide */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_true_divide */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_inplace_floor_divide */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_inplace_true_divide */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyDateTime_DeltaType</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"datetime.timedelta"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyDateTime_Delta</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>delta_repr</name></expr>,				<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>delta_as_number</name></expr>,				<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>delta_hash</name></expr>,				<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,              				<comment type="block">/* tp_call */</comment>
	<expr>(<name>reprfunc</name>)<name>delta_str</name></expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,			<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
	        <name>Py_TPFLAGS_BASETYPE</name></expr>,			<comment type="block">/* tp_flags */</comment>
	<expr><name>delta_doc</name></expr>,					<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_clear */</comment>
	<expr>(<name>richcmpfunc</name>)<name>delta_richcompare</name></expr>,			<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_iternext */</comment>
	<expr><name>delta_methods</name></expr>,					<comment type="block">/* tp_methods */</comment>
	<expr><name>delta_members</name></expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_alloc */</comment>
	<expr><name>delta_new</name></expr>,					<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * PyDateTime_Date implementation.
 */</comment>

<comment type="block">/* Accessor properties. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_year</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_month</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_day</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>date_getset</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"year"</expr>,        <expr>(<name>getter</name>)<name>date_year</name></expr>}</block></expr>,
	<expr><block>{<expr>"month"</expr>,       <expr>(<name>getter</name>)<name>date_month</name></expr>}</block></expr>,
	<expr><block>{<expr>"day"</expr>,         <expr>(<name>getter</name>)<name>date_day</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Constructors. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>date_kws</name><index>[]</index></name> <init>= <expr><block>{<expr>"year"</expr>, <expr>"month"</expr>, <expr>"day"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>year</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>month</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>day</name></decl>;</decl_stmt>

	<comment type="block">/* Check for invocation from pickle with __getstate__ state */</comment>
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
	    <call><name>PyString_Check</name><argument_list>(<argument><expr><name>state</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
	    <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> == <name>_PyDateTime_DATE_DATASIZE</name> &amp;&amp;
	    <call><name>MONTH_IS_SANE</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call><index>[<expr>2</expr>]</index></expr></argument>)</argument_list></call></expr>)</condition><then>
	<block>{
	    	<decl_stmt><decl><type><name>PyDateTime_Date</name> *</type><name>me</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>me</name> = <call>(<name>PyDateTime_Date</name> *) <argument_list>(<argument><expr><call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>me</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>pdata</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>me</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pdata</name></expr></argument>, <argument><expr><name>_PyDateTime_DATE_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>me</name>-&gt;<name>hashcode</name></name> = -1</expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr>(<name>PyObject</name> *)<name>me</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"iii"</expr></argument>, <argument><expr><name>date_kws</name></expr></argument>,
					<argument><expr>&amp;<name>year</name></expr></argument>, <argument><expr>&amp;<name>month</name></expr></argument>, <argument><expr>&amp;<name>day</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>check_date_args</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>self</name> = <call><name>new_date_ex</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<comment type="block">/* Return new date from localtime(t). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_local_from_time_t</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>double</name></type> <name>ts</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>tm</name> *</type><name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>t</name> = <call><name>_PyTime_DoubleToTimet</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>t</name> == (<name>time_t</name>)-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>tm</name> = <call><name>localtime</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tm</name></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr>"iii"</expr></argument>,
					       <argument><expr><name><name>tm</name>-&gt;<name>tm_year</name></name> + 1900</expr></argument>,
					       <argument><expr><name><name>tm</name>-&gt;<name>tm_mon</name></name> + 1</expr></argument>,
					       <argument><expr><name><name>tm</name>-&gt;<name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"timestamp out of range for "
				"platform localtime() function"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Return new date from current time.
 * We say this is equivalent to fromtimestamp(time.time()), and the
 * only way to be sure of that is to *call* time.time().  That's not
 * generally the same as calling C's time.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_today</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dummy</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>time</name> = <call><name>time_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>time</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Note well:  today() is a class method, so this may not call
	 * date.fromtimestamp.  For example, it may call
	 * datetime.fromtimestamp.  That's why we need all the accuracy
	 * time.time() delivers; if someone were gonzo about optimization,
	 * date.today() could get away with plain C time().
	 */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr>"fromtimestamp"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Return new date from given timestamp (Python timestamp -- a double). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_fromtimestamp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>timestamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"d:fromtimestamp"</expr></argument>, <argument><expr>&amp;<name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>date_local_from_time_t</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Return new date from proleptic Gregorian ordinal.  Raises ValueError if
 * the ordinal is out of range.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_fromordinal</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ordinal</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:fromordinal"</expr></argument>, <argument><expr>&amp;<name>ordinal</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>year</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>month</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>day</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>ordinal</name> &lt; 1</expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"ordinal must be "
							  "&gt;= 1"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>ord_to_ymd</name><argument_list>(<argument><expr><name>ordinal</name></expr></argument>, <argument><expr>&amp;<name>year</name></expr></argument>, <argument><expr>&amp;<name>month</name></expr></argument>, <argument><expr>&amp;<name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr>"iii"</expr></argument>,
						       <argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Date arithmetic.
 */</comment>

<comment type="block">/* date + timedelta -&gt; date.  If arg negate is true, subtract the timedelta
 * instead.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>add_date_timedelta</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>date</name></decl></param>, <param><decl><type><name>PyDateTime_Delta</name> *</type><name>delta</name></decl></param>, <param><decl><type><name>int</name></type> <name>negate</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>year</name> <init>= <expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>month</name> <init>= <expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>deltadays</name> <init>= <expr><call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* C-level overflow is impossible because |deltadays| &lt; 1e9. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>day</name> <init>= <expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call> + (<name>negate</name> ? -<name>deltadays</name> : <name>deltadays</name>)</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>normalize_date</name><argument_list>(<argument><expr>&amp;<name>year</name></expr></argument>, <argument><expr>&amp;<name>month</name></expr></argument>, <argument><expr>&amp;<name>day</name></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>new_date</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_add</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> || <call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyDate_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* date + ??? */</comment>
		<if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<comment type="block">/* date + delta */</comment>
			<return>return <expr><call><name>add_date_timedelta</name><argument_list>(<argument><expr>(<name>PyDateTime_Date</name> *) <name>left</name></expr></argument>,
						  <argument><expr>(<name>PyDateTime_Delta</name> *) <name>right</name></expr></argument>,
						  <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* ??? + date
		 * 'right' must be one of us, or we wouldn't have been called
		 */</comment>
		<if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<comment type="block">/* delta + date */</comment>
			<return>return <expr><call><name>add_date_timedelta</name><argument_list>(<argument><expr>(<name>PyDateTime_Date</name> *) <name>right</name></expr></argument>,
						  <argument><expr>(<name>PyDateTime_Delta</name> *) <name>left</name></expr></argument>,
						  <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_subtract</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> || <call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyDate_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyDate_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* date - date */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>left_ord</name> <init>= <expr><call><name>ymd_to_ord</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>right_ord</name> <init>= <expr><call><name>ymd_to_ord</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<return>return <expr><call><name>new_delta</name><argument_list>(<argument><expr><name>left_ord</name> - <name>right_ord</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* date - delta */</comment>
			<return>return <expr><call><name>add_date_timedelta</name><argument_list>(<argument><expr>(<name>PyDateTime_Date</name> *) <name>left</name></expr></argument>,
						  <argument><expr>(<name>PyDateTime_Delta</name> *) <name>right</name></expr></argument>,
						  <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>


<comment type="block">/* Various ways to turn a date into a string. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_repr</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>1028</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type_name</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>type_name</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%s(%d, %d, %d)"</expr></argument>,
		      <argument><expr><name>type_name</name></expr></argument>,
		      <argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_isoformat</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>isoformat_date</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* str() calls the appropriate isoformat() method. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_str</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>"isoformat"</expr></argument>, <argument><expr>"()"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_ctime</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>format_ctime</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_strftime</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* This method can be inherited, and needs to call the
	 * timetuple() method appropriate to self's class.
	 */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>format_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"format"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"s#:strftime"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
					  <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr>&amp;<name>format_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>tuple</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>"timetuple"</expr></argument>, <argument><expr>"()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>wrap_strftime</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>format_len</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
			       <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_format</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>format</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:__format__"</expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Check for str or unicode */</comment>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* If format is zero length, return str(self) */</comment>
		<if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<return>return <expr><call><name>PyObject_Str</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* If format is zero length, return str(self) */</comment>
		<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
			<return>return <expr><call><name>PyObject_Unicode</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			     <argument><expr>"__format__ expects str or unicode, not %.200s"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>
	<return>return <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>"strftime"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ISO methods. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_isoweekday</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>dow</name> <init>= <expr><call><name>weekday</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>dow</name> + 1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_isocalendar</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type>  <name>year</name>         <init>= <expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>  <name>week1_monday</name> <init>= <expr><call><name>iso_week1_monday</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>today</name>         <init>= <expr><call><name>ymd_to_ord</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>  <name>week</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>  <name>day</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>week</name> = <call><name>divmod</name><argument_list>(<argument><expr><name>today</name> - <name>week1_monday</name></expr></argument>, <argument><expr>7</expr></argument>, <argument><expr>&amp;<name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>week</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>--<name>year</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>week1_monday</name> = <call><name>iso_week1_monday</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>week</name> = <call><name>divmod</name><argument_list>(<argument><expr><name>today</name> - <name>week1_monday</name></expr></argument>, <argument><expr>7</expr></argument>, <argument><expr>&amp;<name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>week</name> &gt;= 52 &amp;&amp; <name>today</name> &gt;= <call><name>iso_week1_monday</name><argument_list>(<argument><expr><name>year</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>++<name>year</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>week</name> = 0</expr>;</expr_stmt>
	}</block></then></if></else></if>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iii"</expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><name>week</name> + 1</expr></argument>, <argument><expr><name>day</name> + 1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Miscellaneous methods. */</comment>

<comment type="block">/* This is more natural as a tp_compare, but doesn't work then:  for whatever
 * reason, Python's try_3way_compare ignores tp_compare unless
 * PyInstance_Check returns true, but these aren't old-style classes.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_richcompare</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr>42</expr></init></decl>;</decl_stmt>	<comment type="block">/* nonsense */</comment>

	<if>if <condition>(<expr><call><name>PyDate_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>diff</name> = <call><name>memcmp</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>((<name>PyDateTime_Date</name> *)<name>other</name>)-&gt;<name>data</name></expr></argument>,
			      <argument><expr><name>_PyDateTime_DATE_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

	<else>else <if>if <condition>(<expr><call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr>"timetuple"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* A hook for other kinds of date objects. */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name> || <name>op</name> == <name>Py_NE</name></expr>)</condition><then>
		<expr_stmt><expr><name>diff</name> = 1</expr>;</expr_stmt></then>	<comment type="block">/* any non-zero value will do */</comment>

	<else>else <comment type="block">/* stop this from falling back to address comparison */</comment>
		<return>return <expr><call><name>cmperror</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if></else></if>

	<return>return <expr><call><name>diff_to_bool</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_timetuple</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>build_struct_time</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_replace</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>clone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>year</name> <init>= <expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>month</name> <init>= <expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>day</name> <init>= <expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|iii:replace"</expr></argument>, <argument><expr><name>date_kws</name></expr></argument>,
					  <argument><expr>&amp;<name>year</name></expr></argument>, <argument><expr>&amp;<name>month</name></expr></argument>, <argument><expr>&amp;<name>day</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>tuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iii"</expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>clone</name> = <call><name>date_new</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>clone</name></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>date_getstate</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>date_hash</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>hashcode</name></name> == -1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><call><name>date_getstate</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>temp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>self</name>-&gt;<name>hashcode</name></name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name><name>self</name>-&gt;<name>hashcode</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_toordinal</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>ymd_to_ord</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_weekday</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>dow</name> <init>= <expr><call><name>weekday</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>dow</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Pickle support, a simple use of __reduce__. */</comment>

<comment type="block">/* __getstate__ isn't exposed */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_getstate</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(
		<argument><expr>"(N)"</expr></argument>,
		<argument><expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>self</name>-&gt;<name>data</name></name></expr></argument>,
					   <argument><expr><name>_PyDateTime_DATE_DATASIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>date_reduce</name><parameter_list>(<param><decl><type><name>PyDateTime_Date</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ON)"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>date_getstate</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>date_methods</name><index>[]</index></name> <init>= <expr><block>{

	<comment type="block">/* Class methods: */</comment>

	<expr><block>{<expr>"fromtimestamp"</expr>, <expr>(<name>PyCFunction</name>)<name>date_fromtimestamp</name></expr>, <expr><name>METH_VARARGS</name> |
							   <name>METH_CLASS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"timestamp -&gt; local date from a POSIX timestamp (like "
	 	   "time.time())."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"fromordinal"</expr>, <expr>(<name>PyCFunction</name>)<name>date_fromordinal</name></expr>,	<expr><name>METH_VARARGS</name> |
							<name>METH_CLASS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"int -&gt; date corresponding to a proleptic Gregorian "
	 	   "ordinal."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"today"</expr>,         <expr>(<name>PyCFunction</name>)<name>date_today</name></expr>,   <expr><name>METH_NOARGS</name> | <name>METH_CLASS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Current date or datetime:  same as "
	 	   "self.__class__.fromtimestamp(time.time())."</argument>)</argument_list></macro>}</block></expr>,

	<comment type="block">/* Instance methods: */</comment>

	<expr><block>{<expr>"ctime"</expr>,       <expr>(<name>PyCFunction</name>)<name>date_ctime</name></expr>,        <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return ctime() style string."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"strftime"</expr>,   	<expr>(<name>PyCFunction</name>)<name>date_strftime</name></expr>,	<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"format -&gt; strftime() style string."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"__format__"</expr>, 	<expr>(<name>PyCFunction</name>)<name>date_format</name></expr>,	<expr><name>METH_VARARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Formats self with strftime."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"timetuple"</expr>,   <expr>(<name>PyCFunction</name>)<name>date_timetuple</name></expr>,    <expr><name>METH_NOARGS</name></expr>,
         <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return time tuple, compatible with time.localtime()."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"isocalendar"</expr>, <expr>(<name>PyCFunction</name>)<name>date_isocalendar</name></expr>,  <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return a 3-tuple containing ISO year, week number, and "
	 	   "weekday."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"isoformat"</expr>,   <expr>(<name>PyCFunction</name>)<name>date_isoformat</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return string in ISO 8601 format, YYYY-MM-DD."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"isoweekday"</expr>,  <expr>(<name>PyCFunction</name>)<name>date_isoweekday</name></expr>,   <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return the day of the week represented by the date.\n"
	 	   "Monday == 1 ... Sunday == 7"</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"toordinal"</expr>,   <expr>(<name>PyCFunction</name>)<name>date_toordinal</name></expr>,    <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return proleptic Gregorian ordinal.  January 1 of year "
	 	   "1 is day 1."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"weekday"</expr>,     <expr>(<name>PyCFunction</name>)<name>date_weekday</name></expr>,      <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return the day of the week represented by the date.\n"
		   "Monday == 0 ... Sunday == 6"</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"replace"</expr>,     <expr>(<name>PyCFunction</name>)<name>date_replace</name></expr>,      <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return date with new specified fields."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"__reduce__"</expr>, <expr>(<name>PyCFunction</name>)<name>date_reduce</name></expr>,        <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"__reduce__() -&gt; (cls, state)"</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><name>NULL</name></expr>,	<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>date_doc</name><index>[]</index></name> <init>=
<expr><call><name>PyDoc_STR</name><argument_list>(<argument><expr>"date(year, month, day) --&gt; date object"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>date_as_number</name> <init>= <expr><block>{
	<expr><name>date_add</name></expr>,					<comment type="block">/* nb_add */</comment>
	<expr><name>date_subtract</name></expr>,					<comment type="block">/* nb_subtract */</comment>
	<expr>0</expr>,						<comment type="block">/* nb_multiply */</comment>
	<expr>0</expr>,						<comment type="block">/* nb_divide */</comment>
	<expr>0</expr>,						<comment type="block">/* nb_remainder */</comment>
	<expr>0</expr>,						<comment type="block">/* nb_divmod */</comment>
	<expr>0</expr>,						<comment type="block">/* nb_power */</comment>
	<expr>0</expr>,						<comment type="block">/* nb_negative */</comment>
	<expr>0</expr>,						<comment type="block">/* nb_positive */</comment>
	<expr>0</expr>,						<comment type="block">/* nb_absolute */</comment>
	<expr>0</expr>,						<comment type="block">/* nb_nonzero */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyDateTime_DateType</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"datetime.date"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyDateTime_Date</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>date_repr</name></expr>,				<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>date_as_number</name></expr>,				<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>date_hash</name></expr>,				<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,              				<comment type="block">/* tp_call */</comment>
	<expr>(<name>reprfunc</name>)<name>date_str</name></expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,			<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
        <name>Py_TPFLAGS_BASETYPE</name></expr>,				<comment type="block">/* tp_flags */</comment>
	<expr><name>date_doc</name></expr>,					<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_clear */</comment>
	<expr>(<name>richcmpfunc</name>)<name>date_richcompare</name></expr>,			<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_iternext */</comment>
	<expr><name>date_methods</name></expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_members */</comment>
	<expr><name>date_getset</name></expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_alloc */</comment>
	<expr><name>date_new</name></expr>,					<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,						<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * PyDateTime_TZInfo implementation.
 */</comment>

<comment type="block">/* This is a pure abstract base class, so doesn't do anything beyond
 * raising NotImplemented exceptions.  Real tzinfo classes need
 * to derive from this.  This is mostly for clarity, and for efficiency in
 * datetime and time constructors (their tzinfo arguments need to
 * be subclasses of this tzinfo class, which is easy and quick to check).
 *
 * Note:  For reasons having to do with pickling of subclasses, we have
 * to allow tzinfo objects to be instantiated.  This wasn't an issue
 * in the Python implementation (__init__() could raise NotImplementedError
 * there without ill effect), but doing so in the C implementation hit a
 * brick wall.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tzinfo_nogo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>methodname</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_NotImplementedError</name></expr></argument>,
		     <argument><expr>"a tzinfo subclass must implement %s()"</expr></argument>,
		     <argument><expr><name>methodname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Methods.  A subclass must implement these. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tzinfo_tzname</name><parameter_list>(<param><decl><type><name>PyDateTime_TZInfo</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dt</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>tzinfo_nogo</name><argument_list>(<argument><expr>"tzname"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tzinfo_utcoffset</name><parameter_list>(<param><decl><type><name>PyDateTime_TZInfo</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dt</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>tzinfo_nogo</name><argument_list>(<argument><expr>"utcoffset"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tzinfo_dst</name><parameter_list>(<param><decl><type><name>PyDateTime_TZInfo</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dt</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>tzinfo_nogo</name><argument_list>(<argument><expr>"dst"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tzinfo_fromutc</name><parameter_list>(<param><decl><type><name>PyDateTime_TZInfo</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyDateTime_DateTime</name> *</type><name>dt</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>, <decl><type ref="prev"/><name>m</name></decl>, <decl><type ref="prev"/><name>d</name></decl>, <decl><type ref="prev"/><name>hh</name></decl>, <decl><type ref="prev"/><name>mm</name></decl>, <decl><type ref="prev"/><name>ss</name></decl>, <decl><type ref="prev"/><name>us</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>, <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>none</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"fromutc: argument must be a datetime"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>! <call><name>HASTZINFO</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call> || <name><name>dt</name>-&gt;<name>tzinfo</name></name> != (<name>PyObject</name> *)<name>self</name></expr>)</condition><then> <block>{
	    	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"fromutc: dt.tzinfo "
	    			"is not self"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    	<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>off</name> = <call><name>call_utcoffset</name><argument_list>(<argument><expr><name><name>dt</name>-&gt;<name>tzinfo</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>dt</name></expr></argument>, <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>off</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>none</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"fromutc: non-None "
				"utcoffset() result required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>dst</name> = <call><name>call_dst</name><argument_list>(<argument><expr><name><name>dt</name>-&gt;<name>tzinfo</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>dt</name></expr></argument>, <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dst</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>none</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"fromutc: non-None "
				"dst() result required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>y</name> = <call><name>GET_YEAR</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>m</name> = <call><name>GET_MONTH</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> = <call><name>GET_DAY</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hh</name> = <call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mm</name> = <call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ss</name> = <call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>us</name> = <call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>delta</name> = <name>off</name> - <name>dst</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mm</name> += <name>delta</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>mm</name> &lt; 0 || <name>mm</name> &gt;= 60) &amp;&amp;
	    <call><name>normalize_datetime</name><argument_list>(<argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>hh</name></expr></argument>, <argument><expr>&amp;<name>mm</name></expr></argument>, <argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr>&amp;<name>us</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>new_datetime</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>hh</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>us</name></expr></argument>, <argument><expr><name><name>dt</name>-&gt;<name>tzinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>result</name></expr>;</return></then></if>

	<expr_stmt><expr><name>dst</name> = <call><name>call_dst</name><argument_list>(<argument><expr><name><name>dt</name>-&gt;<name>tzinfo</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dst</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<goto>goto <name>Fail</name>;</goto></then></if>
	<if>if <condition>(<expr><name>none</name></expr>)</condition><then>
		<goto>goto <name>Inconsistent</name>;</goto></then></if>
	<if>if <condition>(<expr><name>dst</name> == 0</expr>)</condition><then>
		<return>return <expr><name>result</name></expr>;</return></then></if>

	<expr_stmt><expr><name>mm</name> += <name>dst</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>mm</name> &lt; 0 || <name>mm</name> &gt;= 60) &amp;&amp;
	    <call><name>normalize_datetime</name><argument_list>(<argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>hh</name></expr></argument>, <argument><expr>&amp;<name>mm</name></expr></argument>, <argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr>&amp;<name>us</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<goto>goto <name>Fail</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>new_datetime</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>hh</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>us</name></expr></argument>, <argument><expr><name><name>dt</name>-&gt;<name>tzinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>

<label><name>Inconsistent</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"fromutc: tz.dst() gave"
			"inconsistent results; cannot convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fall thru to failure */</comment>
<label><name>Fail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Pickle support.  This is solely so that tzinfo subclasses can use
 * pickling -- tzinfo itself is supposed to be uninstantiable.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tzinfo_reduce</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>, *<decl><type ref="prev"/><name>state</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>getinitargs</name></decl>, *<decl><type ref="prev"/><name>getstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tmp</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>getinitargs</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__getinitargs__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>getinitargs</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>args</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>getinitargs</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>getinitargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> = <name>tmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>getstate</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"__getstate__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>getstate</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>state</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>getstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>getstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>state</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name> **</type><name>dictptr</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>state</name> = <name>Py_None</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dictptr</name> = <call><name>_PyObject_GetDictPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dictptr</name> &amp;&amp; *<name>dictptr</name> &amp;&amp; <call><name>PyDict_Size</name><argument_list>(<argument><expr>*<name>dictptr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>state</name> = *<name>dictptr</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>state</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ON)"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ONN)"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>tzinfo_methods</name><index>[]</index></name> <init>= <expr><block>{

	<expr><block>{<expr>"tzname"</expr>,	<expr>(<name>PyCFunction</name>)<name>tzinfo_tzname</name></expr>,		<expr><name>METH_O</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"datetime -&gt; string name of time zone."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"utcoffset"</expr>,	<expr>(<name>PyCFunction</name>)<name>tzinfo_utcoffset</name></expr>,		<expr><name>METH_O</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"datetime -&gt; minutes east of UTC (negative for "
	 	   "west of UTC)."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"dst"</expr>,		<expr>(<name>PyCFunction</name>)<name>tzinfo_dst</name></expr>,		<expr><name>METH_O</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"datetime -&gt; DST offset in minutes east of UTC."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"fromutc"</expr>,	<expr>(<name>PyCFunction</name>)<name>tzinfo_fromutc</name></expr>,		<expr><name>METH_O</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"datetime in UTC -&gt; datetime in local time."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"__reduce__"</expr>,  <expr>(<name>PyCFunction</name>)<name>tzinfo_reduce</name></expr>,             <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"-&gt; (cls, state)"</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>tzinfo_doc</name><index>[]</index></name> <init>=
<expr><call><name>PyDoc_STR</name><argument_list>(<argument><expr>"Abstract base class for time zone info objects."</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>statichere</name> <name>PyTypeObject</name></type> <name>PyDateTime_TZInfoType</name> <init>= <expr><block>{
	<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
	0</expr>,					<comment type="block">/* ob_size */</comment>
	<expr>"datetime.tzinfo"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyDateTime_TZInfo</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,              			<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
        <name>Py_TPFLAGS_BASETYPE</name></expr>,			<comment type="block">/* tp_flags */</comment>
	<expr><name>tzinfo_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>tzinfo_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>PyType_GenericNew</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * PyDateTime_Time implementation.
 */</comment>

<comment type="block">/* Accessor properties.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_hour</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>TIME_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_minute</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>TIME_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* The name time_second conflicted with some platform header file. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>py_time_second</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_microsecond</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_tzinfo</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>time_getset</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"hour"</expr>,        <expr>(<name>getter</name>)<name>time_hour</name></expr>}</block></expr>,
	<expr><block>{<expr>"minute"</expr>,      <expr>(<name>getter</name>)<name>time_minute</name></expr>}</block></expr>,
	<expr><block>{<expr>"second"</expr>,      <expr>(<name>getter</name>)<name>py_time_second</name></expr>}</block></expr>,
	<expr><block>{<expr>"microsecond"</expr>, <expr>(<name>getter</name>)<name>time_microsecond</name></expr>}</block></expr>,
	<expr><block>{<expr>"tzinfo"</expr>,	<expr>(<name>getter</name>)<name>time_tzinfo</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Constructors.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>time_kws</name><index>[]</index></name> <init>= <expr><block>{<expr>"hour"</expr>, <expr>"minute"</expr>, <expr>"second"</expr>, <expr>"microsecond"</expr>,
			   <expr>"tzinfo"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hour</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>minute</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>second</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>usecond</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check for invocation from pickle with __getstate__ state */</comment>
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &gt;= 1 &amp;&amp;
	    <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &lt;= 2 &amp;&amp;
	    <call><name>PyString_Check</name><argument_list>(<argument><expr><name>state</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
	    <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> == <name>_PyDateTime_TIME_DATASIZE</name> &amp;&amp;
	    (<call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr></argument>)</argument_list></call>) &lt; 24</expr>)</condition><then>
	<block>{
		<decl_stmt><decl><type><name>PyDateTime_Time</name> *</type><name>me</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>aware</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>tzinfo</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>check_tzinfo_subclass</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"bad "
					"tzinfo state arg"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>aware</name> = <call>(<name>char</name>)<argument_list>(<argument><expr><name>tzinfo</name> != <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>me</name> = <call>(<name>PyDateTime_Time</name> *) <argument_list>(<argument><expr><call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>aware</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>me</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>pdata</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>me</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pdata</name></expr></argument>, <argument><expr><name>_PyDateTime_TIME_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>me</name>-&gt;<name>hashcode</name></name> = -1</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>me</name>-&gt;<name>hastzinfo</name></name> = <name>aware</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>aware</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>me</name>-&gt;<name>tzinfo</name></name> = <name>tzinfo</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr>(<name>PyObject</name> *)<name>me</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|iiiiO"</expr></argument>, <argument><expr><name>time_kws</name></expr></argument>,
					<argument><expr>&amp;<name>hour</name></expr></argument>, <argument><expr>&amp;<name>minute</name></expr></argument>, <argument><expr>&amp;<name>second</name></expr></argument>, <argument><expr>&amp;<name>usecond</name></expr></argument>,
					<argument><expr>&amp;<name>tzinfo</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>check_time_args</name><argument_list>(<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>, <argument><expr><name>second</name></expr></argument>, <argument><expr><name>usecond</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>check_tzinfo_subclass</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>self</name> = <call><name>new_time_ex</name><argument_list>(<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>, <argument><expr><name>second</name></expr></argument>, <argument><expr><name>usecond</name></expr></argument>, <argument><expr><name>tzinfo</name></expr></argument>,
				   <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Destructor.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>time_dealloc</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Indirect access to tzinfo methods.
 */</comment>

<comment type="block">/* These are all METH_NOARGS, so don't need to check the arglist. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_utcoffset</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><call><name>offset_as_timedelta</name><argument_list>(<argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></argument>,
				   <argument><expr>"utcoffset"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_dst</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><call><name>offset_as_timedelta</name><argument_list>(<argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></argument>,
				   <argument><expr>"dst"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_tzname</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><call><name>call_tzname</name><argument_list>(<argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></argument>,
			   <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Various ways to turn a time into a string.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_repr</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type_name</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><call><name>TIME_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><call><name>TIME_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>us</name> <init>= <expr><call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>us</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"%s(%d, %d, %d, %d)"</expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>s</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"%s(%d, %d, %d)"</expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"%s(%d, %d)"</expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> != <name>NULL</name> &amp;&amp; <call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>append_keyword_tzinfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_str</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>"isoformat"</expr></argument>, <argument><expr>"()"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_isoformat</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<comment type="block">/* Reuse the time format code from the datetime type. */</comment>
	<decl_stmt><decl><type><name>PyDateTime_DateTime</name></type> <name>datetime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyDateTime_DateTime</name> *</type><name>pdatetime</name> <init>= <expr>&amp;<name>datetime</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Copy over just the time bytes. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pdatetime</name>-&gt;<name>data</name></name> + <name>_PyDateTime_DATE_DATASIZE</name></expr></argument>,
	       <argument><expr><name><name>self</name>-&gt;<name>data</name></name></expr></argument>,
	       <argument><expr><name>_PyDateTime_TIME_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>isoformat_time</name><argument_list>(<argument><expr><name>pdatetime</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name> || ! <call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> || <name><name>self</name>-&gt;<name>tzinfo</name></name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr><name>result</name></expr>;</return></then></if>

	<comment type="block">/* We need to append the UTC offset. */</comment>
	<if>if <condition>(<expr><call><name>format_utcoffset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>,
			     <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_strftime</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>format_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"format"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"s#:strftime"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
					  <argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr>&amp;<name>format_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Python's strftime does insane things with the year part of the
	 * timetuple.  The year is forced to (the otherwise nonsensical)
	 * 1900 to worm around that.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiiiiiiii"</expr></argument>,
		              <argument><expr>1900</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <comment type="block">/* year, month, day */</comment>
			      <argument><expr><call><name>TIME_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><call><name>TIME_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* weekday, daynum, dst */</comment>
	<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> == 9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>wrap_strftime</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>format_len</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
			       <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Miscellaneous methods.
 */</comment>

<comment type="block">/* This is more natural as a tp_compare, but doesn't work then:  for whatever
 * reason, Python's try_3way_compare ignores tp_compare unless
 * PyInstance_Check returns true, but these aren't old-style classes.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_richcompare</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>naivety</name></type> <name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset1</name></decl>, <decl><type ref="prev"/><name>offset2</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyTime_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name> || <name>op</name> == <name>Py_NE</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>op</name> == <name>Py_EQ</name> ? <name>Py_False</name> : <name>Py_True</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Stop this from falling back to address comparison. */</comment>
		<return>return <expr><call><name>cmperror</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>classify_two_utcoffsets</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>&amp;<name>offset1</name></expr></argument>, <argument><expr>&amp;<name>n1</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>,
				     <argument><expr><name>other</name></expr></argument>, <argument><expr>&amp;<name>offset2</name></expr></argument>, <argument><expr>&amp;<name>n2</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n1</name> != <name>OFFSET_UNKNOWN</name> &amp;&amp; <name>n2</name> != <name>OFFSET_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If they're both naive, or both aware and have the same offsets,
	 * we get off cheap.  Note that if they're both naive, offset1 ==
	 * offset2 == 0 at this point.
	 */</comment>
	<if>if <condition>(<expr><name>n1</name> == <name>n2</name> &amp;&amp; <name>offset1</name> == <name>offset2</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>diff</name> = <call><name>memcmp</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>((<name>PyDateTime_Time</name> *)<name>other</name>)-&gt;<name>data</name></expr></argument>,
			      <argument><expr><name>_PyDateTime_TIME_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>diff_to_bool</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>n1</name> == <name>OFFSET_AWARE</name> &amp;&amp; <name>n2</name> == <name>OFFSET_AWARE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset1</name> != <name>offset2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else last "if" handled it */</comment>
		<comment type="block">/* Convert everything except microseconds to seconds.  These
		 * can't overflow (no more than the # of seconds in 2 days).
		 */</comment>
		<expr_stmt><expr><name>offset1</name> = <call><name>TIME_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> * 3600 +
			  (<call><name>TIME_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>offset1</name>) * 60 +
			  <call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset2</name> = <call><name>TIME_GET_HOUR</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call> * 3600 +
			  (<call><name>TIME_GET_MINUTE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call> - <name>offset2</name>) * 60 +
			  <call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>diff</name> = <name>offset1</name> - <name>offset2</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>diff</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>diff</name> = <call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> -
			       <call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><call><name>diff_to_bool</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n1</name> != <name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"can't compare offset-naive and "
			"offset-aware times"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>time_hash</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>hashcode</name></name> == -1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>naivety</name></type> <name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>n</name> = <call><name>classify_utcoffset</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> != <name>OFFSET_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> == <name>OFFSET_ERROR</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>

		<comment type="block">/* Reduce this to a hash of another object. */</comment>
		<if>if <condition>(<expr><name>offset</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>temp</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>self</name>-&gt;<name>data</name></name></expr></argument>,
						<argument><expr><name>_PyDateTime_TIME_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>hour</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>minute</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> == <name>OFFSET_AWARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hour</name> = <call><name>divmod</name><argument_list>(<argument><expr><call><name>TIME_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> * 60 +
					<call><name>TIME_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>offset</name></expr></argument>,
				      <argument><expr>60</expr></argument>,
				      <argument><expr>&amp;<name>minute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>0 &lt;= <name>hour</name> &amp;&amp; <name>hour</name> &lt; 24</expr>)</condition><then>
				<expr_stmt><expr><name>temp</name> = <call><name>new_time</name><argument_list>(<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>,
						<argument><expr><call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>temp</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiii"</expr></argument>,
					   <argument><expr><name>hour</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>,
					   <argument><expr><call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		}</block></else></if>
		<if>if <condition>(<expr><name>temp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>self</name>-&gt;<name>hashcode</name></name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name><name>self</name>-&gt;<name>hashcode</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_replace</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>clone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hh</name> <init>= <expr><call><name>TIME_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mm</name> <init>= <expr><call><name>TIME_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ss</name> <init>= <expr><call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>us</name> <init>= <expr><call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|iiiiO:replace"</expr></argument>,
					  <argument><expr><name>time_kws</name></expr></argument>,
					  <argument><expr>&amp;<name>hh</name></expr></argument>, <argument><expr>&amp;<name>mm</name></expr></argument>, <argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr>&amp;<name>us</name></expr></argument>, <argument><expr>&amp;<name>tzinfo</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>tuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiiiO"</expr></argument>, <argument><expr><name>hh</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>us</name></expr></argument>, <argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>clone</name> = <call><name>time_new</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>clone</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>time_nonzero</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>none</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> || <call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Since utcoffset is in whole minutes, nothing can
		 * alter the conclusion that this is nonzero.
		 */</comment>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>self</name>-&gt;<name>tzinfo</name></name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>offset</name> = <call><name>call_utcoffset</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>offset</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr>(<call><name>TIME_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>offset</name> + <call><name>TIME_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>*60) != 0</expr>;</return>
}</block></function>

<comment type="block">/* Pickle support, a simple use of __reduce__. */</comment>

<comment type="block">/* Let basestate be the non-tzinfo data string.
 * If tzinfo is None, this returns (basestate,), else (basestate, tzinfo).
 * So it's a tuple in any (non-error) case.
 * __getstate__ isn't exposed.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_getstate</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>basestate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>basestate</name> =  <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>self</name>-&gt;<name>data</name></name></expr></argument>,
						<argument><expr><name>_PyDateTime_TIME_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>basestate</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>! <call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> || <name><name>self</name>-&gt;<name>tzinfo</name></name> == <name>Py_None</name></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>basestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>result</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>basestate</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>basestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>time_reduce</name><parameter_list>(<param><decl><type><name>PyDateTime_Time</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ON)"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>time_getstate</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>time_methods</name><index>[]</index></name> <init>= <expr><block>{

	<expr><block>{<expr>"isoformat"</expr>,   <expr>(<name>PyCFunction</name>)<name>time_isoformat</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return string in ISO 8601 format, HH:MM:SS[.mmmmmm]"
	 	   "[+HH:MM]."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"strftime"</expr>,   	<expr>(<name>PyCFunction</name>)<name>time_strftime</name></expr>,	<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"format -&gt; strftime() style string."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"__format__"</expr>, 	<expr>(<name>PyCFunction</name>)<name>date_format</name></expr>,	<expr><name>METH_VARARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Formats self with strftime."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"utcoffset"</expr>,	<expr>(<name>PyCFunction</name>)<name>time_utcoffset</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return self.tzinfo.utcoffset(self)."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"tzname"</expr>,	<expr>(<name>PyCFunction</name>)<name>time_tzname</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return self.tzinfo.tzname(self)."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"dst"</expr>,		<expr>(<name>PyCFunction</name>)<name>time_dst</name></expr>,		<expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return self.tzinfo.dst(self)."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"replace"</expr>,     <expr>(<name>PyCFunction</name>)<name>time_replace</name></expr>,	<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return time with new specified fields."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"__reduce__"</expr>, <expr>(<name>PyCFunction</name>)<name>time_reduce</name></expr>,        <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"__reduce__() -&gt; (cls, state)"</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><name>NULL</name></expr>,	<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>time_doc</name><index>[]</index></name> <init>=
<expr><call><name>PyDoc_STR</name><argument_list>(<argument><expr>"time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --&gt; a time object\n\
\n\
All arguments are optional. tzinfo may be None, or an instance of\n\
a tzinfo subclass. The remaining arguments may be ints or longs.\n"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>time_as_number</name> <init>= <expr><block>{
	<expr>0</expr>,					<comment type="block">/* nb_add */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_subtract */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_multiply */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_divide */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_remainder */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_divmod */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_power */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_negative */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_positive */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_absolute */</comment>
	<expr>(<name>inquiry</name>)<name>time_nonzero</name></expr>,			<comment type="block">/* nb_nonzero */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>statichere</name> <name>PyTypeObject</name></type> <name>PyDateTime_TimeType</name> <init>= <expr><block>{
	<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
	0</expr>,					<comment type="block">/* ob_size */</comment>
	<expr>"datetime.time"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyDateTime_Time</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>(<name>destructor</name>)<name>time_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>time_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>time_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>time_hash</name></expr>,			<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,              			<comment type="block">/* tp_call */</comment>
	<expr>(<name>reprfunc</name>)<name>time_str</name></expr>,			<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
        <name>Py_TPFLAGS_BASETYPE</name></expr>,			<comment type="block">/* tp_flags */</comment>
	<expr><name>time_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>(<name>richcmpfunc</name>)<name>time_richcompare</name></expr>,		<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>time_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr><name>time_getset</name></expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr><name>time_alloc</name></expr>,				<comment type="block">/* tp_alloc */</comment>
	<expr><name>time_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * PyDateTime_DateTime implementation.
 */</comment>

<comment type="block">/* Accessor properties.  Properties for day, month, and year are inherited
 * from date.
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_hour</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_minute</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_second</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_microsecond</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_tzinfo</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>datetime_getset</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"hour"</expr>,        <expr>(<name>getter</name>)<name>datetime_hour</name></expr>}</block></expr>,
	<expr><block>{<expr>"minute"</expr>,      <expr>(<name>getter</name>)<name>datetime_minute</name></expr>}</block></expr>,
	<expr><block>{<expr>"second"</expr>,      <expr>(<name>getter</name>)<name>datetime_second</name></expr>}</block></expr>,
	<expr><block>{<expr>"microsecond"</expr>, <expr>(<name>getter</name>)<name>datetime_microsecond</name></expr>}</block></expr>,
	<expr><block>{<expr>"tzinfo"</expr>,	<expr>(<name>getter</name>)<name>datetime_tzinfo</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Constructors.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>datetime_kws</name><index>[]</index></name> <init>= <expr><block>{
	<expr>"year"</expr>, <expr>"month"</expr>, <expr>"day"</expr>, <expr>"hour"</expr>, <expr>"minute"</expr>, <expr>"second"</expr>,
	<expr>"microsecond"</expr>, <expr>"tzinfo"</expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>year</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>month</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>day</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hour</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>minute</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>second</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>usecond</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check for invocation from pickle with __getstate__ state */</comment>
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &gt;= 1 &amp;&amp;
	    <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &lt;= 2 &amp;&amp;
	    <call><name>PyString_Check</name><argument_list>(<argument><expr><name>state</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
	    <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> == <name>_PyDateTime_DATETIME_DATASIZE</name> &amp;&amp;
	    <call><name>MONTH_IS_SANE</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call><index>[<expr>2</expr>]</index></expr></argument>)</argument_list></call></expr>)</condition><then>
	<block>{
		<decl_stmt><decl><type><name>PyDateTime_DateTime</name> *</type><name>me</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>aware</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>tzinfo</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>check_tzinfo_subclass</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"bad "
					"tzinfo state arg"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>aware</name> = <call>(<name>char</name>)<argument_list>(<argument><expr><name>tzinfo</name> != <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>me</name> = <call>(<name>PyDateTime_DateTime</name> *) <argument_list>(<argument><expr><call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument> , <argument><expr><name>aware</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>me</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>pdata</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>me</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pdata</name></expr></argument>, <argument><expr><name>_PyDateTime_DATETIME_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>me</name>-&gt;<name>hashcode</name></name> = -1</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>me</name>-&gt;<name>hastzinfo</name></name> = <name>aware</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>aware</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>me</name>-&gt;<name>tzinfo</name></name> = <name>tzinfo</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr>(<name>PyObject</name> *)<name>me</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"iii|iiiiO"</expr></argument>, <argument><expr><name>datetime_kws</name></expr></argument>,
					<argument><expr>&amp;<name>year</name></expr></argument>, <argument><expr>&amp;<name>month</name></expr></argument>, <argument><expr>&amp;<name>day</name></expr></argument>, <argument><expr>&amp;<name>hour</name></expr></argument>, <argument><expr>&amp;<name>minute</name></expr></argument>,
					<argument><expr>&amp;<name>second</name></expr></argument>, <argument><expr>&amp;<name>usecond</name></expr></argument>, <argument><expr>&amp;<name>tzinfo</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>check_date_args</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>check_time_args</name><argument_list>(<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>, <argument><expr><name>second</name></expr></argument>, <argument><expr><name>usecond</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>check_tzinfo_subclass</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>self</name> = <call><name>new_datetime_ex</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>,
				    	<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>, <argument><expr><name>second</name></expr></argument>, <argument><expr><name>usecond</name></expr></argument>,
				    	<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<comment type="block">/* TM_FUNC is the shared type of localtime() and gmtime(). */</comment>
<typedef>typedef <function_decl><type>struct <name>tm</name> *</type>(*<name>TM_FUNC</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>time_t</name> *</type><name>timer</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Internal helper.
 * Build datetime from a time_t and a distinct count of microseconds.
 * Pass localtime or gmtime for f, to control the interpretation of timet.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_from_timet_and_us</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>TM_FUNC</name></type> <name>f</name></decl></param>, <param><decl><type><name>time_t</name></type> <name>timet</name></decl></param>, <param><decl><type><name>int</name></type> <name>us</name></decl></param>,
			   <param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>tm</name> *</type><name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tm</name> = <call><name>f</name><argument_list>(<argument><expr>&amp;<name>timet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tm</name></expr>)</condition><then> <block>{
		<comment type="block">/* The platform localtime/gmtime may insert leap seconds,
		 * indicated by tm-&gt;tm_sec &gt; 59.  We don't care about them,
		 * except to the extent that passing them on to the datetime
		 * constructor would raise ValueError for a reason that
		 * made no sense to the user.
		 */</comment>
		<if>if <condition>(<expr><name><name>tm</name>-&gt;<name>tm_sec</name></name> &gt; 59</expr>)</condition><then>
			<expr_stmt><expr><name><name>tm</name>-&gt;<name>tm_sec</name></name> = 59</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr>"iiiiiiiO"</expr></argument>,
					       <argument><expr><name><name>tm</name>-&gt;<name>tm_year</name></name> + 1900</expr></argument>,
					       <argument><expr><name><name>tm</name>-&gt;<name>tm_mon</name></name> + 1</expr></argument>,
					       <argument><expr><name><name>tm</name>-&gt;<name>tm_mday</name></name></expr></argument>,
					       <argument><expr><name><name>tm</name>-&gt;<name>tm_hour</name></name></expr></argument>,
					       <argument><expr><name><name>tm</name>-&gt;<name>tm_min</name></name></expr></argument>,
					       <argument><expr><name><name>tm</name>-&gt;<name>tm_sec</name></name></expr></argument>,
					       <argument><expr><name>us</name></expr></argument>,
					       <argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"timestamp out of range for "
				"platform localtime()/gmtime() function"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Internal helper.
 * Build datetime from a Python timestamp.  Pass localtime or gmtime for f,
 * to control the interpretation of the timestamp.  Since a double doesn't
 * have enough bits to cover a datetime's full range of precision, it's
 * better to call datetime_from_timet_and_us provided you have a way
 * to get that much precision (e.g., C time() isn't good enough).
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_from_timestamp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>TM_FUNC</name></type> <name>f</name></decl></param>, <param><decl><type><name>double</name></type> <name>timestamp</name></decl></param>,
			<param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>time_t</name></type> <name>timet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>fraction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>us</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>timet</name> = <call><name>_PyTime_DoubleToTimet</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>timet</name> == (<name>time_t</name>)-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>fraction</name> = <name>timestamp</name> - (<name>double</name>)<name>timet</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>us</name> = (<name>int</name>)<call><name>round_to_long</name><argument_list>(<argument><expr><name>fraction</name> * 1e6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>us</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* Truncation towards zero is not what we wanted
		   for negative numbers (Python's mod semantics) */</comment>
		<expr_stmt><expr><name>timet</name> -= 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>us</name> += 1000000</expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* If timestamp is less than one microsecond smaller than a
	 * full second, round up. Otherwise, ValueErrors are raised
	 * for some floats. */</comment>
	<if>if <condition>(<expr><name>us</name> == 1000000</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>timet</name> += 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>us</name> = 0</expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><call><name>datetime_from_timet_and_us</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>timet</name></expr></argument>, <argument><expr><name>us</name></expr></argument>, <argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Internal helper.
 * Build most accurate possible datetime for current time.  Pass localtime or
 * gmtime for f as appropriate.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_best_possible</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>TM_FUNC</name></type> <name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETTIMEOFDAY</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>timeval</name></type> <name>t</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GETTIMEOFDAY_NO_TZ</name></cpp:ifdef>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr>(struct <name>timezone</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><call><name>datetime_from_timet_and_us</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>t</name>.<name>tv_sec</name></name></expr></argument>, <argument><expr>(<name>int</name>)<name><name>t</name>.<name>tv_usec</name></name></expr></argument>,
					  <argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="block">/* ! HAVE_GETTIMEOFDAY */</comment>
	<comment type="block">/* No flavor of gettimeofday exists on this platform.  Python's
	 * time.time() does a lot of other platform tricks to get the
	 * best time it can on the platform, and we're not going to do
	 * better than that (if we could, the better code would belong
	 * in time.time()!)  We're limited by the precision of a double,
	 * though.
	 */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>dtime</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>time</name> = <call><name>time_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    	<if>if <condition>(<expr><name>time</name> == <name>NULL</name></expr>)</condition><then>
    		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>dtime</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dtime</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>datetime_from_timestamp</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>dtime</name></expr></argument>, <argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* ! HAVE_GETTIMEOFDAY */</comment>
}</block></function>

<comment type="block">/* Return best possible local time -- this isn't constrained by the
 * precision of a timestamp.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_now</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"tz"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|O:now"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
					  <argument><expr>&amp;<name>tzinfo</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>check_tzinfo_subclass</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>self</name> = <call><name>datetime_best_possible</name><argument_list>(<argument><expr><name>cls</name></expr></argument>,
				      <argument><expr><name>tzinfo</name> == <name>Py_None</name> ? <name>localtime</name> : <name>gmtime</name></expr></argument>,
				      <argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> != <name>NULL</name> &amp;&amp; <name>tzinfo</name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<comment type="block">/* Convert UTC to tzinfo's zone. */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name>self</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>self</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr>"fromutc"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<comment type="block">/* Return best possible UTC time -- this isn't constrained by the
 * precision of a timestamp.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_utcnow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>dummy</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>datetime_best_possible</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>gmtime</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Return new local datetime from timestamp (Python timestamp -- a double). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_fromtimestamp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>timestamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"timestamp"</expr>, <expr>"tz"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"d|O:fromtimestamp"</expr></argument>,
					  <argument><expr><name>keywords</name></expr></argument>, <argument><expr>&amp;<name>timestamp</name></expr></argument>, <argument><expr>&amp;<name>tzinfo</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>check_tzinfo_subclass</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>self</name> = <call><name>datetime_from_timestamp</name><argument_list>(<argument><expr><name>cls</name></expr></argument>,
				       <argument><expr><name>tzinfo</name> == <name>Py_None</name> ? <name>localtime</name> : <name>gmtime</name></expr></argument>,
				       <argument><expr><name>timestamp</name></expr></argument>,
				       <argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> != <name>NULL</name> &amp;&amp; <name>tzinfo</name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<comment type="block">/* Convert UTC to tzinfo's zone. */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name>self</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>self</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr>"fromutc"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<comment type="block">/* Return new UTC datetime from timestamp (Python timestamp -- a double). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_utcfromtimestamp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>timestamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"d:utcfromtimestamp"</expr></argument>, <argument><expr>&amp;<name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>datetime_from_timestamp</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><name>gmtime</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>,
						 <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Return new datetime from time.strptime(). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_strptime</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>module</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init>, *<name>obj</name></decl>, *<decl><type ref="prev"/><name>st</name> <init>= <expr><name>NULL</name></expr></init>, *<name>frac</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl>, *<decl><type ref="prev"/><name>format</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss:strptime"</expr></argument>, <argument><expr>&amp;<name>string</name></expr></argument>, <argument><expr>&amp;<name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>module</name> == <name>NULL</name> &amp;&amp;
	    (<name>module</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"_strptime"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* _strptime._strptime returns a two-element tuple.  The first
	   element is a time.struct_time object.  The second is the
	   microseconds (which are not defined for time.struct_time). */</comment>
	<expr_stmt><expr><name>obj</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"_strptime"</expr></argument>, <argument><expr>"ss"</expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>obj</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>good_timetuple</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name> <name>int</name></type> <name><name>ia</name><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PySequence_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>st</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>frac</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>st</name> == <name>NULL</name> || <name>frac</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>good_timetuple</name> = 0</expr>;</expr_stmt></then></if>
			<comment type="block">/* copy y/m/d/h/m/s values out of the
			   time.struct_time */</comment>
			<if>if <condition>(<expr><name>good_timetuple</name> &amp;&amp;
			    <call><name>PySequence_Check</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call> &amp;&amp;
			    <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call> &gt;= 6</expr>)</condition><then> <block>{
				<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; 6</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
					<decl_stmt><decl><type><name>PyObject</name> *</type><name>p</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>good_timetuple</name> = 0</expr>;</expr_stmt>
						<break>break;</break>
					}</block></then></if>
					<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
						<expr_stmt><expr><name><name>ia</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
					<else>else
						<expr_stmt><expr><name>good_timetuple</name> = 0</expr>;</expr_stmt></else></if>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></for>
			}</block></then>
			<else>else
				<expr_stmt><expr><name>good_timetuple</name> = 0</expr>;</expr_stmt></else></if>
			<comment type="block">/* follow that up with a little dose of microseconds */</comment>
			<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>frac</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name><name>ia</name><index>[<expr>6</expr>]</index></name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>frac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>good_timetuple</name> = 0</expr>;</expr_stmt></else></if>
		}</block></then>
		<else>else
			<expr_stmt><expr><name>good_timetuple</name> = 0</expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>good_timetuple</name></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr>"iiiiiii"</expr></argument>,
						       <argument><expr><name><name>ia</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>ia</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>ia</name><index>[<expr>2</expr>]</index></name></expr></argument>,
						       <argument><expr><name><name>ia</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr><name><name>ia</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr><name><name>ia</name><index>[<expr>5</expr>]</index></name></expr></argument>,
						       <argument><expr><name><name>ia</name><index>[<expr>6</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"unexpected value from _strptime._strptime"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>frac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Return new datetime from date/datetime and time arguments. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_combine</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
 	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"date"</expr>, <expr>"time"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>date</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"O!O!:combine"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
					<argument><expr>&amp;<name>PyDateTime_DateType</name></expr></argument>, <argument><expr>&amp;<name>date</name></expr></argument>,
					<argument><expr>&amp;<name>PyDateTime_TimeType</name></expr></argument>, <argument><expr>&amp;<name>time</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>tzinfo</name> = ((<name>PyDateTime_Time</name> *)<name>time</name>)-&gt;<name>tzinfo</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr>"iiiiiiiO"</expr></argument>,
						<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>,
				    		<argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>,
				    		<argument><expr><call><name>TIME_GET_HOUR</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr></argument>,
				    		<argument><expr><call><name>TIME_GET_MINUTE</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr></argument>,
				    		<argument><expr><call><name>TIME_GET_SECOND</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr></argument>,
				    		<argument><expr><call><name>TIME_GET_MICROSECOND</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr></argument>,
				    		<argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Destructor.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>datetime_dealloc</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Indirect access to tzinfo methods.
 */</comment>

<comment type="block">/* These are all METH_NOARGS, so don't need to check the arglist. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_utcoffset</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><call><name>offset_as_timedelta</name><argument_list>(<argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></argument>,
				   <argument><expr>"utcoffset"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_dst</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><call><name>offset_as_timedelta</name><argument_list>(<argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></argument>,
				   <argument><expr>"dst"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_tzname</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><call><name>call_tzname</name><argument_list>(<argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></argument>,
			   <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * datetime arithmetic.
 */</comment>

<comment type="block">/* factor must be 1 (to add) or -1 (to subtract).  The result inherits
 * the tzinfo state of date.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>add_datetime_timedelta</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>date</name></decl></param>, <param><decl><type><name>PyDateTime_Delta</name> *</type><name>delta</name></decl></param>,
		       <param><decl><type><name>int</name></type> <name>factor</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Note that the C-level additions can't overflow, because of
	 * invariant bounds on the member values.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>year</name> <init>= <expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>month</name> <init>= <expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>day</name> <init>= <expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call> + <call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call> * <name>factor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hour</name> <init>= <expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>minute</name> <init>= <expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>second</name> <init>= <expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call> + <call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call> * <name>factor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>microsecond</name> <init>= <expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call> +
			  <call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call> * <name>factor</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>factor</name> == 1 || <name>factor</name> == -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>normalize_datetime</name><argument_list>(<argument><expr>&amp;<name>year</name></expr></argument>, <argument><expr>&amp;<name>month</name></expr></argument>, <argument><expr>&amp;<name>day</name></expr></argument>,
			       <argument><expr>&amp;<name>hour</name></expr></argument>, <argument><expr>&amp;<name>minute</name></expr></argument>, <argument><expr>&amp;<name>second</name></expr></argument>, <argument><expr>&amp;<name>microsecond</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>new_datetime</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>,
				    <argument><expr><name>hour</name></expr></argument>, <argument><expr><name>minute</name></expr></argument>, <argument><expr><name>second</name></expr></argument>, <argument><expr><name>microsecond</name></expr></argument>,
				    <argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call> ? <name><name>date</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_add</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* datetime + ??? */</comment>
		<if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<comment type="block">/* datetime + delta */</comment>
			<return>return <expr><call><name>add_datetime_timedelta</name><argument_list>(
					<argument><expr>(<name>PyDateTime_DateTime</name> *)<name>left</name></expr></argument>,
					<argument><expr>(<name>PyDateTime_Delta</name> *)<name>right</name></expr></argument>,
					<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* delta + datetime */</comment>
		<return>return <expr><call><name>add_datetime_timedelta</name><argument_list>(<argument><expr>(<name>PyDateTime_DateTime</name> *) <name>right</name></expr></argument>,
					      <argument><expr>(<name>PyDateTime_Delta</name> *) <name>left</name></expr></argument>,
					      <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_subtract</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>Py_NotImplemented</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* datetime - ??? */</comment>
		<if>if <condition>(<expr><call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* datetime - datetime */</comment>
			<decl_stmt><decl><type><name>naivety</name></type> <name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>offset1</name></decl>, <decl><type ref="prev"/><name>offset2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>delta_d</name></decl>, <decl><type ref="prev"/><name>delta_s</name></decl>, <decl><type ref="prev"/><name>delta_us</name></decl>;</decl_stmt>

			<if>if <condition>(<expr><call><name>classify_two_utcoffsets</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr>&amp;<name>offset1</name></expr></argument>, <argument><expr>&amp;<name>n1</name></expr></argument>, <argument><expr><name>left</name></expr></argument>,
						    <argument><expr><name>right</name></expr></argument>, <argument><expr>&amp;<name>offset2</name></expr></argument>, <argument><expr>&amp;<name>n2</name></expr></argument>,
						    <argument><expr><name>right</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n1</name> != <name>OFFSET_UNKNOWN</name> &amp;&amp; <name>n2</name> != <name>OFFSET_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>n1</name> != <name>n2</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"can't subtract offset-naive and "
					"offset-aware datetimes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>delta_d</name> = <call><name>ymd_to_ord</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> -
				  <call><name>ymd_to_ord</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* These can't overflow, since the values are
			 * normalized.  At most this gives the number of
			 * seconds in one day.
			 */</comment>
			<expr_stmt><expr><name>delta_s</name> = (<call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> -
				   <call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call>) * 3600 +
			          (<call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> -
			           <call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call>) * 60 +
				  (<call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> -
				   <call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
			<expr_stmt><expr><name>delta_us</name> = <call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> -
				   <call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* (left - offset1) - (right - offset2) =
			 * (left - right) + (offset2 - offset1)
			 */</comment>
			<expr_stmt><expr><name>delta_s</name> += (<name>offset2</name> - <name>offset1</name>) * 60</expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> = <call><name>new_delta</name><argument_list>(<argument><expr><name>delta_d</name></expr></argument>, <argument><expr><name>delta_s</name></expr></argument>, <argument><expr><name>delta_us</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><call><name>PyDelta_Check</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* datetime - delta */</comment>
			<expr_stmt><expr><name>result</name> = <call><name>add_datetime_timedelta</name><argument_list>(
					<argument><expr>(<name>PyDateTime_DateTime</name> *)<name>left</name></expr></argument>,
					<argument><expr>(<name>PyDateTime_Delta</name> *)<name>right</name></expr></argument>,
					<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></else></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>result</name> == <name>Py_NotImplemented</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Various ways to turn a datetime into a string. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_repr</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>1000</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type_name</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>baserepr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"%s(%d, %d, %d, %d, %d, %d, %d)"</expr></argument>,
			      <argument><expr><name>type_name</name></expr></argument>,
			      <argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"%s(%d, %d, %d, %d, %d, %d)"</expr></argument>,
			      <argument><expr><name>type_name</name></expr></argument>,
			      <argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"%s(%d, %d, %d, %d, %d)"</expr></argument>,
			      <argument><expr><name>type_name</name></expr></argument>,
			      <argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<expr_stmt><expr><name>baserepr</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>baserepr</name> == <name>NULL</name> || ! <call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>baserepr</name></expr>;</return></then></if>
	<return>return <expr><call><name>append_keyword_tzinfo</name><argument_list>(<argument><expr><name>baserepr</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_str</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>"isoformat"</expr></argument>, <argument><expr>"(s)"</expr></argument>, <argument><expr>" "</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_isoformat</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name>sep</name> <init>= <expr>'T'</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"sep"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|c:isoformat"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
					 <argument><expr>&amp;<name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>cp</name> = <call><name>isoformat_date</name><argument_list>(<argument><expr>(<name>PyDateTime_Date</name> *)<name>self</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cp</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>cp</name>++ = <name>sep</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>isoformat_time</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> - (<name>cp</name> - <name>buffer</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name> || ! <call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>result</name></expr>;</return></then></if>

	<comment type="block">/* We need to append the UTC offset. */</comment>
	<if>if <condition>(<expr><call><name>format_utcoffset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>,
			     <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyString_ConcatAndDel</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_ctime</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>format_ctime</name><argument_list>(<argument><expr>(<name>PyDateTime_Date</name> *)<name>self</name></expr></argument>,
			    <argument><expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Miscellaneous methods. */</comment>

<comment type="block">/* This is more natural as a tp_compare, but doesn't work then:  for whatever
 * reason, Python's try_3way_compare ignores tp_compare unless
 * PyInstance_Check returns true, but these aren't old-style classes.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_richcompare</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>other</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>naivety</name></type> <name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset1</name></decl>, <decl><type ref="prev"/><name>offset2</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyDateTime_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* If other has a "timetuple" attr, that's an advertised
		 * hook for other classes to ask to get comparison control.
		 * However, date instances have a timetuple attr, and we
		 * don't want to allow that comparison.  Because datetime
		 * is a subclass of date, when mixing date and datetime
		 * in a comparison, Python gives datetime the first shot
		 * (it's the more specific subtype).  So we can stop that
		 * combination here reliably.
		 */</comment>
		<if>if <condition>(<expr><call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr>"timetuple"</expr></argument>)</argument_list></call> &amp;&amp;
		    ! <call><name>PyDate_Check</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* A hook for other kinds of datetime objects. */</comment>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name> || <name>op</name> == <name>Py_NE</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>op</name> == <name>Py_EQ</name> ? <name>Py_False</name> : <name>Py_True</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* Stop this from falling back to address comparison. */</comment>
		<return>return <expr><call><name>cmperror</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>classify_two_utcoffsets</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>&amp;<name>offset1</name></expr></argument>, <argument><expr>&amp;<name>n1</name></expr></argument>,
				    <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
				     <argument><expr><name>other</name></expr></argument>, <argument><expr>&amp;<name>offset2</name></expr></argument>, <argument><expr>&amp;<name>n2</name></expr></argument>,
				     <argument><expr><name>other</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n1</name> != <name>OFFSET_UNKNOWN</name> &amp;&amp; <name>n2</name> != <name>OFFSET_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<comment type="block">/* If they're both naive, or both aware and have the same offsets,
	 * we get off cheap.  Note that if they're both naive, offset1 ==
	 * offset2 == 0 at this point.
	 */</comment>
	<if>if <condition>(<expr><name>n1</name> == <name>n2</name> &amp;&amp; <name>offset1</name> == <name>offset2</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>diff</name> = <call><name>memcmp</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>((<name>PyDateTime_DateTime</name> *)<name>other</name>)-&gt;<name>data</name></expr></argument>,
			      <argument><expr><name>_PyDateTime_DATETIME_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>diff_to_bool</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>n1</name> == <name>OFFSET_AWARE</name> &amp;&amp; <name>n2</name> == <name>OFFSET_AWARE</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyDateTime_Delta</name> *</type><name>delta</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset1</name> != <name>offset2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else last "if" handled it */</comment>
		<expr_stmt><expr><name>delta</name> = (<name>PyDateTime_Delta</name> *)<call><name>datetime_subtract</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
							       <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>delta</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>diff</name> = <call><name>GET_TD_DAYS</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>diff</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>diff</name> = <call><name>GET_TD_SECONDS</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call> |
			       <call><name>GET_TD_MICROSECONDS</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>diff_to_bool</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n1</name> != <name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"can't compare offset-naive and "
			"offset-aware datetimes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>datetime_hash</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>hashcode</name></name> == -1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>naivety</name></type> <name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>n</name> = <call><name>classify_utcoffset</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
				       <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> != <name>OFFSET_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> == <name>OFFSET_ERROR</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>

		<comment type="block">/* Reduce this to a hash of another object. */</comment>
		<if>if <condition>(<expr><name>n</name> == <name>OFFSET_NAIVE</name></expr>)</condition><then>
			<expr_stmt><expr><name>temp</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(
					<argument><expr>(<name>char</name> *)<name><name>self</name>-&gt;<name>data</name></name></expr></argument>,
					<argument><expr><name>_PyDateTime_DATETIME_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>days</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>seconds</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> == <name>OFFSET_AWARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>days</name> = <call><name>ymd_to_ord</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>seconds</name> = <call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> * 3600 +
				  (<call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> - <name>offset</name>) * 60 +
				  <call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>temp</name> = <call><name>new_delta</name><argument_list>(<argument><expr><name>days</name></expr></argument>,
					 <argument><expr><name>seconds</name></expr></argument>,
					 <argument><expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>temp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>self</name>-&gt;<name>hashcode</name></name> = <call><name>PyObject_Hash</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name><name>self</name>-&gt;<name>hashcode</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_replace</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>clone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hh</name> <init>= <expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mm</name> <init>= <expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ss</name> <init>= <expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>us</name> <init>= <expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name> <init>= <expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|iiiiiiiO:replace"</expr></argument>,
					  <argument><expr><name>datetime_kws</name></expr></argument>,
					  <argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>hh</name></expr></argument>, <argument><expr>&amp;<name>mm</name></expr></argument>, <argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr>&amp;<name>us</name></expr></argument>,
					  <argument><expr>&amp;<name>tzinfo</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>tuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiiiiiiO"</expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>hh</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>us</name></expr></argument>, <argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tuple</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>clone</name> = <call><name>datetime_new</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>clone</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_astimezone</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>, <decl><type ref="prev"/><name>m</name></decl>, <decl><type ref="prev"/><name>d</name></decl>, <decl><type ref="prev"/><name>hh</name></decl>, <decl><type ref="prev"/><name>mm</name></decl>, <decl><type ref="prev"/><name>ss</name></decl>, <decl><type ref="prev"/><name>us</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>none</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tzinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"tz"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>! <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"O!:astimezone"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
					  <argument><expr>&amp;<name>PyDateTime_TZInfoType</name></expr></argument>, <argument><expr>&amp;<name>tzinfo</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

        <if>if <condition>(<expr>!<call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> || <name><name>self</name>-&gt;<name>tzinfo</name></name> == <name>Py_None</name></expr>)</condition><then>
        	<goto>goto <name>NeedAware</name>;</goto></then></if>

        <comment type="block">/* Conversion to self's own time zone is a NOP. */</comment>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>tzinfo</name></name> == <name>tzinfo</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
	}</block></then></if>

        <comment type="block">/* Convert self to UTC. */</comment>
        <expr_stmt><expr><name>offset</name> = <call><name>call_utcoffset</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>offset</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        	<return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>none</name></expr>)</condition><then>
        	<goto>goto <name>NeedAware</name>;</goto></then></if>

	<expr_stmt><expr><name>y</name> = <call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>m</name> = <call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> = <call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hh</name> = <call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mm</name> = <call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ss</name> = <call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>us</name> = <call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>mm</name> -= <name>offset</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>mm</name> &lt; 0 || <name>mm</name> &gt;= 60) &amp;&amp;
	    <call><name>normalize_datetime</name><argument_list>(<argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>hh</name></expr></argument>, <argument><expr>&amp;<name>mm</name></expr></argument>, <argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr>&amp;<name>us</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Attach new tzinfo and let fromutc() do the rest. */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>new_datetime</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>hh</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>us</name></expr></argument>, <argument><expr><name>tzinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>tzinfo</name></expr></argument>, <argument><expr>"fromutc"</expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>

<label><name>NeedAware</name>:</label>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"astimezone() cannot be applied to "
					  "a naive datetime"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_timetuple</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>dstflag</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>self</name>-&gt;<name>tzinfo</name></name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>none</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dstflag</name> = <call><name>call_dst</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dstflag</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<if>if <condition>(<expr><name>none</name></expr>)</condition><then>
			<expr_stmt><expr><name>dstflag</name> = -1</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>dstflag</name> != 0</expr>)</condition><then>
			<expr_stmt><expr><name>dstflag</name> = 1</expr>;</expr_stmt></then></if></else></if>

	}</block></then></if>
	<return>return <expr><call><name>build_struct_time</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>dstflag</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_getdate</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>new_date</name><argument_list>(<argument><expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_gettime</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>new_time</name><argument_list>(<argument><expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_gettimetz</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>new_time</name><argument_list>(<argument><expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>DATE_GET_MICROSECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> ? <name><name>self</name>-&gt;<name>tzinfo</name></name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_utctimetuple</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><call><name>GET_YEAR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><call><name>GET_MONTH</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>GET_DAY</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hh</name> <init>= <expr><call><name>DATE_GET_HOUR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mm</name> <init>= <expr><call><name>DATE_GET_MINUTE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ss</name> <init>= <expr><call><name>DATE_GET_SECOND</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>us</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* microseconds are ignored in a timetuple */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>self</name>-&gt;<name>tzinfo</name></name> != <name>Py_None</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>none</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>offset</name> = <call><name>call_utcoffset</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>&amp;<name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>offset</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<comment type="block">/* Even if offset is 0, don't call timetuple() -- tm_isdst should be
	 * 0 in a UTC timetuple regardless of what dst() says.
	 */</comment>
	<if>if <condition>(<expr><name>offset</name></expr>)</condition><then> <block>{
		<comment type="block">/* Subtract offset minutes &amp; normalize. */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>stat</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mm</name> -= <name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stat</name> = <call><name>normalize_datetime</name><argument_list>(<argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>hh</name></expr></argument>, <argument><expr>&amp;<name>mm</name></expr></argument>, <argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr>&amp;<name>us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>stat</name> &lt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* At the edges, it's possible we overflowed
			 * beyond MINYEAR or MAXYEAR.
			 */</comment>
			<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<return>return <expr><name>NULL</name></expr>;</return></else></if>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><call><name>build_struct_time</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>hh</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Pickle support, a simple use of __reduce__. */</comment>

<comment type="block">/* Let basestate be the non-tzinfo data string.
 * If tzinfo is None, this returns (basestate,), else (basestate, tzinfo).
 * So it's a tuple in any (non-error) case.
 * __getstate__ isn't exposed.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_getstate</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>basestate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>basestate</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>self</name>-&gt;<name>data</name></name></expr></argument>,
					  <argument><expr><name>_PyDateTime_DATETIME_DATASIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>basestate</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>! <call><name>HASTZINFO</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> || <name><name>self</name>-&gt;<name>tzinfo</name></name> == <name>Py_None</name></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>basestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>result</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>basestate</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>tzinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>basestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>datetime_reduce</name><parameter_list>(<param><decl><type><name>PyDateTime_DateTime</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ON)"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>datetime_getstate</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>datetime_methods</name><index>[]</index></name> <init>= <expr><block>{

	<comment type="block">/* Class methods: */</comment>

	<expr><block>{<expr>"now"</expr>,         <expr>(<name>PyCFunction</name>)<name>datetime_now</name></expr>,
	 <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name> | <name>METH_CLASS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"[tz] -&gt; new datetime with tz's local day and time."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"utcnow"</expr>,         <expr>(<name>PyCFunction</name>)<name>datetime_utcnow</name></expr>,
	 <expr><name>METH_NOARGS</name> | <name>METH_CLASS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return a new datetime representing UTC day and time."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"fromtimestamp"</expr>, <expr>(<name>PyCFunction</name>)<name>datetime_fromtimestamp</name></expr>,
	 <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name> | <name>METH_CLASS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"timestamp[, tz] -&gt; tz's local time from POSIX timestamp."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"utcfromtimestamp"</expr>, <expr>(<name>PyCFunction</name>)<name>datetime_utcfromtimestamp</name></expr>,
	 <expr><name>METH_VARARGS</name> | <name>METH_CLASS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"timestamp -&gt; UTC datetime from a POSIX timestamp "
	 	   "(like time.time())."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"strptime"</expr>, <expr>(<name>PyCFunction</name>)<name>datetime_strptime</name></expr>,
	 <expr><name>METH_VARARGS</name> | <name>METH_CLASS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"string, format -&gt; new datetime parsed from a string "
	 	   "(like time.strptime())."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"combine"</expr>, <expr>(<name>PyCFunction</name>)<name>datetime_combine</name></expr>,
	 <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name> | <name>METH_CLASS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"date, time -&gt; datetime with same date and time fields"</argument>)</argument_list></macro>}</block></expr>,

	<comment type="block">/* Instance methods: */</comment>

	<expr><block>{<expr>"date"</expr>,   <expr>(<name>PyCFunction</name>)<name>datetime_getdate</name></expr>, <expr><name>METH_NOARGS</name></expr>,
         <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return date object with same year, month and day."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"time"</expr>,   <expr>(<name>PyCFunction</name>)<name>datetime_gettime</name></expr>, <expr><name>METH_NOARGS</name></expr>,
         <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return time object with same time but with tzinfo=None."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"timetz"</expr>,   <expr>(<name>PyCFunction</name>)<name>datetime_gettimetz</name></expr>, <expr><name>METH_NOARGS</name></expr>,
         <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return time object with same time and tzinfo."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"ctime"</expr>,       <expr>(<name>PyCFunction</name>)<name>datetime_ctime</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return ctime() style string."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"timetuple"</expr>,   <expr>(<name>PyCFunction</name>)<name>datetime_timetuple</name></expr>, <expr><name>METH_NOARGS</name></expr>,
         <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return time tuple, compatible with time.localtime()."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"utctimetuple"</expr>,   <expr>(<name>PyCFunction</name>)<name>datetime_utctimetuple</name></expr>, <expr><name>METH_NOARGS</name></expr>,
         <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return UTC time tuple, compatible with time.localtime()."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"isoformat"</expr>,   <expr>(<name>PyCFunction</name>)<name>datetime_isoformat</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"[sep] -&gt; string in ISO 8601 format, "
	 	   "YYYY-MM-DDTHH:MM:SS[.mmmmmm][+HH:MM].\n\n"
	 	   "sep is used to separate the year from the time, and "
	 	   "defaults to 'T'."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"utcoffset"</expr>,	<expr>(<name>PyCFunction</name>)<name>datetime_utcoffset</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return self.tzinfo.utcoffset(self)."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"tzname"</expr>,	<expr>(<name>PyCFunction</name>)<name>datetime_tzname</name></expr>,	<expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return self.tzinfo.tzname(self)."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"dst"</expr>,		<expr>(<name>PyCFunction</name>)<name>datetime_dst</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return self.tzinfo.dst(self)."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"replace"</expr>,     <expr>(<name>PyCFunction</name>)<name>datetime_replace</name></expr>,	<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"Return datetime with new specified fields."</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"astimezone"</expr>,  <expr>(<name>PyCFunction</name>)<name>datetime_astimezone</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"tz -&gt; convert to local time in new timezone tz\n"</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr>"__reduce__"</expr>, <expr>(<name>PyCFunction</name>)<name>datetime_reduce</name></expr>,     <expr><name>METH_NOARGS</name></expr>,
	 <macro><name>PyDoc_STR</name><argument_list>(<argument>"__reduce__() -&gt; (cls, state)"</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><name>NULL</name></expr>,	<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>datetime_doc</name><index>[]</index></name> <init>=
<expr><call><name>PyDoc_STR</name><argument_list>(<argument><expr>"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\
\n\
The year, month and day arguments are required. tzinfo may be None, or an\n\
instance of a tzinfo subclass. The remaining arguments may be ints or longs.\n"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>datetime_as_number</name> <init>= <expr><block>{
	<expr><name>datetime_add</name></expr>,				<comment type="block">/* nb_add */</comment>
	<expr><name>datetime_subtract</name></expr>,			<comment type="block">/* nb_subtract */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_multiply */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_divide */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_remainder */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_divmod */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_power */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_negative */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_positive */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_absolute */</comment>
	<expr>0</expr>,					<comment type="block">/* nb_nonzero */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>statichere</name> <name>PyTypeObject</name></type> <name>PyDateTime_DateTimeType</name> <init>= <expr><block>{
	<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
	0</expr>,					<comment type="block">/* ob_size */</comment>
	<expr>"datetime.datetime"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyDateTime_DateTime</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>(<name>destructor</name>)<name>datetime_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>datetime_repr</name></expr>,		<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>datetime_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>(<name>hashfunc</name>)<name>datetime_hash</name></expr>,		<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,              			<comment type="block">/* tp_call */</comment>
	<expr>(<name>reprfunc</name>)<name>datetime_str</name></expr>,			<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
        <name>Py_TPFLAGS_BASETYPE</name></expr>,			<comment type="block">/* tp_flags */</comment>
	<expr><name>datetime_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>(<name>richcmpfunc</name>)<name>datetime_richcompare</name></expr>,	<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>datetime_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr><name>datetime_getset</name></expr>,			<comment type="block">/* tp_getset */</comment>
	<expr>&amp;<name>PyDateTime_DateType</name></expr>,			<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr><name>datetime_alloc</name></expr>,				<comment type="block">/* tp_alloc */</comment>
	<expr><name>datetime_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ---------------------------------------------------------------------------
 * Module methods and initialization.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>module_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* C API.  Clients get at this via PyDateTime_IMPORT, defined in
 * datetime.h.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyDateTime_CAPI</name></type> <name>CAPI</name> <init>= <expr><block>{
        <expr>&amp;<name>PyDateTime_DateType</name></expr>,
        <expr>&amp;<name>PyDateTime_DateTimeType</name></expr>,
        <expr>&amp;<name>PyDateTime_TimeType</name></expr>,
        <expr>&amp;<name>PyDateTime_DeltaType</name></expr>,
        <expr>&amp;<name>PyDateTime_TZInfoType</name></expr>,
        <expr><name>new_date_ex</name></expr>,
        <expr><name>new_datetime_ex</name></expr>,
        <expr><name>new_time_ex</name></expr>,
        <expr><name>new_delta_ex</name></expr>,
        <expr><name>datetime_fromtimestamp</name></expr>,
        <expr><name>date_fromtimestamp</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><name>PyMODINIT_FUNC</name></type>
<name>initdatetime</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>	<comment type="block">/* a module object */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>;</decl_stmt>	<comment type="block">/* its dict */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"datetime"</expr></argument>, <argument><expr><name>module_methods</name></expr></argument>,
			   <argument><expr>"Fast implementation of the datetime type."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_DateType</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_DateTimeType</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_DeltaType</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_TimeType</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_TZInfoType</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* timedelta values */</comment>
	<expr_stmt><expr><name>d</name> = <name><name>PyDateTime_DeltaType</name>.<name>tp_dict</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_delta</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"resolution"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_delta</name><argument_list>(<argument><expr>-<name>MAX_DELTA_DAYS</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"min"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_delta</name><argument_list>(<argument><expr><name>MAX_DELTA_DAYS</name></expr></argument>, <argument><expr>24*3600-1</expr></argument>, <argument><expr>1000000-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"max"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* date values */</comment>
	<expr_stmt><expr><name>d</name> = <name><name>PyDateTime_DateType</name>.<name>tp_dict</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_date</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"min"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_date</name><argument_list>(<argument><expr><name>MAXYEAR</name></expr></argument>, <argument><expr>12</expr></argument>, <argument><expr>31</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"max"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_delta</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"resolution"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* time values */</comment>
	<expr_stmt><expr><name>d</name> = <name><name>PyDateTime_TimeType</name>.<name>tp_dict</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_time</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"min"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_time</name><argument_list>(<argument><expr>23</expr></argument>, <argument><expr>59</expr></argument>, <argument><expr>59</expr></argument>, <argument><expr>999999</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"max"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_delta</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"resolution"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* datetime values */</comment>
	<expr_stmt><expr><name>d</name> = <name><name>PyDateTime_DateTimeType</name>.<name>tp_dict</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_datetime</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"min"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_datetime</name><argument_list>(<argument><expr><name>MAXYEAR</name></expr></argument>, <argument><expr>12</expr></argument>, <argument><expr>31</expr></argument>, <argument><expr>23</expr></argument>, <argument><expr>59</expr></argument>, <argument><expr>59</expr></argument>, <argument><expr>999999</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"max"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>new_delta</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == <name>NULL</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"resolution"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* module initialization */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MINYEAR"</expr></argument>, <argument><expr><name>MINYEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MAXYEAR"</expr></argument>, <argument><expr><name>MAXYEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_DateType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"date"</expr></argument>, <argument><expr>(<name>PyObject</name> *) &amp;<name>PyDateTime_DateType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_DateTimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"datetime"</expr></argument>,
			   <argument><expr>(<name>PyObject</name> *)&amp;<name>PyDateTime_DateTimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_TimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"time"</expr></argument>, <argument><expr>(<name>PyObject</name> *) &amp;<name>PyDateTime_TimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_DeltaType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"timedelta"</expr></argument>, <argument><expr>(<name>PyObject</name> *) &amp;<name>PyDateTime_DeltaType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyDateTime_TZInfoType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"tzinfo"</expr></argument>, <argument><expr>(<name>PyObject</name> *) &amp;<name>PyDateTime_TZInfoType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>x</name> = <call><name>PyCObject_FromVoidPtrAndDesc</name><argument_list>(<argument><expr>&amp;<name>CAPI</name></expr></argument>, <argument><expr>(<name>void</name>*) <name>DATETIME_API_MAGIC</name></expr></argument>,
                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
            <return>return;</return></then></if>
        <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"datetime_CAPI"</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A 4-year cycle has an extra leap day over what we'd get from
	 * pasting together 4 single years.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>DI4Y</name> == 4 * 365 + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>DI4Y</name> == <call><name>days_before_year</name><argument_list>(<argument><expr>4+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Similarly, a 400-year cycle has an extra leap day over what we'd
	 * get from pasting together 4 100-year cycles.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>DI400Y</name> == 4 * <name>DI100Y</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>DI400Y</name> == <call><name>days_before_year</name><argument_list>(<argument><expr>400+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OTOH, a 100-year cycle has one fewer leap day than we'd get from
	 * pasting together 25 4-year cycles.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>DI100Y</name> == 25 * <name>DI4Y</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>DI100Y</name> == <call><name>days_before_year</name><argument_list>(<argument><expr>100+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>us_per_us</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>us_per_ms</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>us_per_second</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>1000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>us_per_minute</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>60000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>seconds_per_day</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>24 * 3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>us_per_us</name> == <name>NULL</name> || <name>us_per_ms</name> == <name>NULL</name> || <name>us_per_second</name> == <name>NULL</name> ||
	    <name>us_per_minute</name> == <name>NULL</name> || <name>seconds_per_day</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* The rest are too big for 32-bit ints, but even
	 * us_per_week fits in 40 bits, so doubles should be exact.
	 */</comment>
	<expr_stmt><expr><name>us_per_hour</name> = <call><name>PyLong_FromDouble</name><argument_list>(<argument><expr>3600000000.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>us_per_day</name> = <call><name>PyLong_FromDouble</name><argument_list>(<argument><expr>86400000000.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>us_per_week</name> = <call><name>PyLong_FromDouble</name><argument_list>(<argument><expr>604800000000.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>us_per_hour</name> == <name>NULL</name> || <name>us_per_day</name> == <name>NULL</name> || <name>us_per_week</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------------
Some time zone algebra.  For a datetime x, let
    x.n = x stripped of its timezone -- its naive time.
    x.o = x.utcoffset(), and assuming that doesn't raise an exception or
          return None
    x.d = x.dst(), and assuming that doesn't raise an exception or
          return None
    x.s = x's standard offset, x.o - x.d

Now some derived rules, where k is a duration (timedelta).

1. x.o = x.s + x.d
   This follows from the definition of x.s.

2. If x and y have the same tzinfo member, x.s = y.s.
   This is actually a requirement, an assumption we need to make about
   sane tzinfo classes.

3. The naive UTC time corresponding to x is x.n - x.o.
   This is again a requirement for a sane tzinfo class.

4. (x+k).s = x.s
   This follows from #2, and that datimetimetz+timedelta preserves tzinfo.

5. (x+k).n = x.n + k
   Again follows from how arithmetic is defined.

Now we can explain tz.fromutc(x).  Let's assume it's an interesting case
(meaning that the various tzinfo methods exist, and don't blow up or return
None when called).

The function wants to return a datetime y with timezone tz, equivalent to x.
x is already in UTC.

By #3, we want

    y.n - y.o = x.n                             [1]

The algorithm starts by attaching tz to x.n, and calling that y.  So
x.n = y.n at the start.  Then it wants to add a duration k to y, so that [1]
becomes true; in effect, we want to solve [2] for k:

   (y+k).n - (y+k).o = x.n                      [2]

By #1, this is the same as

   (y+k).n - ((y+k).s + (y+k).d) = x.n          [3]

By #5, (y+k).n = y.n + k, which equals x.n + k because x.n=y.n at the start.
Substituting that into [3],

   x.n + k - (y+k).s - (y+k).d = x.n; the x.n terms cancel, leaving
   k - (y+k).s - (y+k).d = 0; rearranging,
   k = (y+k).s - (y+k).d; by #4, (y+k).s == y.s, so
   k = y.s - (y+k).d

On the RHS, (y+k).d can't be computed directly, but y.s can be, and we
approximate k by ignoring the (y+k).d term at first.  Note that k can't be
very large, since all offset-returning methods return a duration of magnitude
less than 24 hours.  For that reason, if y is firmly in std time, (y+k).d must
be 0, so ignoring it has no consequence then.

In any case, the new value is

    z = y + y.s                                 [4]

It's helpful to step back at look at [4] from a higher level:  it's simply
mapping from UTC to tz's standard time.

At this point, if

    z.n - z.o = x.n                             [5]

we have an equivalent time, and are almost done.  The insecurity here is
at the start of daylight time.  Picture US Eastern for concreteness.  The wall
time jumps from 1:59 to 3:00, and wall hours of the form 2:MM don't make good
sense then.  The docs ask that an Eastern tzinfo class consider such a time to
be EDT (because it's "after 2"), which is a redundant spelling of 1:MM EST
on the day DST starts.  We want to return the 1:MM EST spelling because that's
the only spelling that makes sense on the local wall clock.

In fact, if [5] holds at this point, we do have the standard-time spelling,
but that takes a bit of proof.  We first prove a stronger result.  What's the
difference between the LHS and RHS of [5]?  Let

    diff = x.n - (z.n - z.o)                    [6]

Now
    z.n =                       by [4]
    (y + y.s).n =               by #5
    y.n + y.s =                 since y.n = x.n
    x.n + y.s =                 since z and y are have the same tzinfo member,
                                    y.s = z.s by #2
    x.n + z.s

Plugging that back into [6] gives

    diff =
    x.n - ((x.n + z.s) - z.o) =     expanding
    x.n - x.n - z.s + z.o =         cancelling
    - z.s + z.o =                   by #2
    z.d

So diff = z.d.

If [5] is true now, diff = 0, so z.d = 0 too, and we have the standard-time
spelling we wanted in the endcase described above.  We're done.  Contrarily,
if z.d = 0, then we have a UTC equivalent, and are also done.

If [5] is not true now, diff = z.d != 0, and z.d is the offset we need to
add to z (in effect, z is in tz's standard time, and we need to shift the
local clock into tz's daylight time).

Let

    z' = z + z.d = z + diff                     [7]

and we can again ask whether

    z'.n - z'.o = x.n                           [8]

If so, we're done.  If not, the tzinfo class is insane, according to the
assumptions we've made.  This also requires a bit of proof.  As before, let's
compute the difference between the LHS and RHS of [8] (and skipping some of
the justifications for the kinds of substitutions we've done several times
already):

    diff' = x.n - (z'.n - z'.o) =           replacing z'.n via [7]
            x.n  - (z.n + diff - z'.o) =    replacing diff via [6]
            x.n - (z.n + x.n - (z.n - z.o) - z'.o) =
            x.n - z.n - x.n + z.n - z.o + z'.o =    cancel x.n
            - z.n + z.n - z.o + z'.o =              cancel z.n
            - z.o + z'.o =                      #1 twice
            -z.s - z.d + z'.s + z'.d =          z and z' have same tzinfo
            z'.d - z.d

So z' is UTC-equivalent to x iff z'.d = z.d at this point.  If they are equal,
we've found the UTC-equivalent so are done.  In fact, we stop with [7] and
return z', not bothering to compute z'.d.

How could z.d and z'd differ?  z' = z + z.d [7], so merely moving z' by
a dst() offset, and starting *from* a time already in DST (we know z.d != 0),
would have to change the result dst() returns:  we start in DST, and moving
a little further into it takes us out of DST.

There isn't a sane case where this can happen.  The closest it gets is at
the end of DST, where there's an hour in UTC with no spelling in a hybrid
tzinfo class.  In US Eastern, that's 5:MM UTC = 0:MM EST = 1:MM EDT.  During
that hour, on an Eastern clock 1:MM is taken as being in standard time (6:MM
UTC) because the docs insist on that, but 0:MM is taken as being in daylight
time (4:MM UTC).  There is no local time mapping to 5:MM UTC.  The local
clock jumps from 1:59 back to 1:00 again, and repeats the 1:MM hour in
standard time.  Since that's what the local clock *does*, we want to map both
UTC hours 5:MM and 6:MM to 1:MM Eastern.  The result is ambiguous
in local time, but so it goes -- it's the way the local clock works.

When x = 5:MM UTC is the input to this algorithm, x.o=0, y.o=-5 and y.d=0,
so z=0:MM.  z.d=60 (minutes) then, so [5] doesn't hold and we keep going.
z' = z + z.d = 1:MM then, and z'.d=0, and z'.d - z.d = -60 != 0 so [8]
(correctly) concludes that z' is not UTC-equivalent to x.

Because we know z.d said z was in daylight time (else [5] would have held and
we would have stopped then), and we know z.d != z'.d (else [8] would have held
and we would have stopped then), and there are only 2 possible values dst() can
return in Eastern, it follows that z'.d must be 0 (which it is in the example,
but the reasoning doesn't depend on the example -- it depends on there being
two possible dst() outcomes, one zero and the other non-zero).  Therefore
z' must be in standard time, and is the spelling we want in this case.

Note again that z' is not UTC-equivalent as far as the hybrid tzinfo class is
concerned (because it takes z' as being in standard time rather than the
daylight time we intend here), but returning it gives the real-life "local
clock repeats an hour" behavior when mapping the "unspellable" UTC hour into
tz.

When the input is 6:MM, z=1:MM and z.d=0, and we stop at once, again with
the 1:MM standard time spelling we want.

So how can this break?  One of the assumptions must be violated.  Two
possibilities:

1) [2] effectively says that y.s is invariant across all y belong to a given
   time zone.  This isn't true if, for political reasons or continental drift,
   a region decides to change its base offset from UTC.

2) There may be versions of "double daylight" time where the tail end of
   the analysis gives up a step too early.  I haven't thought about that
   enough to say.

In any case, it's clear that the default fromutc() is strong enough to handle
"almost all" time zones:  so long as the standard offset is invariant, it
doesn't matter if daylight time transition points change from year to year, or
if daylight time is skipped in some years; it doesn't matter how large or
small dst() may get within its bounds; and it doesn't even matter if some
perverse time zone returns a negative dst()).  So a breaking case must be
pretty bizarre, and a tzinfo subclass can override fromutc() if it is.
--------------------------------------------------------------------------- */</comment>
</unit>
