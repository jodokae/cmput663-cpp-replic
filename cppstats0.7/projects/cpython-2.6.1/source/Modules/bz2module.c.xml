<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/bz2module.c"><comment type="block">/*

python-bz2 - python bz2 library interface

Copyright (c) 2002  Gustavo Niemeyer &lt;niemeyer@conectiva.com&gt;
Copyright (c) 2002  Python Software Foundation; All Rights Reserved

*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bzlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>__author__</name><index>[]</index></name> <init>=
<expr>"The bz2 python module was written by:\n\
\n\
    Gustavo Niemeyer &lt;niemeyer@conectiva.com&gt;\n\
"</expr></init></decl>;</decl_stmt>

<comment type="block">/* Our very own off_t-like type, 64-bit if possible */</comment>
<comment type="block">/* copied from Objects/fileobject.c */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>off_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_OFF_T</name> &gt;= 8</expr></cpp:elif>
<typedef>typedef <type><name>off_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_FPOS_T</name> &gt;= 8</expr></cpp:elif>
<typedef>typedef <type><name>fpos_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "Large file support, but neither off_t nor fpos_t is large enough."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyString_AS_STRING((PyStringObject *)v)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_CLOSED</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_READ</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_READ_EOF</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_WRITE</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2FileObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(Py_TYPE(v) == &amp;BZ2File_Type)</cpp:value></cpp:define>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BZ_CONFIG_ERROR</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt;= 8</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZS_TOTAL_OUT</name><parameter_list>(<param><type><name>bzs</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>(((long)bzs-&gt;total_out_hi32 &lt;&lt; 32) + bzs-&gt;total_out_lo32)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> &gt;= 8</expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZS_TOTAL_OUT</name><parameter_list>(<param><type><name>bzs</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>(((PY_LONG_LONG)bzs-&gt;total_out_hi32 &lt;&lt; 32) + bzs-&gt;total_out_lo32)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZS_TOTAL_OUT</name><parameter_list>(<param><type><name>bzs</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>bzs-&gt;total_out_lo32</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* ! BZ_CONFIG_ERROR */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzRead</name></cpp:macro> <cpp:value>bzRead</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzReadOpen</name></cpp:macro> <cpp:value>bzReadOpen</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzReadClose</name></cpp:macro> <cpp:value>bzReadClose</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzWrite</name></cpp:macro> <cpp:value>bzWrite</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzWriteOpen</name></cpp:macro> <cpp:value>bzWriteOpen</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzWriteClose</name></cpp:macro> <cpp:value>bzWriteClose</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzCompress</name></cpp:macro> <cpp:value>bzCompress</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzCompressInit</name></cpp:macro> <cpp:value>bzCompressInit</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzCompressEnd</name></cpp:macro> <cpp:value>bzCompressEnd</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzDecompress</name></cpp:macro> <cpp:value>bzDecompress</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzDecompressInit</name></cpp:macro> <cpp:value>bzDecompressInit</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ2_bzDecompressEnd</name></cpp:macro> <cpp:value>bzDecompressEnd</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZS_TOTAL_OUT</name><parameter_list>(<param><type><name>bzs</name></type></param>)</parameter_list></cpp:macro> <cpp:value>bzs-&gt;total_out</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ! BZ_CONFIG_ERROR */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_LOCK</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyThread_acquire_lock(obj-&gt;lock, 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_LOCK</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyThread_release_lock(obj-&gt;lock)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_LOCK</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_LOCK</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Bits in f_newlinetypes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_UNKNOWN</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>	<comment type="block">/* No newline seen, yet */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_CR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>		<comment type="block">/* \r newline seen */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_LF</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>		<comment type="block">/* \n newline seen */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_CRLF</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>		<comment type="block">/* \r\n newline seen */</comment>

<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Structure definitions. */</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyObject</name> *</type><name>file</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>*</type> <name>f_buf</name></decl>;</decl_stmt>		<comment type="block">/* Allocated readahead buffer */</comment>
	<decl_stmt><decl><type><name>char</name>*</type> <name>f_bufend</name></decl>;</decl_stmt>		<comment type="block">/* Points after last occupied position */</comment>
	<decl_stmt><decl><type><name>char</name>*</type> <name>f_bufptr</name></decl>;</decl_stmt>		<comment type="block">/* Current buffer position */</comment>

	<decl_stmt><decl><type><name>int</name></type> <name>f_softspace</name></decl>;</decl_stmt>	<comment type="block">/* Flag used by 'print' command */</comment>

	<decl_stmt><decl><type><name>int</name></type> <name>f_univ_newline</name></decl>;</decl_stmt>	<comment type="block">/* Handle any newline convention */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>f_newlinetypes</name></decl>;</decl_stmt>	<comment type="block">/* Types of newlines seen */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>f_skipnextlf</name></decl>;</decl_stmt>	<comment type="block">/* Skip next \n */</comment>

	<decl_stmt><decl><type><name>BZFILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_off_t</name></type> <name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_off_t</name></type> <name>size</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyThread_type_lock</name></type> <name>lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>BZ2FileObject</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>bz_stream</name></type> <name>bzs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>running</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyThread_type_lock</name></type> <name>lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>BZ2CompObject</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>bz_stream</name></type> <name>bzs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>running</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>unused_data</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PyThread_type_lock</name></type> <name>lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>BZ2DecompObject</name>;</typedef>

<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Utility functions. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Util_CatchBZ2Error</name><parameter_list>(<param><decl><type><name>int</name></type> <name>bzerror</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<switch>switch<condition>(<expr><name>bzerror</name></expr>)</condition> <block>{
		<case>case <expr><name>BZ_OK</name></expr>:
		</case><case>case <expr><name>BZ_STREAM_END</name></expr>:
			<break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BZ_CONFIG_ERROR</name></cpp:ifdef>
		</case><case>case <expr><name>BZ_CONFIG_ERROR</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
					<argument><expr>"the bz2 library was not compiled "
					"correctly"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		</case><case>case <expr><name>BZ_PARAM_ERROR</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"the bz2 library has received wrong "
					"parameters"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>BZ_MEM_ERROR</name></expr>:
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>BZ_DATA_ERROR</name></expr>:
		</case><case>case <expr><name>BZ_DATA_ERROR_MAGIC</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr>"invalid data stream"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>BZ_IO_ERROR</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr>"unknown IO error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>BZ_UNEXPECTED_EOF</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_EOFError</name></expr></argument>,
					<argument><expr>"compressed file ended before the "
					"logical end-of-stream was detected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>BZ_SEQUENCE_ERROR</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
					<argument><expr>"wrong sequence of bz2 library "
					"commands used"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
			<break>break;</break>
	</case>}</block></switch>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BUFSIZ</name> &lt; 8192</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLCHUNK</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLCHUNK</name></cpp:macro> <cpp:value>BUFSIZ</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> &lt; 4</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGCHUNK</name></cpp:macro>  <cpp:value>(512 * 32)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGCHUNK</name></cpp:macro>  <cpp:value>(512 * 1024)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This is a hacked version of Python's fileobject.c:new_buffersize(). */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>Util_NewBufferSize</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>currentsize</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>currentsize</name> &gt; <name>SMALLCHUNK</name></expr>)</condition><then> <block>{
		<comment type="block">/* Keep doubling until we reach BIGCHUNK;
		   then keep adding BIGCHUNK. */</comment>
		<if>if <condition>(<expr><name>currentsize</name> &lt;= <name>BIGCHUNK</name></expr>)</condition><then>
			<return>return <expr><name>currentsize</name> + <name>currentsize</name></expr>;</return></then>
		<else>else
			<return>return <expr><name>currentsize</name> + <name>BIGCHUNK</name></expr>;</return></else></if>
	}</block></then></if>
	<return>return <expr><name>currentsize</name> + <name>SMALLCHUNK</name></expr>;</return>
}</block></function>

<comment type="block">/* This is a hacked version of Python's fileobject.c:get_line(). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Util_GetLine</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>total_v_size</name></decl>;</decl_stmt>	<comment type="block">/* total # of slots in buffer */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>used_v_size</name></decl>;</decl_stmt>	<comment type="block">/* # used slots in buffer */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>increment</name></decl>;</decl_stmt>       <comment type="block">/* amount to increment the buffer */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bytes_read</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>newlinetypes</name> <init>= <expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>skipnextlf</name> <init>= <expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>univ_newline</name> <init>= <expr><name><name>f</name>-&gt;<name>f_univ_newline</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>total_v_size</name> = <name>n</name> &gt; 0 ? <name>n</name> : 100</expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>total_v_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>buf</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> = <name>buf</name> + <name>total_v_size</name></expr>;</expr_stmt>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
		<while>while <condition>(<expr><name>buf</name> != <name>end</name></expr>)</condition> <block>{
			<expr_stmt><expr><name>bytes_read</name> = <call><name>BZ2_bzRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>f</name>-&gt;<name>pos</name></name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>bytes_read</name> == 0</expr>)</condition><then> <break>break;</break></then></if>
			<if>if <condition>(<expr><name>univ_newline</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>skipnextlf</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
					<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
						<comment type="block">/* Seeing a \n here with skipnextlf true means we
						 * saw a \r before.
						 */</comment>
						<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CRLF</name></expr>;</expr_stmt>
						<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <break>break;</break></then></if>
						<expr_stmt><expr><name>bytes_read</name> = <call><name>BZ2_bzRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>f</name>-&gt;<name>pos</name></name>++</expr>;</expr_stmt>
						<if>if <condition>(<expr><name>bytes_read</name> == 0</expr>)</condition><then> <break>break;</break></then></if>
					}</block></then> <else>else <block>{
						<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt>
					}</block></else></if>
				}</block></then></if>
				<if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>skipnextlf</name> = 1</expr>;</expr_stmt>
					<expr_stmt><expr><name>c</name> = '\n'</expr>;</expr_stmt>
				}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
					<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_LF</name></expr>;</expr_stmt></then></if></else></if>
			}</block></then></if>
			<expr_stmt><expr>*<name>buf</name>++ = <name>c</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name> || <name>c</name> == '\n'</expr>)</condition><then> <break>break;</break></then></if>
		}</block></while>
		<if>if <condition>(<expr><name>univ_newline</name> &amp;&amp; <name>bzerror</name> == <name>BZ_STREAM_END</name> &amp;&amp; <name>skipnextlf</name></expr>)</condition><then>
			<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if>
		<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
		<name><name>f</name>-&gt;<name>f_newlinetypes</name></name> <init>= <expr><name>newlinetypes</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name> = <name>skipnextlf</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>f</name>-&gt;<name>size</name></name> = <name><name>f</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>f</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if></else></if>
		<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
			<break>break;</break></then></if>
		<comment type="block">/* Must be because buf == end */</comment>
		<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><name>used_v_size</name> = <name>total_v_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>increment</name> = <name>total_v_size</name> &gt;&gt; 2</expr>;</expr_stmt> <comment type="block">/* mild exponential growth */</comment>
		<expr_stmt><expr><name>total_v_size</name> += <name>increment</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>total_v_size</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			    <argument><expr>"line is longer than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>total_v_size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>buf</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>used_v_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>total_v_size</name></expr>;</expr_stmt>
	}</block></for>

	<expr_stmt><expr><name>used_v_size</name> = <name>buf</name> - <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>used_v_size</name> != <name>total_v_size</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>used_v_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/* This is a hacked version of Python's
 * fileobject.c:Py_UniversalNewlineFread(). */</comment>
<function><type><name>size_t</name></type>
<name>Util_UnivNewlineRead</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>bzerror</name></decl></param>, <param><decl><type><name>BZFILE</name> *</type><name>stream</name></decl></param>,
		     <param><decl><type><name>char</name>*</type> <name>buf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>, <param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>dst</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>newlinetypes</name></decl>, <decl><type ref="prev"/><name>skipnextlf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stream</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<name><name>f</name>-&gt;<name>f_univ_newline</name></name></expr>)</condition><then>
		<return>return <expr><call><name>BZ2_bzRead</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><name>newlinetypes</name> = <name><name>f</name>-&gt;<name>f_newlinetypes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>skipnextlf</name> = <name><name>f</name>-&gt;<name>f_skipnextlf</name></name></expr>;</expr_stmt>

	<comment type="block">/* Invariant:  n is the number of bytes remaining to be filled
	 * in the buffer.
	 */</comment>
	<while>while <condition>(<expr><name>n</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>size_t</name></type> <name>nread</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>shortread</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>src</name> <init>= <expr><name>dst</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nread</name> = <call><name>BZ2_bzRead</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nread</name> &lt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> -= <name>nread</name></expr>;</expr_stmt> <comment type="block">/* assuming 1 byte out for each in; will adjust */</comment>
		<expr_stmt><expr><name>shortread</name> = <name>n</name> != 0</expr>;</expr_stmt>	<comment type="block">/* true iff EOF or error */</comment>
		<while>while <condition>(<expr><name>nread</name>--</expr>)</condition> <block>{
			<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then> <block>{
				<comment type="block">/* Save as LF and set flag to skip next LF. */</comment>
				<expr_stmt><expr>*<name>dst</name>++ = '\n'</expr>;</expr_stmt>
				<expr_stmt><expr><name>skipnextlf</name> = 1</expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>skipnextlf</name> &amp;&amp; <name>c</name> == '\n'</expr>)</condition><then> <block>{
				<comment type="block">/* Skip LF, and remember we saw CR LF. */</comment>
				<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CRLF</name></expr>;</expr_stmt>
				<expr_stmt><expr>++<name>n</name></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<comment type="block">/* Normal char to be stored in buffer.  Also
				 * update the newlinetypes flag if either this
				 * is an LF or the previous char was a CR.
				 */</comment>
				<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
					<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_LF</name></expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name>skipnextlf</name></expr>)</condition><then>
					<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if></else></if>
				<expr_stmt><expr>*<name>dst</name>++ = <name>c</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
			}</block></else></if></else></if>
		}</block></while>
		<if>if <condition>(<expr><name>shortread</name></expr>)</condition><then> <block>{
			<comment type="block">/* If this is EOF, update type flags. */</comment>
			<if>if <condition>(<expr><name>skipnextlf</name> &amp;&amp; *<name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then>
				<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if>
			<break>break;</break>
		}</block></then></if>
	}</block></while>
	<expr_stmt><expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name> = <name>newlinetypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name> = <name>skipnextlf</name></expr>;</expr_stmt>
	<return>return <expr><name>dst</name> - <name>buf</name></expr>;</return>
}</block></function>

<comment type="block">/* This is a hacked version of Python's fileobject.c:drop_readahead(). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Util_DropReadAhead</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name>-&gt;<name>f_buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<comment type="block">/* This is a hacked version of Python's fileobject.c:readahead(). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>Util_ReadAhead</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>chunksize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<if>if<condition>(<expr>(<name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name>) &gt;= 1</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then>
		<else>else
			<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>f</name>-&gt;<name>mode</name></name> == <name>MODE_READ_EOF</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufend</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>(<name><name>f</name>-&gt;<name>f_buf</name></name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>chunksize</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_buf</name></name></expr></argument>,
					 <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
	<name><name>f</name>-&gt;<name>pos</name></name> += <name>chunksize</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>f</name>-&gt;<name>size</name></name> = <name><name>f</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if></else></if>
	<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufend</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name> + <name>chunksize</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* This is a hacked version of Python's
 * fileobject.c:readahead_get_line_skip(). */</comment>
<function><type><specifier>static</specifier> <name>PyStringObject</name> *</type>
<name>Util_ReadAheadGetLineSkip</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>skip</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyStringObject</name>*</type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>bufptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> == <name>NULL</name></expr>)</condition><then>
		<if>if <condition>(<expr><call><name>Util_ReadAhead</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if></then></if>

	<expr_stmt><expr><name>len</name> = <name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
		<return>return <expr>(<name>PyStringObject</name> *)
			<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>bufptr</name> = <call><name>memchr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bufptr</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>bufptr</name>++</expr>;</expr_stmt>			<comment type="block">/* Count the '\n' */</comment>
		<expr_stmt><expr><name>len</name> = <name>bufptr</name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> = (<name>PyStringObject</name> *)
			<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>skip</name>+<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>+<name>skip</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name> = <name>bufptr</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bufptr</name> == <name><name>f</name>-&gt;<name>f_bufend</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>bufptr</name> = <name><name>f</name>-&gt;<name>f_bufptr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name>-&gt;<name>f_buf</name></name> = <name>NULL</name></expr>;</expr_stmt> 	<comment type="block">/* Force new readahead buffer */</comment>
                <expr_stmt><expr><name>s</name> = <call><name>Util_ReadAheadGetLineSkip</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>skip</name>+<name>len</name></expr></argument>,
					      <argument><expr><name>bufsize</name> + (<name>bufsize</name>&gt;&gt;2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
		        <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>+<name>skip</name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr><name>s</name></expr>;</return>
}</block></function>

<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Methods of BZ2File. */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_read__doc__</name></expr></argument>,
<argument><expr>"read([size]) -&gt; string\n\
\n\
Read at most size uncompressed bytes, returned as a string. If the size\n\
argument is negative or omitted, read until EOF is reached.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* This is a hacked version of Python's fileobject.c:file_read(). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_read</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>bytesrequested</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bytesread</name></decl>, <decl><type ref="prev"/><name>buffersize</name></decl>, <decl><type ref="prev"/><name>chunksize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|l:read"</expr></argument>, <argument><expr>&amp;<name>bytesrequested</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
		<case>case <expr><name>MODE_READ</name></expr>:
			<break>break;</break>
		</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
			<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</case><case>case <expr><name>MODE_CLOSED</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
					<argument><expr>"file is not ready for reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
	</default>}</block></switch>

	<if>if <condition>(<expr><name>bytesrequested</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>buffersize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr>(<name>size_t</name>)0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>buffersize</name> = <name>bytesrequested</name></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><name>buffersize</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"requested number of bytes is "
				"more than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>cleanup</name>;</goto></then></if>
	<expr_stmt><expr><name>bytesread</name> = 0</expr>;</expr_stmt>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>chunksize</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
						 <argument><expr><call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>+<name>bytesread</name></expr></argument>,
						 <argument><expr><name>buffersize</name>-<name>bytesread</name></expr></argument>,
						 <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>chunksize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
		<name>bytesread</name> += <name>chunksize</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		}</block></then></if></else></if>
		<if>if <condition>(<expr><name>bytesrequested</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>buffersize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<goto>goto <name>cleanup</name>;</goto></then></if>
		}</block></then> <else>else <block>{
			<break>break;</break>
		}</block></else></if>
	}</block></for>
	<if>if <condition>(<expr><name>bytesread</name> != <name>buffersize</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bytesread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_readline__doc__</name></expr></argument>,
<argument><expr>"readline([size]) -&gt; string\n\
\n\
Return the next line from the file, as a string, retaining newline.\n\
A non-negative size argument will limit the maximum number of bytes to\n\
return (an incomplete line may be returned then). Return an empty\n\
string at EOF.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_readline</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sizehint</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:readline"</expr></argument>, <argument><expr>&amp;<name>sizehint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
		<case>case <expr><name>MODE_READ</name></expr>:
			<break>break;</break>
		</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
			<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</case><case>case <expr><name>MODE_CLOSED</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
					<argument><expr>"file is not ready for reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
	</default>}</block></switch>

	<if>if <condition>(<expr><name>sizehint</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>ret</name> = <call><name>Util_GetLine</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>sizehint</name> &lt; 0) ? 0 : <name>sizehint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_readlines__doc__</name></expr></argument>,
<argument><expr>"readlines([size]) -&gt; list\n\
\n\
Call readline() repeatedly and return a list of lines read.\n\
The optional size argument, if given, is an approximate bound on the\n\
total number of bytes in the lines returned.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* This is a hacked version of Python's fileobject.c:file_readlines(). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_readlines</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>sizehint</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>small_buffer</name><index>[<expr><name>SMALLCHUNK</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> <init>= <expr><name>small_buffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>buffersize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>big_buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nfilled</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nread</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>totalread</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shortread</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|l:readlines"</expr></argument>, <argument><expr>&amp;<name>sizehint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
		<case>case <expr><name>MODE_READ</name></expr>:
			<break>break;</break>
		</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
			<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</case><case>case <expr><name>MODE_CLOSED</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
					<argument><expr>"file is not ready for reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
	</default>}</block></switch>

	<if>if <condition>(<expr>(<name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>cleanup</name>;</goto></then></if>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>nread</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
					     <argument><expr><name>buffer</name>+<name>nfilled</name></expr></argument>,
					     <argument><expr><name>buffersize</name>-<name>nfilled</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>nread</name></expr>;</expr_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>nread</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>sizehint</name> = 0</expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><name>shortread</name> = 1</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <label><name>error</name>:</label>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>list</name> = <name>NULL</name></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		}</block></then></if></else></if>
		<expr_stmt><expr><name>totalread</name> += <name>nread</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> = <call><name>memchr</name><argument_list>(<argument><expr><name>buffer</name>+<name>nfilled</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>shortread</name> &amp;&amp; <name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<comment type="block">/* Need a larger buffer to fit this line */</comment>
			<expr_stmt><expr><name>nfilled</name> += <name>nread</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>buffersize</name> *= 2</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>buffersize</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"line is longer than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			}</block></then></if>
			<if>if <condition>(<expr><name>big_buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<comment type="block">/* Create the big buffer */</comment>
				<expr_stmt><expr><name>big_buffer</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>big_buffer</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>error</name>;</goto></then></if>
				<expr_stmt><expr><name>buffer</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>big_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>small_buffer</name></expr></argument>, <argument><expr><name>nfilled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<comment type="block">/* Grow the big buffer */</comment>
				<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>big_buffer</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buffer</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>big_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<continue>continue;</continue>			
		}</block></then></if>
		<expr_stmt><expr><name>end</name> = <name>buffer</name>+<name>nfilled</name>+<name>nread</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>q</name> = <name>buffer</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition> <block>{
			<comment type="block">/* Process complete lines */</comment>
			<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
			<expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>p</name>-<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
			<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
			<expr_stmt><expr><name>q</name> = <name>p</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> = <call><name>memchr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>end</name>-<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<comment type="block">/* Move the remaining incomplete line to the start */</comment>
		<expr_stmt><expr><name>nfilled</name> = <name>end</name>-<name>q</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>nfilled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>sizehint</name> &gt; 0</expr>)</condition><then>
			<if>if <condition>(<expr><name>totalread</name> &gt;= (<name>size_t</name>)<name>sizehint</name></expr>)</condition><then>
				<break>break;</break></then></if></then></if>
		<if>if <condition>(<expr><name>shortread</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>sizehint</name> = 0</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>nfilled</name> != 0</expr>)</condition><then> <block>{
		<comment type="block">/* Partial last line */</comment>
		<expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nfilled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<if>if <condition>(<expr><name>sizehint</name> &gt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* Need to complete the last line */</comment>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>rest</name> <init>= <expr><call><name>Util_GetLine</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>rest</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyString_Concat</name><argument_list>(<argument><expr>&amp;<name>line</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></then></if>

  <label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>big_buffer</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>big_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>list</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_xreadlines__doc__</name></expr></argument>,
<argument><expr>"xreadlines() -&gt; self\n\
\n\
For backward compatibility. BZ2File objects now include the performance\n\
optimizations previously implemented in the xreadlines module.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_write__doc__</name></expr></argument>,
<argument><expr>"write(data) -&gt; None\n\
\n\
Write the 'data' string to file. Note that due to buffering, close() may\n\
be needed before the file on disk reflects the data written.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* This is a hacked version of Python's fileobject.c:file_write(). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_write</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*:write"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>buf</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
		<case>case <expr><name>MODE_WRITE</name></expr>:
			<break>break;</break>

		</case><case>case <expr><name>MODE_CLOSED</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>

		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
					<argument><expr>"file is not ready for writing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
	</default>}</block></switch>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>f_softspace</name></name> = 0</expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>BZ2_bzWrite</name> <argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>len</name></expr>;</expr_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <name>Py_None</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_writelines__doc__</name></expr></argument>,
<argument><expr>"writelines(sequence_of_strings) -&gt; None\n\
\n\
Write the sequence of strings to the file. Note that newlines are not\n\
added. The sequence can be any iterable object producing strings. This is\n\
equivalent to calling write() for each string.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* This is a hacked version of Python's fileobject.c:file_writelines(). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_writelines</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNKSIZE</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>index</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>islist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
		<case>case <expr><name>MODE_WRITE</name></expr>:
			<break>break;</break>

		</case><case>case <expr><name>MODE_CLOSED</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>

		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
					<argument><expr>"file is not ready for writing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
	</default>}</block></switch>

	<expr_stmt><expr><name>islist</name> = <call><name>PyList_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if  <condition>(<expr>!<name>islist</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>iter</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>iter</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"writelines() requires an iterable argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>CHUNKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
	}</block></then></if>

	<comment type="block">/* Strategy: slurp CHUNKSIZE lines into a private list,
	   checking that they are all strings, then write that list
	   without holding the interpreter lock, then come back for more. */</comment>
	<for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>index</name> += <name>CHUNKSIZE</name></expr></incr>) <block>{
		<if>if <condition>(<expr><name>islist</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>list</name> = <call><name>PyList_GetSlice</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name>+<name>CHUNKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
			<expr_stmt><expr><name>j</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>CHUNKSIZE</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name>line</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
						<goto>goto <name>error</name>;</goto></then></if>
					<break>break;</break>
				}</block></then></if>
				<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>
		}</block></else></if>
		<if>if <condition>(<expr><name>j</name> == 0</expr>)</condition><then>
			<break>break;</break></then></if>

		<comment type="block">/* Check that all entries are indeed strings. If not,
		   apply the same rules as for file.write() and
		   convert the rets to strings. This is slow, but
		   seems to be the only way since all conversion APIs
		   could potentially execute Python code. */</comment>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
			    	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
				<if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
							<argument><expr>"writelines() "
							"argument must be "
							"a sequence of "
							"strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error</name>;</goto>
				}</block></then></if>
				<expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
								  <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>error</name>;</goto></then></if>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>

		<expr_stmt><expr><name><name>self</name>-&gt;<name>f_softspace</name></name> = 0</expr>;</expr_stmt>

		<comment type="block">/* Since we are releasing the global lock, the
		   following code may *not* execute Python code. */</comment>
		<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		    	<expr_stmt><expr><name>line</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BZ2_bzWrite</name> <argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
				     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
				<function_decl><type><name>Py_BLOCK_THREADS</name></type>
				<name>Util_CatchBZ2Error</name><parameter_list>(<param><decl><type><name>bzerror</name></type></decl></param>)</parameter_list>;</function_decl>
				<goto>goto <name>error</name>;</goto>
			}</block></then></if>
		}</block></for>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>

		<if>if <condition>(<expr><name>j</name> &lt; <name>CHUNKSIZE</name></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <name>Py_None</name></expr>;</expr_stmt>

  <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHUNKSIZE</name></cpp:undef>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_seek__doc__</name></expr></argument>,
<argument><expr>"seek(offset [, whence]) -&gt; None\n\
\n\
Move to new file position. Argument offset is a byte count. Optional\n\
argument whence defaults to 0 (offset from start of file, offset\n\
should be &gt;= 0); other values are 1 (move relative to current position,\n\
positive or negative), and 2 (move relative to end of file, usually\n\
negative, although many platforms allow seeking beyond the end of a file).\n\
\n\
Note that seeking of bz2 files is emulated, and depending on the parameters\n\
the operation may be extremely slow.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_seek</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>where</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>offobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>small_buffer</name><index>[<expr><name>SMALLCHUNK</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> <init>= <expr><name>small_buffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>buffersize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_off_t</name></type> <name>bytesread</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>readsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>chunksize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|i:seek"</expr></argument>, <argument><expr>&amp;<name>offobj</name></expr></argument>, <argument><expr>&amp;<name>where</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>offset</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>offset</name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call> ?
		<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call> : <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
		<case>case <expr><name>MODE_READ</name></expr>:
		</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
			<break>break;</break>

		</case><case>case <expr><name>MODE_CLOSED</name></expr>:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>

		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
					<argument><expr>"seek works only while reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
	</default>}</block></switch>

	<if>if <condition>(<expr><name>where</name> == 2</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>self</name>-&gt;<name>size</name></name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>mode</name></name> != <name>MODE_READ_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
				<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
				<name>chunksize</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(
						<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
						<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>,
						<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>chunksize</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>

				<name>bytesread</name> += <name>chunksize</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
					<break>break;</break>
				}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>cleanup</name>;</goto>
				}</block></then></if></else></if>
			}</block></for>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bytesread</name> = 0</expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>offset</name> = <name><name>self</name>-&gt;<name>size</name></name> + <name>offset</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>where</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>offset</name> = <name><name>self</name>-&gt;<name>pos</name></name> + <name>offset</name></expr>;</expr_stmt>
	}</block></then></if></else></if>

	<comment type="block">/* Before getting here, offset must be the absolute position the file 
	 * pointer should be set to. */</comment>

	<if>if <condition>(<expr><name>offset</name> &gt;= <name><name>self</name>-&gt;<name>pos</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* we can move forward */</comment>
		<expr_stmt><expr><name>offset</name> -= <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<comment type="block">/* we cannot move back, so rewind the stream */</comment>
		<expr_stmt><expr><call><name>BZ2_bzReadClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fp</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyFile_DecUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name>ret</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"seek"</expr></argument>, <argument><expr>"(i)"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
			<goto>goto <name>cleanup</name>;</goto></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <call><name>BZ2_bzReadOpen</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fp</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyFile_IncUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ</name></expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><name>offset</name> &lt;= 0 || <name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_READ_EOF</name></expr>)</condition><then>
		<goto>goto <name>exit</name>;</goto></then></if>

	<comment type="block">/* Before getting here, offset must be set to the number of bytes
	 * to walk forward. */</comment>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<if>if <condition>(<expr><name>offset</name>-<name>bytesread</name> &gt; <name>buffersize</name></expr>)</condition><then>
			<expr_stmt><expr><name>readsize</name> = <name>buffersize</name></expr>;</expr_stmt></then>
		<else>else
			<comment type="block">/* offset might be wider that readsize, but the result
			 * of the subtraction is bound by buffersize (see the
			 * condition above). buffersize is 8192. */</comment>
			<expr_stmt><expr><name>readsize</name> = <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>offset</name>-<name>bytesread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>chunksize</name> <init>= <expr><call><name>Util_UnivNewlineRead</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
						 <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>readsize</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>chunksize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
		<name>bytesread</name> += <name>chunksize</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_READ_EOF</name></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		}</block></then></if></else></if>
		<if>if <condition>(<expr><name>bytesread</name> == <name>offset</name></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>

<label><name>exit</name>:</label>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <name>Py_None</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_tell__doc__</name></expr></argument>,
<argument><expr>"tell() -&gt; int\n\
\n\
Return the current file position, an integer (may be a long integer).\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_tell</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_CLOSED</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	}</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>ret</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>ret</name> = <call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>cleanup</name>:</label>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2File_close__doc__</name></expr></argument>,
<argument><expr>"close() -&gt; None or (perhaps) an integer\n\
\n\
Close the file. Sets data attribute .closed to true. A closed file\n\
cannot be used for further I/O operations. close() may be called more\n\
than once without error.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_close</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name> <init>= <expr><name>BZ_OK</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
		<case>case <expr><name>MODE_READ</name></expr>:
		</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
			<expr_stmt><expr><call><name>BZ2_bzReadClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>MODE_WRITE</name></expr>:
			<expr_stmt><expr><call><name>BZ2_bzWriteClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
					 <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</case>}</block></switch>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fp</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyFile_DecUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = <name>MODE_CLOSED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"close"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>BZ2File_getiter</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>BZ2File_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"read"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_read</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_read__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"readline"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_readline</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_readline__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"readlines"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_readlines</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_readlines__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"xreadlines"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_getiter</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_xreadlines__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"write"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_write</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_write__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"writelines"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_writelines</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>BZ2File_writelines__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"seek"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_seek</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2File_seek__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"tell"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_tell</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>BZ2File_tell__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2File_close</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>BZ2File_close__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Getters and setters of BZ2File. */</comment>

<comment type="block">/* This is a hacked version of Python's fileobject.c:get_newlines(). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_get_newlines</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>f_newlinetypes</name></name></expr>)</condition> <block>{
	<case>case <expr><name>NEWLINE_UNKNOWN</name></expr>:
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	</case><case>case <expr><name>NEWLINE_CR</name></expr>:
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"\r"</expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>NEWLINE_LF</name></expr>:
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>NEWLINE_CR</name>|<name>NEWLINE_LF</name></expr>:
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ss)"</expr></argument>, <argument><expr>"\r"</expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>NEWLINE_CRLF</name></expr>:
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>NEWLINE_CR</name>|<name>NEWLINE_CRLF</name></expr>:
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ss)"</expr></argument>, <argument><expr>"\r"</expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>NEWLINE_LF</name>|<name>NEWLINE_CRLF</name></expr>:
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ss)"</expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr><name>NEWLINE_CR</name>|<name>NEWLINE_LF</name>|<name>NEWLINE_CRLF</name></expr>:
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(sss)"</expr></argument>, <argument><expr>"\r"</expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>, 
			     <argument><expr>"Unknown newlines value 0x%x\n"</expr></argument>, 
			     <argument><expr><name><name>self</name>-&gt;<name>f_newlinetypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_get_closed</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_CLOSED</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_get_mode</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"mode"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_get_name</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"name"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>BZ2File_getset</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"closed"</expr>, <expr>(<name>getter</name>)<name>BZ2File_get_closed</name></expr>, <expr><name>NULL</name></expr>,
			<expr>"True if the file is closed"</expr>}</block></expr>,
	<expr><block>{<expr>"newlines"</expr>, <expr>(<name>getter</name>)<name>BZ2File_get_newlines</name></expr>, <expr><name>NULL</name></expr>, 
			<expr>"end-of-line convention used in this file"</expr>}</block></expr>,
	<expr><block>{<expr>"mode"</expr>, <expr>(<name>getter</name>)<name>BZ2File_get_mode</name></expr>, <expr><name>NULL</name></expr>,
			<expr>"file mode ('r', 'w', or 'U')"</expr>}</block></expr>,
	<expr><block>{<expr>"name"</expr>, <expr>(<name>getter</name>)<name>BZ2File_get_name</name></expr>, <expr><name>NULL</name></expr>,
			<expr>"file name"</expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>	<comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Members of BZ2File_Type. */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OFF</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(BZ2FileObject, x)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>BZ2File_members</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"softspace"</expr>,	<expr><name>T_INT</name></expr>,		<expr><call><name>OFF</name><argument_list>(<argument><expr><name>f_softspace</name></expr></argument>)</argument_list></call></expr>, <expr>0</expr>,
	 <expr>"flag indicating that a space needs to be printed; used by print"</expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>	<comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Slot definitions for BZ2File_Type. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>BZ2File_init</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"filename"</expr>, <expr>"mode"</expr>, <expr>"buffering"</expr>,
                                       <expr>"compresslevel"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>buffering</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>compresslevel</name> <init>= <expr>9</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mode_char</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = -1</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwargs</name></expr></argument>, <argument><expr>"O|sii:BZ2File"</expr></argument>,
					 <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>buffering</name></expr></argument>,
					 <argument><expr>&amp;<name>compresslevel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<if>if <condition>(<expr><name>compresslevel</name> &lt; 1 || <name>compresslevel</name> &gt; 9</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"compresslevel must be between 1 and 9"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr>*<name>mode</name></expr>)</condition> <block>{
			<case>case <expr>'r'</expr>:
			</case><case>case <expr>'w'</expr>:
				<if>if <condition>(<expr><name>mode_char</name></expr>)</condition><then>
					<expr_stmt><expr><name>error</name> = 1</expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>mode_char</name> = *<name>mode</name></expr>;</expr_stmt>
				<break>break;</break>

			</case><case>case <expr>'b'</expr>:
				<break>break;</break>

			</case><case>case <expr>'U'</expr>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
				<expr_stmt><expr><name><name>self</name>-&gt;<name>f_univ_newline</name></name> = 0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><name><name>self</name>-&gt;<name>f_univ_newline</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<break>break;</break>

			</case><default>default:
				<expr_stmt><expr><name>error</name> = 1</expr>;</expr_stmt>
				<break>break;</break>
		</default>}</block></switch>
		<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				     <argument><expr>"invalid mode char %c"</expr></argument>, <argument><expr>*<name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>mode</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>mode</name> == '\0'</expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>

	<if>if <condition>(<expr><name>mode_char</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>mode_char</name> = 'r'</expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>mode</name> = (<name>mode_char</name> == 'r') ? "rb" : "wb"</expr>;</expr_stmt>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>file</name></name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name>*)&amp;<name>PyFile_Type</name></expr></argument>, <argument><expr>"(Osi)"</expr></argument>,
					   <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>buffering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>file</name></name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<comment type="block">/* From now on, we have stuff to dealloc, so jump to error label
	 * instead of returning */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"unable to allocate lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>mode_char</name> == 'r'</expr>)</condition><then>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <call><name>BZ2_bzReadOpen</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>,
					  <argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <call><name>BZ2_bzWriteOpen</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>,
					   <argument><expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyFile_IncUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>mode</name></name> = (<name>mode_char</name> == 'r') ? <name>MODE_READ</name> : <name>MODE_WRITE</name></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>BZ2File_dealloc</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<switch>switch <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
		<case>case <expr><name>MODE_READ</name></expr>:
		</case><case>case <expr><name>MODE_READ_EOF</name></expr>:
			<expr_stmt><expr><call><name>BZ2_bzReadClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>MODE_WRITE</name></expr>:
			<expr_stmt><expr><call><name>BZ2_bzWriteClose</name><argument_list>(<argument><expr>&amp;<name>bzerror</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>fp</name></name></expr></argument>,
					 <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</case>}</block></switch>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>fp</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyFile_DecUseCount</name><argument_list>(<argument><expr>(<name>PyFileObject</name> *)<name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>fp</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Util_DropReadAhead</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* This is a hacked version of Python's fileobject.c:file_getiter(). */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_getiter</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_CLOSED</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>

<comment type="block">/* This is a hacked version of Python's fileobject.c:file_iternext(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READAHEAD_BUFSIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2File_iternext</name><parameter_list>(<param><decl><type><name>BZ2FileObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyStringObject</name>*</type> <name>ret</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>mode</name></name> == <name>MODE_CLOSED</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>ret</name> = <call><name>Util_ReadAheadGetLineSkip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>READAHEAD_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ret</name> == <name>NULL</name> || <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>ret</name></expr>;</return>
}</block></function>

<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* BZ2File_Type definition. */</comment>

<expr_stmt><expr><call><name>PyDoc_VAR</name><argument_list>(<argument><expr><name>BZ2File__doc__</name></expr></argument>)</argument_list></call> =
<macro><name>PyDoc_STR</name><argument_list>(
<argument>"BZ2File(name [, mode='r', buffering=0, compresslevel=9]) -&gt; file object\n\
\n\
Open a bz2 file. The mode can be 'r' or 'w', for reading (default) or\n\
writing. When opened for writing, the file will be created if it doesn't\n\
exist, and truncated otherwise. If the buffering argument is given, 0 means\n\
unbuffered, and larger numbers specify the buffer size. If compresslevel\n\
is given, must be a number between 1 and 9.\n\
"</argument>)</argument_list></macro>
<call><name>PyDoc_STR</name><argument_list>(
<argument><expr>"\n\
Add a 'U' to mode to open the file for input with universal newline\n\
support. Any line ending in the input file will be seen as a '\\n' in\n\
Python. Also, a file so opened gains the attribute 'newlines'; the value\n\
for this attribute is one of None (no newline read yet), '\\r', '\\n',\n\
'\\r\\n' or a tuple containing all the newline types seen. Universal\n\
newlines are available only when reading.\n\
"</expr></argument>)</argument_list></call></expr>
;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>BZ2File_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"bz2.BZ2File"</expr>,		<comment type="block">/*tp_name*/</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>BZ2FileObject</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/*tp_basicsize*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_itemsize*/</comment>
	<expr>(<name>destructor</name>)<name>BZ2File_dealloc</name></expr>, <comment type="block">/*tp_dealloc*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_print*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_getattr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_setattr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_compare*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_repr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_number*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_sequence*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_mapping*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_hash*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_call*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_str*/</comment>
        <expr><name>PyObject_GenericGetAttr</name></expr>,<comment type="block">/*tp_getattro*/</comment>
        <expr><name>PyObject_GenericSetAttr</name></expr>,<comment type="block">/*tp_setattro*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_as_buffer*/</comment>
        <expr><name>Py_TPFLAGS_DEFAULT</name>|<name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/*tp_flags*/</comment>
        <expr><name>BZ2File__doc__</name></expr>,         <comment type="block">/*tp_doc*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_traverse*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_clear*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_richcompare*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_weaklistoffset*/</comment>
        <expr>(<name>getiterfunc</name>)<name>BZ2File_getiter</name></expr>, <comment type="block">/*tp_iter*/</comment>
        <expr>(<name>iternextfunc</name>)<name>BZ2File_iternext</name></expr>, <comment type="block">/*tp_iternext*/</comment>
        <expr><name>BZ2File_methods</name></expr>,        <comment type="block">/*tp_methods*/</comment>
        <expr><name>BZ2File_members</name></expr>,        <comment type="block">/*tp_members*/</comment>
        <expr><name>BZ2File_getset</name></expr>,         <comment type="block">/*tp_getset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_base*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dict*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_get*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_set*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dictoffset*/</comment>
        <expr>(<name>initproc</name>)<name>BZ2File_init</name></expr>, <comment type="block">/*tp_init*/</comment>
        <expr><name>PyType_GenericAlloc</name></expr>,    <comment type="block">/*tp_alloc*/</comment>
        <expr><name>PyType_GenericNew</name></expr>,      <comment type="block">/*tp_new*/</comment>
      	<expr><name>_PyObject_Del</name></expr>,          <comment type="block">/*tp_free*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_is_gc*/</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Methods of BZ2Comp. */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Comp_compress__doc__</name></expr></argument>,
<argument><expr>"compress(data) -&gt; string\n\
\n\
Provide more data to the compressor object. It will return chunks of\n\
compressed data whenever possible. When you've finished providing data\n\
to compress, call the flush() method to finish the compression process,\n\
and return what is left in the internal buffers.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2Comp_compress</name><parameter_list>(<param><decl><type><name>BZ2CompObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>datasize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>totalout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*:compress"</expr></argument>, <argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>data</name> = <name><name>pdata</name>.<name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>datasize</name> = <name><name>pdata</name>.<name>len</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>datasize</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>running</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"this object was already flushed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_in</name></name> = <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> = <name>datasize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>totalout</name> = <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>bzerror</name> <init>= <expr><call><name>BZ2_bzCompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr><name>BZ_RUN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_RUN_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> == 0</expr>)</condition><then>
			<break>break;</break></then></if> <comment type="block">/* no more input data */</comment>
		<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + (<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call>
						    - <name>totalout</name>)</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

	<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call> - <name>totalout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Comp_flush__doc__</name></expr></argument>,
<argument><expr>"flush() -&gt; string\n\
\n\
Finish the compression process and return what is left in internal buffers.\n\
You must not use the compressor object after calling this method.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2Comp_flush</name><parameter_list>(<param><decl><type><name>BZ2CompObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>totalout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>running</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"object was already "
						  "flushed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>running</name></name> = 0</expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>totalout</name> = <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>bzerror</name> <init>= <expr><call><name>BZ2_bzCompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr><name>BZ_FINISH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
			<break>break;</break>
		}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_FINISH_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		}</block></then></if></else></if>
		<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + (<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call>
						    - <name>totalout</name>)</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

	<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call> - <name>totalout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>BZ2Comp_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"compress"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2Comp_compress</name></expr>, <expr><name>METH_VARARGS</name></expr>,
	 <expr><name>BZ2Comp_compress__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"flush"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2Comp_flush</name></expr>, <expr><name>METH_NOARGS</name></expr>,
	 <expr><name>BZ2Comp_flush__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Slot definitions for BZ2Comp_Type. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>BZ2Comp_init</name><parameter_list>(<param><decl><type><name>BZ2CompObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>compresslevel</name> <init>= <expr>9</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"compresslevel"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwargs</name></expr></argument>, <argument><expr>"|i:BZ2Compressor"</expr></argument>,
					 <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>compresslevel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<if>if <condition>(<expr><name>compresslevel</name> &lt; 1 || <name>compresslevel</name> &gt; 9</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"compresslevel must be between 1 and 9"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"unable to allocate lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bzerror</name> = <call><name>BZ2_bzCompressInit</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>running</name></name> = 1</expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>
<label><name>error</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>BZ2Comp_dealloc</name><parameter_list>(<param><decl><type><name>BZ2CompObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* BZ2Comp_Type definition. */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Comp__doc__</name></expr></argument>,
<argument><expr>"BZ2Compressor([compresslevel=9]) -&gt; compressor object\n\
\n\
Create a new compressor object. This object may be used to compress\n\
data sequentially. If you want to compress data in one shot, use the\n\
compress() function instead. The compresslevel parameter, if given,\n\
must be a number between 1 and 9.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>BZ2Comp_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"bz2.BZ2Compressor"</expr>,	<comment type="block">/*tp_name*/</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>BZ2CompObject</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/*tp_basicsize*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_itemsize*/</comment>
	<expr>(<name>destructor</name>)<name>BZ2Comp_dealloc</name></expr>, <comment type="block">/*tp_dealloc*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_print*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_getattr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_setattr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_compare*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_repr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_number*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_sequence*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_mapping*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_hash*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_call*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_str*/</comment>
        <expr><name>PyObject_GenericGetAttr</name></expr>,<comment type="block">/*tp_getattro*/</comment>
        <expr><name>PyObject_GenericSetAttr</name></expr>,<comment type="block">/*tp_setattro*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_as_buffer*/</comment>
        <expr><name>Py_TPFLAGS_DEFAULT</name>|<name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/*tp_flags*/</comment>
        <expr><name>BZ2Comp__doc__</name></expr>,         <comment type="block">/*tp_doc*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_traverse*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_clear*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_richcompare*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_weaklistoffset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_iter*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_iternext*/</comment>
        <expr><name>BZ2Comp_methods</name></expr>,        <comment type="block">/*tp_methods*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_members*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_getset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_base*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dict*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_get*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_set*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dictoffset*/</comment>
        <expr>(<name>initproc</name>)<name>BZ2Comp_init</name></expr>, <comment type="block">/*tp_init*/</comment>
        <expr><name>PyType_GenericAlloc</name></expr>,    <comment type="block">/*tp_alloc*/</comment>
        <expr><name>PyType_GenericNew</name></expr>,      <comment type="block">/*tp_new*/</comment>
      	<expr><name>_PyObject_Del</name></expr>,          <comment type="block">/*tp_free*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_is_gc*/</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Members of BZ2Decomp. */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OFF</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(BZ2DecompObject, x)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>BZ2Decomp_members</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"unused_data"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>unused_data</name></expr></argument>)</argument_list></call></expr>, <expr><name>RO</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>}</block></expr>	<comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Methods of BZ2Decomp. */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Decomp_decompress__doc__</name></expr></argument>,
<argument><expr>"decompress(data) -&gt; string\n\
\n\
Provide more data to the decompressor object. It will return chunks\n\
of decompressed data whenever possible. If you try to decompress data\n\
after the end of stream is found, EOFError will be raised. If any data\n\
was found after the end of stream, it'll be ignored and saved in\n\
unused_data attribute.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BZ2Decomp_decompress</name><parameter_list>(<param><decl><type><name>BZ2DecompObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>datasize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>totalout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*:decompress"</expr></argument>, <argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>data</name> = <name><name>pdata</name>.<name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>datasize</name> = <name><name>pdata</name>.<name>len</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ACQUIRE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>running</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_EOFError</name></expr></argument>, <argument><expr>"end of stream was "
						"already found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_in</name></name> = <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> = <name>datasize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>totalout</name> = <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>bzerror</name> <init>= <expr><call><name>BZ2_bzDecompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>unused_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>self</name>-&gt;<name>unused_data</name></name> =
				    <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>bzs</name>-&gt;<name>next_in</name></name></expr></argument>,
							       <argument><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>running</name></name> = 0</expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
		<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> == 0</expr>)</condition><then>
			<break>break;</break></then></if> <comment type="block">/* no more input data */</comment>
		<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			}</block></then></if>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + (<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call>
						    - <name>totalout</name>)</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

	<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call> - <name>totalout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>RELEASE_LOCK</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>BZ2Decomp_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"decompress"</expr>, <expr>(<name>PyCFunction</name>)<name>BZ2Decomp_decompress</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>BZ2Decomp_decompress__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Slot definitions for BZ2Decomp_Type. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>BZ2Decomp_init</name><parameter_list>(<param><decl><type><name>BZ2DecompObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>":BZ2Decompressor"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"unable to allocate lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>unused_data</name></name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>unused_data</name></name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bzerror</name> = <call><name>BZ2_bzDecompressInit</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>running</name></name> = 1</expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>

<label><name>error</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>lock</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>unused_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>BZ2Decomp_dealloc</name><parameter_list>(<param><decl><type><name>BZ2DecompObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock</name></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>unused_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>bzs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* BZ2Decomp_Type definition. */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>BZ2Decomp__doc__</name></expr></argument>,
<argument><expr>"BZ2Decompressor() -&gt; decompressor object\n\
\n\
Create a new decompressor object. This object may be used to decompress\n\
data sequentially. If you want to decompress data in one shot, use the\n\
decompress() function instead.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>BZ2Decomp_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"bz2.BZ2Decompressor"</expr>,	<comment type="block">/*tp_name*/</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>BZ2DecompObject</name></expr></argument>)</argument_list></sizeof></expr>, <comment type="block">/*tp_basicsize*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_itemsize*/</comment>
	<expr>(<name>destructor</name>)<name>BZ2Decomp_dealloc</name></expr>, <comment type="block">/*tp_dealloc*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_print*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_getattr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_setattr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_compare*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_repr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_number*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_sequence*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_mapping*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_hash*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_call*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_str*/</comment>
        <expr><name>PyObject_GenericGetAttr</name></expr>,<comment type="block">/*tp_getattro*/</comment>
        <expr><name>PyObject_GenericSetAttr</name></expr>,<comment type="block">/*tp_setattro*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_as_buffer*/</comment>
        <expr><name>Py_TPFLAGS_DEFAULT</name>|<name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/*tp_flags*/</comment>
        <expr><name>BZ2Decomp__doc__</name></expr>,       <comment type="block">/*tp_doc*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_traverse*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_clear*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_richcompare*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_weaklistoffset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_iter*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_iternext*/</comment>
        <expr><name>BZ2Decomp_methods</name></expr>,      <comment type="block">/*tp_methods*/</comment>
        <expr><name>BZ2Decomp_members</name></expr>,      <comment type="block">/*tp_members*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_getset*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_base*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dict*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_get*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_descr_set*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_dictoffset*/</comment>
        <expr>(<name>initproc</name>)<name>BZ2Decomp_init</name></expr>, <comment type="block">/*tp_init*/</comment>
        <expr><name>PyType_GenericAlloc</name></expr>,    <comment type="block">/*tp_alloc*/</comment>
        <expr><name>PyType_GenericNew</name></expr>,      <comment type="block">/*tp_new*/</comment>
      	<expr><name>_PyObject_Del</name></expr>,          <comment type="block">/*tp_free*/</comment>
        <expr>0</expr>,                      <comment type="block">/*tp_is_gc*/</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Module functions. */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bz2_compress__doc__</name></expr></argument>,
<argument><expr>"compress(data [, compresslevel=9]) -&gt; string\n\
\n\
Compress data in one shot. If you want to compress data sequentially,\n\
use an instance of BZ2Compressor instead. The compresslevel parameter, if\n\
given, must be a number between 1 and 9.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bz2_compress</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwargs</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>compresslevel</name><init>=<expr>9</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>datasize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bz_stream</name></type> <name>_bzs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name>_bzs</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"data"</expr>, <expr>"compresslevel"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwargs</name></expr></argument>, <argument><expr>"s*|i"</expr></argument>,
					 <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>pdata</name></expr></argument>,
					 <argument><expr>&amp;<name>compresslevel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>data</name> = <name><name>pdata</name>.<name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>datasize</name> = <name><name>pdata</name>.<name>len</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>compresslevel</name> &lt; 1 || <name>compresslevel</name> &gt; 9</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"compresslevel must be between 1 and 9"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Conforming to bz2 manual, this is large enough to fit compressed
	 * data in one shot. We will check it later anyway. */</comment>
	<expr_stmt><expr><name>bufsize</name> = <name>datasize</name> + (<name>datasize</name>/100+1) + 600</expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_in</name></name> = <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> = <name>datasize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>bzerror</name> = <call><name>BZ2_bzCompressInit</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>bzerror</name> <init>= <expr><call><name>BZ2_bzCompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr><name>BZ_FINISH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
			<break>break;</break>
		}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_FINISH_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if></else></if>
		<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

	<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr>(<name>Py_ssize_t</name>)<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>BZ2_bzCompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bz2_decompress__doc__</name></expr></argument>,
<argument><expr>"decompress(data) -&gt; decompressed data\n\
\n\
Decompress data in one shot. If you want to decompress data sequentially,\n\
use an instance of BZ2Decompressor instead.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bz2_decompress</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>datasize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bz_stream</name></type> <name>_bzs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bz_stream</name> *</type><name>bzs</name> <init>= <expr>&amp;<name>_bzs</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bzerror</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*:decompress"</expr></argument>, <argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>data</name> = <name><name>pdata</name>.<name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>datasize</name> = <name><name>pdata</name>.<name>len</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>datasize</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_in</name></name> = <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> = <name>datasize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>bzerror</name> = <call><name>BZ2_bzDecompressInit</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>bzerror</name> <init>= <expr><call><name>BZ2_bzDecompress</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>bzerror</name> == <name>BZ_STREAM_END</name></expr>)</condition><then> <block>{
			<break>break;</break>
		}</block></then> <else>else <if>if <condition>(<expr><name>bzerror</name> != <name>BZ_OK</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Util_CatchBZ2Error</name><argument_list>(<argument><expr><name>bzerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if></else></if>
		<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_in</name></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"couldn't find end of stream"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>bufsize</name> = <call><name>Util_NewBufferSize</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>next_out</name></name> = <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> + <call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> = <name>bufsize</name> - (<name><name>bzs</name>-&gt;<name>next_out</name></name> - <call><name>BUF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

	<if>if <condition>(<expr><name><name>bzs</name>-&gt;<name>avail_out</name></name> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>ret</name></expr></argument>, <argument><expr>(<name>Py_ssize_t</name>)<call><name>BZS_TOTAL_OUT</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><name>bzs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>bz2_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"compress"</expr>, <expr>(<name>PyCFunction</name>) <name>bz2_compress</name></expr>, <expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>,
		<expr><name>bz2_compress__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr>"decompress"</expr>, <expr>(<name>PyCFunction</name>) <name>bz2_decompress</name></expr>, <expr><name>METH_VARARGS</name></expr>,
		<expr><name>bz2_decompress__doc__</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ===================================================================== */</comment>
<comment type="block">/* Initialization function. */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bz2__doc__</name></expr></argument>,
<argument><expr>"The python bz2 module provides a comprehensive interface for\n\
the bz2 compression library. It implements a complete file\n\
interface, one shot (de)compression functions, and types for\n\
sequential (de)compression.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>initbz2</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>BZ2File_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>BZ2Comp_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>BZ2Decomp_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"bz2"</expr></argument>, <argument><expr><name>bz2_methods</name></expr></argument>, <argument><expr><name>bz2__doc__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"__author__"</expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>__author__</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>BZ2File_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BZ2File"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>BZ2File_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>BZ2Comp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BZ2Compressor"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>BZ2Comp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>BZ2Decomp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BZ2Decompressor"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>BZ2Decomp_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
