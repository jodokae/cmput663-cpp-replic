<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/shamodule.c"><comment type="block">/* SHA module */</comment>

<comment type="block">/* This module provides an interface to NIST's Secure Hash Algorithm */</comment>

<comment type="block">/* See below for information about the original code this module was
   based upon. Additional work performed by:

   Andrew Kuchling (amk@amk.ca)
   Greg Stein (gstein@lyra.org)

   Copyright (C) 2005   Gregory P. Smith (greg@krypto.org)
   Licensed to PSF under a Contributor Agreement.

*/</comment>

<comment type="block">/* SHA objects */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>


<comment type="block">/* Endianness testing and definitions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TestEndianness</name><parameter_list>(<param><type><name>variable</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{int i=1; variable=PCT_BIG_ENDIAN;\
	if (*((char*)&amp;i)==1) variable=PCT_LITTLE_ENDIAN;}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCT_LITTLE_ENDIAN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCT_BIG_ENDIAN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* Some useful types */</comment>

<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>SHA_BYTE</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> == 4</expr></cpp:if>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>SHA_INT32</name>;</typedef>	<comment type="block">/* 32-bit integer */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* not defined. compilation will die. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The SHA block size and message digest sizes, in bytes */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHA_BLOCKSIZE</name></cpp:macro>    <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHA_DIGESTSIZE</name></cpp:macro>  <cpp:value>20</cpp:value></cpp:define>

<comment type="block">/* The structure for storing SHS info */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>PyObject_HEAD</name>
    <name>SHA_INT32</name></type> <name><name>digest</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* Message digest */</comment>
    <decl_stmt><decl><type><name>SHA_INT32</name></type> <name>count_lo</name></decl>, <name>count_hi</name>;</decl_stmt>	<comment type="block">/* 64-bit bit count */</comment>
    <decl_stmt><decl><type><name>SHA_BYTE</name></type> <name><name>data</name><index>[<expr><name>SHA_BLOCKSIZE</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* SHA data buffer */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>Endianness</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>local</name></decl>;</decl_stmt>				<comment type="block">/* unprocessed amount in data */</comment>
}</block></struct></type> <name>SHAobject</name>;</typedef>

<comment type="block">/* When run on a little-endian CPU we need to perform byte reversal on an
   array of longwords. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>longReverse</name><parameter_list>(<param><decl><type><name>SHA_INT32</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>int</name></type> <name>byteCount</name></decl></param>, <param><decl><type><name>int</name></type> <name>Endianness</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SHA_INT32</name></type> <name>value</name></decl>;</decl_stmt>

    <if>if <condition>( <expr><name>Endianness</name> == <name>PCT_BIG_ENDIAN</name></expr> )</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><name>byteCount</name> /= <sizeof>sizeof<argument_list>(<argument><expr>*<name>buffer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>byteCount</name>--</expr>)</condition> <block>{
        <expr_stmt><expr><name>value</name> = *<name>buffer</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> = ( ( <name>value</name> &amp; 0xFF00FF00L ) &gt;&gt; 8  ) | \
                ( ( <name>value</name> &amp; 0x00FF00FFL ) &lt;&lt; 8 )</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>buffer</name>++ = ( <name>value</name> &lt;&lt; 16 ) | ( <name>value</name> &gt;&gt; 16 )</expr>;</expr_stmt>
    }</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>SHAcopy</name><parameter_list>(<param><decl><type><name>SHAobject</name> *</type><name>src</name></decl></param>, <param><decl><type><name>SHAobject</name> *</type><name>dest</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>dest</name>-&gt;<name>Endianness</name></name> = <name><name>src</name>-&gt;<name>Endianness</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name>-&gt;<name>local</name></name> = <name><name>src</name>-&gt;<name>local</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name>-&gt;<name>count_lo</name></name> = <name><name>src</name>-&gt;<name>count_lo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name>-&gt;<name>count_hi</name></name> = <name><name>src</name>-&gt;<name>count_hi</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name>-&gt;<name>digest</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>digest</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>src</name>-&gt;<name>digest</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 *
 * This code for the SHA algorithm was noted as public domain. The original
 * headers are pasted below.
 *
 * Several changes have been made to make it more compatible with the
 * Python environment and desired interface.
 *
 */</comment>

<comment type="block">/* NIST Secure Hash Algorithm */</comment>
<comment type="block">/* heavily modified by Uwe Hollerbach &lt;uh@alumni.caltech edu&gt; */</comment>
<comment type="block">/* from Peter C. Gutmann's implementation as found in */</comment>
<comment type="block">/* Applied Cryptography by Bruce Schneier */</comment>
<comment type="block">/* Further modifications to include the "UNRAVEL" stuff, below */</comment>

<comment type="block">/* This code is in the public domain */</comment>

<comment type="block">/* UNRAVEL should be fastest &amp; biggest */</comment>
<comment type="block">/* UNROLL_LOOPS should be just as big, but slightly slower */</comment>
<comment type="block">/* both undefined should be smallest and slowest */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNRAVEL</name></cpp:macro></cpp:define>
<comment type="block">/* #define UNROLL_LOOPS */</comment>

<comment type="block">/* The SHA f()-functions.  The f1 and f3 functions can be optimized to
   save one boolean operation each - thanks to Rich Schroeppel,
   rcs@cs.arizona.edu for discovering this */</comment>

<comment type="block">/*#define f1(x,y,z)	((x &amp; y) | (~x &amp; z))		// Rounds  0-19 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f1</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>,<param><type><name>z</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(z ^ (x &amp; (y ^ z)))</cpp:value></cpp:define>		<comment type="block">/* Rounds  0-19 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f2</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>,<param><type><name>z</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(x ^ y ^ z)</cpp:value></cpp:define>			<comment type="block">/* Rounds 20-39 */</comment>
<comment type="block">/*#define f3(x,y,z)	((x &amp; y) | (x &amp; z) | (y &amp; z))	// Rounds 40-59 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f3</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>,<param><type><name>z</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((x &amp; y) | (z &amp; (x | y)))</cpp:value></cpp:define>	<comment type="block">/* Rounds 40-59 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f4</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>,<param><type><name>z</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(x ^ y ^ z)</cpp:value></cpp:define>			<comment type="block">/* Rounds 60-79 */</comment>

<comment type="block">/* SHA constants */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONST1</name></cpp:macro>		<cpp:value>0x5a827999L</cpp:value></cpp:define>			<comment type="block">/* Rounds  0-19 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONST2</name></cpp:macro>		<cpp:value>0x6ed9eba1L</cpp:value></cpp:define>			<comment type="block">/* Rounds 20-39 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONST3</name></cpp:macro>		<cpp:value>0x8f1bbcdcL</cpp:value></cpp:define>			<comment type="block">/* Rounds 40-59 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONST4</name></cpp:macro>		<cpp:value>0xca62c1d6L</cpp:value></cpp:define>			<comment type="block">/* Rounds 60-79 */</comment>

<comment type="block">/* 32-bit rotate */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R32</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((x &lt;&lt; n) | (x &gt;&gt; (32 - n)))</cpp:value></cpp:define>

<comment type="block">/* the generic case, for when the overall rotation is not unraveled */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FG</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	\
    <cpp:value>T = R32(A,5) + f##n(B,C,D) + E + *WP++ + CONST##n;	\
    E = D; D = C; C = R32(B,30); B = A; A = T</cpp:value></cpp:define>

<comment type="block">/* specific cases, for when the overall rotation is unraveled */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FA</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	\
    <cpp:value>T = R32(A,5) + f##n(B,C,D) + E + *WP++ + CONST##n; B = R32(B,30)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FB</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	\
    <cpp:value>E = R32(T,5) + f##n(A,B,C) + D + *WP++ + CONST##n; A = R32(A,30)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FC</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	\
    <cpp:value>D = R32(E,5) + f##n(T,A,B) + C + *WP++ + CONST##n; T = R32(T,30)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	\
    <cpp:value>C = R32(D,5) + f##n(E,T,A) + B + *WP++ + CONST##n; E = R32(E,30)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	\
    <cpp:value>B = R32(C,5) + f##n(D,E,T) + A + *WP++ + CONST##n; D = R32(D,30)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FT</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>	\
    <cpp:value>A = R32(B,5) + f##n(C,D,E) + T + *WP++ + CONST##n; C = R32(C,30)</cpp:value></cpp:define>

<comment type="block">/* do SHA transformation */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sha_transform</name><parameter_list>(<param><decl><type><name>SHAobject</name> *</type><name>sha_info</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SHA_INT32</name></type> <name>T</name></decl>, <decl><type ref="prev"/><name>A</name></decl>, <decl><type ref="prev"/><name>B</name></decl>, <decl><type ref="prev"/><name>C</name></decl>, <decl><type ref="prev"/><name>D</name></decl>, <decl><type ref="prev"/><name>E</name></decl>, <decl><type ref="prev"/><name><name>W</name><index>[<expr>80</expr>]</index></name></decl>, *<decl><type ref="prev"/><name>WP</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>W</name></expr></argument>, <argument><expr><name><name>sha_info</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sha_info</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>longReverse</name><argument_list>(<argument><expr><name>W</name></expr></argument>, <argument><expr>(<name>int</name>)<sizeof>sizeof<argument_list>(<argument><expr><name><name>sha_info</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>sha_info</name>-&gt;<name>Endianness</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 16</expr>;</init> <condition><expr><name>i</name> &lt; 80</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	<expr_stmt><expr><name><name>W</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>W</name><index>[<expr><name>i</name>-3</expr>]</index></name> ^ <name><name>W</name><index>[<expr><name>i</name>-8</expr>]</index></name> ^ <name><name>W</name><index>[<expr><name>i</name>-14</expr>]</index></name> ^ <name><name>W</name><index>[<expr><name>i</name>-16</expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* extra rotation fix */</comment>
	<expr_stmt><expr><name><name>W</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>R32</name><argument_list>(<argument><expr><name><name>W</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>A</name> = <name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>B</name> = <name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>C</name> = <name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>D</name> = <name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>E</name> = <name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>4</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>WP</name> = <name>W</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNRAVEL</name></cpp:ifdef>
    <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FC</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FD</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FE</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FT</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FA</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FB</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>0</expr>]</index></name> += <name>E</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>1</expr>]</index></name> += <name>T</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>2</expr>]</index></name> += <name>A</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>3</expr>]</index></name> += <name>B</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>4</expr>]</index></name> += <name>C</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !UNRAVEL */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNROLL_LOOPS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !UNROLL_LOOPS */</comment>
    <for>for (<init><expr><name>i</name> =  0</expr>;</init> <condition><expr><name>i</name> &lt; 20</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{ <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></for>
    <for>for (<init><expr><name>i</name> = 20</expr>;</init> <condition><expr><name>i</name> &lt; 40</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{ <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></for>
    <for>for (<init><expr><name>i</name> = 40</expr>;</init> <condition><expr><name>i</name> &lt; 60</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{ <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></for>
    <for>for (<init><expr><name>i</name> = 60</expr>;</init> <condition><expr><name>i</name> &lt; 80</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{ <expr_stmt><expr><call><name>FG</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !UNROLL_LOOPS */</comment>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>0</expr>]</index></name> += <name>A</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>1</expr>]</index></name> += <name>B</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>2</expr>]</index></name> += <name>C</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>3</expr>]</index></name> += <name>D</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>4</expr>]</index></name> += <name>E</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !UNRAVEL */</comment>
}</block></function>

<comment type="block">/* initialize the SHA digest */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sha_init</name><parameter_list>(<param><decl><type><name>SHAobject</name> *</type><name>sha_info</name></decl></param>)</parameter_list>
<block>{
    <macro><name>TestEndianness</name><argument_list>(<argument>sha_info-&gt;Endianness</argument>)</argument_list></macro>

    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>0</expr>]</index></name> = 0x67452301L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>1</expr>]</index></name> = 0xefcdab89L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>2</expr>]</index></name> = 0x98badcfeL</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>3</expr>]</index></name> = 0x10325476L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>4</expr>]</index></name> = 0xc3d2e1f0L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>count_lo</name></name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>count_hi</name></name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>local</name></name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* update the SHA digest */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sha_update</name><parameter_list>(<param><decl><type><name>SHAobject</name> *</type><name>sha_info</name></decl></param>, <param><decl><type><name>SHA_BYTE</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SHA_INT32</name></type> <name>clo</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>clo</name> = <name><name>sha_info</name>-&gt;<name>count_lo</name></name> + ((<name>SHA_INT32</name>) <name>count</name> &lt;&lt; 3)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>clo</name> &lt; <name><name>sha_info</name>-&gt;<name>count_lo</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name><name>sha_info</name>-&gt;<name>count_hi</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>count_lo</name></name> = <name>clo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>count_hi</name></name> += (<name>SHA_INT32</name>) <name>count</name> &gt;&gt; 29</expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>sha_info</name>-&gt;<name>local</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>i</name> = <name>SHA_BLOCKSIZE</name> - <name><name>sha_info</name>-&gt;<name>local</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>i</name> &gt; <name>count</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>i</name> = <name>count</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>((<name>SHA_BYTE</name> *) <name><name>sha_info</name>-&gt;<name>data</name></name>) + <name><name>sha_info</name>-&gt;<name>local</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> -= <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buffer</name> += <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>local</name></name> += <name>i</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>sha_info</name>-&gt;<name>local</name></name> == <name>SHA_BLOCKSIZE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>sha_transform</name><argument_list>(<argument><expr><name>sha_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <return>return;</return>
        }</block></else></if>
    }</block></then></if>
    <while>while <condition>(<expr><name>count</name> &gt;= <name>SHA_BLOCKSIZE</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sha_info</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>SHA_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buffer</name> += <name>SHA_BLOCKSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> -= <name>SHA_BLOCKSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sha_transform</name><argument_list>(<argument><expr><name>sha_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sha_info</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>local</name></name> = <name>count</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* finish computing the SHA digest */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sha_final</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr>20</expr>]</index></name></decl></param>, <param><decl><type><name>SHAobject</name> *</type><name>sha_info</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SHA_INT32</name></type> <name>lo_bit_count</name></decl>, <decl><type ref="prev"/><name>hi_bit_count</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>lo_bit_count</name> = <name><name>sha_info</name>-&gt;<name>count_lo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hi_bit_count</name> = <name><name>sha_info</name>-&gt;<name>count_hi</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>count</name> = <call>(<name>int</name>) <argument_list>(<argument><expr>(<name>lo_bit_count</name> &gt;&gt; 3) &amp; 0x3f</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>((<name>SHA_BYTE</name> *) <name><name>sha_info</name>-&gt;<name>data</name></name>)<index>[<expr><name>count</name>++</expr>]</index> = 0x80</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>count</name> &gt; <name>SHA_BLOCKSIZE</name> - 8</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>((<name>SHA_BYTE</name> *) <name><name>sha_info</name>-&gt;<name>data</name></name>) + <name>count</name></expr></argument>, <argument><expr>0</expr></argument>,
	       <argument><expr><name>SHA_BLOCKSIZE</name> - <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sha_transform</name><argument_list>(<argument><expr><name>sha_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>SHA_BYTE</name> *) <name><name>sha_info</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SHA_BLOCKSIZE</name> - 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>((<name>SHA_BYTE</name> *) <name><name>sha_info</name>-&gt;<name>data</name></name>) + <name>count</name></expr></argument>, <argument><expr>0</expr></argument>,
	       <argument><expr><name>SHA_BLOCKSIZE</name> - 8 - <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* GJS: note that we add the hi/lo in big-endian. sha_transform will
       swap these values into host-order. */</comment>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>data</name><index>[<expr>56</expr>]</index></name> = (<name>hi_bit_count</name> &gt;&gt; 24) &amp; 0xff</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>data</name><index>[<expr>57</expr>]</index></name> = (<name>hi_bit_count</name> &gt;&gt; 16) &amp; 0xff</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>data</name><index>[<expr>58</expr>]</index></name> = (<name>hi_bit_count</name> &gt;&gt;  8) &amp; 0xff</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>data</name><index>[<expr>59</expr>]</index></name> = (<name>hi_bit_count</name> &gt;&gt;  0) &amp; 0xff</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>data</name><index>[<expr>60</expr>]</index></name> = (<name>lo_bit_count</name> &gt;&gt; 24) &amp; 0xff</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>data</name><index>[<expr>61</expr>]</index></name> = (<name>lo_bit_count</name> &gt;&gt; 16) &amp; 0xff</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>data</name><index>[<expr>62</expr>]</index></name> = (<name>lo_bit_count</name> &gt;&gt;  8) &amp; 0xff</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sha_info</name>-&gt;<name>data</name><index>[<expr>63</expr>]</index></name> = (<name>lo_bit_count</name> &gt;&gt;  0) &amp; 0xff</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sha_transform</name><argument_list>(<argument><expr><name>sha_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>0</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>1</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>2</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>0</expr>]</index></name> &gt;&gt;  8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>3</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>0</expr>]</index></name>      ) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>4</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>1</expr>]</index></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>5</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>1</expr>]</index></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>6</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>1</expr>]</index></name> &gt;&gt;  8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>7</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>1</expr>]</index></name>      ) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>8</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>2</expr>]</index></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[ <expr>9</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>2</expr>]</index></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>10</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>2</expr>]</index></name> &gt;&gt;  8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>11</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>2</expr>]</index></name>      ) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>12</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>3</expr>]</index></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>13</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>3</expr>]</index></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>14</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>3</expr>]</index></name> &gt;&gt;  8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>15</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>3</expr>]</index></name>      ) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>16</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>4</expr>]</index></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>17</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>4</expr>]</index></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>18</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>4</expr>]</index></name> &gt;&gt;  8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>digest</name><index>[<expr>19</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>) <argument_list>(<argument><expr>(<name><name>sha_info</name>-&gt;<name>digest</name><index>[<expr>4</expr>]</index></name>      ) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * End of copied SHA code.
 *
 * ------------------------------------------------------------------------
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>SHAtype</name></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>SHAobject</name> *</type>
<name>newSHAobject</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<name>SHAobject</name> *)<call><name>PyObject_New</name><argument_list>(<argument><expr><name>SHAobject</name></expr></argument>, <argument><expr>&amp;<name>SHAtype</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Internal methods for a hashing object */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SHA_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* External methods for a hashing object */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>SHA_copy__doc__</name></expr></argument>, <argument><expr>"Return a copy of the hashing object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SHA_copy</name><parameter_list>(<param><decl><type><name>SHAobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SHAobject</name> *</type><name>newobj</name></decl>;</decl_stmt>

    <if>if <condition>( <expr>(<name>newobj</name> = <call><name>newSHAobject</name><argument_list>()</argument_list></call>)==<name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>SHAcopy</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>PyObject</name> *)<name>newobj</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>SHA_digest__doc__</name></expr></argument>,
<argument><expr>"Return the digest value as a string of binary data."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SHA_digest</name><parameter_list>(<param><decl><type><name>SHAobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>SHA_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SHAobject</name></type> <name>temp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SHAcopy</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sha_final</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>digest</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>digest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>SHA_hexdigest__doc__</name></expr></argument>,
<argument><expr>"Return the digest value as a string of hexadecimal digits."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SHA_hexdigest</name><parameter_list>(<param><decl><type><name>SHAobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>SHA_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SHAobject</name></type> <name>temp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>hex_digest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Get the raw (binary) digest value */</comment>
    <expr_stmt><expr><call><name>SHAcopy</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sha_final</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create a new string */</comment>
    <expr_stmt><expr><name>retval</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>digest</name></expr></argument>)</argument_list></sizeof> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>retval</name></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>hex_digest</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>hex_digest</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Make hex version of the digest */</comment>
    <for>for(<init><expr><name>i</name>=<name>j</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<sizeof>sizeof<argument_list>(<argument><expr><name>digest</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>c</name> = (<name><name>digest</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 4) &amp; 0xf</expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> = (<name>c</name>&gt;9) ? <name>c</name>+'a'-10 : <name>c</name> + '0'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hex_digest</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = (<name><name>digest</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xf)</expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> = (<name>c</name>&gt;9) ? <name>c</name>+'a'-10 : <name>c</name> + '0'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hex_digest</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>SHA_update__doc__</name></expr></argument>,
<argument><expr>"Update this hashing object's state with the provided string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SHA_update</name><parameter_list>(<param><decl><type><name>SHAobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:update"</expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>sha_update</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>SHA_methods</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"copy"</expr>,	  <expr>(<name>PyCFunction</name>)<name>SHA_copy</name></expr>,      <expr><name>METH_NOARGS</name></expr>,  <expr><name>SHA_copy__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"digest"</expr>,	  <expr>(<name>PyCFunction</name>)<name>SHA_digest</name></expr>,    <expr><name>METH_NOARGS</name></expr>,  <expr><name>SHA_digest__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"hexdigest"</expr>, <expr>(<name>PyCFunction</name>)<name>SHA_hexdigest</name></expr>, <expr><name>METH_NOARGS</name></expr>,  <expr><name>SHA_hexdigest__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"update"</expr>,	  <expr>(<name>PyCFunction</name>)<name>SHA_update</name></expr>,    <expr><name>METH_VARARGS</name></expr>, <expr><name>SHA_update__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>,	  <expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SHA_get_block_size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>SHA_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SHA_get_digest_size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>SHA_DIGESTSIZE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SHA_get_name</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>"SHA1"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>SHA_getseters</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"digest_size"</expr>,
     <expr>(<name>getter</name>)<name>SHA_get_digest_size</name></expr>, <expr><name>NULL</name></expr>,
     <expr><name>NULL</name></expr>,
     <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr>"block_size"</expr>,
     <expr>(<name>getter</name>)<name>SHA_get_block_size</name></expr>, <expr><name>NULL</name></expr>,
     <expr><name>NULL</name></expr>,
     <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr>"name"</expr>,
     <expr>(<name>getter</name>)<name>SHA_get_name</name></expr>, <expr><name>NULL</name></expr>,
     <expr><name>NULL</name></expr>,
     <expr><name>NULL</name></expr>}</block></expr>,
    <comment type="block">/* the old md5 and sha modules support 'digest_size' as in PEP 247.
     * the old sha module also supported 'digestsize'.  ugh. */</comment>
    <expr><block>{<expr>"digestsize"</expr>,
     <expr>(<name>getter</name>)<name>SHA_get_digest_size</name></expr>, <expr><name>NULL</name></expr>,
     <expr><name>NULL</name></expr>,
     <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>  <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>SHAtype</name> <init>= <expr><block>{
    <expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
    "_sha.sha"</expr>,		<comment type="block">/*tp_name*/</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SHAobject</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/*tp_size*/</comment>
    <expr>0</expr>,			<comment type="block">/*tp_itemsize*/</comment>
    <comment type="block">/* methods */</comment>
    <expr><name>SHA_dealloc</name></expr>,	<comment type="block">/*tp_dealloc*/</comment>
    <expr>0</expr>,			<comment type="block">/*tp_print*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_getattr*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_setattr*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_compare*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_repr*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_as_number*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_as_sequence*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_as_mapping*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_hash*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_call*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_str*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_getattro*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_setattro*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_as_buffer*/</comment>
    <expr><name>Py_TPFLAGS_DEFAULT</name></expr>, <comment type="block">/*tp_flags*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_doc*/</comment>
    <expr>0</expr>,                  <comment type="block">/*tp_traverse*/</comment>
    <expr>0</expr>,			<comment type="block">/*tp_clear*/</comment>
    <expr>0</expr>,			<comment type="block">/*tp_richcompare*/</comment>
    <expr>0</expr>,			<comment type="block">/*tp_weaklistoffset*/</comment>
    <expr>0</expr>,			<comment type="block">/*tp_iter*/</comment>
    <expr>0</expr>,			<comment type="block">/*tp_iternext*/</comment>
    <expr><name>SHA_methods</name></expr>,	<comment type="block">/* tp_methods */</comment>
    <expr>0</expr>,                  <comment type="block">/* tp_members */</comment>
    <expr><name>SHA_getseters</name></expr>,      <comment type="block">/* tp_getset */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* The single module-level function: new() */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>SHA_new__doc__</name></expr></argument>,
<argument><expr>"Return a new SHA hashing object.  An optional string argument\n\
may be provided; if present, this string will be automatically\n\
hashed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SHA_new</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwdict</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"string"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SHAobject</name> *</type><name>new</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>cp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwdict</name></expr></argument>, <argument><expr>"|s#:new"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
                                     <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>new</name> = <call><name>newSHAobject</name><argument_list>()</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>sha_init</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>cp</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>sha_update</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>PyObject</name> *)<name>new</name></expr>;</return>
}</block></function>


<comment type="block">/* List of functions exported by this module */</comment>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>SHA_functions</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"new"</expr>, <expr>(<name>PyCFunction</name>)<name>SHA_new</name></expr>, <expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>SHA_new__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>,	<expr><name>NULL</name></expr>}</block></expr>		 <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Initialize this module. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>insint</name><parameter_list>(<param><type><name>n</name></type></param>,<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ PyModule_AddIntConstant(m,n,v); }</cpp:value></cpp:define>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_sha</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>SHAtype</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>SHAtype</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><name>m</name> = <call><name>Py_InitModule</name><argument_list>(<argument><expr>"_sha"</expr></argument>, <argument><expr><name>SHA_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <comment type="block">/* Add some symbolic constants to the module */</comment>
    <expr_stmt><expr><call><name>insint</name><argument_list>(<argument><expr>"blocksize"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For future use, in case some hash
                                functions require an integral number of
                                blocks */</comment> 
    <expr_stmt><expr><call><name>insint</name><argument_list>(<argument><expr>"digestsize"</expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>insint</name><argument_list>(<argument><expr>"digest_size"</expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
