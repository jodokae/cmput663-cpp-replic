<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/pyexpat.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"frameobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"expat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyexpat.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_COMBINED_VERSION</name></cpp:macro> <cpp:value>(10000*XML_MAJOR_VERSION+100*XML_MINOR_VERSION+XML_MICRO_VERSION)</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyDoc_STRVAR</name></cpp:ifndef>

<comment type="block">/*
 * fdrake says:
 * Don't change the PyDoc_STR macro definition to (str), because
 * '''the parentheses cause compile failures
 * ("non-constant static initializer" or something like that)
 * on some platforms (Irix?)'''
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDoc_STR</name><parameter_list>(<param><type><name>str</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>str</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDoc_VAR</name><parameter_list>(<param><type><name>name</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>static char name[]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDoc_STRVAR</name><parameter_list>(<param><type><name>name</name></type></param>,<param><type><name>str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyDoc_VAR(name) = PyDoc_STR(str)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_MAJOR_VERSION</name> == 2 &amp;&amp; <name>PY_MINOR_VERSION</name> &lt; 2)</expr></cpp:if>
<comment type="block">/* In Python 2.0 and  2.1, disabling Unicode was not possible. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_USING_UNICODE</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIX_TRACE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum <name>HandlerTypes</name> <block>{
    <decl><name>StartElement</name></decl>,
    <decl><name>EndElement</name></decl>,
    <decl><name>ProcessingInstruction</name></decl>,
    <decl><name>CharacterData</name></decl>,
    <decl><name>UnparsedEntityDecl</name></decl>,
    <decl><name>NotationDecl</name></decl>,
    <decl><name>StartNamespaceDecl</name></decl>,
    <decl><name>EndNamespaceDecl</name></decl>,
    <decl><name>Comment</name></decl>,
    <decl><name>StartCdataSection</name></decl>,
    <decl><name>EndCdataSection</name></decl>,
    <decl><name>Default</name></decl>,
    <decl><name>DefaultHandlerExpand</name></decl>,
    <decl><name>NotStandalone</name></decl>,
    <decl><name>ExternalEntityRef</name></decl>,
    <decl><name>StartDoctypeDecl</name></decl>,
    <decl><name>EndDoctypeDecl</name></decl>,
    <decl><name>EntityDecl</name></decl>,
    <decl><name>XmlDecl</name></decl>,
    <decl><name>ElementDecl</name></decl>,
    <decl><name>AttlistDecl</name></decl>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XML_COMBINED_VERSION</name> &gt;= 19504</expr></cpp:if>
    <decl><name>SkippedEntity</name></decl>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl><name>_DummyDecl</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>ErrorObject</name></decl>;</decl_stmt>

<comment type="block">/* ----------------------------------------------------- */</comment>

<comment type="block">/* Declarations for objects of type xmlparser */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>PyObject_HEAD</name>

    <name>XML_Parser</name></type> <name>itself</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>returns_unicode</name></decl>;</decl_stmt>        <comment type="block">/* True if Unicode strings are returned;
                                   if false, UTF-8 strings are returned */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ordered_attributes</name></decl>;</decl_stmt>     <comment type="block">/* Return attributes as a list. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>specified_attributes</name></decl>;</decl_stmt>   <comment type="block">/* Report only specified attributes. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>in_callback</name></decl>;</decl_stmt>            <comment type="block">/* Is a callback active? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ns_prefixes</name></decl>;</decl_stmt>            <comment type="block">/* Namespace-triplets mode? */</comment>
    <decl_stmt><decl><type><name>XML_Char</name> *</type><name>buffer</name></decl>;</decl_stmt>           <comment type="block">/* Buffer used when accumulating characters */</comment>
                                <comment type="block">/* NULL if not enabled */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>buffer_size</name></decl>;</decl_stmt>            <comment type="block">/* Size of buffer, in XML_Char units */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>buffer_used</name></decl>;</decl_stmt>            <comment type="block">/* Buffer units in use */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>intern</name></decl>;</decl_stmt>           <comment type="block">/* Dictionary to intern strings */</comment>
    <decl_stmt><decl><type><name>PyObject</name> **</type><name>handlers</name></decl>;</decl_stmt>
}</block></struct></type> <name>xmlparseobject</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARACTER_DATA_BUFFER_SIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Xmlparsetype</name></decl>;</decl_stmt>

<typedef>typedef <function_decl><type><name>void</name></type> (*<name>xmlhandlersetter</name>)<parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>meth</name></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <type><name>void</name>*</type> <name>xmlhandler</name>;</typedef>

<struct>struct <name>HandlerInfo</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xmlhandlersetter</name></type> <name>setter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xmlhandler</name></type> <name>handler</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>tb_code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>nameobj</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>HandlerInfo</name></type> <name><name>handler_info</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* Set an integer attribute on the error object; return true on success,
 * false on an exception.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_error_attr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>err</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Build and set an Expat exception, including positioning
 * information.  Always returns NULL.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_error</name><argument_list>(<argument><expr><name>xmlparseobject</name> *<name>self</name></expr></argument>, <argument>enum <expr><name>XML_Error</name> <name>code</name></expr></argument>)</argument_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><name><name>self</name>-&gt;<name>itself</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr><call><name>XML_GetErrorLineNumber</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>column</name> <init>= <expr><call><name>XML_GetErrorColumnNumber</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* There is no risk of overflowing this buffer, since
       even for 64-bit integers, there is sufficient space. */</comment>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"%.200s: line %i, column %i"</expr></argument>,
            <argument><expr><call><name>XML_ErrorString</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>err</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>ErrorObject</name></expr></argument>, <argument><expr>"s"</expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(  <expr><name>err</name> != <name>NULL</name>
          &amp;&amp; <call><name>set_error_attr</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr>"code"</expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call>
          &amp;&amp; <call><name>set_error_attr</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr>"offset"</expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call>
          &amp;&amp; <call><name>set_error_attr</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr>"lineno"</expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>ErrorObject</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>have_handler</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>handler</name> <init>= <expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>type</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>handler</name> != <name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_handler_name</name><parameter_list>(<param><decl><type>struct <name>HandlerInfo</name> *</type><name>hinfo</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name><name>hinfo</name>-&gt;<name>nameobj</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>name</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>hinfo</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hinfo</name>-&gt;<name>nameobj</name></name> = <name>name</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>name</name></expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<comment type="block">/* Convert a string of XML_Chars into a Unicode string.
   Returns None if str is a null pointer. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>conv_string_to_unicode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* XXX currently this code assumes that XML_Char is 8-bit,
       and hence in UTF-8.  */</comment>
    <comment type="block">/* UTF-8 from Expat, Unicode desired */</comment>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Py_None</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>conv_string_len_to_unicode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* XXX currently this code assumes that XML_Char is 8-bit,
       and hence in UTF-8.  */</comment>
    <comment type="block">/* UTF-8 from Expat, Unicode desired */</comment>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Py_None</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Convert a string of XML_Chars into an 8-bit Python string.
   Returns None if str is a null pointer. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>conv_string_to_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* XXX currently this code assumes that XML_Char is 8-bit,
       and hence in UTF-8.  */</comment>
    <comment type="block">/* UTF-8 from Expat, UTF-8 desired */</comment>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Py_None</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>conv_string_len_to_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* XXX currently this code assumes that XML_Char is 8-bit,
       and hence in UTF-8.  */</comment>
    <comment type="block">/* UTF-8 from Expat, UTF-8 desired */</comment>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Py_None</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Callback routines */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clear_handlers</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>initial</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* This handler is used when an error has been detected, in the hope
   that actual parsing can be terminated early.  This will only help
   if an external entity reference is encountered. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>error_external_entity_ref_handler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>context</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>base</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>systemId</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>publicId</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Dummy character data handler used when an error (exception) has
   been detected, and the actual parsing can be terminated early.
   This is needed since character data handler can't be safely removed
   from within the character data handler, but can be replaced.  It is
   used only from the character data handler trampoline, and must be
   used right after `flag_error()` is called. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>noop_character_data_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list> 
<block>{
    <comment type="block">/* Do nothing. */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flag_error</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>clear_handlers</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>,
                                    <argument><expr><name>error_external_entity_ref_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyCodeObject</name>*</type>
<name>getcode</name><argument_list>(<argument>enum <expr><name>HandlerTypes</name> <name>slot</name></expr></argument>, <argument><expr><name>char</name>* <name>func_name</name></expr></argument>, <argument><expr><name>int</name> <name>lineno</name></expr></argument>)</argument_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>code</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>nulltuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>handler_info</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>tb_code</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>code</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>code</name> == <name>NULL</name></expr>)</condition><then>
            <goto>goto <name>failed</name>;</goto></then></if>
        <expr_stmt><expr><name>name</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
            <goto>goto <name>failed</name>;</goto></then></if>
        <expr_stmt><expr><name>nulltuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nulltuple</name> == <name>NULL</name></expr>)</condition><then>
            <goto>goto <name>failed</name>;</goto></then></if>
        <expr_stmt><expr><name>filename</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handler_info</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>tb_code</name> =
            <call><name>PyCode_New</name><argument_list>(<argument><expr>0</expr></argument>,		<comment type="block">/* argcount */</comment>
                       <argument><expr>0</expr></argument>,		<comment type="block">/* nlocals */</comment>
                       <argument><expr>0</expr></argument>,		<comment type="block">/* stacksize */</comment>
                       <argument><expr>0</expr></argument>,		<comment type="block">/* flags */</comment>
                       <argument><expr><name>code</name></expr></argument>,		<comment type="block">/* code */</comment>
                       <argument><expr><name>nulltuple</name></expr></argument>,	<comment type="block">/* consts */</comment>
                       <argument><expr><name>nulltuple</name></expr></argument>,	<comment type="block">/* names */</comment>
                       <argument><expr><name>nulltuple</name></expr></argument>,	<comment type="block">/* varnames */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PYTHON_API_VERSION</name> &gt;= 1010</expr></cpp:if>
                       <argument><expr><name>nulltuple</name></expr></argument>,	<comment type="block">/* freevars */</comment>
                       <argument><expr><name>nulltuple</name></expr></argument>,	<comment type="block">/* cellvars */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                       <argument><expr><name>filename</name></expr></argument>,	<comment type="block">/* filename */</comment>
                       <argument><expr><name>name</name></expr></argument>,		<comment type="block">/* name */</comment>
                       <argument><expr><name>lineno</name></expr></argument>,		<comment type="block">/* firstlineno */</comment>
                       <argument><expr><name>code</name></expr></argument>		<comment type="block">/* lnotab */</comment>
                       )</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>handler_info</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>tb_code</name> == <name>NULL</name></expr>)</condition><then>
            <goto>goto <name>failed</name>;</goto></then></if>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>nulltuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name><name>handler_info</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>tb_code</name></expr>;</return>
 <label><name>failed</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></decl></decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FIX_TRACE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>trace_frame</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>code</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name><name>tstate</name>-&gt;<name>use_tracing</name></name> || <name><name>tstate</name>-&gt;<name>tracing</name></name></expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tracing</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name><name>tstate</name>-&gt;<name>c_profilefunc</name></name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_profileobj</name></name></expr></argument>,
				       <argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name></expr></argument> , <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = ((<name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name>)
			       || (<name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> != <name>NULL</name>))</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tracing</name></name>--</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
	    <return>return <expr><name>result</name></expr>;</return></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tracing</name></name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>c_traceobj</name></name></expr></argument>,
				     <argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name></expr></argument> , <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>use_tracing</name></name> = ((<name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> != <name>NULL</name>)
			       || (<name><name>tstate</name>-&gt;<name>c_profilefunc</name></name> != <name>NULL</name>))</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tstate</name>-&gt;<name>tracing</name></name>--</expr>;</expr_stmt>
    }</block></then></if>	
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>trace_frame_exc</name><parameter_list>(<param><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>type</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>traceback</name></decl>, *<decl><type ref="prev"/><name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>c_tracefunc</name></name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>&amp;<name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>value</name> = <name>Py_None</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> &lt; 0x02040000</expr></cpp:if>
    <expr_stmt><expr><name>arg</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(OOO)"</expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>arg</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>err</name> = <call><name>trace_frame</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>PyTrace_EXCEPTION</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>traceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>err</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>call_with_frame</name><parameter_list>(<param><decl><type><name>PyCodeObject</name> *</type><name>c</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>func</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>,
                <param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyFrameObject</name> *</type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>c</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    
    <expr_stmt><expr><name>f</name> = <call><name>PyFrame_New</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>tstate</name>-&gt;<name>frame</name></name> = <name>f</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FIX_TRACE</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>trace_frame</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>PyTrace_CALL</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>curexc_traceback</name></name> == <name>NULL</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>PyTraceBack_Here</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FIX_TRACE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>trace_frame_exc</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
	    <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
    }</block></then>
    <else>else <block>{
	<if>if <condition>(<expr><call><name>trace_frame</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>PyTrace_RETURN</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>tstate</name>-&gt;<name>frame</name></name> = <name><name>f</name>-&gt;<name>f_back</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
}

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRING_CONV_FUNC</name></cpp:macro> <cpp:value>conv_string_to_utf8</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Python 2.0 and later versions, when built with Unicode support */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRING_CONV_FUNC</name></cpp:macro> <cpp:value>(self-&gt;returns_unicode \
                          ? conv_string_to_unicode : conv_string_to_utf8)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static <function><type><name>PyObject</name>*</type>
<name>string_intern</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>str</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>STRING_CONV_FUNC</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
    <comment type="block">/* result can be NULL if the unicode conversion failed. */</comment>
    <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
	<return>return <expr><name>result</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>intern</name></name></expr>)</condition><then>
	<return>return <expr><name>result</name></expr>;</return></then></if>
    <expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>intern</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>intern</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><name>result</name></expr>;</return></then>
        <else>else
            <return>return <expr><name>NULL</name></expr>;</return></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>value</name></expr>;</return>
}</block></function>

<comment type="block">/* Return 0 on success, -1 on exception.
 * flag_error() will be called before return if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>call_character_handler</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
    <expr_stmt><expr><name>temp</name> = (<name><name>self</name>-&gt;<name>returns_unicode</name></name> 
            ? <call><name>conv_string_len_to_unicode</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> 
            : <call><name>conv_string_len_to_utf8</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>temp</name> = <call><name>conv_string_len_to_utf8</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>,
                                    <argument><expr><name>noop_character_data_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* temp is now a borrowed reference; consider it unused. */</comment>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>in_callback</name></name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>temp</name> = <call><name>call_with_frame</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>CharacterData</name></expr></argument>, <argument><expr>"CharacterData"</expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>CharacterData</name></expr>]</index></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* temp is an owned reference again, or NULL */</comment>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>in_callback</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>,
                                    <argument><expr><name>noop_character_data_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>flush_character_buffer</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer</name></name> == <name>NULL</name> || <name><name>self</name>-&gt;<name>buffer_used</name></name> == 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>call_character_handler</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>buffer_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer_used</name></name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>my_CharacterDataHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>xmlparseobject</name> *</type><name>self</name> <init>= <expr>(<name>xmlparseobject</name> *) <name>userData</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer</name></name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>call_character_handler</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
        <if>if <condition>(<expr>(<name><name>self</name>-&gt;<name>buffer_used</name></name> + <name>len</name>) &gt; <name><name>self</name>-&gt;<name>buffer_size</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>flush_character_buffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return;</return></then></if>
            <comment type="block">/* handler might have changed; drop the rest on the floor
             * if there isn't a handler anymore
             */</comment>
            <if>if <condition>(<expr>!<call><name>have_handler</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>CharacterData</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return;</return></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>len</name> &gt; <name><name>self</name>-&gt;<name>buffer_size</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>call_character_handler</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer_used</name></name> = 0</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name> + <name><name>self</name>-&gt;<name>buffer_used</name></name></expr></argument>,
                   <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer_used</name></name> += <name>len</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>my_StartElementHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name><name>atts</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>xmlparseobject</name> *</type><name>self</name> <init>= <expr>(<name>xmlparseobject</name> *)<name>userData</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>have_handler</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>StartElement</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>container</name></decl>, *<decl><type ref="prev"/><name>rv</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>flush_character_buffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return;</return></then></if>
        <comment type="block">/* Set max to the number of slots filled in atts[]; max/2 is
         * the number of attributes we need to process.
         */</comment>
        <if>if <condition>(<expr><name><name>self</name>-&gt;<name>specified_attributes</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>max</name> = <call><name>XML_GetSpecifiedAttributeCount</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>max</name> = 0</expr>;</expr_stmt>
            <while>while <condition>(<expr><name><name>atts</name><index>[<expr><name>max</name></expr>]</index></name> != <name>NULL</name></expr>)</condition>
                <expr_stmt><expr><name>max</name> += 2</expr>;</expr_stmt></while>
        }</block></else></if>
        <comment type="block">/* Build the container. */</comment>
        <if>if <condition>(<expr><name><name>self</name>-&gt;<name>ordered_attributes</name></name></expr>)</condition><then>
            <expr_stmt><expr><name>container</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>container</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
        <if>if <condition>(<expr><name>container</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>max</name></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>n</name> <init>= <expr><call><name>string_intern</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>XML_Char</name> *) <name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>
            <expr_stmt><expr><name>v</name> = <call><name>STRING_CONV_FUNC</name><argument_list>(<argument><expr>(<name>XML_Char</name> *) <name><name>atts</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>self</name>-&gt;<name>ordered_attributes</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></for>
        <expr_stmt><expr><name>args</name> = <call><name>string_intern</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>args</name> != <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name>args</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(NN)"</expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <comment type="block">/* Container is now a borrowed reference; ignore it. */</comment>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>in_callback</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>call_with_frame</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>StartElement</name></expr></argument>, <argument><expr>"StartElement"</expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>StartElement</name></expr>]</index></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>in_callback</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RC_HANDLER</name><parameter_list>(<param><type><name>RC</name></type></param>, <param><type><name>NAME</name></type></param>, <param><type><name>PARAMS</name></type></param>, <param><type><name>INIT</name></type></param>, <param><type><name>PARAM_FORMAT</name></type></param>, <param><type><name>CONVERSION</name></type></param>, \
                <param><type><name>RETURN</name></type></param>, <param><type><name>GETUSERDATA</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static RC \
my_##NAME##Handler PARAMS {\
    xmlparseobject *self = GETUSERDATA ; \
    PyObject *args = NULL; \
    PyObject *rv = NULL; \
    INIT \
\
    if (have_handler(self, NAME)) { \
        if (flush_character_buffer(self) &lt; 0) \
            return RETURN; \
        args = Py_BuildValue PARAM_FORMAT ;\
        if (!args) { flag_error(self); return RETURN;} \
        self-&gt;in_callback = 1; \
        rv = call_with_frame(getcode(NAME,#NAME,__LINE__), \
                             self-&gt;handlers[NAME], args, self); \
        self-&gt;in_callback = 0; \
        Py_DECREF(args); \
        if (rv == NULL) { \
            flag_error(self); \
            return RETURN; \
        } \
        CONVERSION \
        Py_DECREF(rv); \
    } \
    return RETURN; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VOID_HANDLER</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>PARAMS</name></type></param>, <param><type><name>PARAM_FORMAT</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>RC_HANDLER(void, NAME, PARAMS, ;, PARAM_FORMAT, ;, ;,\
	(xmlparseobject *)userData)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT_HANDLER</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>PARAMS</name></type></param>, <param><type><name>PARAM_FORMAT</name></type></param>)</parameter_list></cpp:macro>\
	<cpp:value>RC_HANDLER(int, NAME, PARAMS, int rc=0;, PARAM_FORMAT, \
			rc = PyInt_AsLong(rv);, rc, \
	(xmlparseobject *)userData)</cpp:value></cpp:define>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>EndElement</argument>,
             <argument>(void *userData, const XML_Char *name)</argument>,
             <argument>("(N)", string_intern(self, name))</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>ProcessingInstruction</argument>,
             <argument>(void *userData,
              const XML_Char *target,
              const XML_Char *data)</argument>,
             <argument>("(NO&amp;)", string_intern(self, target), STRING_CONV_FUNC,data)</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>UnparsedEntityDecl</argument>,
             <argument>(void *userData,
              const XML_Char *entityName,
              const XML_Char *base,
              const XML_Char *systemId,
              const XML_Char *publicId,
              const XML_Char *notationName)</argument>,
             <argument>("(NNNNN)",
              string_intern(self, entityName), string_intern(self, base),
              string_intern(self, systemId), string_intern(self, publicId),
              string_intern(self, notationName))</argument>)</argument_list></macro>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifndef>
<macro><name>VOID_HANDLER</name><argument_list>(<argument>EntityDecl</argument>,
             <argument>(void *userData,
              const XML_Char *entityName,
              int is_parameter_entity,
              const XML_Char *value,
              int value_length,
              const XML_Char *base,
              const XML_Char *systemId,
              const XML_Char *publicId,
              const XML_Char *notationName)</argument>,
             <argument>("NiNNNNN",
              string_intern(self, entityName), is_parameter_entity,
              conv_string_len_to_utf8(value, value_length),
              string_intern(self, base), string_intern(self, systemId),
              string_intern(self, publicId),
              string_intern(self, notationName))</argument>)</argument_list></macro>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>VOID_HANDLER</name><argument_list>(<argument>EntityDecl</argument>,
             <argument>(void *userData,
              const XML_Char *entityName,
              int is_parameter_entity,
              const XML_Char *value,
              int value_length,
              const XML_Char *base,
              const XML_Char *systemId,
              const XML_Char *publicId,
              const XML_Char *notationName)</argument>,
             <argument>("NiNNNNN",
              string_intern(self, entityName), is_parameter_entity,
              (self-&gt;returns_unicode
               ? conv_string_len_to_unicode(value, value_length)
               : conv_string_len_to_utf8(value, value_length)),
              string_intern(self, base), string_intern(self, systemId),
              string_intern(self, publicId),
              string_intern(self, notationName))</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>XmlDecl</argument>,
             <argument>(void *userData,
              const XML_Char *version,
              const XML_Char *encoding,
              int standalone)</argument>,
             <argument>("(O&amp;O&amp;i)",
              STRING_CONV_FUNC,version, STRING_CONV_FUNC,encoding,
              standalone)</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>conv_content_model</name><parameter_list>(<param><decl><type><name>XML_Content</name> * <specifier>const</specifier></type> <name>model</name></decl></param>,
                   <param><function_decl><type><name>PyObject</name> *</type>(*<name>conv_string</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>XML_Char</name> *</decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>children</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr><name><name>model</name>-&gt;<name>numchildren</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>children</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>model</name>-&gt;<name>numchildren</name></name> &lt; <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<name>int</name>)<name><name>model</name>-&gt;<name>numchildren</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>child</name> <init>= <expr><call><name>conv_content_model</name><argument_list>(<argument><expr>&amp;<name><name>model</name>-&gt;<name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                 <argument><expr><name>conv_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>child</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(iiO&amp;N)"</expr></argument>,
                               <argument><expr><name><name>model</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name><name>model</name>-&gt;<name>quant</name></name></expr></argument>,
                               <argument><expr><name>conv_string</name></expr></argument>,<argument><expr><name><name>model</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>my_ElementDeclHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl></param>,
                      <param><decl><type><name>XML_Content</name> *</type><name>model</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>xmlparseobject</name> *</type><name>self</name> <init>= <expr>(<name>xmlparseobject</name> *)<name>userData</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>have_handler</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>ElementDecl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>modelobj</name></decl>, *<decl><type ref="prev"/><name>nameobj</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>flush_character_buffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <goto>goto <name>finally</name>;</goto></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
        <expr_stmt><expr><name>modelobj</name> = <call><name>conv_content_model</name><argument_list>(<argument><expr><name>model</name></expr></argument>,
                                      <argument><expr>(<name><name>self</name>-&gt;<name>returns_unicode</name></name>
                                       ? <name>conv_string_to_unicode</name>
                                       : <name>conv_string_to_utf8</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>modelobj</name> = <call><name>conv_content_model</name><argument_list>(<argument><expr><name>model</name></expr></argument>, <argument><expr><name>conv_string_to_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr><name>modelobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>finally</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name>nameobj</name> = <call><name>string_intern</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nameobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>modelobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>finally</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name>args</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"NN"</expr></argument>, <argument><expr><name>nameobj</name></expr></argument>, <argument><expr><name>modelobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>modelobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>finally</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>in_callback</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>call_with_frame</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>ElementDecl</name></expr></argument>, <argument><expr>"ElementDecl"</expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>ElementDecl</name></expr>]</index></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>in_callback</name></name> = 0</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>flag_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>finally</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
 <label><name>finally</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XML_FreeContentModel</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>AttlistDecl</argument>,
             <argument>(void *userData,
              const XML_Char *elname,
              const XML_Char *attname,
              const XML_Char *att_type,
              const XML_Char *dflt,
              int isrequired)</argument>,
             <argument>("(NNO&amp;O&amp;i)",
              string_intern(self, elname), string_intern(self, attname),
              STRING_CONV_FUNC,att_type, STRING_CONV_FUNC,dflt,
              isrequired)</argument>)</argument_list></macro>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XML_COMBINED_VERSION</name> &gt;= 19504</expr></cpp:if>
<macro><name>VOID_HANDLER</name><argument_list>(<argument>SkippedEntity</argument>,
             <argument>(void *userData,
              const XML_Char *entityName,
              int is_parameter_entity)</argument>,
             <argument>("Ni",
              string_intern(self, entityName), is_parameter_entity)</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>NotationDecl</argument>,
		<argument>(void *userData,
			const XML_Char *notationName,
			const XML_Char *base,
			const XML_Char *systemId,
			const XML_Char *publicId)</argument>,
                <argument>("(NNNN)",
		 string_intern(self, notationName), string_intern(self, base),
		 string_intern(self, systemId), string_intern(self, publicId))</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>StartNamespaceDecl</argument>,
		<argument>(void *userData,
		      const XML_Char *prefix,
		      const XML_Char *uri)</argument>,
                <argument>("(NN)",
                 string_intern(self, prefix), string_intern(self, uri))</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>EndNamespaceDecl</argument>,
		<argument>(void *userData,
		    const XML_Char *prefix)</argument>,
                <argument>("(N)", string_intern(self, prefix))</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>Comment</argument>,
               <argument>(void *userData, const XML_Char *data)</argument>,
                <argument>("(O&amp;)", STRING_CONV_FUNC,data)</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>StartCdataSection</argument>,
               <argument>(void *userData)</argument>,
		<argument>("()")</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>EndCdataSection</argument>,
               <argument>(void *userData)</argument>,
		<argument>("()")</argument>)</argument_list></macro>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifndef>
<macro><name>VOID_HANDLER</name><argument_list>(<argument>Default</argument>,
	      <argument>(void *userData, const XML_Char *s, int len)</argument>,
	      <argument>("(N)", conv_string_len_to_utf8(s,len))</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>DefaultHandlerExpand</argument>,
	      <argument>(void *userData, const XML_Char *s, int len)</argument>,
	      <argument>("(N)", conv_string_len_to_utf8(s,len))</argument>)</argument_list></macro>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>VOID_HANDLER</name><argument_list>(<argument>Default</argument>,
	      <argument>(void *userData, const XML_Char *s, int len)</argument>,
	      <argument>("(N)", (self-&gt;returns_unicode
		       ? conv_string_len_to_unicode(s,len)
		       : conv_string_len_to_utf8(s,len)))</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>DefaultHandlerExpand</argument>,
	      <argument>(void *userData, const XML_Char *s, int len)</argument>,
	      <argument>("(N)", (self-&gt;returns_unicode
		       ? conv_string_len_to_unicode(s,len)
		       : conv_string_len_to_utf8(s,len)))</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>INT_HANDLER</name><argument_list>(<argument>NotStandalone</argument>,
		<argument>(void *userData)</argument>,
		<argument>("()")</argument>)</argument_list></macro>

<macro><name>RC_HANDLER</name><argument_list>(<argument>int</argument>, <argument>ExternalEntityRef</argument>,
		<argument>(XML_Parser parser,
		    const XML_Char *context,
		    const XML_Char *base,
		    const XML_Char *systemId,
		    const XML_Char *publicId)</argument>,
		<argument>int rc=0;</argument>,
                <argument>("(O&amp;NNN)",
		 STRING_CONV_FUNC,context, string_intern(self, base),
		 string_intern(self, systemId), string_intern(self, publicId))</argument>,
		<argument>rc = PyInt_AsLong(rv);</argument>, <argument>rc</argument>,
		<argument>XML_GetUserData(parser)</argument>)</argument_list></macro>

<comment type="block">/* XXX UnknownEncodingHandler */</comment>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>StartDoctypeDecl</argument>,
             <argument>(void *userData, const XML_Char *doctypeName,
              const XML_Char *sysid, const XML_Char *pubid,
              int has_internal_subset)</argument>,
             <argument>("(NNNi)", string_intern(self, doctypeName),
              string_intern(self, sysid), string_intern(self, pubid),
              has_internal_subset)</argument>)</argument_list></macro>

<macro><name>VOID_HANDLER</name><argument_list>(<argument>EndDoctypeDecl</argument>, <argument>(void *userData)</argument>, <argument>("()")</argument>)</argument_list></macro>

<comment type="block">/* ---------------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_parse_result</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>rv</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>rv</name> == 0</expr>)</condition><then> <block>{
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>flush_character_buffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>xmlparse_Parse__doc__</name></expr></argument>,
<argument><expr>"Parse(data[, isfinal])\n\
Parse XML data.  `isfinal' should be true at end of input."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>xmlparse_Parse</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isFinal</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#|i:Parse"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>slen</name></expr></argument>, <argument><expr>&amp;<name>isFinal</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr><call><name>get_parse_result</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>isFinal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* File reading copied from cPickle */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_SIZE</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>readinst</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>buf_size</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>meth</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>bytes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>bytes</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>buf_size</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>finally</name>;</goto></then></if>

    <if>if <condition>(<expr>(<name>arg</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>finally</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> &lt; 0x02020000</expr></cpp:if>
    <expr_stmt><expr><name>str</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>meth</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>str</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>meth</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
        <goto>goto <name>finally</name>;</goto></then></if>

    <comment type="block">/* XXX what to do if it returns a Unicode string? */</comment>
    <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                     <argument><expr>"read() did not return a string object (type=%.400s)"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>finally</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len</name> &gt; <name>buf_size</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
                     <argument><expr>"read() returned too much data: "
                     "%i bytes requested, %i returned"</expr></argument>,
                     <argument><expr><name>buf_size</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>finally</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>finally</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>len</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>xmlparse_ParseFile__doc__</name></expr></argument>,
<argument><expr>"ParseFile(file)\n\
Parse XML data from file-like object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>xmlparse_ParseFile</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>readmethod</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>fp</name> = <call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>fp</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>readmethod</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"read"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>readmethod</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                            <argument><expr>"argument must have 'read' attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
    }</block></else></if>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>bytes_read</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>buf</name> <init>= <expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>readmethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>fp</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>bytes_read</name> = <call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>bytes_read</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>bytes_read</name> = <call><name>readinst</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>, <argument><expr><name>readmethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>bytes_read</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>readmethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
        }</block></else></if>
        <expr_stmt><expr><name>rv</name> = <call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>bytes_read</name></expr></argument>, <argument><expr><name>bytes_read</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>readmethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>!<name>rv</name> || <name>bytes_read</name> == 0</expr>)</condition><then>
            <break>break;</break></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>readmethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>get_parse_result</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>xmlparse_SetBase__doc__</name></expr></argument>,
<argument><expr>"SetBase(base_url)\n\
Set the base URL for the parser."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>xmlparse_SetBase</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>base</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:SetBase"</expr></argument>, <argument><expr>&amp;<name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>XML_SetBase</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>xmlparse_GetBase__doc__</name></expr></argument>,
<argument><expr>"GetBase() -&gt; url\n\
Return base URL string for the parser."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>xmlparse_GetBase</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"z"</expr></argument>, <argument><expr><call><name>XML_GetBase</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>xmlparse_GetInputContext__doc__</name></expr></argument>,
<argument><expr>"GetInputContext() -&gt; string\n\
Return the untranslated text of the input that caused the current event.\n\
If the event was generated by a large amount of text (such as a start tag\n\
for an element with many attributes), not all of the text may be available."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>xmlparse_GetInputContext</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>in_callback</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name>
            <init>= <expr><call><name>XML_GetInputContext</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>buffer</name> != <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name> + <name>offset</name></expr></argument>,
                                              <argument><expr><name>size</name> - <name>offset</name></expr></argument>)</argument_list></call></expr>;</return></then>
        <else>else
            <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></else></if>
    }</block></then>
    <else>else
        <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>xmlparse_ExternalEntityParserCreate__doc__</name></expr></argument>,
<argument><expr>"ExternalEntityParserCreate(context[, encoding])\n\
Create a parser for parsing an external entity based on the\n\
information passed to the ExternalEntityRefHandler."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>xmlparse_ExternalEntityParserCreate</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xmlparseobject</name> *</type><name>new_parser</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"z|s:ExternalEntityParserCreate"</expr></argument>,
                          <argument><expr>&amp;<name>context</name></expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_TPFLAGS_HAVE_GC</name></cpp:ifndef>
    <comment type="block">/* Python versions 2.0 and 2.1 */</comment>
    <expr_stmt><expr><name>new_parser</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>xmlparseobject</name></expr></argument>, <argument><expr>&amp;<name>Xmlparsetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Python versions 2.2 and later */</comment>
    <expr_stmt><expr><name>new_parser</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>xmlparseobject</name></expr></argument>, <argument><expr>&amp;<name>Xmlparsetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>new_parser</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>buffer_size</name></name> = <name><name>self</name>-&gt;<name>buffer_size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>buffer_used</name></name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>buffer</name></name> = <call><name>malloc</name><argument_list>(<argument><expr><name><name>new_parser</name>-&gt;<name>buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>new_parser</name>-&gt;<name>buffer</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_TPFLAGS_HAVE_GC</name></cpp:ifndef>
            <comment type="block">/* Code for versions 2.0 and 2.1 */</comment>
            <expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="block">/* Code for versions 2.2 and later. */</comment>
            <expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then>
    <else>else
        <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>buffer</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>returns_unicode</name></name> = <name><name>self</name>-&gt;<name>returns_unicode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>ordered_attributes</name></name> = <name><name>self</name>-&gt;<name>ordered_attributes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>specified_attributes</name></name> = <name><name>self</name>-&gt;<name>specified_attributes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>in_callback</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>ns_prefixes</name></name> = <name><name>self</name>-&gt;<name>ns_prefixes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>itself</name></name> = <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
							<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>handlers</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>intern</name></name> = <name><name>self</name>-&gt;<name>intern</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>new_parser</name>-&gt;<name>intern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TPFLAGS_HAVE_GC</name></cpp:ifdef>
    <expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>PyObject_GC_Init</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr>!<name><name>new_parser</name>-&gt;<name>itself</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name><name>new_parser</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* allocate and clear handlers first */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <comment type="block">/* do nothing */</comment><empty_stmt>;</empty_stmt></for>

    <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>handlers</name></name> = <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof> * <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>new_parser</name>-&gt;<name>handlers</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>clear_handlers</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* then copy handlers from self */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>handler</name> <init>= <expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>handler</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_parser</name>-&gt;<name>handlers</name><index>[<expr><name>i</name></expr>]</index></name> = <name>handler</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>setter</name><argument_list>(<argument><expr><name><name>new_parser</name>-&gt;<name>itself</name></name></expr></argument>,
                                   <argument><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
    <return>return <expr>(<name>PyObject</name> *)<name>new_parser</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>xmlparse_SetParamEntityParsing__doc__</name></expr></argument>,
<argument><expr>"SetParamEntityParsing(flag) -&gt; success\n\
Controls parsing of parameter entities (including the external DTD\n\
subset). Possible flag values are XML_PARAM_ENTITY_PARSING_NEVER,\n\
XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE and\n\
XML_PARAM_ENTITY_PARSING_ALWAYS. Returns true if setting the flag\n\
was successful."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>xmlparse_SetParamEntityParsing</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>&amp;<name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>flag</name> = <call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XML_COMBINED_VERSION</name> &gt;= 19505</expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>xmlparse_UseForeignDTD__doc__</name></expr></argument>,
<argument><expr>"UseForeignDTD([flag])\n\
Allows the application to provide an artificial external subset if one is\n\
not specified as part of the document instance.  This readily allows the\n\
use of a 'default' document type controlled by the application, while still\n\
getting the advantage of providing document type information to the parser.\n\
'flag' defaults to True if not provided."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>xmlparse_UseForeignDTD</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>flagobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XML_Bool</name></type> <name>flag</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>
    <enum>enum <name>XML_Error</name> <name>rc</name>;</enum>
    <if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"UseForeignDTD"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>flagobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>flagobj</name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>flag</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>flagobj</name></expr></argument>)</argument_list></call> ? <name>XML_TRUE</name> : <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rc</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>xmlparse_methods</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"Parse"</expr>,	  <expr>(<name>PyCFunction</name>)<name>xmlparse_Parse</name></expr>,
		  <expr><name>METH_VARARGS</name></expr>,	<expr><name>xmlparse_Parse__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"ParseFile"</expr>, <expr>(<name>PyCFunction</name>)<name>xmlparse_ParseFile</name></expr>,
		  <expr><name>METH_O</name></expr>,	<expr><name>xmlparse_ParseFile__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"SetBase"</expr>,   <expr>(<name>PyCFunction</name>)<name>xmlparse_SetBase</name></expr>,
		  <expr><name>METH_VARARGS</name></expr>, <expr><name>xmlparse_SetBase__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"GetBase"</expr>,   <expr>(<name>PyCFunction</name>)<name>xmlparse_GetBase</name></expr>,
		  <expr><name>METH_NOARGS</name></expr>, <expr><name>xmlparse_GetBase__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"ExternalEntityParserCreate"</expr>, <expr>(<name>PyCFunction</name>)<name>xmlparse_ExternalEntityParserCreate</name></expr>,
	 	  <expr><name>METH_VARARGS</name></expr>, <expr><name>xmlparse_ExternalEntityParserCreate__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"SetParamEntityParsing"</expr>, <expr>(<name>PyCFunction</name>)<name>xmlparse_SetParamEntityParsing</name></expr>,
		  <expr><name>METH_VARARGS</name></expr>, <expr><name>xmlparse_SetParamEntityParsing__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"GetInputContext"</expr>, <expr>(<name>PyCFunction</name>)<name>xmlparse_GetInputContext</name></expr>,
		  <expr><name>METH_NOARGS</name></expr>, <expr><name>xmlparse_GetInputContext__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XML_COMBINED_VERSION</name> &gt;= 19505</expr></cpp:if>
    <expr><block>{<expr>"UseForeignDTD"</expr>, <expr>(<name>PyCFunction</name>)<name>xmlparse_UseForeignDTD</name></expr>,
		  <expr><name>METH_VARARGS</name></expr>, <expr><name>xmlparse_UseForeignDTD__doc__</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><block>{<expr><name>NULL</name></expr>,	  <expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ---------- */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>

<comment type="block">/* pyexpat international encoding support.
   Make it as simple as possible.
*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>template_buffer</name><index>[<expr>257</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>template_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_template_buffer</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<expr_stmt><expr><name><name>template_buffer</name><index>[<expr><name>i</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>template_buffer</name><index>[<expr>256</expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>PyUnknownEncodingHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>encodingHandlerData</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl></param>,
                         <param><decl><type><name>XML_Encoding</name> *</type><name>info</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>_u_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Yes, supports only 8bit encodings */</comment>
    <expr_stmt><expr><name>_u_string</name> = (<name>PyUnicodeObject</name> *)
        <call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><name>template_buffer</name></expr></argument>, <argument><expr>256</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>_u_string</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>result</name></expr>;</return></then></if>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<comment type="block">/* Stupid to access directly, but fast */</comment>
	<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr><name><name>_u_string</name>-&gt;<name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>c</name> == <name>Py_UNICODE_REPLACEMENT_CHARACTER</name></expr>)</condition><then>
	    <expr_stmt><expr><name><name>info</name>-&gt;<name>map</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name><name>info</name>-&gt;<name>map</name><index>[<expr><name>i</name></expr>]</index></name> = <name>c</name></expr>;</expr_stmt></else></if>
    }</block></for>
    <expr_stmt><expr><name><name>info</name>-&gt;<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name>-&gt;<name>convert</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name>-&gt;<name>release</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>_u_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>newxmlparseobject</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>encoding</name></decl></param>, <param><decl><type><name>char</name> *</type><name>namespace_separator</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>intern</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TPFLAGS_HAVE_GC</name></cpp:ifdef>
    <comment type="block">/* Code for versions 2.2 and later */</comment>
    <expr_stmt><expr><name>self</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>xmlparseobject</name></expr></argument>, <argument><expr>&amp;<name>Xmlparsetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>xmlparseobject</name></expr></argument>, <argument><expr>&amp;<name>Xmlparsetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>returns_unicode</name></name> = 1</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>returns_unicode</name></name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer_size</name></name> = <name>CHARACTER_DATA_BUFFER_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer_used</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>ordered_attributes</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>specified_attributes</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>in_callback</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>ns_prefixes</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>handlers</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>namespace_separator</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>self</name>-&gt;<name>itself</name></name> = <call><name>XML_ParserCreateNS</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>*<name>namespace_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>self</name>-&gt;<name>itself</name></name> = <call><name>XML_ParserCreate</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>intern</name></name> = <name>intern</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>intern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TPFLAGS_HAVE_GC</name></cpp:ifdef>
    <expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>PyObject_GC_Init</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>itself</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
                        <argument><expr>"XML_ParserCreate failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>,
                  <argument><expr>(<name>XML_UnknownEncodingHandler</name>) <name>PyUnknownEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <comment type="block">/* do nothing */</comment><empty_stmt>;</empty_stmt></for>

    <expr_stmt><expr><name><name>self</name>-&gt;<name>handlers</name></name> = <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof> * <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>handlers</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>clear_handlers</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>xmlparse_dealloc</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TPFLAGS_HAVE_GC</name></cpp:ifdef>
    <expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>PyObject_GC_Fini</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>itself</name></name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>itself</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>handlers</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>temp</name> = <name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>handlers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>handlers</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>intern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_TPFLAGS_HAVE_GC</name></cpp:ifndef>
    <comment type="block">/* Code for versions 2.0 and 2.1 */</comment>
    <expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Code for versions 2.2 and later. */</comment>
    <expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>handlername2int</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <return>return <expr><name>i</name></expr>;</return>
        }</block></then></if>
    }</block></for>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_pybool</name><parameter_list>(<param><decl><type><name>int</name></type> <name>istrue</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>istrue</name> ? <name>Py_True</name> : <name>Py_False</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>xmlparse_getattr</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>handlernum</name> <init>= <expr><call><name>handlername2int</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>handlernum</name> != -1</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>handlernum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == 'E'</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"ErrorCode"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)
                                  <call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"ErrorLineNumber"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)
                                  <call><name>XML_GetErrorLineNumber</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"ErrorColumnNumber"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)
                                  <call><name>XML_GetErrorColumnNumber</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"ErrorByteIndex"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)
                                  <call><name>XML_GetErrorByteIndex</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == 'C'</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"CurrentLineNumber"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)
                                  <call><name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"CurrentColumnNumber"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)
                                  <call><name>XML_GetCurrentColumnNumber</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"CurrentByteIndex"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)
                                  <call><name>XML_GetCurrentByteIndex</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == 'b'</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"buffer_size"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>self</name>-&gt;<name>buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"buffer_text"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>get_pybool</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"buffer_used"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>self</name>-&gt;<name>buffer_used</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"namespace_prefixes"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><call><name>get_pybool</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ns_prefixes</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"ordered_attributes"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><call><name>get_pybool</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ordered_attributes</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"returns_unicode"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><call><name>get_pybool</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>self</name>-&gt;<name>returns_unicode</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"specified_attributes"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><call><name>get_pybool</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>self</name>-&gt;<name>specified_attributes</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"intern"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>self</name>-&gt;<name>intern</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>Py_None</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>intern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>self</name>-&gt;<name>intern</name></name></expr>;</return>
        }</block></else></if>
    }</block></then></if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND</name><parameter_list>(<param><type><name>list</name></type></param>, <param><type><name>str</name></type></param>)</parameter_list></cpp:macro>				\
        <cpp:value>do {						\
                PyObject *o = PyString_FromString(str);	\
                if (o != NULL)				\
        	        PyList_Append(list, o);		\
                Py_XDECREF(o);				\
        } while (0)</cpp:value></cpp:define>

    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"__members__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>rc</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>rc</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>get_handler_name</name><argument_list>(<argument><expr>&amp;<name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>o</name> != <name>NULL</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"ErrorCode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"ErrorLineNumber"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"ErrorColumnNumber"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"ErrorByteIndex"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"CurrentLineNumber"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"CurrentColumnNumber"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"CurrentByteIndex"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"buffer_size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"buffer_text"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"buffer_used"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"namespace_prefixes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"ordered_attributes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"returns_unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"specified_attributes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APPEND</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr>"intern"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APPEND</name></cpp:undef>
        <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>Py_FindMethod</name><argument_list>(<argument><expr><name>xmlparse_methods</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sethandler</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>handlernum</name> <init>= <expr><call><name>handlername2int</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>handlernum</name> &gt;= 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>xmlhandler</name></type> <name>c_handler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>handlernum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>v</name> == <name>Py_None</name></expr>)</condition><then> <block>{
            <comment type="block">/* If this is the character data handler, and a character
               data handler is already active, we need to be more
               careful.  What we can safely do is replace the existing
               character data handler callback function with a no-op
               function that will refuse to call Python.  The downside
               is that this doesn't completely remove the character
               data handler from the C layer if there's any callback
               active, so Expat does a little more work than it
               otherwise would, but that's really an odd case.  A more
               elaborate system of handlers and state could remove the
               C handler more effectively. */</comment>
            <if>if <condition>(<expr><name>handlernum</name> == <name>CharacterData</name> &amp;&amp; <name><name>self</name>-&gt;<name>in_callback</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>c_handler</name> = <name>noop_character_data_handler</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>c_handler</name> = <name><name>handler_info</name><index>[<expr><name>handlernum</name></expr>]</index></name>.<name>handler</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>handlernum</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handler_info</name><index>[<expr><name>handlernum</name></expr>]</index></name>.<call><name>setter</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>c_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>xmlparse_setattr</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Set attribute 'name' to value 'v'. v==NULL means delete */</comment>
    <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"Cannot delete attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"buffer_text"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name></name> = <call><name>malloc</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr>-1</expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer_used</name></name> = 0</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>flush_character_buffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr>-1</expr>;</return></then></if>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"namespace_prefixes"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name><name>self</name>-&gt;<name>ns_prefixes</name></name> = 1</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>self</name>-&gt;<name>ns_prefixes</name></name> = 0</expr>;</expr_stmt></else></if>
        <expr_stmt><expr><call><name>XML_SetReturnNSTriplet</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ns_prefixes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"ordered_attributes"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name><name>self</name>-&gt;<name>ordered_attributes</name></name> = 1</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>self</name>-&gt;<name>ordered_attributes</name></name> = 0</expr>;</expr_stmt></else></if>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"returns_unicode"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifndef>
            <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
                            <argument><expr>"Unicode support not available"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name><name>self</name>-&gt;<name>returns_unicode</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then>
        <else>else
            <expr_stmt><expr><name><name>self</name>-&gt;<name>returns_unicode</name></name> = 0</expr>;</expr_stmt></else></if>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"specified_attributes"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name><name>self</name>-&gt;<name>specified_attributes</name></name> = 1</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>self</name>-&gt;<name>specified_attributes</name></name> = 0</expr>;</expr_stmt></else></if>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"buffer_size"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>long</name></type> <name>new_buffer_size</name></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"buffer_size must be an integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      	<return>return <expr>-1</expr>;</return>
      }</block></then></if>

      <expr_stmt><expr><name>new_buffer_size</name>=<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* trivial case -- no change */</comment>
      <if>if <condition>(<expr><name>new_buffer_size</name> == <name><name>self</name>-&gt;<name>buffer_size</name></name></expr>)</condition><then> <block>{
	<return>return <expr>0</expr>;</return>
      }</block></then></if>

      <if>if <condition>(<expr><name>new_buffer_size</name> &lt;= 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"buffer_size must be greater than zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
      }</block></then></if>

      <comment type="block">/* check maximum */</comment>
      <if>if <condition>(<expr><name>new_buffer_size</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>errmsg</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>errmsg</name></expr></argument>, <argument><expr>"buffer_size must not be greater than %i"</expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>	
      }</block></then></if>

      <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
	<comment type="block">/* there is already a buffer */</comment>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer_used</name></name> != 0</expr>)</condition><then> <block>{
	  <expr_stmt><expr><call><name>flush_character_buffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* free existing buffer */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer</name></name> = <call><name>malloc</name><argument_list>(<argument><expr><name>new_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buffer</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
      }</block></then></if>	  
      <expr_stmt><expr><name><name>self</name>-&gt;<name>buffer_size</name></name> = <name>new_buffer_size</name></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"CharacterDataHandler"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* If we're changing the character data handler, flush all
         * cached data with the old handler.  Not sure there's a
         * "right" thing to do, though, but this probably won't
         * happen.
         */</comment>
        <if>if <condition>(<expr><call><name>flush_character_buffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>sethandler</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_CYCLE_GC</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>xmlparse_traverse</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>handlers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>xmlparse_clear</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>clear_handlers</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>intern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>Xmlparsetype__doc__</name></expr></argument>, <argument><expr>"XML parser"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Xmlparsetype</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"pyexpat.xmlparser"</expr>,		<comment type="block">/*tp_name*/</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>xmlparseobject</name></expr></argument>)</argument_list></sizeof> + <name>PyGC_HEAD_SIZE</name></expr>,<comment type="block">/*tp_basicsize*/</comment>
	<expr>0</expr>,				<comment type="block">/*tp_itemsize*/</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>xmlparse_dealloc</name></expr>,	<comment type="block">/*tp_dealloc*/</comment>
	<expr>(<name>printfunc</name>)0</expr>,		<comment type="block">/*tp_print*/</comment>
	<expr>(<name>getattrfunc</name>)<name>xmlparse_getattr</name></expr>,	<comment type="block">/*tp_getattr*/</comment>
	<expr>(<name>setattrfunc</name>)<name>xmlparse_setattr</name></expr>,	<comment type="block">/*tp_setattr*/</comment>
	<expr>(<name>cmpfunc</name>)0</expr>,		<comment type="block">/*tp_compare*/</comment>
	<expr>(<name>reprfunc</name>)0</expr>,		<comment type="block">/*tp_repr*/</comment>
	<expr>0</expr>,			<comment type="block">/*tp_as_number*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_as_sequence*/</comment>
	<expr>0</expr>,		<comment type="block">/*tp_as_mapping*/</comment>
	<expr>(<name>hashfunc</name>)0</expr>,		<comment type="block">/*tp_hash*/</comment>
	<expr>(<name>ternaryfunc</name>)0</expr>,		<comment type="block">/*tp_call*/</comment>
	<expr>(<name>reprfunc</name>)0</expr>,		<comment type="block">/*tp_str*/</comment>
	<expr>0</expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,		<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,		<comment type="block">/* tp_as_buffer */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TPFLAGS_HAVE_GC</name></cpp:ifdef>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>, <comment type="block">/*tp_flags*/</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_GC</name></expr>, <comment type="block">/*tp_flags*/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><name>Xmlparsetype__doc__</name></expr>, <comment type="block">/* tp_doc - Documentation string */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_CYCLE_GC</name></cpp:ifdef>
	<expr>(<name>traverseproc</name>)<name>xmlparse_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>xmlparse_clear</name>		<comment type="block">/* tp_clear */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	0</expr>, <expr>0</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* End of code for xmlparser objects */</comment>
<comment type="block">/* -------------------------------------------------------- */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyexpat_ParserCreate__doc__</name></expr></argument>,
<argument><expr>"ParserCreate([encoding[, namespace_separator]]) -&gt; parser\n\
Return a new XML parser object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pyexpat_ParserCreate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>notused</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>namespace_separator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>intern</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>intern_decref</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"encoding"</expr>, <expr>"namespace_separator"</expr>,
                                   <expr>"intern"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|zzO:ParserCreate"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
                                     <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>namespace_separator</name></expr></argument>, <argument><expr>&amp;<name>intern</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>namespace_separator</name> != <name>NULL</name>
        &amp;&amp; <call><name>strlen</name><argument_list>(<argument><expr><name>namespace_separator</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
                        <argument><expr>"namespace_separator must be at most one"
                        " character, omitted, or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/* Explicitly passing None means no interning is desired.
       Not passing anything means that a new dictionary is used. */</comment>
    <if>if <condition>(<expr><name>intern</name> == <name>Py_None</name></expr>)</condition><then>
	<expr_stmt><expr><name>intern</name> = <name>NULL</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>intern</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>intern</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>intern</name></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>intern_decref</name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>intern</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"intern must be a dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if></else></if></else></if>

    <expr_stmt><expr><name>result</name> = <call><name>newxmlparseobject</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>namespace_separator</name></expr></argument>, <argument><expr><name>intern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>intern_decref</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>intern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyexpat_ErrorString__doc__</name></expr></argument>,
<argument><expr>"ErrorString(errno) -&gt; string\n\
Returns string error for given number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pyexpat_ErrorString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>long</name></type> <name>code</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"l:ErrorString"</expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"z"</expr></argument>, <argument><expr><call><name>XML_ErrorString</name><argument_list>(<argument><expr>(<name>int</name>)<name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* List of methods defined in the module */</comment>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>pyexpat_methods</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"ParserCreate"</expr>,	<expr>(<name>PyCFunction</name>)<name>pyexpat_ParserCreate</name></expr>,
     <expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>pyexpat_ParserCreate__doc__</name></expr>}</block></expr>,
    <expr><block>{<expr>"ErrorString"</expr>,	<expr>(<name>PyCFunction</name>)<name>pyexpat_ErrorString</name></expr>,
     <expr><name>METH_VARARGS</name></expr>,	<expr><name>pyexpat_ErrorString__doc__</name></expr>}</block></expr>,

    <expr><block>{<expr><name>NULL</name></expr>,	 <expr>(<name>PyCFunction</name>)<name>NULL</name></expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Module docstring */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyexpat_module_documentation</name></expr></argument>,
<argument><expr>"Python wrapper for Expat parser."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Return a Python string that represents the version number without the
 * extra cruft added by revision control, even if the right options were
 * given to the "cvs export" command to make it not include the extra
 * cruft.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_version_string</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>rcsid</name> <init>= <expr>"$Revision$"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>rev</name> <init>= <expr><name>rcsid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr>!<call><name>isdigit</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>rev</name></expr>;</expr_stmt></while>
    <while>while <condition>(<expr><name><name>rev</name><index>[<expr><name>i</name></expr>]</index></name> != ' ' &amp;&amp; <name><name>rev</name><index>[<expr><name>i</name></expr>]</index></name> != '\0'</expr>)</condition>
        <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt></while>

    <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Initialization function for the module */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MODULE_NAME</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODULE_NAME</name></cpp:macro> <cpp:value>"pyexpat"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MODULE_INITFUNC</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODULE_INITFUNC</name></cpp:macro> <cpp:value>initpyexpat</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyMODINIT_FUNC</name></cpp:ifndef>
<cpp:ifdef>#   <cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:define>#       <cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>__declspec(dllexport) void</cpp:value></cpp:define>
<cpp:else>#   <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#       <cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>void</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>PyMODINIT_FUNC</name></type> <name>MODULE_INITFUNC</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>  <comment type="block">/* avoid compiler warnings */</comment>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>MODULE_INITFUNC</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errmod_name</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>MODULE_NAME</name> ".errors"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>errors_module</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>modelmod_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>model_module</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>sys_modules</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> struct <name>PyExpat_CAPI</name></type> <name>capi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>capi_object</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>errmod_name</name> == <name>NULL</name></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><name>modelmod_name</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>MODULE_NAME</name> ".model"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>modelmod_name</name> == <name>NULL</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Xmlparsetype</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>

    <comment type="block">/* Create the module and add the functions */</comment>
    <expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr><name>MODULE_NAME</name></expr></argument>, <argument><expr><name>pyexpat_methods</name></expr></argument>,
                       <argument><expr><name>pyexpat_module_documentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <comment type="block">/* Add some symbolic constants to the module */</comment>
    <if>if <condition>(<expr><name>ErrorObject</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ErrorObject</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"xml.parsers.expat.ExpatError"</expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ErrorObject</name> == <name>NULL</name></expr>)</condition><then>
            <return>return;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ErrorObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>ErrorObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ErrorObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"ExpatError"</expr></argument>, <argument><expr><name>ErrorObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>Xmlparsetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"XMLParserType"</expr></argument>, <argument><expr>(<name>PyObject</name> *) &amp;<name>Xmlparsetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"__version__"</expr></argument>, <argument><expr><call><name>get_version_string</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EXPAT_VERSION"</expr></argument>,
                               <argument><expr>(<name>char</name> *) <call><name>XML_ExpatVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{
        <decl_stmt><decl><type><name>XML_Expat_Version</name></type> <name>info</name> <init>= <expr><call><name>XML_ExpatVersionInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"version_info"</expr></argument>,
                           <argument><expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(iii)"</expr></argument>, <argument><expr><name><name>info</name>.<name>major</name></name></expr></argument>,
                                         <argument><expr><name><name>info</name>.<name>minor</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>micro</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>init_template_buffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* XXX When Expat supports some way of figuring out how it was
       compiled, this should check and set native_encoding
       appropriately.
    */</comment>
    <expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"native_encoding"</expr></argument>, <argument><expr>"UTF-8"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sys_modules</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"modules"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errors_module</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>errmod_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>errors_module</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>errors_module</name> = <call><name>PyModule_New</name><argument_list>(<argument><expr><name>MODULE_NAME</name> ".errors"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>errors_module</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>sys_modules</name></expr></argument>, <argument><expr><name>errmod_name</name></expr></argument>, <argument><expr><name>errors_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* gives away the reference to errors_module */</comment>
            <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"errors"</expr></argument>, <argument><expr><name>errors_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>errmod_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>model_module</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>modelmod_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>model_module</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>model_module</name> = <call><name>PyModule_New</name><argument_list>(<argument><expr><name>MODULE_NAME</name> ".model"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>model_module</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>sys_modules</name></expr></argument>, <argument><expr><name>modelmod_name</name></expr></argument>, <argument><expr><name>model_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* gives away the reference to model_module */</comment>
            <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"model"</expr></argument>, <argument><expr><name>model_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>modelmod_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>errors_module</name> == <name>NULL</name> || <name>model_module</name> == <name>NULL</name></expr>)</condition><then>
        <comment type="block">/* Don't core dump later! */</comment>
        <return>return;</return></then></if>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XML_COMBINED_VERSION</name> &gt; 19505</expr></cpp:if>
    <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>XML_Feature</name> *</type><name>features</name> <init>= <expr><call><name>XML_GetFeatureList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
            <comment type="block">/* just ignore it */</comment>
            <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
        <else>else <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <for>for (<init>;</init> <condition><expr><name><name>features</name><index>[<expr><name>i</name></expr>]</index></name>.<name>feature</name> != <name>XML_FEATURE_END</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"si"</expr></argument>, <argument><expr><name><name>features</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>,
                                               <argument><expr><name><name>features</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>list</name> = <name>NULL</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name>ok</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>ok</name> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>list</name> != <name>NULL</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"features"</expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></else></if>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MYCONST</name><parameter_list>(<param><type><name>name</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>PyModule_AddStringConstant(errors_module, #name, \
                               (char*)XML_ErrorString(name))</cpp:value></cpp:define>

    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_NO_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_NO_ELEMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_PARTIAL_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_TAG_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_DUPLICATE_ATTRIBUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_JUNK_AFTER_DOC_ELEMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_PARAM_ENTITY_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_ASYNC_ENTITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_BAD_CHAR_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_BINARY_ENTITY_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_MISPLACED_XML_PI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_INCORRECT_ENCODING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_NOT_STANDALONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_ENTITY_DECLARED_IN_PE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_FEATURE_REQUIRES_XML_DTD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Added in Expat 1.95.7. */</comment>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_UNBOUND_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Added in Expat 1.95.8. */</comment>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_UNDECLARING_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_INCOMPLETE_PE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_XML_DECL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_TEXT_DECL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_PUBLICID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_SUSPENDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_NOT_SUSPENDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_ABORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_FINISHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_ERROR_SUSPEND_PE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>errors_module</name></expr></argument>, <argument><expr>"__doc__"</expr></argument>,
                               <argument><expr>"Constants used to describe error conditions."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MYCONST</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MYCONST</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyModule_AddIntConstant(m, #c, c)</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_PARAM_ENTITY_PARSING_NEVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MYCONST</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MYCONST</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyModule_AddIntConstant(model_module, #c, c)</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>model_module</name></expr></argument>, <argument><expr>"__doc__"</expr></argument>,
                     <argument><expr>"Constants used to interpret content model information."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CTYPE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CTYPE_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CTYPE_MIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CTYPE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CTYPE_CHOICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CTYPE_SEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CQUANT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CQUANT_OPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CQUANT_REP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MYCONST</name><argument_list>(<argument><expr><name>XML_CQUANT_PLUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MYCONST</name></cpp:undef>

    <comment type="block">/* initialize pyexpat dispatch table */</comment>
    <expr_stmt><expr><name><name>capi</name>.<name>size</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>capi</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>magic</name></name> = <name>PyExpat_CAPI_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>MAJOR_VERSION</name></name> = <name>XML_MAJOR_VERSION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>MINOR_VERSION</name></name> = <name>XML_MINOR_VERSION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>MICRO_VERSION</name></name> = <name>XML_MICRO_VERSION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>ErrorString</name></name> = <name>XML_ErrorString</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>GetErrorCode</name></name> = <name>XML_GetErrorCode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>GetErrorColumnNumber</name></name> = <name>XML_GetErrorColumnNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>GetErrorLineNumber</name></name> = <name>XML_GetErrorLineNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>Parse</name></name> = <name>XML_Parse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>ParserCreate_MM</name></name> = <name>XML_ParserCreate_MM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>ParserFree</name></name> = <name>XML_ParserFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>SetCharacterDataHandler</name></name> = <name>XML_SetCharacterDataHandler</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>SetCommentHandler</name></name> = <name>XML_SetCommentHandler</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>SetDefaultHandlerExpand</name></name> = <name>XML_SetDefaultHandlerExpand</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>SetElementHandler</name></name> = <name>XML_SetElementHandler</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>SetNamespaceDeclHandler</name></name> = <name>XML_SetNamespaceDeclHandler</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>SetProcessingInstructionHandler</name></name> = <name>XML_SetProcessingInstructionHandler</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>SetUnknownEncodingHandler</name></name> = <name>XML_SetUnknownEncodingHandler</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>capi</name>.<name>SetUserData</name></name> = <name>XML_SetUserData</name></expr>;</expr_stmt>
    
    <comment type="block">/* export as cobject */</comment>
    <expr_stmt><expr><name>capi_object</name> = <call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr>&amp;<name>capi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>capi_object</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"expat_CAPI"</expr></argument>, <argument><expr><name>capi_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_handlers</name><parameter_list>(<param><decl><type><name>xmlparseobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>initial</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>

    <for>for (<init>;</init> <condition><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name>initial</name></expr>)</condition><then>
	    <expr_stmt><expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt></then>
	<else>else <block>{
            <expr_stmt><expr><name>temp</name> = <name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name>-&gt;<name>handlers</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>handler_info</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>setter</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>itself</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>HandlerInfo</name></type> <name><name>handler_info</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"StartElementHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetStartElementHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_StartElementHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"EndElementHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetEndElementHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_EndElementHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"ProcessingInstructionHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetProcessingInstructionHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_ProcessingInstructionHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"CharacterDataHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetCharacterDataHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_CharacterDataHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"UnparsedEntityDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetUnparsedEntityDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_UnparsedEntityDeclHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"NotationDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetNotationDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_NotationDeclHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"StartNamespaceDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetStartNamespaceDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_StartNamespaceDeclHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"EndNamespaceDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetEndNamespaceDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_EndNamespaceDeclHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"CommentHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetCommentHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_CommentHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"StartCdataSectionHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetStartCdataSectionHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_StartCdataSectionHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"EndCdataSectionHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetEndCdataSectionHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_EndCdataSectionHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"DefaultHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetDefaultHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_DefaultHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"DefaultHandlerExpand"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetDefaultHandlerExpand</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_DefaultHandlerExpandHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"NotStandaloneHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetNotStandaloneHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_NotStandaloneHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"ExternalEntityRefHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetExternalEntityRefHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_ExternalEntityRefHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"StartDoctypeDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetStartDoctypeDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_StartDoctypeDeclHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"EndDoctypeDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetEndDoctypeDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_EndDoctypeDeclHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"EntityDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetEntityDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_EntityDeclHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"XmlDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetXmlDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_XmlDeclHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"ElementDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetElementDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_ElementDeclHandler</name></expr>}</block></expr>,
    <expr><block>{<expr>"AttlistDeclHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetAttlistDeclHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_AttlistDeclHandler</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XML_COMBINED_VERSION</name> &gt;= 19504</expr></cpp:if>
    <expr><block>{<expr>"SkippedEntityHandler"</expr>,
     <expr>(<name>xmlhandlersetter</name>)<name>XML_SetSkippedEntityHandler</name></expr>,
     <expr>(<name>xmlhandler</name>)<name>my_SkippedEntityHandler</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr> <comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>
</unit>
