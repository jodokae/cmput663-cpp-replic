<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/fcntlmodule.c">
<comment type="block">/* fcntl module */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_FILE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STROPTS_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stropts.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>conv_descriptor</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>object</name></decl></param>, <param><decl><type><name>int</name> *</type><name>target</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>PyObject_AsFileDescriptor</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr>*<name>target</name> = <name>fd</name></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
}</block></function>


<comment type="block">/* fcntl(fd, opt, [arg]) */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fcntl_fcntl</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;is#:fcntl"</expr></argument>,
                             <argument><expr><name>conv_descriptor</name></expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>len</name> &gt; sizeof <name>buf</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"fcntl string arg too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>ret</name> <init>= <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arg</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
             <argument><expr>"O&amp;i|i;fcntl requires a file or file descriptor,"
             " an integer and optionally a third integer or a string"</expr></argument>, 
			      <argument><expr><name>conv_descriptor</name></expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	  <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>ret</name> <init>= <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>ret</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fcntl_doc</name></expr></argument>,
<argument><expr>"fcntl(fd, opt, [arg])\n\
\n\
Perform the requested operation on file descriptor fd.  The operation\n\
is defined by op and is operating system dependent.  These constants are\n\
available from the fcntl module.  The argument arg is optional, and\n\
defaults to 0; it may be an int or a string. If arg is given as a string,\n\
the return value of fcntl is a string of that length, containing the\n\
resulting value put in the arg buffer by the operating system.The length\n\
of the arg string is not allowed to exceed 1024 bytes. If the arg given\n\
is an integer or if none is specified, the result value is an integer\n\
corresponding to the return value of the fcntl call in the C code."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* ioctl(fd, opt, [arg]) */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fcntl_ioctl</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOCTL_BUFSZ</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<comment type="block">/* In PyArg_ParseTuple below, we use the unsigned non-checked 'I'
	   format for the 'code' parameter because Python turns 0x8000000
	   into either a large positive number (PyLong or PyInt on 64-bit
	   platforms) or a negative number on others (32-bit PyInt)
	   whereas the system expects it to be a 32bit bit field value
	   regardless of it being passed as an int or unsigned long on
	   various platforms.  See the termios.TIOCSWINSZ constant across
	   platforms for an example of thise.

	   If any of the 64bit platforms ever decide to use more than 32bits
	   in their unsigned long ioctl codes this will break and need
	   special casing based on the platform being built on.
	 */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mutate_arg</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
 	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>IOCTL_BUFSZ</name>+1</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* argument plus NUL byte */</comment>

	<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;Iw#|i:ioctl"</expr></argument>,
                             <argument><expr><name>conv_descriptor</name></expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>, 
			     <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>mutate_arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>arg</name></decl>;</decl_stmt>

	       	<if>if <condition>(<expr><name>mutate_arg</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>len</name> &lt;= <name>IOCTL_BUFSZ</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
				<expr_stmt><expr><name>arg</name> = <name>buf</name></expr>;</expr_stmt>
			}</block></then> 
			<else>else <block>{
				<expr_stmt><expr><name>arg</name> = <name>str</name></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then>
		<else>else <block>{
			<if>if <condition>(<expr><name>len</name> &gt; <name>IOCTL_BUFSZ</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"ioctl string arg too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
				<expr_stmt><expr><name>arg</name> = <name>buf</name></expr>;</expr_stmt>
			}</block></else></if>
		}</block></else></if>
		<if>if <condition>(<expr><name>buf</name> == <name>arg</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type> <comment type="block">/* think array.resize() */</comment>
			<name>ret</name> <init>= <expr><call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>ret</name> = <call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>mutate_arg</name> &amp;&amp; (<name>len</name> &lt; <name>IOCTL_BUFSZ</name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>mutate_arg</name></expr>)</condition><then> <block>{
			<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else <block>{
			<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></else></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;Is#:ioctl"</expr></argument>,
                             <argument><expr><name>conv_descriptor</name></expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>len</name> &gt; <name>IOCTL_BUFSZ</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"ioctl string arg too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>ret</name> <init>= <expr><call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>
		<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arg</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
	     <argument><expr>"O&amp;I|i;ioctl requires a file or file descriptor,"
	     " an integer and optionally an integer or buffer argument"</expr></argument>,
			      <argument><expr><name>conv_descriptor</name></expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	  <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
	<name>ret</name> <init>= <expr><call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>ret</name> = <call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>ret</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IOCTL_BUFSZ</name></cpp:undef>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ioctl_doc</name></expr></argument>,
<argument><expr>"ioctl(fd, opt[, arg[, mutate_flag]])\n\
\n\
Perform the requested operation on file descriptor fd.  The operation is\n\
defined by opt and is operating system dependent.  Typically these codes are\n\
retrieved from the fcntl or termios library modules.\n\
\n\
The argument arg is optional, and defaults to 0; it may be an int or a\n\
buffer containing character data (most likely a string or an array). \n\
\n\
If the argument is a mutable buffer (such as an array) and if the\n\
mutate_flag argument (which is only allowed in this case) is true then the\n\
buffer is (in effect) passed to the operating system and changes made by\n\
the OS will be reflected in the contents of the buffer after the call has\n\
returned.  The return value is the integer returned by the ioctl system\n\
call.\n\
\n\
If the argument is a mutable buffer and the mutable_flag argument is not\n\
passed or is false, the behavior is as if a string had been passed.  This\n\
behavior will change in future releases of Python.\n\
\n\
If the argument is an immutable buffer (most likely a string) then a copy\n\
of the buffer is passed to the operating system and the return value is a\n\
string of the same length containing whatever the operating system put in\n\
the buffer.  The length of the arg buffer in this case is not allowed to\n\
exceed 1024 bytes.\n\
\n\
If the arg given is an integer or if none is specified, the result value is\n\
an integer corresponding to the return value of the ioctl call in the C\n\
code."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* flock(fd, operation) */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fcntl_flock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;i:flock"</expr></argument>,
                              <argument><expr><name>conv_descriptor</name></expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FLOCK</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>ret</name> <init>= <expr><call><name>flock</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LOCK_SH</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_SH</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* shared lock */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_EX</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>	<comment type="block">/* exclusive lock */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_NB</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>	<comment type="block">/* don't block when locking */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_UN</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* unlock */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{
		<decl_stmt><decl><type>struct <name>flock</name></type> <name>l</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>code</name> == <name>LOCK_UN</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>l</name>.<name>l_type</name></name> = <name>F_UNLCK</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>code</name> &amp; <name>LOCK_SH</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>l</name>.<name>l_type</name></name> = <name>F_RDLCK</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>code</name> &amp; <name>LOCK_EX</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>l</name>.<name>l_type</name></name> = <name>F_WRLCK</name></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"unrecognized flock argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></else></if></else></if></else></if>
		<expr_stmt><expr><name><name>l</name>.<name>l_whence</name></name> = <name><name>l</name>.<name>l_start</name></name> = <name><name>l</name>.<name>l_len</name></name> = 0</expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>ret</name> <init>= <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>(<name>code</name> &amp; <name>LOCK_NB</name>) ? <name>F_SETLK</name> : <name>F_SETLKW</name></expr></argument>, <argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_FLOCK */</comment>
	<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>flock_doc</name></expr></argument>,
<argument><expr>"flock(fd, operation)\n\
\n\
Perform the lock operation op on file descriptor fd.  See the Unix \n\
manual page for flock(3) for details.  (On some systems, this function is\n\
emulated using fcntl().)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* lockf(fd, operation) */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fcntl_lockf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>code</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>whence</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>lenobj</name> <init>= <expr><name>NULL</name></expr></init>, *<name>startobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O&amp;i|OOi:lockf"</expr></argument>,
                              <argument><expr><name>conv_descriptor</name></expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>,
			      <argument><expr>&amp;<name>lenobj</name></expr></argument>, <argument><expr>&amp;<name>startobj</name></expr></argument>, <argument><expr>&amp;<name>whence</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_NotImplementedError</name></expr></argument>,
			<argument><expr>"lockf not supported on OS/2 (EMX)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LOCK_SH</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_SH</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* shared lock */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_EX</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>	<comment type="block">/* exclusive lock */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_NB</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>	<comment type="block">/* don't block when locking */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_UN</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* unlock */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* LOCK_SH */</comment>
	<block>{
		<decl_stmt><decl><type>struct <name>flock</name></type> <name>l</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>code</name> == <name>LOCK_UN</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>l</name>.<name>l_type</name></name> = <name>F_UNLCK</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>code</name> &amp; <name>LOCK_SH</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>l</name>.<name>l_type</name></name> = <name>F_RDLCK</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>code</name> &amp; <name>LOCK_EX</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>l</name>.<name>l_type</name></name> = <name>F_WRLCK</name></expr>;</expr_stmt></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"unrecognized lockf argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></else></if></else></if></else></if>
		<expr_stmt><expr><name><name>l</name>.<name>l_start</name></name> = <name><name>l</name>.<name>l_len</name></name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>startobj</name> != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<expr_stmt><expr><name><name>l</name>.<name>l_start</name></name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>startobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name><name>l</name>.<name>l_start</name></name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>startobj</name></expr></argument>)</argument_list></call> ?
					<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>startobj</name></expr></argument>)</argument_list></call> :
					<call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>startobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></then></if>
		<if>if <condition>(<expr><name>lenobj</name> != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<expr_stmt><expr><name><name>l</name>.<name>l_len</name></name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name><name>l</name>.<name>l_len</name></name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call> ?
					<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call> :
					<call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>lenobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr><name><name>l</name>.<name>l_whence</name></name> = <name>whence</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>ret</name> <init>= <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>(<name>code</name> &amp; <name>LOCK_NB</name>) ? <name>F_SETLK</name> : <name>F_SETLKW</name></expr></argument>, <argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
	}</block>
	<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* defined(PYOS_OS2) &amp;&amp; defined(PYCC_GCC) */</comment>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lockf_doc</name></expr></argument>,
<argument><expr>"lockf (fd, operation, length=0, start=0, whence=0)\n\
\n\
This is essentially a wrapper around the fcntl() locking calls.  fd is the\n\
file descriptor of the file to lock or unlock, and operation is one of the\n\
following values:\n\
\n\
    LOCK_UN - unlock\n\
    LOCK_SH - acquire a shared lock\n\
    LOCK_EX - acquire an exclusive lock\n\
\n\
When operation is LOCK_SH or LOCK_EX, it can also be bitwise ORed with\n\
LOCK_NB to avoid blocking on lock acquisition.  If LOCK_NB is used and the\n\
lock cannot be acquired, an IOError will be raised and the exception will\n\
have an errno attribute set to EACCES or EAGAIN (depending on the operating\n\
system -- for portability, check for either value).\n\
\n\
length is the number of bytes to lock, with the default meaning to lock to\n\
EOF.  start is the byte offset, relative to whence, to that the lock\n\
starts.  whence is as with fileobj.seek(), specifically:\n\
\n\
    0 - relative to the start of the file (SEEK_SET)\n\
    1 - relative to the current buffer position (SEEK_CUR)\n\
    2 - relative to the end of the file (SEEK_END)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* List of functions */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>fcntl_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"fcntl"</expr>,	<expr><name>fcntl_fcntl</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>fcntl_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"ioctl"</expr>,	<expr><name>fcntl_ioctl</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>ioctl_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"flock"</expr>,	<expr><name>fcntl_flock</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>flock_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"lockf"</expr>,       <expr><name>fcntl_lockf</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>lockf_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"This module performs file control and I/O control on file \n\
descriptors.  It is an interface to the fcntl() and ioctl() Unix\n\
routines.  File descriptors can be obtained with the fileno() method of\n\
a file or socket object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Module initialisation */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ins</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>d</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>symbol</name></decl></param>, <param><decl><type><name>long</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyObject</name>*</type> <name>v</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>v</name> || <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>symbol</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr>-1</expr>;</return></then></if>

        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (ins(d, #x, (long)x)) return -1</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>all_ins</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>d</name></decl></param>)</parameter_list>
<block>{
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LOCK_SH"</expr></argument>, <argument><expr>(<name>long</name>)<name>LOCK_SH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LOCK_EX"</expr></argument>, <argument><expr>(<name>long</name>)<name>LOCK_EX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LOCK_NB"</expr></argument>, <argument><expr>(<name>long</name>)<name>LOCK_NB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LOCK_UN"</expr></argument>, <argument><expr>(<name>long</name>)<name>LOCK_UN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<comment type="block">/* GNU extensions, as of glibc 2.2.4 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_MAND</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LOCK_MAND"</expr></argument>, <argument><expr>(<name>long</name>)<name>LOCK_MAND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_READ</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LOCK_READ"</expr></argument>, <argument><expr>(<name>long</name>)<name>LOCK_READ</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_WRITE</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LOCK_WRITE"</expr></argument>, <argument><expr>(<name>long</name>)<name>LOCK_WRITE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_RW</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LOCK_RW"</expr></argument>, <argument><expr>(<name>long</name>)<name>LOCK_RW</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_DUPFD</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_DUPFD"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_DUPFD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_GETFD</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_GETFD"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_GETFD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETFD</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SETFD"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SETFD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_GETFL</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_GETFL"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_GETFL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETFL</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SETFL"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SETFL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_GETLK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_GETLK"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_GETLK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETLK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SETLK"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SETLK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETLKW</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SETLKW"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SETLKW</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_GETOWN</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_GETOWN"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_GETOWN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETOWN</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SETOWN"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SETOWN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_GETSIG</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_GETSIG"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_GETSIG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETSIG</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SETSIG"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SETSIG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_RDLCK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_RDLCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_RDLCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_WRLCK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_WRLCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_WRLCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_UNLCK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_UNLCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_UNLCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* LFS constants */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_GETLK64</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_GETLK64"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_GETLK64</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETLK64</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SETLK64"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SETLK64</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETLKW64</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SETLKW64"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SETLKW64</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* GNU extensions, as of glibc 2.2.4. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASYNC</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"FASYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>FASYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETLEASE</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SETLEASE"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SETLEASE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_GETLEASE</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_GETLEASE"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_GETLEASE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_NOTIFY</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_NOTIFY"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_NOTIFY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Old BSD flock(). */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_EXLCK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_EXLCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_EXLCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SHLCK</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_SHLCK"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_SHLCK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* OS X (and maybe others) let you tell the storage device to flush to physical media */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_FULLFSYNC</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"F_FULLFSYNC"</expr></argument>, <argument><expr>(<name>long</name>)<name>F_FULLFSYNC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* For F_{GET|SET}FL */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FD_CLOEXEC</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"FD_CLOEXEC"</expr></argument>, <argument><expr>(<name>long</name>)<name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* For F_NOTIFY */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_ACCESS</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"DN_ACCESS"</expr></argument>, <argument><expr>(<name>long</name>)<name>DN_ACCESS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_MODIFY</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"DN_MODIFY"</expr></argument>, <argument><expr>(<name>long</name>)<name>DN_MODIFY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_CREATE</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"DN_CREATE"</expr></argument>, <argument><expr>(<name>long</name>)<name>DN_CREATE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_DELETE</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"DN_DELETE"</expr></argument>, <argument><expr>(<name>long</name>)<name>DN_DELETE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_RENAME</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"DN_RENAME"</expr></argument>, <argument><expr>(<name>long</name>)<name>DN_RENAME</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_ATTRIB</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"DN_ATTRIB"</expr></argument>, <argument><expr>(<name>long</name>)<name>DN_ATTRIB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_MULTISHOT</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"DN_MULTISHOT"</expr></argument>, <argument><expr>(<name>long</name>)<name>DN_MULTISHOT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STROPTS_H</name></cpp:ifdef>
	<comment type="block">/* Unix 98 guarantees that these are in stropts.h. */</comment>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_POP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_LOOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_FLUSHBAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_SETSIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_GETSIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_FIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_PEEK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_SRDOPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_GRDOPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_NREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_FDINSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_SWROPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>I_GWROPT</name></cpp:ifdef>
	<comment type="block">/* despite the comment above, old-ish glibcs miss a couple... */</comment>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_GWROPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_SENDFD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_RECVFD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_ATMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_CKBAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_GETBAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_CANPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_SETCLTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>I_GETCLTIME</name></cpp:ifdef>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_GETCLTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_LINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_UNLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_PLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INS</name><argument_list>(<argument><expr><name>I_PUNLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>initfcntl</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

	<comment type="block">/* Create the module and add the functions and documentation */</comment>
	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"fcntl"</expr></argument>, <argument><expr><name>fcntl_methods</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* Add some symbolic constants to the module */</comment>
	<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>all_ins</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
