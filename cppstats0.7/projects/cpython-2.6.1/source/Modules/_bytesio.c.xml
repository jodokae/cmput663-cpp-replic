<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_bytesio.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>PyObject_HEAD</name>
    <name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>string_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>buf_size</name></decl>;</decl_stmt>
}</block></struct></type> <name>BytesIOObject</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_CLOSED</name><parameter_list>(<param><type><name>self</name></type></param>)</parameter_list></cpp:macro>                                  \
    <cpp:value>if ((self)-&gt;buf == NULL) {                              \
        PyErr_SetString(PyExc_ValueError,                   \
                        "I/O operation on closed file.");   \
        return NULL;                                        \
    }</cpp:value></cpp:define>

<comment type="block">/* Internal routine to get a line from the buffer of a BytesIO
   object. Returns the length between the current position to the
   next newline character. */</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>get_line</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> **</type><name>output</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str_end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Move to the end of the line, up to the end of the string, s. */</comment>
    <expr_stmt><expr><name>str_end</name> = <name><name>self</name>-&gt;<name>buf</name></name> + <name><name>self</name>-&gt;<name>string_size</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>n</name> = <name><name>self</name>-&gt;<name>buf</name></name> + <name><name>self</name>-&gt;<name>pos</name></name></expr>;</init>
         <condition><expr><name>n</name> &lt; <name>str_end</name> &amp;&amp; *<name>n</name> != '\n'</expr>;</condition>
         <incr><expr><name>n</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>

    <comment type="block">/* Skip the newline character */</comment>
    <if>if <condition>(<expr><name>n</name> &lt; <name>str_end</name></expr>)</condition><then>
        <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if>

    <comment type="block">/* Get the length from the current position to the end of the line. */</comment>
    <expr_stmt><expr><name>len</name> = <name>n</name> - (<name><name>self</name>-&gt;<name>buf</name></name> + <name><name>self</name>-&gt;<name>pos</name></name>)</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>output</name> = <name><name>self</name>-&gt;<name>buf</name></name> + <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name> &lt; <name>PY_SSIZE_T_MAX</name> - <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>len</name></expr>;</expr_stmt>

    <return>return <expr><name>len</name></expr>;</return>
}</block></function>

<comment type="block">/* Internal routine for changing the size of the buffer of BytesIO objects.
   The caller should ensure that the 'size' argument is non-negative.  Returns
   0 on success, -1 otherwise. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>resize_buffer</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Here, unsigned types are used to avoid dealing with signed integer
       overflow, which is undefined in C. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>alloc</name> <init>= <expr><name><name>self</name>-&gt;<name>buf_size</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>new_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* For simplicity, stay in the range of the signed type. Anyway, Python
       doesn't allow strings to be longer than this. */</comment>
    <if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then>
        <goto>goto <name>overflow</name>;</goto></then></if>

    <if>if <condition>(<expr><name>size</name> &lt; <name>alloc</name> / 2</expr>)</condition><then> <block>{
        <comment type="block">/* Major downsize; resize down to exact size. */</comment>
        <expr_stmt><expr><name>alloc</name> = <name>size</name> + 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>size</name> &lt; <name>alloc</name></expr>)</condition><then> <block>{
        <comment type="block">/* Within allocated size; quick exit */</comment>
        <return>return <expr>0</expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>size</name> &lt;= <name>alloc</name> * 1.125</expr>)</condition><then> <block>{
        <comment type="block">/* Moderate upsize; overallocate similar to list_resize() */</comment>
        <expr_stmt><expr><name>alloc</name> = <name>size</name> + (<name>size</name> &gt;&gt; 3) + (<name>size</name> &lt; 9 ? 3 : 6)</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* Major upsize; resize up to exact size */</comment>
        <expr_stmt><expr><name>alloc</name> = <name>size</name> + 1</expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>

    <if>if <condition>(<expr><name>alloc</name> &gt; ((<name>size_t</name>)-1) / <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
        <goto>goto <name>overflow</name>;</goto></then></if>
    <expr_stmt><expr><name>new_buf</name> = (<name>char</name> *)<call><name>PyMem_Realloc</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>alloc</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>new_buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>buf_size</name></name> = <name>alloc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>buf</name></name> = <name>new_buf</name></expr>;</expr_stmt>

    <return>return <expr>0</expr>;</return>

  <label><name>overflow</name>:</label>
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
                    <argument><expr>"new buffer size too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* Internal routine for writing a string of bytes to the buffer of a BytesIO
   object. Returns the number of bytes wrote, or -1 on error. */</comment>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>write_bytes</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>size_t</name>)<name><name>self</name>-&gt;<name>pos</name></name> + <name>len</name> &gt; <name><name>self</name>-&gt;<name>buf_size</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>resize_buffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name><name>self</name>-&gt;<name>pos</name></name> + <name>len</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>pos</name></name> &gt; <name><name>self</name>-&gt;<name>string_size</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* In case of overseek, pad with null bytes the buffer region between
           the end of stream and the current position.

          0   lo      string_size                           hi
          |   |&lt;---used---&gt;|&lt;----------available-----------&gt;|
          |   |            &lt;--to pad--&gt;|&lt;---to write---&gt;    |
          0   buf                   position
        */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name> + <name><name>self</name>-&gt;<name>string_size</name></name></expr></argument>, <argument><expr>'\0'</expr></argument>,
               <argument><expr>(<name><name>self</name>-&gt;<name>pos</name></name> - <name><name>self</name>-&gt;<name>string_size</name></name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Copy the data to the internal buffer, overwriting some of the existing
       data if self-&gt;pos &lt; self-&gt;string_size. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name> + <name><name>self</name>-&gt;<name>pos</name></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* Set the new length of the internal string if it has changed. */</comment>
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>string_size</name></name> &lt; <name><name>self</name>-&gt;<name>pos</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>self</name>-&gt;<name>string_size</name></name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>len</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_get_closed</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buf</name></name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></else></if>
}</block></function>

<comment type="block">/* Generic getter for the writable, readable and seekable properties */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>return_true</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>flush_doc</name></expr></argument>,
<argument><expr>"flush() -&gt; None.  Does nothing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_flush</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getval_doc</name></expr></argument>,
<argument><expr>"getvalue() -&gt; bytes.\n"
"\n"
"Retrieve the entire contents of the BytesIO object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_getvalue</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>string_size</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isatty_doc</name></expr></argument>,
<argument><expr>"isatty() -&gt; False.\n"
"\n"
"Always returns False since BytesIO objects are not connected\n"
"to a tty-like device."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_isatty</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>tell_doc</name></expr></argument>,
<argument><expr>"tell() -&gt; current file position, an integer\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_tell</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>read_doc</name></expr></argument>,
<argument><expr>"read([size]) -&gt; read at most size bytes, returned as a string.\n"
"\n"
"If the size argument is negative, read until EOF is reached.\n"
"Return an empty string at EOF."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_read</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>output</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:read"</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>size</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>size</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
        <comment type="block">/* Read until EOF is reached, by default. */</comment>
        <expr_stmt><expr><name>size</name> = -1</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"integer argument expected, got '%s'"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></else></if></else></if>

    <comment type="block">/* adjust invalid sizes */</comment>
    <expr_stmt><expr><name>n</name> = <name><name>self</name>-&gt;<name>string_size</name></name> - <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>size</name> &lt; 0 || <name>size</name> &gt; <name>n</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>size</name> = <name>n</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then>
            <expr_stmt><expr><name>size</name> = 0</expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>output</name> = <name><name>self</name>-&gt;<name>buf</name></name> + <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>size</name></expr>;</expr_stmt>

    <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>read1_doc</name></expr></argument>,
<argument><expr>"read1(size) -&gt; read at most size bytes, returned as a string.\n"
"\n"
"If the size argument is negative or omitted, read until EOF is reached.\n"
"Return an empty string at EOF."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_read1</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>arg</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>arg</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>res</name>  = <call><name>bytesio_read</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>readline_doc</name></expr></argument>,
<argument><expr>"readline([size]) -&gt; next line from the file, as a string.\n"
"\n"
"Retain newline.  A non-negative size argument limits the maximum\n"
"number of bytes to return (an incomplete line may be returned then).\n"
"Return an empty string at EOF.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_readline</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>output</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:readline"</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>size</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>size</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
        <comment type="block">/* No size limit, by default. */</comment>
        <expr_stmt><expr><name>size</name> = -1</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"integer argument expected, got '%s'"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></else></if></else></if>

    <expr_stmt><expr><name>n</name> = <call><name>get_line</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>size</name> &gt;= 0 &amp;&amp; <name>size</name> &lt; <name>n</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>size</name> = <name>n</name> - <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> -= <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> -= <name>size</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>readlines_doc</name></expr></argument>,
<argument><expr>"readlines([size]) -&gt; list of strings, each a line from the file.\n"
"\n"
"Call readline() repeatedly and return a list of the lines so read.\n"
"The optional size argument, if given, is an approximate bound on the\n"
"total number of bytes in the lines returned.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_readlines</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxsize</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>, *<decl><type ref="prev"/><name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>output</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:readlines"</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>maxsize</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>maxsize</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
        <comment type="block">/* No size limit, by default. */</comment>
        <expr_stmt><expr><name>maxsize</name> = -1</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"integer argument expected, got '%s'"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></else></if></else></if>

    <expr_stmt><expr><name>size</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <while>while <condition>(<expr>(<name>n</name> = <call><name>get_line</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>output</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition> <block>{
        <expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>line</name></expr>)</condition><then>
            <goto>goto <name>on_error</name>;</goto></then></if>
        <if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>on_error</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> += <name>n</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>maxsize</name> &gt; 0 &amp;&amp; <name>size</name> &gt;= <name>maxsize</name></expr>)</condition><then>
            <break>break;</break></then></if>
    }</block></while>
    <return>return <expr><name>result</name></expr>;</return>

  <label><name>on_error</name>:</label>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>readinto_doc</name></expr></argument>,
<argument><expr>"readinto(bytearray) -&gt; int.  Read up to len(b) bytes into b.\n"
"\n"
"Returns number of bytes read (0 for EOF), or None if the object\n"
"is set not to block as has no data to read."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_readinto</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>buffer</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>raw_buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>PyObject_AsWriteBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name>raw_buffer</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>pos</name></name> + <name>len</name> &gt; <name><name>self</name>-&gt;<name>string_size</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>len</name> = <name><name>self</name>-&gt;<name>string_size</name></name> - <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>raw_buffer</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>buf</name></name> + <name><name>self</name>-&gt;<name>pos</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name> + <name>len</name> &lt; <name>PY_SSIZE_T_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> += <name>len</name></expr>;</expr_stmt>

    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>truncate_doc</name></expr></argument>,
<argument><expr>"truncate([size]) -&gt; int.  Truncate the file to at most size bytes.\n"
"\n"
"Size defaults to the current file position, as returned by tell().\n"
"Returns the new size.  Imply an absolute seek to the position size."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_truncate</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:truncate"</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>size</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>size</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then> <block>{
        <comment type="block">/* Truncate to current position if no argument is passed. */</comment>
        <expr_stmt><expr><name>size</name> = <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"integer argument expected, got '%s'"</expr></argument>,
                     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></else></if></else></if>

    <if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
                     <argument><expr>"negative size value %zd"</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>size</name> &lt; <name><name>self</name>-&gt;<name>string_size</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>self</name>-&gt;<name>string_size</name></name> = <name>size</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>resize_buffer</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> = <name>size</name></expr>;</expr_stmt>

    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_iternext</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>n</name> = <call><name>get_line</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>next</name> || <name>n</name> == 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>seek_doc</name></expr></argument>,
<argument><expr>"seek(pos, whence=0) -&gt; int.  Change stream position.\n"
"\n"
"Seek to byte offset pos relative to position indicated by whence:\n"
"     0  Start of stream (the default).  pos should be &gt;= 0;\n"
"     1  Current position - pos may be negative;\n"
"     2  End of stream - pos usually negative.\n"
"Returns the new absolute position."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_seek</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>pos_obj</name></decl>, *<decl><type ref="prev"/><name>mode_obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Special-case for 2.x to prevent floats from passing through.
       This only needed to make a test in test_io succeed. */</comment>
    <if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"seek"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>pos_obj</name></expr></argument>, <argument><expr>&amp;<name>mode_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>pos_obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                        <argument><expr>"position argument must be an integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|i:seek"</expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>pos</name> &lt; 0 &amp;&amp; <name>mode</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
                     <argument><expr>"negative seek value %zd"</expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* mode 0: offset relative to beginning of the string.
       mode 1: offset relative to current position.
       mode 2: offset relative the end of the string. */</comment>
    <if>if <condition>(<expr><name>mode</name> == 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>pos</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name><name>self</name>-&gt;<name>pos</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
                            <argument><expr>"new position too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>pos</name> += <name><name>self</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>mode</name> == 2</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>pos</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name><name>self</name>-&gt;<name>string_size</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
                            <argument><expr>"new position too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>pos</name> += <name><name>self</name>-&gt;<name>string_size</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>mode</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
                     <argument><expr>"invalid whence (%i, should be 0, 1 or 2)"</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if></else></if></else></if>

    <if>if <condition>(<expr><name>pos</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>pos</name> = 0</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> = <name>pos</name></expr>;</expr_stmt>

    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>pos</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>write_doc</name></expr></argument>,
<argument><expr>"write(bytes) -&gt; int.  Write bytes to file.\n"
"\n"
"Return the number of bytes written."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_write</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Special-case in 2.x to prevent unicode objects to pass through. */</comment>
    <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
                        <argument><expr>"expecting a bytes object, got unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>PyObject_AsReadBuffer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>(<name>void</name> *)&amp;<name>bytes</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>size</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>n</name> = <call><name>write_bytes</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>writelines_doc</name></expr></argument>,
<argument><expr>"writelines(sequence_of_strings) -&gt; None.  Write strings to the file.\n"
"\n"
"Note that newlines are not added.  The sequence can be any iterable\n"
"object producing strings. This is equivalent to calling write() for\n"
"each string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_writelines</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_CLOSED</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <while>while <condition>(<expr>(<name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>ret</name> = <call><name>bytesio_write</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* See if PyIter_Next failed */</comment>
    <if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>close_doc</name></expr></argument>,
<argument><expr>"close() -&gt; None.  Disable all I/O operations."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_close</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bytesio_dealloc</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bytesio_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> != <name>NULL</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_alloc</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>self</name> = (<name>BytesIOObject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>self</name>-&gt;<name>string_size</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>buf_size</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>buf</name></name> = (<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>self</name>-&gt;<name>buf</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytesio_init</name><parameter_list>(<param><decl><type><name>BytesIOObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>initvalue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|O:BytesIO"</expr></argument>, <argument><expr>&amp;<name>initvalue</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <comment type="block">/* In case, __init__ is called multiple times. */</comment>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>string_size</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>initvalue</name> &amp;&amp; <name>initvalue</name> != <name>Py_None</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>res</name> = <call><name>bytesio_write</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>initvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name>-&gt;<name>pos</name></name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>bytesio_getsetlist</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"closed"</expr>,  <expr>(<name>getter</name>)<name>bytesio_get_closed</name></expr>, <expr><name>NULL</name></expr>,
     <expr>"True if the file is closed."</expr>}</block></expr>,
    <expr><block>{<expr>0</expr>}</block></expr>,            <comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>bytesio_methods</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"readable"</expr>,   <expr>(<name>PyCFunction</name>)<name>return_true</name></expr>,        <expr><name>METH_NOARGS</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr>"seekable"</expr>,   <expr>(<name>PyCFunction</name>)<name>return_true</name></expr>,        <expr><name>METH_NOARGS</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr>"writable"</expr>,   <expr>(<name>PyCFunction</name>)<name>return_true</name></expr>,        <expr><name>METH_NOARGS</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr>"close"</expr>,      <expr>(<name>PyCFunction</name>)<name>bytesio_close</name></expr>,      <expr><name>METH_NOARGS</name></expr>, <expr><name>close_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"flush"</expr>,      <expr>(<name>PyCFunction</name>)<name>bytesio_flush</name></expr>,      <expr><name>METH_NOARGS</name></expr>, <expr><name>flush_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"isatty"</expr>,     <expr>(<name>PyCFunction</name>)<name>bytesio_isatty</name></expr>,     <expr><name>METH_NOARGS</name></expr>, <expr><name>isatty_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"tell"</expr>,       <expr>(<name>PyCFunction</name>)<name>bytesio_tell</name></expr>,       <expr><name>METH_NOARGS</name></expr>, <expr><name>tell_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"write"</expr>,      <expr>(<name>PyCFunction</name>)<name>bytesio_write</name></expr>,      <expr><name>METH_O</name></expr>, <expr><name>write_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"writelines"</expr>, <expr>(<name>PyCFunction</name>)<name>bytesio_writelines</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>writelines_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"read1"</expr>,      <expr>(<name>PyCFunction</name>)<name>bytesio_read1</name></expr>,      <expr><name>METH_O</name></expr>, <expr><name>read1_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"readinto"</expr>,   <expr>(<name>PyCFunction</name>)<name>bytesio_readinto</name></expr>,   <expr><name>METH_O</name></expr>, <expr><name>readinto_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"readline"</expr>,   <expr>(<name>PyCFunction</name>)<name>bytesio_readline</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>readline_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"readlines"</expr>,  <expr>(<name>PyCFunction</name>)<name>bytesio_readlines</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>readlines_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"read"</expr>,       <expr>(<name>PyCFunction</name>)<name>bytesio_read</name></expr>,       <expr><name>METH_VARARGS</name></expr>, <expr><name>read_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"getvalue"</expr>,   <expr>(<name>PyCFunction</name>)<name>bytesio_getvalue</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>getval_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"seek"</expr>,       <expr>(<name>PyCFunction</name>)<name>bytesio_seek</name></expr>,       <expr><name>METH_VARARGS</name></expr>, <expr><name>seek_doc</name></expr>}</block></expr>,
    <expr><block>{<expr>"truncate"</expr>,   <expr>(<name>PyCFunction</name>)<name>bytesio_truncate</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>truncate_doc</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>        <comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bytesio_doc</name></expr></argument>,
<argument><expr>"BytesIO([buffer]) -&gt; object\n"
"\n"
"Create a buffered I/O implementation using an in-memory bytes\n"
"buffer, ready for reading and writing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>BytesIO_Type</name> <init>= <expr><block>{
    <expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
    "_bytesio._BytesIO"</expr>,                       <comment type="block">/*tp_name*/</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>BytesIOObject</name></expr></argument>)</argument_list></sizeof></expr>,                     <comment type="block">/*tp_basicsize*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_itemsize*/</comment>
    <expr>(<name>destructor</name>)<name>bytesio_dealloc</name></expr>,               <comment type="block">/*tp_dealloc*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_print*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_getattr*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_setattr*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_compare*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_repr*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_as_number*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_as_sequence*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_as_mapping*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_hash*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_call*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_str*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_getattro*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_setattro*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_as_buffer*/</comment>
    <expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>,  <comment type="block">/*tp_flags*/</comment>
    <expr><name>bytesio_doc</name></expr>,                               <comment type="block">/*tp_doc*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_traverse*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_clear*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_richcompare*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_weaklistoffset*/</comment>
    <expr><name>PyObject_SelfIter</name></expr>,                         <comment type="block">/*tp_iter*/</comment>
    <expr>(<name>iternextfunc</name>)<name>bytesio_iternext</name></expr>,            <comment type="block">/*tp_iternext*/</comment>
    <expr><name>bytesio_methods</name></expr>,                           <comment type="block">/*tp_methods*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_members*/</comment>
    <expr><name>bytesio_getsetlist</name></expr>,                        <comment type="block">/*tp_getset*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_base*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_dict*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_descr_get*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_descr_set*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_dictoffset*/</comment>
    <expr>(<name>initproc</name>)<name>bytesio_init</name></expr>,                    <comment type="block">/*tp_init*/</comment>
    <expr>0</expr>,                                         <comment type="block">/*tp_alloc*/</comment>
    <expr><name>bytesio_new</name></expr>,                               <comment type="block">/*tp_new*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_bytesio</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>BytesIO_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><name>m</name> = <call><name>Py_InitModule</name><argument_list>(<argument><expr>"_bytesio"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>BytesIO_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_BytesIO"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>BytesIO_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
