<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/cjkcodecs/_codecs_cn.c"><comment type="block">/*
 * _codecs_cn.c: Codecs collection for Mainland Chinese encodings
 *
 * Written by Hye-Shik Chang &lt;perky@FreeBSD.org&gt;
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cjkcodecs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mappings_cn.h"</cpp:file></cpp:include>

<comment type="block">/**
 * hz is predefined as 100 on AIX. So we undefine it to avoid
 * conflict against hz codec's.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_AIX</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>hz</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* GBK and GB2312 map differently in few codepoints that are listed below:
 *
 *		gb2312				gbk
 * A1A4		U+30FB KATAKANA MIDDLE DOT	U+00B7 MIDDLE DOT
 * A1AA		U+2015 HORIZONTAL BAR		U+2014 EM DASH
 * A844		undefined			U+2015 HORIZONTAL BAR
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GBK_DECODE</name><parameter_list>(<param><type><name>dc1</name></type></param>, <param><type><name>dc2</name></type></param>, <param><type><name>assi</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>if ((dc1) == 0xa1 &amp;&amp; (dc2) == 0xaa) (assi) = 0x2014; \
	else if ((dc1) == 0xa8 &amp;&amp; (dc2) == 0x44) (assi) = 0x2015; \
	else if ((dc1) == 0xa1 &amp;&amp; (dc2) == 0xa4) (assi) = 0x00b7; \
	else TRYMAP_DEC(gb2312, assi, dc1 ^ 0x80, dc2 ^ 0x80); \
	else TRYMAP_DEC(gbkext, assi, dc1, dc2);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GBK_ENCODE</name><parameter_list>(<param><type><name>code</name></type></param>, <param><type><name>assi</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>if ((code) == 0x2014) (assi) = 0xa1aa; \
	else if ((code) == 0x2015) (assi) = 0xa844; \
	else if ((code) == 0x00b7) (assi) = 0xa1a4; \
	else if ((code) != 0x30fb &amp;&amp; TRYMAP_ENC_COND(gbcommon, assi, code));</cpp:value></cpp:define>

<comment type="block">/*
 * GB2312 codec
 */</comment>

<macro><name>ENCODER</name><argument_list>(<argument>gb2312</argument>)</argument_list></macro>
<block>{
	<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr><name>IN1</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBCHAR</name></type> <name>code</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then> <block>{
			<macro><name>WRITE1</name><argument_list>(<argument>(unsigned char)c</argument>)</argument_list></macro>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
			<continue>continue;</continue>
		}</block></then></if>
		<macro><name>UCS4INVALID</name><argument_list>(<argument>c</argument>)</argument_list></macro>

		<macro><name>REQUIRE_OUTBUF</name><argument_list>(<argument>2</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>TRYMAP_ENC</name><argument_list>(<argument><expr><name>gbcommon</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<else>else <return>return <expr>1</expr>;</return></else>

		<if>if <condition>(<expr><name>code</name> &amp; 0x8000</expr>)</condition><then> <comment type="block">/* MSB set: GBK */</comment>
			<return>return <expr>1</expr>;</return></then></if>

		<macro><name>OUT1</name><argument_list>(<argument>(code &gt;&gt; 8) | 0x80</argument>)</argument_list></macro>
		<macro><name>OUT2</name><argument_list>(<argument>(code &amp; 0xFF) | 0x80</argument>)</argument_list></macro>
		<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>2</argument>)</argument_list></macro>
	}</block></while>

	<return>return <expr>0</expr>;</return>
}</block>

<macro><name>DECODER</name><argument_list>(<argument>gb2312</argument>)</argument_list></macro>
<block>{
	<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr>**<name>inbuf</name></expr></init></decl>;</decl_stmt>

		<macro><name>REQUIRE_OUTBUF</name><argument_list>(<argument>1</argument>)</argument_list></macro>

		<if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then> <block>{
			<macro><name>OUT1</name><argument_list>(<argument>c</argument>)</argument_list></macro>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
			<continue>continue;</continue>
		}</block></then></if>

		<macro><name>REQUIRE_INBUF</name><argument_list>(<argument>2</argument>)</argument_list></macro>
		<macro><name>TRYMAP_DEC</name><argument_list>(<argument>gb2312</argument>, <argument>**outbuf</argument>, <argument>c ^ 0x80</argument>, <argument>IN2 ^ 0x80</argument>)</argument_list></macro> <block>{
			<macro><name>NEXT</name><argument_list>(<argument>2</argument>, <argument>1</argument>)</argument_list></macro>
		}</block>
		<else>else <return>return <expr>2</expr>;</return></else>
	}</block></while>

	<return>return <expr>0</expr>;</return>
}</block>


<comment type="block">/*
 * GBK codec
 */</comment>

<macro><name>ENCODER</name><argument_list>(<argument>gbk</argument>)</argument_list></macro>
<block>{
	<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr><name>IN1</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBCHAR</name></type> <name>code</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then> <block>{
			<macro><name>WRITE1</name><argument_list>(<argument>(unsigned char)c</argument>)</argument_list></macro>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
			<continue>continue;</continue>
		}</block></then></if>
		<macro><name>UCS4INVALID</name><argument_list>(<argument>c</argument>)</argument_list></macro>

		<macro><name>REQUIRE_OUTBUF</name><argument_list>(<argument>2</argument>)</argument_list></macro>

		<macro><name>GBK_ENCODE</name><argument_list>(<argument>c</argument>, <argument>code</argument>)</argument_list></macro>
		<else>else <return>return <expr>1</expr>;</return></else>

		<macro><name>OUT1</name><argument_list>(<argument>(code &gt;&gt; 8) | 0x80</argument>)</argument_list></macro>
		<if>if <condition>(<expr><name>code</name> &amp; 0x8000</expr>)</condition><then>
			<macro><name>OUT2</name><argument_list>(<argument>(code &amp; 0xFF)</argument>)</argument_list></macro></then> <comment type="block">/* MSB set: GBK */</comment>
		<else>else
			<macro><name>OUT2</name><argument_list>(<argument>(code &amp; 0xFF) | 0x80</argument>)</argument_list></macro> <comment type="block">/* MSB unset: GB2312 */</comment>
		<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>2</argument>)</argument_list></macro></else></if>
	}</block></while>

	<return>return <expr>0</expr>;</return>
}</block>

<macro><name>DECODER</name><argument_list>(<argument>gbk</argument>)</argument_list></macro>
<block>{
	<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><name>IN1</name></expr></init></decl>;</decl_stmt>

		<macro><name>REQUIRE_OUTBUF</name><argument_list>(<argument>1</argument>)</argument_list></macro>

		<if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then> <block>{
			<macro><name>OUT1</name><argument_list>(<argument>c</argument>)</argument_list></macro>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
			<continue>continue;</continue>
		}</block></then></if>

		<macro><name>REQUIRE_INBUF</name><argument_list>(<argument>2</argument>)</argument_list></macro>

		<macro><name>GBK_DECODE</name><argument_list>(<argument>c</argument>, <argument>IN2</argument>, <argument>**outbuf</argument>)</argument_list></macro>
		<else>else <return>return <expr>2</expr>;</return></else>

		<macro><name>NEXT</name><argument_list>(<argument>2</argument>, <argument>1</argument>)</argument_list></macro>
	}</block></while>

	<return>return <expr>0</expr>;</return>
}</block>


<comment type="block">/*
 * GB18030 codec
 */</comment>

<macro><name>ENCODER</name><argument_list>(<argument>gb18030</argument>)</argument_list></macro>
<block>{
	<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>ucs4_t</name></type> <name>c</name> <init>= <expr><name>IN1</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBCHAR</name></type> <name>code</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then> <block>{
			<macro><name>WRITE1</name><argument_list>(<argument>c</argument>)</argument_list></macro>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
			<continue>continue;</continue>
		}</block></then></if>

		<macro><name>DECODE_SURROGATE</name><argument_list>(<argument>c</argument>)</argument_list></macro>
		<if>if <condition>(<expr><name>c</name> &gt; 0x10FFFF</expr>)</condition><then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Py_UNICODE_SIZE</name> == 2</expr></cpp:if>
			<return>return <expr>2</expr>;</return></then></if> <comment type="block">/* surrogates pair */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<return>return <expr>1</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<else>else <if>if <condition>(<expr><name>c</name> &gt;= 0x10000</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>ucs4_t</name></type> <name>tc</name> <init>= <expr><name>c</name> - 0x10000</expr></init></decl>;</decl_stmt>

			<macro><name>REQUIRE_OUTBUF</name><argument_list>(<argument>4</argument>)</argument_list></macro>

			<macro><name>OUT4</name><argument_list>(<argument>(unsigned char)(tc % 10) + 0x30</argument>)</argument_list></macro>
			<expr_stmt><expr><name>tc</name> /= 10</expr>;</expr_stmt>
			<macro><name>OUT3</name><argument_list>(<argument>(unsigned char)(tc % 126) + 0x81</argument>)</argument_list></macro>
			<expr_stmt><expr><name>tc</name> /= 126</expr>;</expr_stmt>
			<macro><name>OUT2</name><argument_list>(<argument>(unsigned char)(tc % 10) + 0x30</argument>)</argument_list></macro>
			<expr_stmt><expr><name>tc</name> /= 10</expr>;</expr_stmt>
			<macro><name>OUT1</name><argument_list>(<argument>(unsigned char)(tc + 0x90)</argument>)</argument_list></macro>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Py_UNICODE_SIZE</name> == 2</expr></cpp:if>
			<macro><name>NEXT</name><argument_list>(<argument>2</argument>, <argument>4</argument>)</argument_list></macro> <comment type="block">/* surrogates pair */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>4</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<continue>continue;</continue>
		}</block></then></if></else>

		<macro><name>REQUIRE_OUTBUF</name><argument_list>(<argument>2</argument>)</argument_list></macro>

		<macro><name>GBK_ENCODE</name><argument_list>(<argument>c</argument>, <argument>code</argument>)</argument_list></macro>
		<else>else <expr_stmt><expr><call><name>TRYMAP_ENC</name><argument_list>(<argument><expr><name>gb18030ext</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else>
		<else>else <block>{
			<decl_stmt><decl><type><specifier>const</specifier> struct <name>_gb18030_to_unibmp_ranges</name> *</type><name>utrrange</name></decl>;</decl_stmt>

			<macro><name>REQUIRE_OUTBUF</name><argument_list>(<argument>4</argument>)</argument_list></macro>

			<for>for (<init><expr><name>utrrange</name> = <name>gb18030_to_unibmp_ranges</name></expr>;</init>
			     <condition><expr><name><name>utrrange</name>-&gt;<name>first</name></name> != 0</expr>;</condition>
			     <incr><expr><name>utrrange</name>++</expr></incr>)
				<if>if <condition>(<expr><name><name>utrrange</name>-&gt;<name>first</name></name> &lt;= <name>c</name> &amp;&amp;
				    <name>c</name> &lt;= <name><name>utrrange</name>-&gt;<name>last</name></name></expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>tc</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>tc</name> = <name>c</name> - <name><name>utrrange</name>-&gt;<name>first</name></name> +
					     <name><name>utrrange</name>-&gt;<name>base</name></name></expr>;</expr_stmt>

					<macro><name>OUT4</name><argument_list>(<argument>(unsigned char)(tc % 10) + 0x30</argument>)</argument_list></macro>
					<expr_stmt><expr><name>tc</name> /= 10</expr>;</expr_stmt>
					<macro><name>OUT3</name><argument_list>(<argument>(unsigned char)(tc % 126) + 0x81</argument>)</argument_list></macro>
					<expr_stmt><expr><name>tc</name> /= 126</expr>;</expr_stmt>
					<macro><name>OUT2</name><argument_list>(<argument>(unsigned char)(tc % 10) + 0x30</argument>)</argument_list></macro>
					<expr_stmt><expr><name>tc</name> /= 10</expr>;</expr_stmt>
					<macro><name>OUT1</name><argument_list>(<argument>(unsigned char)tc + 0x81</argument>)</argument_list></macro>

					<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>4</argument>)</argument_list></macro>
					<break>break;</break>
				}</block></then></if></for>

			<if>if <condition>(<expr><name><name>utrrange</name>-&gt;<name>first</name></name> == 0</expr>)</condition><then>
				<return>return <expr>1</expr>;</return></then></if>
			<continue>continue;</continue>
		}</block></else>

		<macro><name>OUT1</name><argument_list>(<argument>(code &gt;&gt; 8) | 0x80</argument>)</argument_list></macro>
		<if>if <condition>(<expr><name>code</name> &amp; 0x8000</expr>)</condition><then>
			<macro><name>OUT2</name><argument_list>(<argument>(code &amp; 0xFF)</argument>)</argument_list></macro></then> <comment type="block">/* MSB set: GBK or GB18030ext */</comment>
		<else>else
			<macro><name>OUT2</name><argument_list>(<argument>(code &amp; 0xFF) | 0x80</argument>)</argument_list></macro> <comment type="block">/* MSB unset: GB2312 */</comment>

		<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>2</argument>)</argument_list></macro></else></if>
	}</block></while>

	<return>return <expr>0</expr>;</return>
}</block>

<macro><name>DECODER</name><argument_list>(<argument>gb18030</argument>)</argument_list></macro>
<block>{
	<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><name>IN1</name></expr></init>, <name>c2</name></decl>;</decl_stmt>

		<macro><name>REQUIRE_OUTBUF</name><argument_list>(<argument>1</argument>)</argument_list></macro>

		<if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then> <block>{
			<macro><name>OUT1</name><argument_list>(<argument>c</argument>)</argument_list></macro>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
			<continue>continue;</continue>
		}</block></then></if>

		<macro><name>REQUIRE_INBUF</name><argument_list>(<argument>2</argument>)</argument_list></macro>

		<expr_stmt><expr><name>c2</name> = <name>IN2</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c2</name> &gt;= 0x30 &amp;&amp; <name>c2</name> &lt;= 0x39</expr>)</condition><then> <block>{ <comment type="block">/* 4 bytes seq */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> struct <name>_gb18030_to_unibmp_ranges</name> *</type><name>utr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c3</name></decl>, <decl><type ref="prev"/><name>c4</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ucs4_t</name></type> <name>lseq</name></decl>;</decl_stmt>

			<macro><name>REQUIRE_INBUF</name><argument_list>(<argument>4</argument>)</argument_list></macro>
			<expr_stmt><expr><name>c3</name> = <name>IN3</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>c4</name> = <name>IN4</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> &lt; 0x81 || <name>c3</name> &lt; 0x81 || <name>c4</name> &lt; 0x30 || <name>c4</name> &gt; 0x39</expr>)</condition><then>
				<return>return <expr>4</expr>;</return></then></if>
			<expr_stmt><expr><name>c</name> -= 0x81</expr>;</expr_stmt>  <expr_stmt><expr><name>c2</name> -= 0x30</expr>;</expr_stmt>
			<expr_stmt><expr><name>c3</name> -= 0x81</expr>;</expr_stmt> <expr_stmt><expr><name>c4</name> -= 0x30</expr>;</expr_stmt>

			<if>if <condition>(<expr><name>c</name> &lt; 4</expr>)</condition><then> <block>{ <comment type="block">/* U+0080 - U+FFFF */</comment>
				<expr_stmt><expr><name>lseq</name> = ((<name>ucs4_t</name>)<name>c</name> * 10 + <name>c2</name>) * 1260 +
					(<name>ucs4_t</name>)<name>c3</name> * 10 + <name>c4</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>lseq</name> &lt; 39420</expr>)</condition><then> <block>{
					<for>for (<init><expr><name>utr</name> = <name>gb18030_to_unibmp_ranges</name></expr>;</init>
					     <condition><expr><name>lseq</name> &gt;= (<name>utr</name> + 1)-&gt;<name>base</name></expr>;</condition>
					     <incr><expr><name>utr</name>++</expr></incr>) <empty_stmt>;</empty_stmt></for>
					<macro><name>OUT1</name><argument_list>(<argument>utr-&gt;first - utr-&gt;base + lseq</argument>)</argument_list></macro>
					<macro><name>NEXT</name><argument_list>(<argument>4</argument>, <argument>1</argument>)</argument_list></macro>
					<continue>continue;</continue>
				}</block></then></if>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>c</name> &gt;= 15</expr>)</condition><then> <block>{ <comment type="block">/* U+10000 - U+10FFFF */</comment>
				<expr_stmt><expr><name>lseq</name> = 0x10000 + (((<name>ucs4_t</name>)<name>c</name>-15) * 10 + <name>c2</name>)
					* 1260 + (<name>ucs4_t</name>)<name>c3</name> * 10 + <name>c4</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>lseq</name> &lt;= 0x10FFFF</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>WRITEUCS4</name><argument_list>(<argument><expr><name>lseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<macro><name>NEXT_IN</name><argument_list>(<argument>4</argument>)</argument_list></macro>
					<continue>continue;</continue>
				}</block></then></if>
			}</block></then></if></else></if>
			<return>return <expr>4</expr>;</return>
		}</block></then></if>

		<macro><name>GBK_DECODE</name><argument_list>(<argument>c</argument>, <argument>c2</argument>, <argument>**outbuf</argument>)</argument_list></macro>
		<else>else <expr_stmt><expr><call><name>TRYMAP_DEC</name><argument_list>(<argument><expr><name>gb18030ext</name></expr></argument>, <argument><expr>**<name>outbuf</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else>
		<else>else <return>return <expr>2</expr>;</return></else>

		<macro><name>NEXT</name><argument_list>(<argument>2</argument>, <argument>1</argument>)</argument_list></macro>
	}</block></while>

	<return>return <expr>0</expr>;</return>
}</block>


<comment type="block">/*
 * HZ codec
 */</comment>

<macro><name>ENCODER_INIT</name><argument_list>(<argument>hz</argument>)</argument_list></macro>
<block>{
	<expr_stmt><expr><name><name>state</name>-&gt;<name>i</name></name> = 0</expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block>

<macro><name>ENCODER_RESET</name><argument_list>(<argument>hz</argument>)</argument_list></macro>
<block>{
	<if>if <condition>(<expr><name><name>state</name>-&gt;<name>i</name></name> != 0</expr>)</condition><then> <block>{
		<macro><name>WRITE2</name><argument_list>(<argument>'~'</argument>, <argument>'}'</argument>)</argument_list></macro>
		<expr_stmt><expr><name><name>state</name>-&gt;<name>i</name></name> = 0</expr>;</expr_stmt>
		<macro><name>NEXT_OUT</name><argument_list>(<argument>2</argument>)</argument_list></macro>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block>

<macro><name>ENCODER</name><argument_list>(<argument>hz</argument>)</argument_list></macro>
<block>{
	<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr><name>IN1</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBCHAR</name></type> <name>code</name></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>state</name>-&gt;<name>i</name></name> == 0</expr>)</condition><then> <block>{
				<macro><name>WRITE1</name><argument_list>(<argument>(unsigned char)c</argument>)</argument_list></macro>
				<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
			}</block></then>
			<else>else <block>{
				<macro><name>WRITE3</name><argument_list>(<argument>'~'</argument>, <argument>'}'</argument>, <argument>(unsigned char)c</argument>)</argument_list></macro>
				<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>3</argument>)</argument_list></macro>
				<expr_stmt><expr><name><name>state</name>-&gt;<name>i</name></name> = 0</expr>;</expr_stmt>
			}</block></else></if>
			<continue>continue;</continue>
		}</block></then></if>

		<macro><name>UCS4INVALID</name><argument_list>(<argument>c</argument>)</argument_list></macro>

		<expr_stmt><expr><call><name>TRYMAP_ENC</name><argument_list>(<argument><expr><name>gbcommon</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<else>else <return>return <expr>1</expr>;</return></else>

		<if>if <condition>(<expr><name>code</name> &amp; 0x8000</expr>)</condition><then> <comment type="block">/* MSB set: GBK */</comment>
			<return>return <expr>1</expr>;</return></then></if>

		<if>if <condition>(<expr><name><name>state</name>-&gt;<name>i</name></name> == 0</expr>)</condition><then> <block>{
			<macro><name>WRITE4</name><argument_list>(<argument>'~'</argument>, <argument>'{'</argument>, <argument>code &gt;&gt; 8</argument>, <argument>code &amp; 0xff</argument>)</argument_list></macro>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>4</argument>)</argument_list></macro>
			<expr_stmt><expr><name><name>state</name>-&gt;<name>i</name></name> = 1</expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<macro><name>WRITE2</name><argument_list>(<argument>code &gt;&gt; 8</argument>, <argument>code &amp; 0xff</argument>)</argument_list></macro>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>2</argument>)</argument_list></macro>
		}</block></else></if>
	}</block></while>

	<return>return <expr>0</expr>;</return>
}</block>

<macro><name>DECODER_INIT</name><argument_list>(<argument>hz</argument>)</argument_list></macro>
<block>{
	<expr_stmt><expr><name><name>state</name>-&gt;<name>i</name></name> = 0</expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block>

<macro><name>DECODER_RESET</name><argument_list>(<argument>hz</argument>)</argument_list></macro>
<block>{
	<expr_stmt><expr><name><name>state</name>-&gt;<name>i</name></name> = 0</expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block>

<macro><name>DECODER</name><argument_list>(<argument>hz</argument>)</argument_list></macro>
<block>{
	<while>while <condition>(<expr><name>inleft</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><name>IN1</name></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>c</name> == '~'</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c2</name> <init>= <expr><name>IN2</name></expr></init></decl>;</decl_stmt>

			<macro><name>REQUIRE_INBUF</name><argument_list>(<argument>2</argument>)</argument_list></macro>
			<if>if <condition>(<expr><name>c2</name> == '~'</expr>)</condition><then> <block>{
				<macro><name>WRITE1</name><argument_list>(<argument>'~'</argument>)</argument_list></macro>
				<macro><name>NEXT</name><argument_list>(<argument>2</argument>, <argument>1</argument>)</argument_list></macro>
				<continue>continue;</continue>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>c2</name> == '{' &amp;&amp; <name><name>state</name>-&gt;<name>i</name></name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name><name>state</name>-&gt;<name>i</name></name> = 1</expr>;</expr_stmt></then> <comment type="block">/* set GB */</comment>
			<else>else <if>if <condition>(<expr><name>c2</name> == '}' &amp;&amp; <name><name>state</name>-&gt;<name>i</name></name> == 1</expr>)</condition><then>
				<expr_stmt><expr><name><name>state</name>-&gt;<name>i</name></name> = 0</expr>;</expr_stmt></then> <comment type="block">/* set ASCII */</comment>
			<else>else <if>if <condition>(<expr><name>c2</name> == '\n'</expr>)</condition><then>
				<empty_stmt>;</empty_stmt></then> <comment type="block">/* line-continuation */</comment>
			<else>else
				<return>return <expr>2</expr>;</return></else></if></else></if></else></if></else></if>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>

		<if>if <condition>(<expr><name>c</name> &amp; 0x80</expr>)</condition><then>
			<return>return <expr>1</expr>;</return></then></if>

		<if>if <condition>(<expr><name><name>state</name>-&gt;<name>i</name></name> == 0</expr>)</condition><then> <block>{ <comment type="block">/* ASCII mode */</comment>
			<macro><name>WRITE1</name><argument_list>(<argument>c</argument>)</argument_list></macro>
			<macro><name>NEXT</name><argument_list>(<argument>1</argument>, <argument>1</argument>)</argument_list></macro>
		}</block></then>
		<else>else <block>{ <comment type="block">/* GB mode */</comment>
			<macro><name>REQUIRE_INBUF</name><argument_list>(<argument>2</argument>)</argument_list></macro>
			<macro><name>REQUIRE_OUTBUF</name><argument_list>(<argument>1</argument>)</argument_list></macro>
			<macro><name>TRYMAP_DEC</name><argument_list>(<argument>gb2312</argument>, <argument>**outbuf</argument>, <argument>c</argument>, <argument>IN2</argument>)</argument_list></macro> <block>{
				<macro><name>NEXT</name><argument_list>(<argument>2</argument>, <argument>1</argument>)</argument_list></macro>
			}</block>
			<else>else
				<return>return <expr>2</expr>;</return></else>
		}</block></else></if>
	}</block></while>

	<return>return <expr>0</expr>;</return>
}</block>


<decl_stmt><decl><type><name>BEGIN_MAPPINGS_LIST</name></type>
  <name>MAPPING_DECONLY</name><argument_list>(<argument><expr><name>gb2312</name></expr></argument>)</argument_list>
  <name>MAPPING_DECONLY</name><argument_list>(<argument><expr><name>gbkext</name></expr></argument>)</argument_list>
  <name>MAPPING_ENCONLY</name><argument_list>(<argument><expr><name>gbcommon</name></expr></argument>)</argument_list>
  <name>MAPPING_ENCDEC</name><argument_list>(<argument><expr><name>gb18030ext</name></expr></argument>)</argument_list>
<name>END_MAPPINGS_LIST</name>

<name>BEGIN_CODECS_LIST</name>
  <name>CODEC_STATELESS</name><argument_list>(<argument><expr><name>gb2312</name></expr></argument>)</argument_list>
  <name>CODEC_STATELESS</name><argument_list>(<argument><expr><name>gbk</name></expr></argument>)</argument_list>
  <name>CODEC_STATELESS</name><argument_list>(<argument><expr><name>gb18030</name></expr></argument>)</argument_list>
  <name>CODEC_STATEFUL</name><argument_list>(<argument><expr><name>hz</name></expr></argument>)</argument_list>
<name>END_CODECS_LIST</name>

<name>I_AM_A_MODULE_FOR</name><argument_list>(<argument><expr><name>cn</name></expr></argument>)</argument_list></decl></decl_stmt>
</unit>
