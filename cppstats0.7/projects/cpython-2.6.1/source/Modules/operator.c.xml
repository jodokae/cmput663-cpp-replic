<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/operator.c">
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>operator_doc</name></expr></argument>,
<argument><expr>"Operator interface.\n\
\n\
This module exports a set of functions implemented in C corresponding\n\
to the intrinsic operators of Python.  For example, operator.add(x, y)\n\
is equivalent to the expression x+y.  The function names are those\n\
used for special class methods; variants without leading and trailing\n\
'__' are also provided for convenience."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spam1</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>AOP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a1) { \
  return AOP(a1); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spam2</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>AOP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a) { \
  PyObject *a1, *a2; \
  if(! PyArg_UnpackTuple(a,#OP,2,2,&amp;a1,&amp;a2)) return NULL; \
  return AOP(a1,a2); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spamoi</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>AOP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a) { \
  PyObject *a1; int a2; \
  if(! PyArg_ParseTuple(a,"Oi:" #OP,&amp;a1,&amp;a2)) return NULL; \
  return AOP(a1,a2); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spam2n</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>AOP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a) { \
  PyObject *a1, *a2; \
  if(! PyArg_UnpackTuple(a,#OP,2,2,&amp;a1,&amp;a2)) return NULL; \
  if(-1 == AOP(a1,a2)) return NULL; \
  Py_INCREF(Py_None); \
  return Py_None; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spam3n</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>AOP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a) { \
  PyObject *a1, *a2, *a3; \
  if(! PyArg_UnpackTuple(a,#OP,3,3,&amp;a1,&amp;a2,&amp;a3)) return NULL; \
  if(-1 == AOP(a1,a2,a3)) return NULL; \
  Py_INCREF(Py_None); \
  return Py_None; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spami</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>AOP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a1) { \
  long r; \
  if(-1 == (r=AOP(a1))) return NULL; \
  return PyBool_FromLong(r); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spami2</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>AOP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a) { \
  PyObject *a1, *a2; long r; \
  if(! PyArg_UnpackTuple(a,#OP,2,2,&amp;a1,&amp;a2)) return NULL; \
  if(-1 == (r=AOP(a1,a2))) return NULL; \
  return PyInt_FromLong(r); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spamn2</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>AOP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a) { \
  PyObject *a1, *a2; Py_ssize_t r; \
  if(! PyArg_UnpackTuple(a,#OP,2,2,&amp;a1,&amp;a2)) return NULL; \
  if(-1 == (r=AOP(a1,a2))) return NULL; \
  return PyInt_FromSsize_t(r); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spami2b</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>AOP</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a) { \
  PyObject *a1, *a2; long r; \
  if(! PyArg_UnpackTuple(a,#OP,2,2,&amp;a1,&amp;a2)) return NULL; \
  if(-1 == (r=AOP(a1,a2))) return NULL; \
  return PyBool_FromLong(r); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spamrc</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>A</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject *OP(PyObject *s, PyObject *a) { \
  PyObject *a1, *a2; \
  if(! PyArg_UnpackTuple(a,#OP,2,2,&amp;a1,&amp;a2)) return NULL; \
  return PyObject_RichCompare(a1,a2,A); }</cpp:value></cpp:define>

<macro><name>spami</name><argument_list>(<argument>isCallable</argument>       , <argument>PyCallable_Check</argument>)</argument_list></macro>
<macro><name>spami</name><argument_list>(<argument>isNumberType</argument>     , <argument>PyNumber_Check</argument>)</argument_list></macro>
<macro><name>spami</name><argument_list>(<argument>truth</argument>            , <argument>PyObject_IsTrue</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_add</argument>           , <argument>PyNumber_Add</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_sub</argument>           , <argument>PyNumber_Subtract</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_mul</argument>           , <argument>PyNumber_Multiply</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_div</argument>           , <argument>PyNumber_Divide</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_floordiv</argument>      , <argument>PyNumber_FloorDivide</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_truediv</argument>       , <argument>PyNumber_TrueDivide</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_mod</argument>           , <argument>PyNumber_Remainder</argument>)</argument_list></macro>
<macro><name>spam1</name><argument_list>(<argument>op_neg</argument>           , <argument>PyNumber_Negative</argument>)</argument_list></macro>
<macro><name>spam1</name><argument_list>(<argument>op_pos</argument>           , <argument>PyNumber_Positive</argument>)</argument_list></macro>
<macro><name>spam1</name><argument_list>(<argument>op_abs</argument>           , <argument>PyNumber_Absolute</argument>)</argument_list></macro>
<macro><name>spam1</name><argument_list>(<argument>op_inv</argument>           , <argument>PyNumber_Invert</argument>)</argument_list></macro>
<macro><name>spam1</name><argument_list>(<argument>op_invert</argument>        , <argument>PyNumber_Invert</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_lshift</argument>        , <argument>PyNumber_Lshift</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_rshift</argument>        , <argument>PyNumber_Rshift</argument>)</argument_list></macro>
<macro><name>spami</name><argument_list>(<argument>op_not_</argument>          , <argument>PyObject_Not</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_and_</argument>          , <argument>PyNumber_And</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_xor</argument>           , <argument>PyNumber_Xor</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_or_</argument>           , <argument>PyNumber_Or</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_iadd</argument>          , <argument>PyNumber_InPlaceAdd</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_isub</argument>          , <argument>PyNumber_InPlaceSubtract</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_imul</argument>          , <argument>PyNumber_InPlaceMultiply</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_idiv</argument>          , <argument>PyNumber_InPlaceDivide</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_ifloordiv</argument>     , <argument>PyNumber_InPlaceFloorDivide</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_itruediv</argument>      , <argument>PyNumber_InPlaceTrueDivide</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_imod</argument>          , <argument>PyNumber_InPlaceRemainder</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_ilshift</argument>       , <argument>PyNumber_InPlaceLshift</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_irshift</argument>       , <argument>PyNumber_InPlaceRshift</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_iand</argument>          , <argument>PyNumber_InPlaceAnd</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_ixor</argument>          , <argument>PyNumber_InPlaceXor</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_ior</argument>           , <argument>PyNumber_InPlaceOr</argument>)</argument_list></macro>
<macro><name>spami</name><argument_list>(<argument>isSequenceType</argument>   , <argument>PySequence_Check</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_concat</argument>        , <argument>PySequence_Concat</argument>)</argument_list></macro>
<macro><name>spamoi</name><argument_list>(<argument>op_repeat</argument>       , <argument>PySequence_Repeat</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_iconcat</argument>       , <argument>PySequence_InPlaceConcat</argument>)</argument_list></macro>
<macro><name>spamoi</name><argument_list>(<argument>op_irepeat</argument>      , <argument>PySequence_InPlaceRepeat</argument>)</argument_list></macro>
<macro><name>spami2b</name><argument_list>(<argument>op_contains</argument>     , <argument>PySequence_Contains</argument>)</argument_list></macro>
<macro><name>spami2b</name><argument_list>(<argument>sequenceIncludes</argument>, <argument>PySequence_Contains</argument>)</argument_list></macro>
<macro><name>spamn2</name><argument_list>(<argument>indexOf</argument>         , <argument>PySequence_Index</argument>)</argument_list></macro>
<macro><name>spamn2</name><argument_list>(<argument>countOf</argument>         , <argument>PySequence_Count</argument>)</argument_list></macro>
<macro><name>spami</name><argument_list>(<argument>isMappingType</argument>    , <argument>PyMapping_Check</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>op_getitem</argument>       , <argument>PyObject_GetItem</argument>)</argument_list></macro>
<macro><name>spam2n</name><argument_list>(<argument>op_delitem</argument>       , <argument>PyObject_DelItem</argument>)</argument_list></macro>
<macro><name>spam3n</name><argument_list>(<argument>op_setitem</argument>      , <argument>PyObject_SetItem</argument>)</argument_list></macro>
<macro><name>spamrc</name><argument_list>(<argument>op_lt</argument>           , <argument>Py_LT</argument>)</argument_list></macro>
<macro><name>spamrc</name><argument_list>(<argument>op_le</argument>           , <argument>Py_LE</argument>)</argument_list></macro>
<macro><name>spamrc</name><argument_list>(<argument>op_eq</argument>           , <argument>Py_EQ</argument>)</argument_list></macro>
<macro><name>spamrc</name><argument_list>(<argument>op_ne</argument>           , <argument>Py_NE</argument>)</argument_list></macro>
<macro><name>spamrc</name><argument_list>(<argument>op_gt</argument>           , <argument>Py_GT</argument>)</argument_list></macro>
<macro><name>spamrc</name><argument_list>(<argument>op_ge</argument>           , <argument>Py_GE</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>op_pow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>a1</name></decl>, *<decl><type ref="prev"/><name>a2</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr>"pow"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyNumber_Power</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>op_ipow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>a1</name></decl>, *<decl><type ref="prev"/><name>a2</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr>"ipow"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyNumber_InPlacePower</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>op_index</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyNumber_Index</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>is_</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>a1</name></decl>, *<decl><type ref="prev"/><name>a2</name></decl>, *<decl><type ref="prev"/><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr>"is_"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = (<name>a1</name> == <name>a2</name>) ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>is_not</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>a1</name></decl>, *<decl><type ref="prev"/><name>a2</name></decl>, *<decl><type ref="prev"/><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr>"is_not"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = (<name>a1</name> != <name>a2</name>) ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>op_getslice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>a1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>a2</name></decl>, <decl><type ref="prev"/><name>a3</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>"Onn:getslice"</expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>, <argument><expr>&amp;<name>a3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <return>return <expr><call><name>PySequence_GetSlice</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>op_setslice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>a1</name></decl>, *<decl><type ref="prev"/><name>a4</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>a2</name></decl>, <decl><type ref="prev"/><name>a3</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>"OnnO:setslice"</expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>, <argument><expr>&amp;<name>a3</name></expr></argument>, <argument><expr>&amp;<name>a4</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <if>if <condition>(<expr>-1 == <call><name>PySequence_SetSlice</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>, <argument><expr><name>a4</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>op_delslice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>a1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>a2</name></decl>, <decl><type ref="prev"/><name>a3</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>"Onn:delslice"</expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>, <argument><expr>&amp;<name>a3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <if>if <condition>(<expr>-1 == <call><name>PySequence_DelSlice</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>spam1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>spam2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>spam1o</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>spam1o</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spam1</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{#OP, OP, METH_VARARGS, PyDoc_STR(DOC)},</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spam2</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>ALTOP</name></type></param>,<param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{#OP, op_##OP, METH_VARARGS, PyDoc_STR(DOC)}, \
			   {#ALTOP, op_##OP, METH_VARARGS, PyDoc_STR(DOC)},</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spam1o</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{#OP, OP, METH_O, PyDoc_STR(DOC)},</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spam2o</name><parameter_list>(<param><type><name>OP</name></type></param>,<param><type><name>ALTOP</name></type></param>,<param><type><name>DOC</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{#OP, op_##OP, METH_O, PyDoc_STR(DOC)}, \
			   {#ALTOP, op_##OP, METH_O, PyDoc_STR(DOC)},</cpp:value></cpp:define> 

<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>operator_methods</name><index>[]</index></name> <init>= <expr><block>{

<macro><name>spam1o</name><argument_list>(<argument>isCallable</argument>,
 <argument>"isCallable(a) -- Same as callable(a)."</argument>)</argument_list></macro>
<macro><name>spam1o</name><argument_list>(<argument>isNumberType</argument>,
 <argument>"isNumberType(a) -- Return True if a has a numeric type, False otherwise."</argument>)</argument_list></macro>
<macro><name>spam1o</name><argument_list>(<argument>isSequenceType</argument>,
 <argument>"isSequenceType(a) -- Return True if a has a sequence type, False otherwise."</argument>)</argument_list></macro>
<macro><name>spam1o</name><argument_list>(<argument>truth</argument>,
 <argument>"truth(a) -- Return True if a is true, False otherwise."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>contains</argument>,<argument>__contains__</argument>,
 <argument>"contains(a, b) -- Same as b in a (note reversed operands)."</argument>)</argument_list></macro>
<macro><name>spam1</name><argument_list>(<argument>sequenceIncludes</argument>,
 <argument>"sequenceIncludes(a, b) -- Same as b in a (note reversed operands; deprecated)."</argument>)</argument_list></macro>
<macro><name>spam1</name><argument_list>(<argument>indexOf</argument>,
 <argument>"indexOf(a, b) -- Return the first index of b in a."</argument>)</argument_list></macro>
<macro><name>spam1</name><argument_list>(<argument>countOf</argument>,
 <argument>"countOf(a, b) -- Return the number of times b occurs in a."</argument>)</argument_list></macro>
<macro><name>spam1o</name><argument_list>(<argument>isMappingType</argument>,
 <argument>"isMappingType(a) -- Return True if a has a mapping type, False otherwise."</argument>)</argument_list></macro>

<macro><name>spam1</name><argument_list>(<argument>is_</argument>, <argument>"is_(a, b) -- Same as a is b."</argument>)</argument_list></macro>
<macro><name>spam1</name><argument_list>(<argument>is_not</argument>, <argument>"is_not(a, b) -- Same as a is not b."</argument>)</argument_list></macro>
<macro><name>spam2o</name><argument_list>(<argument>index</argument>, <argument>__index__</argument>, <argument>"index(a) -- Same as a.__index__()"</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>add</argument>,<argument>__add__</argument>, <argument>"add(a, b) -- Same as a + b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>sub</argument>,<argument>__sub__</argument>, <argument>"sub(a, b) -- Same as a - b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>mul</argument>,<argument>__mul__</argument>, <argument>"mul(a, b) -- Same as a * b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>div</argument>,<argument>__div__</argument>, <argument>"div(a, b) -- Same as a / b when __future__.division is not in effect."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>floordiv</argument>,<argument>__floordiv__</argument>, <argument>"floordiv(a, b) -- Same as a // b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>truediv</argument>,<argument>__truediv__</argument>, <argument>"truediv(a, b) -- Same as a / b when __future__.division is in effect."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>mod</argument>,<argument>__mod__</argument>, <argument>"mod(a, b) -- Same as a % b."</argument>)</argument_list></macro>
<macro><name>spam2o</name><argument_list>(<argument>neg</argument>,<argument>__neg__</argument>, <argument>"neg(a) -- Same as -a."</argument>)</argument_list></macro>
<macro><name>spam2o</name><argument_list>(<argument>pos</argument>,<argument>__pos__</argument>, <argument>"pos(a) -- Same as +a."</argument>)</argument_list></macro>
<macro><name>spam2o</name><argument_list>(<argument>abs</argument>,<argument>__abs__</argument>, <argument>"abs(a) -- Same as abs(a)."</argument>)</argument_list></macro>
<macro><name>spam2o</name><argument_list>(<argument>inv</argument>,<argument>__inv__</argument>, <argument>"inv(a) -- Same as ~a."</argument>)</argument_list></macro>
<macro><name>spam2o</name><argument_list>(<argument>invert</argument>,<argument>__invert__</argument>, <argument>"invert(a) -- Same as ~a."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>lshift</argument>,<argument>__lshift__</argument>, <argument>"lshift(a, b) -- Same as a &lt;&lt; b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>rshift</argument>,<argument>__rshift__</argument>, <argument>"rshift(a, b) -- Same as a &gt;&gt; b."</argument>)</argument_list></macro>
<macro><name>spam2o</name><argument_list>(<argument>not_</argument>,<argument>__not__</argument>, <argument>"not_(a) -- Same as not a."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>and_</argument>,<argument>__and__</argument>, <argument>"and_(a, b) -- Same as a &amp; b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>xor</argument>,<argument>__xor__</argument>, <argument>"xor(a, b) -- Same as a ^ b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>or_</argument>,<argument>__or__</argument>, <argument>"or_(a, b) -- Same as a | b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>iadd</argument>,<argument>__iadd__</argument>, <argument>"iadd(a, b) -- Same as a += b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>isub</argument>,<argument>__isub__</argument>, <argument>"isub(a, b) -- Same as a -= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>imul</argument>,<argument>__imul__</argument>, <argument>"imul(a, b) -- Same as a *= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>idiv</argument>,<argument>__idiv__</argument>, <argument>"idiv(a, b) -- Same as a /= b when __future__.division is not in effect."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>ifloordiv</argument>,<argument>__ifloordiv__</argument>, <argument>"ifloordiv(a, b) -- Same as a //= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>itruediv</argument>,<argument>__itruediv__</argument>, <argument>"itruediv(a, b) -- Same as a /= b when __future__.division is in effect."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>imod</argument>,<argument>__imod__</argument>, <argument>"imod(a, b) -- Same as a %= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>ilshift</argument>,<argument>__ilshift__</argument>, <argument>"ilshift(a, b) -- Same as a &lt;&lt;= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>irshift</argument>,<argument>__irshift__</argument>, <argument>"irshift(a, b) -- Same as a &gt;&gt;= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>iand</argument>,<argument>__iand__</argument>, <argument>"iand(a, b) -- Same as a &amp;= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>ixor</argument>,<argument>__ixor__</argument>, <argument>"ixor(a, b) -- Same as a ^= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>ior</argument>,<argument>__ior__</argument>, <argument>"ior(a, b) -- Same as a |= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>concat</argument>,<argument>__concat__</argument>,
 <argument>"concat(a, b) -- Same as a + b, for a and b sequences."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>repeat</argument>,<argument>__repeat__</argument>,
 <argument>"repeat(a, b) -- Return a * b, where a is a sequence, and b is an integer."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>iconcat</argument>,<argument>__iconcat__</argument>,
 <argument>"iconcat(a, b) -- Same as a += b, for a and b sequences."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>irepeat</argument>,<argument>__irepeat__</argument>,
 <argument>"irepeat(a, b) -- Same as a *= b, where a is a sequence, and b is an integer."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>getitem</argument>,<argument>__getitem__</argument>,
 <argument>"getitem(a, b) -- Same as a[b]."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>setitem</argument>,<argument>__setitem__</argument>,
 <argument>"setitem(a, b, c) -- Same as a[b] = c."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>delitem</argument>,<argument>__delitem__</argument>,
 <argument>"delitem(a, b) -- Same as del a[b]."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>pow</argument>,<argument>__pow__</argument>, <argument>"pow(a, b) -- Same as a ** b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>ipow</argument>,<argument>__ipow__</argument>, <argument>"ipow(a, b) -- Same as a **= b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>getslice</argument>,<argument>__getslice__</argument>,
 <argument>"getslice(a, b, c) -- Same as a[b:c]."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>setslice</argument>,<argument>__setslice__</argument>,
<argument>"setslice(a, b, c, d) -- Same as a[b:c] = d."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>delslice</argument>,<argument>__delslice__</argument>,
<argument>"delslice(a, b, c) -- Same as del a[b:c]."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>lt</argument>,<argument>__lt__</argument>, <argument>"lt(a, b) -- Same as a&lt;b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>le</argument>,<argument>__le__</argument>, <argument>"le(a, b) -- Same as a&lt;=b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>eq</argument>,<argument>__eq__</argument>, <argument>"eq(a, b) -- Same as a==b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>ne</argument>,<argument>__ne__</argument>, <argument>"ne(a, b) -- Same as a!=b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>gt</argument>,<argument>__gt__</argument>, <argument>"gt(a, b) -- Same as a&gt;b."</argument>)</argument_list></macro>
<macro><name>spam2</name><argument_list>(<argument>ge</argument>,<argument>__ge__</argument>, <argument>"ge(a, b) -- Same as a&gt;=b."</argument>)</argument_list></macro>

	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>

}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* itemgetter object **********************************************************/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>Py_ssize_t</name></type> <name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
}</block></struct></type> <name>itemgetterobject</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>itemgetter_type</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>itemgetter_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>itemgetterobject</name> *</type><name>ig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nitems</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"itemgetter()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>nitems</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>nitems</name> &lt;= 1</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"itemgetter"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then> <else>else 
		<expr_stmt><expr><name>item</name> = <name>args</name></expr>;</expr_stmt></else></if>

	<comment type="block">/* create itemgetterobject structure */</comment>
	<expr_stmt><expr><name>ig</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>itemgetterobject</name></expr></argument>, <argument><expr>&amp;<name>itemgetter_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ig</name> == <name>NULL</name></expr>)</condition><then> 
		<return>return <expr><name>NULL</name></expr>;</return></then></if>	
	
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ig</name>-&gt;<name>item</name></name> = <name>item</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ig</name>-&gt;<name>nitems</name></name> = <name>nitems</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>ig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>ig</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>itemgetter_dealloc</name><parameter_list>(<param><decl><type><name>itemgetterobject</name> *</type><name>ig</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>ig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ig</name>-&gt;<name>item</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>ig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>itemgetter_traverse</name><parameter_list>(<param><decl><type><name>itemgetterobject</name> *</type><name>ig</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>ig</name>-&gt;<name>item</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>itemgetter_call</name><parameter_list>(<param><decl><type><name>itemgetterobject</name> *</type><name>ig</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nitems</name><init>=<expr><name><name>ig</name>-&gt;<name>nitems</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"itemgetter"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>nitems</name> == 1</expr>)</condition><then>
		<return>return <expr><call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>ig</name>-&gt;<name>item</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name><name>ig</name>-&gt;<name>item</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>ig</name>-&gt;<name>item</name></name></expr></argument>)</argument_list></call> == <name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>nitems</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>item</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>ig</name>-&gt;<name>item</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>itemgetter_doc</name></expr></argument>,
<argument><expr>"itemgetter(item, ...) --&gt; itemgetter object\n\
\n\
Return a callable object that fetches the given item(s) from its operand.\n\
After, f=itemgetter(2), the call f(r) returns r[2].\n\
After, g=itemgetter(2,5,3), the call g(r) returns (r[2], r[5], r[3])"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>itemgetter_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"operator.itemgetter"</expr>,		<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>itemgetterobject</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>itemgetter_dealloc</name></expr>,	<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_hash */</comment>
	<expr>(<name>ternaryfunc</name>)<name>itemgetter_call</name></expr>,	<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,	<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>itemgetter_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>itemgetter_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_alloc */</comment>
	<expr><name>itemgetter_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* attrgetter object **********************************************************/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>Py_ssize_t</name></type> <name>nattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>attr</name></decl>;</decl_stmt>
}</block></struct></type> <name>attrgetterobject</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>attrgetter_type</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>attrgetter_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>attrgetterobject</name> *</type><name>ag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nattrs</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"attrgetter()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>nattrs</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>nattrs</name> &lt;= 1</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"attrgetter"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then> <else>else 
		<expr_stmt><expr><name>attr</name> = <name>args</name></expr>;</expr_stmt></else></if>

	<comment type="block">/* create attrgetterobject structure */</comment>
	<expr_stmt><expr><name>ag</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>attrgetterobject</name></expr></argument>, <argument><expr>&amp;<name>attrgetter_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ag</name> == <name>NULL</name></expr>)</condition><then> 
		<return>return <expr><name>NULL</name></expr>;</return></then></if>	
	
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ag</name>-&gt;<name>attr</name></name> = <name>attr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ag</name>-&gt;<name>nattrs</name></name> = <name>nattrs</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>ag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>ag</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>attrgetter_dealloc</name><parameter_list>(<param><decl><type><name>attrgetterobject</name> *</type><name>ag</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>ag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ag</name>-&gt;<name>attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>ag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>attrgetter_traverse</name><parameter_list>(<param><decl><type><name>attrgetterobject</name> *</type><name>ag</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>ag</name>-&gt;<name>attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dotted_getattr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>attr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>attr</name> = <call><name>_PyUnicode_AsDefaultEncodedString</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>attr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"attribute name must be a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>newobj</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>p</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> = <name>p</name> ? <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>p</name>-<name>s</name>)</expr></argument>)</argument_list></call> : 
			  <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>newobj</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>obj</name> = <name>newobj</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <break>break;</break></then></if>
		<expr_stmt><expr><name>s</name> = <name>p</name>+1</expr>;</expr_stmt>
	}</block></for>

	<return>return <expr><name>obj</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>attrgetter_call</name><parameter_list>(<param><decl><type><name>attrgetterobject</name> *</type><name>ag</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nattrs</name><init>=<expr><name><name>ag</name>-&gt;<name>nattrs</name></name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"attrgetter"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name><name>ag</name>-&gt;<name>nattrs</name></name> == 1</expr>)</condition><then>
		<return>return <expr><call><name>dotted_getattr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>ag</name>-&gt;<name>attr</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name><name>ag</name>-&gt;<name>attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>ag</name>-&gt;<name>attr</name></name></expr></argument>)</argument_list></call> == <name>nattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>nattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>nattrs</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>attr</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>attr</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>ag</name>-&gt;<name>attr</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> = <call><name>dotted_getattr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>attrgetter_doc</name></expr></argument>,
<argument><expr>"attrgetter(attr, ...) --&gt; attrgetter object\n\
\n\
Return a callable object that fetches the given attribute(s) from its operand.\n\
After, f=attrgetter('name'), the call f(r) returns r.name.\n\
After, g=attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\n\
After, h=attrgetter('name.first', 'name.last'), the call h(r) returns\n\
(r.name.first, r.name.last)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>attrgetter_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"operator.attrgetter"</expr>,		<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrgetterobject</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>attrgetter_dealloc</name></expr>,	<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_hash */</comment>
	<expr>(<name>ternaryfunc</name>)<name>attrgetter_call</name></expr>,	<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,	<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,	<comment type="block">/* tp_flags */</comment>
	<expr><name>attrgetter_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>attrgetter_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_alloc */</comment>
	<expr><name>attrgetter_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* methodcaller object **********************************************************/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>kwds</name></decl>;</decl_stmt>
}</block></struct></type> <name>methodcallerobject</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>methodcaller_type</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>methodcaller_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>methodcallerobject</name> *</type><name>mc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>newargs</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &lt; 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"methodcaller needs at least "
				"one argument, the method name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* create methodcallerobject structure */</comment>
	<expr_stmt><expr><name>mc</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>methodcallerobject</name></expr></argument>, <argument><expr>&amp;<name>methodcaller_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mc</name> == <name>NULL</name></expr>)</condition><then> 
		<return>return <expr><name>NULL</name></expr>;</return></then></if>	

	<expr_stmt><expr><name>newargs</name> = <call><name>PyTuple_GetSlice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newargs</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>mc</name>-&gt;<name>args</name></name> = <name>newargs</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>name</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mc</name>-&gt;<name>name</name></name> = <name>name</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mc</name>-&gt;<name>kwds</name></name> = <name>kwds</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>mc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>mc</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>methodcaller_dealloc</name><parameter_list>(<param><decl><type><name>methodcallerobject</name> *</type><name>mc</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>mc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>kwds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>mc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>methodcaller_traverse</name><parameter_list>(<param><decl><type><name>methodcallerobject</name> *</type><name>mc</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>kwds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>methodcaller_call</name><parameter_list>(<param><decl><type><name>methodcallerobject</name> *</type><name>mc</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>method</name></decl>, *<decl><type ref="prev"/><name>obj</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"methodcaller"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>method</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>method</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>kwds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>methodcaller_doc</name></expr></argument>,
<argument><expr>"methodcaller(name, ...) --&gt; methodcaller object\n\
\n\
Return a callable object that calls the given method on its operand.\n\
After, f = methodcaller('name'), the call f(r) returns r.name().\n\
After, g = methodcaller('name', 'date', foo=1), the call g(r) returns\n\
r.name('date', foo=1)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>methodcaller_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"operator.methodcaller"</expr>,	<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>methodcallerobject</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_itemsize */</comment>
	<comment type="block">/* methods */</comment>
	<expr>(<name>destructor</name>)<name>methodcaller_dealloc</name></expr>, <comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_hash */</comment>
	<expr>(<name>ternaryfunc</name>)<name>methodcaller_call</name></expr>,	<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,	<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,<comment type="block">/* tp_flags */</comment>
	<expr><name>methodcaller_doc</name></expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>methodcaller_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_alloc */</comment>
	<expr><name>methodcaller_new</name></expr>,		<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,				<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Initialization function for the module (*must* be called initoperator) */</comment>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>initoperator</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
        
	<comment type="block">/* Create the module and add the functions */</comment>
        <expr_stmt><expr><name>m</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"operator"</expr></argument>, <argument><expr><name>operator_methods</name></expr></argument>, <argument><expr><name>operator_doc</name></expr></argument>,
		       <argument><expr>(<name>PyObject</name>*)<name>NULL</name></expr></argument>, <argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>itemgetter_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>itemgetter_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"itemgetter"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>itemgetter_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>attrgetter_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>attrgetter_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"attrgetter"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>attrgetter_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>methodcaller_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>methodcaller_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"methodcaller"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>methodcaller_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
