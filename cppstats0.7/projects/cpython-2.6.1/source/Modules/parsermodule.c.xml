<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/parsermodule.c"><comment type="block">/*  parsermodule.c
 *
 *  Copyright 1995-1996 by Fred L. Drake, Jr. and Virginia Polytechnic
 *  Institute and State University, Blacksburg, Virginia, USA.
 *  Portions copyright 1991-1995 by Stichting Mathematisch Centrum,
 *  Amsterdam, The Netherlands.  Copying is permitted under the terms
 *  associated with the main Python distribution, with the additional
 *  restriction that this additional notice be included and maintained
 *  on all distributed copies.
 *
 *  This module serves to replace the original parser module written
 *  by Guido.  The functionality is not matched precisely, but the
 *  original may be implemented on top of this.  This is desirable
 *  since the source of the text to be parsed is now divorced from
 *  this interface.
 *
 *  Unlike the prior interface, the ability to give a parse tree
 *  produced by Python code as a tuple to the compiler is enabled by
 *  this module.  See the documentation for more details.
 *
 *  I've added some annotations that help with the lint code-checking
 *  program, but they're not complete by a long shot.  The real errors
 *  that lint detects are gone, but there are still warnings with
 *  Py_[X]DECREF() and Py_[X]INCREF() macros.  The lint annotations
 *  look like "NOTE(...)".
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>                     <comment type="block">/* general Python API             */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>                 <comment type="block">/* mod_ty */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"graminit.h"</cpp:file></cpp:include>                   <comment type="block">/* symbols defined in the grammar */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>                       <comment type="block">/* internal parser structure      */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errcode.h"</cpp:file></cpp:include>                    <comment type="block">/* error codes for PyNode_*()     */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"token.h"</cpp:file></cpp:include>                      <comment type="block">/* token definitions              */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grammar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parsetok.h"</cpp:file></cpp:include>
                                        <comment type="block">/* ISTERMINAL() / ISNONTERMINAL() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Yield</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyarena.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>extern</specifier> <name>grammar</name></type> <name>_PyParser_Grammar</name></decl>;</decl_stmt> <comment type="block">/* From graminit.c */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>lint</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;note.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOTE</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*  String constants used to initialize module attributes.
 *
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>parser_copyright_string</name><index>[]</index></name> <init>=
<expr>"Copyright 1995-1996 by Virginia Polytechnic Institute &amp; State\n\
University, Blacksburg, Virginia, USA, and Fred L. Drake, Jr., Reston,\n\
Virginia, USA.  Portions copyright 1991-1995 by Stichting Mathematisch\n\
Centrum, Amsterdam, The Netherlands."</expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>parser_doc_string</name></expr></argument>,
<argument><expr>"This is an interface to Python's internal parser."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>parser_version_string</name><index>[]</index></name> <init>= <expr>"0.5"</expr></init></decl>;</decl_stmt>


<typedef>typedef <function_decl><type><name>PyObject</name>*</type> (*<name>SeqMaker</name>) <parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int</name></type> (*<name>SeqInserter</name>) <parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>sequence</name></decl></param>,
                            <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>,
                            <param><decl><type><name>PyObject</name>*</type> <name>element</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/*  The function below is copyrighted by Stichting Mathematisch Centrum.  The
 *  original copyright statement is included below, and continues to apply
 *  in full to the function immediately following.  All other material is
 *  original, copyrighted by Fred L. Drake, Jr. and Virginia Polytechnic
 *  Institute and State University.  Changes were made to comply with the
 *  new naming conventions.  Added arguments to provide support for creating
 *  lists as well as tuples, and optionally including the line numbers.
 */</comment>


<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>node2tuple</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>n</name></decl></param>,                     <comment type="block">/* node to convert               */</comment>
           <param><decl><type><name>SeqMaker</name></type> <name>mkseq</name></decl></param>,              <comment type="block">/* create sequence               */</comment>
           <param><decl><type><name>SeqInserter</name></type> <name>addelem</name></decl></param>,         <comment type="block">/* func. to add elem. in seq.    */</comment>
           <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>,                  <comment type="block">/* include line numbers?         */</comment>
           <param><decl><type><name>int</name></type> <name>col_offset</name></decl></param>)</parameter_list>              <comment type="block">/* include column offsets?       */</comment>
<block>{
    <if>if <condition>(<expr><name>n</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>Py_None</name>)</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>ISNONTERMINAL</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>v</name> = <call><name>mkseq</name><argument_list>(<argument><expr>1 + <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> + (<call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>encoding_decl</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
            <return>return <expr>(<name>v</name>)</expr>;</return></then></if>
        <expr_stmt><expr><name>w</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>((<name>PyObject</name>*) <name>NULL</name>)</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr>(<name>void</name>) <call><name>addelem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>w</name> = <call><name>node2tuple</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mkseq</name></expr></argument>, <argument><expr><name>addelem</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>((<name>PyObject</name>*) <name>NULL</name>)</expr>;</return>
            }</block></then></if>
            <expr_stmt><expr>(<name>void</name>) <call><name>addelem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> == <name>encoding_decl</name></expr>)</condition><then>
            <expr_stmt><expr>(<name>void</name>) <call><name>addelem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr>(<name>v</name>)</expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>ISTERMINAL</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>mkseq</name><argument_list>(<argument><expr>2 + <name>lineno</name> + <name>col_offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>(<name>void</name>) <call><name>addelem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>(<name>void</name>) <call><name>addelem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>lineno</name> == 1</expr>)</condition><then>
                <expr_stmt><expr>(<name>void</name>) <call><name>addelem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>n</name>-&gt;<name>n_lineno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>col_offset</name> == 1</expr>)</condition><then>
                <expr_stmt><expr>(<name>void</name>) <call><name>addelem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>n</name>-&gt;<name>n_col_offset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
        <return>return <expr>(<name>result</name>)</expr>;</return>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
                        <argument><expr>"unrecognized parse tree node type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>((<name>PyObject</name>*) <name>NULL</name>)</expr>;</return>
    }</block></else></if></else></if>
}</block></function>
<comment type="block">/*
 *  End of material copyrighted by Stichting Mathematisch Centrum.
 */</comment>



<comment type="block">/*  There are two types of intermediate objects we're interested in:
 *  'eval' and 'exec' types.  These constants can be used in the st_type
 *  field of the object type to identify which any given object represents.
 *  These should probably go in an external header to allow other extensions
 *  to use them, but then, we really should be using C++ too.  ;-)
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyST_EXPR</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyST_SUITE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>


<comment type="block">/*  These are the internal objects and definitions required to implement the
 *  ST type.  Most of the internal names are more reminiscent of the 'old'
 *  naming style, but the code uses the new naming convention.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_error</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>


<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>PyObject_HEAD</name>                       <comment type="block">/* standard object header           */</comment>
    <name>node</name>*</type> <name>st_node</name></decl>;</decl_stmt>                      <comment type="block">/* the node* returned by the parser */</comment>
    <decl_stmt><decl><type><name>int</name></type>   <name>st_type</name></decl>;</decl_stmt>                      <comment type="block">/* EXPR or SUITE ?                  */</comment>
    <decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>st_flags</name></decl>;</decl_stmt>           <comment type="block">/* Parser and compiler flags        */</comment>
}</block></struct></type> <name>PyST_Object</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parser_free</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>st</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>parser_compare</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyST_Object</name> *</type><name>right</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>parser_getattr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>static</specifier>
<name>PyTypeObject</name></type> <name>PyST_Type</name> <init>= <expr><block>{
    <expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
    "parser.st"</expr>,                        <comment type="block">/* tp_name              */</comment>
    <expr>(<name>int</name>) <sizeof>sizeof<argument_list>(<argument><expr><name>PyST_Object</name></expr></argument>)</argument_list></sizeof></expr>,          <comment type="block">/* tp_basicsize         */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_itemsize          */</comment>
    <expr>(<name>destructor</name>)<name>parser_free</name></expr>,            <comment type="block">/* tp_dealloc           */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_print             */</comment>
    <expr><name>parser_getattr</name></expr>,                     <comment type="block">/* tp_getattr           */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_setattr           */</comment>
    <expr>(<name>cmpfunc</name>)<name>parser_compare</name></expr>,            <comment type="block">/* tp_compare           */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_repr              */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_as_number         */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_as_sequence       */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_as_mapping        */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_hash              */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_call              */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_str               */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_getattro          */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_setattro          */</comment>

    <comment type="block">/* Functions to access object as input/output buffer */</comment>
    <expr>0</expr>,                                  <comment type="block">/* tp_as_buffer         */</comment>

    <expr><name>Py_TPFLAGS_DEFAULT</name></expr>,                 <comment type="block">/* tp_flags             */</comment>

    <comment type="block">/* __doc__ */</comment>
    <expr>"Intermediate representation of a Python parse tree."</expr>
}</block></expr></init></decl>;</decl_stmt>  <comment type="block">/* PyST_Type */</comment>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parser_compare_nodes</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>left</name></decl></param>, <param><decl><type><name>node</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> &lt; <call><name>TYPE</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>(-1)</expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> &lt; <call><name>TYPE</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>(1)</expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>ISTERMINAL</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>(-1)</expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>(1)</expr>;</return></then></if>

    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><call><name>parser_compare_nodes</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>v</name> != 0</expr>)</condition><then>
            <return>return <expr>(<name>v</name>)</expr>;</return></then></if>
    }</block></for>
    <return>return <expr>(0)</expr>;</return>
}</block></function>


<comment type="block">/*  int parser_compare(PyST_Object* left, PyST_Object* right)
 *
 *  Comparison function used by the Python operators ==, !=, &lt;, &gt;, &lt;=, &gt;=
 *  This really just wraps a call to parser_compare_nodes() with some easy
 *  checks and protection code.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parser_compare</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>left</name></decl></param>, <param><decl><type><name>PyST_Object</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>left</name> == <name>right</name></expr>)</condition><then>
        <return>return <expr>(0)</expr>;</return></then></if>

    <if>if <condition>(<expr>(<name>left</name> == 0) || (<name>right</name> == 0)</expr>)</condition><then>
        <return>return <expr>(-1)</expr>;</return></then></if>

    <return>return <expr>(<call><name>parser_compare_nodes</name><argument_list>(<argument><expr><name><name>left</name>-&gt;<name>st_node</name></name></expr></argument>, <argument><expr><name><name>right</name>-&gt;<name>st_node</name></name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<comment type="block">/*  parser_newstobject(node* st)
 *
 *  Allocates a new Python object representing an ST.  This is simply the
 *  'wrapper' object that holds a node* and allows it to be passed around in
 *  Python code.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_newstobject</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>st</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyST_Object</name>*</type> <name>o</name> <init>= <expr><call><name>PyObject_New</name><argument_list>(<argument><expr><name>PyST_Object</name></expr></argument>, <argument><expr>&amp;<name>PyST_Type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>o</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>o</name>-&gt;<name>st_node</name></name> = <name>st</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>o</name>-&gt;<name>st_type</name></name> = <name>type</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>o</name>-&gt;<name>st_flags</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr>((<name>PyObject</name>*)<name>o</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  void parser_free(PyST_Object* st)
 *
 *  This is called by a del statement that reduces the reference count to 0.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parser_free</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>st</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>st_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*  parser_st2tuple(PyObject* self, PyObject* args, PyObject* kw)
 *
 *  This provides conversion from a node* to a tuple object that can be
 *  returned to the Python-level caller.  The ST object is not modified.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_st2tuple</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>line_option</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>col_option</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"ast"</expr>, <expr>"line_info"</expr>, <expr>"col_info"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"O!|OO:st2tuple"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
                                         <argument><expr>&amp;<name>PyST_Type</name></expr></argument>, <argument><expr>&amp;<name>self</name></expr></argument>, <argument><expr>&amp;<name>line_option</name></expr></argument>,
                                         <argument><expr>&amp;<name>col_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|OO:totuple"</expr></argument>, <argument><expr>&amp;<name><name>keywords</name><index>[<expr>1</expr>]</index></name></expr></argument>,
                                         <argument><expr>&amp;<name>line_option</name></expr></argument>, <argument><expr>&amp;<name>col_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr><name>ok</name> != 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>col_offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>line_option</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>lineno</name> = (<call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>line_option</name></expr></argument>)</argument_list></call> != 0) ? 1 : 0</expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>col_option</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>col_offset</name> = (<call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>col_option</name></expr></argument>)</argument_list></call> != 0) ? 1 : 0</expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/*
         *  Convert ST into a tuple representation.  Use Guido's function,
         *  since it's known to work already.
         */</comment>
        <expr_stmt><expr><name>res</name> = <call><name>node2tuple</name><argument_list>(<argument><expr>((<name>PyST_Object</name>*)<name>self</name>)-&gt;<name>st_node</name></expr></argument>,
                         <argument><expr><name>PyTuple_New</name></expr></argument>, <argument><expr><name>PyTuple_SetItem</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_ast2tuple</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"ast2tuple is removed in 3.x; use st2tuple"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>parser_st2tuple</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*  parser_st2list(PyObject* self, PyObject* args, PyObject* kw)
 *
 *  This provides conversion from a node* to a list object that can be
 *  returned to the Python-level caller.  The ST object is not modified.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_st2list</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>line_option</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>col_option</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"ast"</expr>, <expr>"line_info"</expr>, <expr>"col_info"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"O!|OO:st2list"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
                                         <argument><expr>&amp;<name>PyST_Type</name></expr></argument>, <argument><expr>&amp;<name>self</name></expr></argument>, <argument><expr>&amp;<name>line_option</name></expr></argument>,
                                         <argument><expr>&amp;<name>col_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|OO:tolist"</expr></argument>, <argument><expr>&amp;<name><name>keywords</name><index>[<expr>1</expr>]</index></name></expr></argument>,
                                         <argument><expr>&amp;<name>line_option</name></expr></argument>, <argument><expr>&amp;<name>col_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>col_offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>line_option</name> != 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>lineno</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>line_option</name></expr></argument>)</argument_list></call> ? 1 : 0</expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>col_option</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>col_offset</name> = (<call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>col_option</name></expr></argument>)</argument_list></call> != 0) ? 1 : 0</expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/*
         *  Convert ST into a tuple representation.  Use Guido's function,
         *  since it's known to work already.
         */</comment>
        <expr_stmt><expr><name>res</name> = <call><name>node2tuple</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st_node</name></name></expr></argument>,
                         <argument><expr><name>PyList_New</name></expr></argument>, <argument><expr><name>PyList_SetItem</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>col_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_ast2list</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"ast2list is removed in 3.x; use st2list"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>parser_st2list</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*  parser_compilest(PyObject* self, PyObject* args)
 *
 *  This function creates code objects from the parse tree represented by
 *  the passed-in data object.  An optional file name is passed in as well.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_compilest</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name>*</type>     <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyArena</name>*</type>      <name>arena</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mod_ty</name></type>        <name>mod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type>         <name>str</name> <init>= <expr>"&lt;syntax-tree&gt;"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"ast"</expr>, <expr>"filename"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"O!|s:compilest"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
                                         <argument><expr>&amp;<name>PyST_Type</name></expr></argument>, <argument><expr>&amp;<name>self</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|s:compile"</expr></argument>, <argument><expr>&amp;<name><name>keywords</name><index>[<expr>1</expr>]</index></name></expr></argument>,
                                         <argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>arena</name> = <call><name>PyArena_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>arena</name></expr>)</condition><then> <block>{
           <expr_stmt><expr><name>mod</name> = <call><name>PyAST_FromNode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st_node</name></name></expr></argument>, <argument><expr>&amp;(<name><name>self</name>-&gt;<name>st_flags</name></name>)</expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <if>if <condition>(<expr><name>mod</name></expr>)</condition><then> <block>{
               <expr_stmt><expr><name>res</name> = (<name>PyObject</name> *)<call><name>PyAST_Compile</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;(<name><name>self</name>-&gt;<name>st_flags</name></name>)</expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           }</block></then></if>
           <expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_compileast</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"compileast is removed in 3.x; use compilest"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>parser_compilest</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*  PyObject* parser_isexpr(PyObject* self, PyObject* args)
 *  PyObject* parser_issuite(PyObject* self, PyObject* args)
 *
 *  Checks the passed-in ST object to determine if it is an expression or
 *  a statement suite, respectively.  The return is a Python truth value.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_isexpr</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"ast"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"O!:isexpr"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
                                         <argument><expr>&amp;<name>PyST_Type</name></expr></argument>, <argument><expr>&amp;<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>":isexpr"</expr></argument>, <argument><expr>&amp;<name><name>keywords</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
        <comment type="block">/* Check to see if the ST represents an expression or not. */</comment>
        <expr_stmt><expr><name>res</name> = (<name><name>self</name>-&gt;<name>st_type</name></name> == <name>PyST_EXPR</name>) ? <name>Py_True</name> : <name>Py_False</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_issuite</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"ast"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"O!:issuite"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
                                         <argument><expr>&amp;<name>PyST_Type</name></expr></argument>, <argument><expr>&amp;<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>ok</name> = <call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>":issuite"</expr></argument>, <argument><expr>&amp;<name><name>keywords</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
        <comment type="block">/* Check to see if the ST represents an expression or not. */</comment>
        <expr_stmt><expr><name>res</name> = (<name><name>self</name>-&gt;<name>st_type</name></name> == <name>PyST_EXPR</name>) ? <name>Py_False</name> : <name>Py_True</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_METHOD_TYPE</name></cpp:macro> <cpp:value>(METH_VARARGS|METH_KEYWORDS)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type>
<name><name>parser_methods</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"compile"</expr>,         <expr>(<name>PyCFunction</name>)<name>parser_compilest</name></expr>,  <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Compile this ST object into a code object."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"isexpr"</expr>,          <expr>(<name>PyCFunction</name>)<name>parser_isexpr</name></expr>,     <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Determines if this ST object was created from an expression."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"issuite"</expr>,         <expr>(<name>PyCFunction</name>)<name>parser_issuite</name></expr>,    <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Determines if this ST object was created from a suite."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"tolist"</expr>,          <expr>(<name>PyCFunction</name>)<name>parser_st2list</name></expr>,    <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates a list-tree representation of this ST."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"totuple"</expr>,         <expr>(<name>PyCFunction</name>)<name>parser_st2tuple</name></expr>,   <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates a tuple-tree representation of this ST."</argument>)</argument_list></macro>}</block></expr>,

    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_getattr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>Py_FindMethod</name><argument_list>(<argument><expr><name>parser_methods</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<comment type="block">/*  err_string(char* message)
 *
 *  Sets the error string for an exception of type ParserError.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>err_string</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>message</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*  PyObject* parser_do_parse(PyObject* args, int type)
 *
 *  Internal function to actually execute the parse and return the result if
 *  successful or set an exception if not.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_do_parse</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>, <param><decl><type><name>char</name> *</type><name>argspec</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name>*</type>     <name>string</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name>*</type> <name>res</name>    <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name>        <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>perrdetail</name></type> <name>err</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"source"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr><name>argspec</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr>&amp;<name>string</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>node</name>*</type> <name>n</name> <init>= <expr><call><name>PyParser_ParseStringFlagsFilenameEx</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                       <argument><expr>&amp;<name>_PyParser_Grammar</name></expr></argument>,
                                                      <argument><expr>(<name>type</name> == <name>PyST_EXPR</name>)
                                                      ? <name>eval_input</name> : <name>file_input</name></expr></argument>,
                                                      <argument><expr>&amp;<name>err</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>n</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>res</name> = <call><name>parser_newstobject</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
                <expr_stmt><expr>((<name>PyST_Object</name> *)<name>res</name>)-&gt;<name><name>st_flags</name>.<name>cf_flags</name></name> = <name>flags</name> &amp; <name>PyCF_MASK</name></expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><call><name>PyParser_SetError</name><argument_list>(<argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  PyObject* parser_expr(PyObject* self, PyObject* args)
 *  PyObject* parser_suite(PyObject* self, PyObject* args)
 *
 *  External interfaces to the parser itself.  Which is called determines if
 *  the parser attempts to recognize an expression ('eval' form) or statement
 *  suite ('exec' form).  The real work is done by parser_do_parse() above.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_expr</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <macro><name>NOTE</name><argument_list>(<argument>ARGUNUSED(self)</argument>)</argument_list></macro>
    <return>return <expr>(<call><name>parser_do_parse</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"s:expr"</expr></argument>, <argument><expr><name>PyST_EXPR</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_suite</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <macro><name>NOTE</name><argument_list>(<argument>ARGUNUSED(self)</argument>)</argument_list></macro>
    <return>return <expr>(<call><name>parser_do_parse</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"s:suite"</expr></argument>, <argument><expr><name>PyST_SUITE</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>



<comment type="block">/*  This is the messy part of the code.  Conversion from a tuple to an ST
 *  object requires that the input tuple be valid without having to rely on
 *  catching an exception from the compiler.  This is done to allow the
 *  compiler itself to remain fast, since most of its input will come from
 *  the parser directly, and therefore be known to be syntactically correct.
 *  This validation is done to ensure that we don't core dump the compile
 *  phase, returning an exception instead.
 *
 *  Two aspects can be broken out in this code:  creating a node tree from
 *  the tuple passed in, and verifying that it is indeed valid.  It may be
 *  advantageous to expand the number of ST types to include funcdefs and
 *  lambdadefs to take advantage of the optimizer, recognizing those STs
 *  here.  They are not necessary, and not quite as useful in a raw form.
 *  For now, let's get expressions and suites working reliably.
 */</comment>


<function_decl><type><specifier>static</specifier> <name>node</name>*</type> <name>build_node_tree</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>tuple</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>   <name>validate_expr_tree</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>   <name>validate_file_input</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>   <name>validate_encoding_decl</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*  PyObject* parser_tuple2st(PyObject* self, PyObject* args)
 *
 *  This is the public function, called from the Python code.  It receives a
 *  single tuple object from the caller, and creates an ST object if the
 *  tuple can be validated.  It does this by checking the first code of the
 *  tuple, and, if acceptable, builds the internal representation.  If this
 *  step succeeds, the internal representation is validated as fully as
 *  possible with the various validate_*() routines defined below.
 *
 *  This function must be changed if support is to be added for PyST_FRAGMENT
 *  ST objects.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_tuple2st</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <macro><name>NOTE</name><argument_list>(<argument>ARGUNUSED(self)</argument>)</argument_list></macro>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>st</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>node</name> *</type><name>tree</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"sequence"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"O:sequence2st"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
                                     <argument><expr>&amp;<name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>(0)</expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>PySequence_Check</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
                        <argument><expr>"sequence2st() requires a single sequence argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(0)</expr>;</return>
    }</block></then></if>
    <comment type="block">/*
     *  Convert the tree to the internal form before checking it.
     */</comment>
    <expr_stmt><expr><name>tree</name> = <call><name>build_node_tree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tree</name> != 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>start_sym</name> <init>= <expr><call><name>TYPE</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>start_sym</name> == <name>eval_input</name></expr>)</condition><then> <block>{
            <comment type="block">/*  Might be an eval form.  */</comment>
            <if>if <condition>(<expr><call><name>validate_expr_tree</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>st</name> = <call><name>parser_newstobject</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>PyST_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>start_sym</name> == <name>file_input</name></expr>)</condition><then> <block>{
            <comment type="block">/*  This looks like an exec form so far.  */</comment>
            <if>if <condition>(<expr><call><name>validate_file_input</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>st</name> = <call><name>parser_newstobject</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>PyST_SUITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>start_sym</name> == <name>encoding_decl</name></expr>)</condition><then> <block>{
            <comment type="block">/* This looks like an encoding_decl so far. */</comment>
            <if>if <condition>(<expr><call><name>validate_encoding_decl</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>st</name> = <call><name>parser_newstobject</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>PyST_SUITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then>
        <else>else <block>{
            <comment type="block">/*  This is a fragment, at best. */</comment>
            <expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"parse tree does not use a valid start symbol"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>
    }</block></then></if>
    <comment type="block">/*  Make sure we throw an exception on all errors.  We should never
     *  get this, but we'd do well to be sure something is done.
     */</comment>
    <if>if <condition>(<expr><name>st</name> == <name>NULL</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"unspecified ST error occurred"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>st</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser_tuple2ast</name><parameter_list>(<param><decl><type><name>PyST_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"tuple2ast is removed in 3.x; use tuple2st"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>parser_tuple2st</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*  node* build_node_children()
 *
 *  Iterate across the children of the current non-terminal node and build
 *  their structures.  If successful, return the root of this portion of
 *  the tree, otherwise, 0.  Any required exception will be specified already,
 *  and no memory will have been deallocated.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>node</name>*</type>
<name>build_node_children</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>tuple</name></decl></param>, <param><decl><type><name>node</name> *</type><name>root</name></decl></param>, <param><decl><type><name>int</name> *</type><name>line_num</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyObject_Size</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>err</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <comment type="block">/* elem must always be a sequence, however simple */</comment>
        <decl_stmt><decl><type><name>PyObject</name>*</type> <name>elem</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><name>elem</name> != <name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type>  <name>type</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>strn</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
            <expr_stmt><expr><name>ok</name> = <call><name>PySequence_Check</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
                <expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt></then>
            <else>else <block>{
                <expr_stmt><expr><name>ok</name> = <call><name>PyInt_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
                    <expr_stmt><expr><name>type</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>err</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"os"</expr></argument>, <argument><expr><name>elem</name></expr></argument>,
                                          <argument><expr>"Illegal node construct."</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>(0)</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>ISTERMINAL</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyObject_Size</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name></decl>;</decl_stmt>

            <if>if <condition>(<expr>(<name>len</name> != 2) &amp;&amp; (<name>len</name> != 3)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"terminal nodes must have 2 or 3 entries"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>temp</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>,
                             <argument><expr>"second item in terminal node must be a string,"
                             " found %s"</expr></argument>,
                             <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name>len</name> == 3</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>o</name> != <name>NULL</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr>*<name>line_num</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                    <else>else <block>{
                        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>,
                                     <argument><expr>"third item in terminal node must be an"
                                     " integer, found %s"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr>0</expr>;</return>
                    }</block></else></if>
                    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
            <expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>strn</name> = (<name>char</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>strn</name> != <name>NULL</name></expr>)</condition><then>
                <expr_stmt><expr>(<name>void</name>) <call><name>memcpy</name><argument_list>(<argument><expr><name>strn</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>ISNONTERMINAL</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/*
             *  It has to be one or the other; this is an error.
             *  Throw an exception.
             */</comment>
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>err</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"os"</expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr>"unknown node type."</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>(0)</expr>;</return>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>err</name> = <call><name>PyNode_AddChild</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>strn</name></expr></argument>, <argument><expr>*<name>line_num</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name> == <name>E_NOMEM</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>strn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>(<name>node</name> *) <call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>err</name> == <name>E_OVERFLOW</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>strn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
                            <argument><expr>"unsupported number of child nodes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><call><name>ISNONTERMINAL</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>node</name>*</type> <name>new_child</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>new_child</name> != <call><name>build_node_children</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>new_child</name></expr></argument>, <argument><expr><name>line_num</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>(0)</expr>;</return>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>type</name> == <name>NEWLINE</name></expr>)</condition><then> <block>{     <comment type="block">/* It's true:  we increment the     */</comment>
            <expr_stmt><expr>++(*<name>line_num</name>)</expr>;</expr_stmt>              <comment type="block">/* line number *after* the newline! */</comment>
        }</block></then></if></else></if>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>root</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>node</name>*</type>
<name>build_node_tree</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>tuple</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>node</name>*</type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>num</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>temp</name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>num</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>ISTERMINAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         *  The tuple is simple, but it doesn't start with a start symbol.
         *  Throw an exception now and be done with it.
         */</comment>
        <expr_stmt><expr><name>tuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"os"</expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                    <argument><expr>"Illegal syntax-tree; cannot start with terminal symbol."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>ISNONTERMINAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         *  Not efficient, but that can be handled later.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>line_num</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>num</name> == <name>encoding_decl</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>encoding</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* tuple isn't borrowed anymore here, need to DECREF */</comment>
            <expr_stmt><expr><name>tuple</name> = <call><name>PySequence_GetSlice</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>res</name> = <call><name>PyNode_New</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>res</name> != <call><name>build_node_children</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr>&amp;<name>line_num</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>PyNode_Free</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>res</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>encoding</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>res</name>-&gt;<name>n_str</name></name> = (<name>char</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>res</name>-&gt;<name>n_str</name></name> != <name>NULL</name></expr>)</condition><then>
                    <expr_stmt><expr>(<name>void</name>) <call><name>memcpy</name><argument_list>(<argument><expr><name><name>res</name>-&gt;<name>n_str</name></name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <comment type="block">/*  The tuple is illegal -- if the number is neither TERMINAL nor
         *  NONTERMINAL, we can't use it.  Not sure the implementation
         *  allows this condition, but the API doesn't preclude it.
         */</comment>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>err</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"os"</expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                                      <argument><expr>"Illegal component tuple."</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*
 *  Validation routines used within the validation section:
 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>validate_terminal</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>terminal</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>string</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_ampersand</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>validate_terminal(ch,      AMPER, "&amp;")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_circumflex</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>validate_terminal(ch, CIRCUMFLEX, "^")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_colon</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>validate_terminal(ch,      COLON, ":")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_comma</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>validate_terminal(ch,      COMMA, ",")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_dedent</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>validate_terminal(ch,     DEDENT, "")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_equal</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>validate_terminal(ch,      EQUAL, "=")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_indent</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>validate_terminal(ch,     INDENT, (char*)NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_lparen</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>validate_terminal(ch,       LPAR, "(")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_newline</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>validate_terminal(ch,    NEWLINE, (char*)NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_rparen</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>validate_terminal(ch,       RPAR, ")")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_semi</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>validate_terminal(ch,       SEMI, ";")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_star</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>validate_terminal(ch,       STAR, "*")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_vbar</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>validate_terminal(ch,       VBAR, "|")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_doublestar</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>validate_terminal(ch, DOUBLESTAR, "**")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_dot</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>validate_terminal(ch,        DOT, ".")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_at</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>validate_terminal(ch,         AT, "@")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>validate_name</name><parameter_list>(<param><type><name>ch</name></type></param>, <param><type><name>str</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>validate_terminal(ch,       NAME, str)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALIDATER</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>static int validate_##n(node *tree)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>small_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>suite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>testlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>varargslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>fpdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>fplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>simple_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>expr_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>power</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>print_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>del_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>return_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>list_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>raise_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>import_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>import_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>import_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>global_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>list_if</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>assert_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>list_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>exec_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>compound_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>VALIDATER</name><argument_list>(<argument>while</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>               <macro><name>VALIDATER</name><argument_list>(<argument>for</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>try</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>except_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>and_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>not_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>comparison</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>comp_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>xor_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>and_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>shift_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>arith_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>lambdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>trailer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>subscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>subscriptlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>sliceop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>dictmaker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>arglist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>listmaker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>yield_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>testlist1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>gen_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>gen_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>gen_if</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>testlist_gexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>yield_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>yield_or_testlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>or_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>old_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 		<expr_stmt><expr><call><name>VALIDATER</name><argument_list>(<argument><expr><name>old_lambdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VALIDATER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_even</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>(((n) &amp; 1) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_odd</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>(((n) &amp; 1) == 1)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_ntype</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>t</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> != <name>t</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>, <argument><expr>"Expected node type %d, got %d."</expr></argument>,
                     <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>


<comment type="block">/*  Verifies that the number of child nodes is exactly 'num', raising
 *  an exception if it isn't.  The exception message does not indicate
 *  the exact number of nodes, allowing this to be used to raise the
 *  "right" exception when the wrong number of nodes is present in a
 *  specific variant of a statement's syntax.  This is commonly used
 *  in that fashion.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_numnodes</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>num</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name>name</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> != <name>num</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>,
                     <argument><expr>"Illegal number of children for %s node."</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_terminal</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>terminal</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>string</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>terminal</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>string</name> == 0) || (<call><name>strcmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>terminal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0)))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>,
                     <argument><expr>"Illegal terminal: expected \"%s\""</expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  X (',' X) [',']
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_repeating_list</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>, <param><decl><type><name>int</name></type> <name>ntype</name></decl></param>, <param><function_decl><type><name>int</name></type> (*<name>vfunc</name>)<parameter_list>(<param><decl><type><name>node</name> *</type></decl></param>)</parameter_list></function_decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<name>nch</name> &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>ntype</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>vfunc</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>(<name>void</name>) <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
        <if>if <condition>(<expr><call><name>is_even</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>--<name>nch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>nch</name> &gt; 1</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
            <for>for ( <init>;</init> <condition><expr><name>res</name> &amp;&amp; <name>pos</name> &lt; <name>nch</name></expr>;</condition> <incr><expr><name>pos</name> += 2</expr></incr>)
                <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>vfunc</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>
        }</block></then></if>
    }</block></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  validate_class()
 *
 *  classdef:
 *      'class' NAME ['(' testlist ')'] ':' suite
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_class</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>classdef</name></expr></argument>)</argument_list></call> &amp;&amp;
	       	((<name>nch</name> == 4) || (<name>nch</name> == 6) || (<name>nch</name> == 7)))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"class"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr>(<name>void</name>) <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>"class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
	
    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>nch</name> == 7</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = ((<call><name>validate_lparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
			<call><name>validate_testlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
			<call><name>validate_rparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>))</expr>;</expr_stmt>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>nch</name> == 6</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name> = (<call><name>validate_lparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
			<call><name>validate_rparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>,<argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
	}</block></then></if></else></if>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  if_stmt:
 *      'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_if</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>if_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; (<name>nch</name> &gt;= 4)
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"if"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; ((<name>nch</name> % 4) == 3)</expr>)</condition><then> <block>{
        <comment type="block">/*  ... 'else' ':' suite  */</comment>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 3</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"else"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>nch</name> -= 3</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>(<name>void</name>) <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>"if"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    <if>if <condition>(<expr>(<name>nch</name> % 4) != 0</expr>)</condition><then>
        <comment type="block">/* Will catch the case for nch &lt; 4 */</comment>
        <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>"if"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> &gt; 4)</expr>)</condition><then> <block>{
        <comment type="block">/*  ... ('elif' test ':' suite)+ ...  */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>(<name>j</name> &lt; <name>nch</name>) &amp;&amp; <name>res</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"elif"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name> + 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> += 4</expr>;</expr_stmt>
        }</block></while>
    }</block></then></if></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  parameters:
 *      '(' [varargslist] ')'
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_parameters</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>parameters</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>nch</name> == 2) || (<name>nch</name> == 3))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = (<call><name>validate_lparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_rparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 3)</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_varargslist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr>(<name>void</name>) <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"parameters"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  validate_suite()
 *
 *  suite:
 *      simple_stmt
 *    | NEWLINE INDENT stmt+ DEDENT
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_suite</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>suite</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>nch</name> == 1) || (<name>nch</name> &gt;= 4)))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 1)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_simple_stmt</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <comment type="block">/*  NEWLINE INDENT stmt+ DEDENT  */</comment>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_newline</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_indent</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_stmt</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_dedent</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

        <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> &gt; 4)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr>--<name>nch</name></expr>;</expr_stmt>                      <comment type="block">/* forget the DEDENT     */</comment>
            <for>for ( <init>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>i</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
                <expr_stmt><expr><name>res</name> = <call><name>validate_stmt</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>nch</name> &lt; 4</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>"suite"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    }</block></then></if></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_testlist</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_repeating_list</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>testlist</name></expr></argument>,
                                    <argument><expr><name>validate_test</name></expr></argument>, <argument><expr>"testlist"</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_testlist1</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_repeating_list</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>testlist1</name></expr></argument>,
                                    <argument><expr><name>validate_test</name></expr></argument>, <argument><expr>"testlist1"</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_testlist_safe</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_repeating_list</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>testlist_safe</name></expr></argument>,
                                    <argument><expr><name>validate_old_test</name></expr></argument>, <argument><expr>"testlist_safe"</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<comment type="block">/* '*' NAME [',' '**' NAME] | '**' NAME
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_varargslist_trailer</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sym</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nch</name> &lt;= <name>start</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"expected variable argument trailer for varargslist"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>sym</name> = <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>sym</name> == <name>STAR</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         *  ('*' NAME [',' '**' NAME]
         */</comment>
        <if>if <condition>(<expr><name>nch</name>-<name>start</name> == 2</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>start</name>+1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>nch</name>-<name>start</name> == 5</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>start</name>+1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>start</name>+2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_doublestar</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>start</name>+3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>start</name>+4</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>sym</name> == <name>DOUBLESTAR</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         *  '**' NAME
         */</comment>
        <if>if <condition>(<expr><name>nch</name>-<name>start</name> == 2</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>start</name>+1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if></else></if>
    <if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal variable argument trailer for varargslist"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>


<comment type="block">/*  validate_varargslist()
 *
 *  varargslist:
 *      (fpdef ['=' test] ',')*
 *           ('*' NAME [',' '**' NAME]
 *         | '**' NAME)
 *    | fpdef ['=' test] (',' fpdef ['=' test])* [',']
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_varargslist</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>varargslist</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>nch</name> != 0)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sym</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr><name>nch</name> &lt; 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"varargslist missing child nodes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>sym</name> = <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>sym</name> == <name>STAR</name> || <name>sym</name> == <name>DOUBLESTAR</name></expr>)</condition><then>
        <comment type="block">/* whole thing matches:
         *      '*' NAME [',' '**' NAME] | '**' NAME
         */</comment>
        <expr_stmt><expr><name>res</name> = <call><name>validate_varargslist_trailer</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>sym</name> == <name>fpdef</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>sym</name> = <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>sym</name> == <name>NAME</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             *   (fpdef ['=' test] ',')+
             *       ('*' NAME [',' '**' NAME]
             *     | '**' NAME)
             */</comment>
            <comment type="block">/* skip over (fpdef ['=' test] ',')+ */</comment>
            <while>while <condition>(<expr><name>res</name> &amp;&amp; (<name>i</name>+2 &lt;= <name>nch</name>)</expr>)</condition> <block>{
                <expr_stmt><expr><name>res</name> = <call><name>validate_fpdef</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>res</name> &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>EQUAL</name> &amp;&amp; (<name>i</name>+2 &lt;= <name>nch</name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>res</name> = (<call><name>validate_equal</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                           &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
                        <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt></then></if>
                }</block></then></if>
                <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>i</name> &lt; <name>nch</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>res</name> = <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>i</name> &lt; <name>nch</name>
                        &amp;&amp; (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>DOUBLESTAR</name>
                            || <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>STAR</name>)</expr>)</condition><then>
                        <break>break;</break></then></if>
                }</block></then></if>
            }</block></while>
            <comment type="block">/* ... '*' NAME [',' '**' NAME] | '**' NAME
             * i --^^^
             */</comment>
            <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = <call><name>validate_varargslist_trailer</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else <block>{
            <comment type="block">/*
             *  fpdef ['=' test] (',' fpdef ['=' test])* [',']
             */</comment>
            <comment type="block">/* strip trailing comma node */</comment>
            <if>if <condition>(<expr><name>sym</name> == <name>COMMA</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>res</name> = <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
                    <return>return <expr>0</expr>;</return></then></if>
                <expr_stmt><expr>--<name>nch</name></expr>;</expr_stmt>
            }</block></then></if>
            <comment type="block">/*
             *  fpdef ['=' test] (',' fpdef ['=' test])*
             */</comment>
            <expr_stmt><expr><name>res</name> = <call><name>validate_fpdef</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>i</name>+2 &lt;= <name>nch</name>) &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>EQUAL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>res</name> = (<call><name>validate_equal</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
            }</block></then></if>
            <comment type="block">/*
             *  ... (',' fpdef ['=' test])*
             *  i ---^^^
             */</comment>
            <while>while <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> - <name>i</name>) &gt;= 2</expr>)</condition> <block>{
                <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>validate_fpdef</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> - <name>i</name>) &gt;= 2 &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>EQUAL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>res</name> = (<call><name>validate_equal</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                           &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                    <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
                }</block></then></if>
            }</block></while>
            <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>nch</name> - <name>i</name> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal formation for varargslist"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if></else></if>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>


<comment type="block">/*  list_iter:  list_for | list_if
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_list_iter</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>list_iter</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"list_iter"</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>list_for</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_list_for</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>res</name> = <call><name>validate_list_if</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*  gen_iter:  gen_for | gen_if
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_gen_iter</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>gen_iter</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"gen_iter"</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>gen_for</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_gen_for</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>res</name> = <call><name>validate_gen_if</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*  list_for:  'for' exprlist 'in' testlist [list_iter]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_list_for</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nch</name> == 5</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_list_iter</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>"list_for"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"for"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_exprlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"in"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_testlist_safe</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*  gen_for:  'for' exprlist 'in' test [gen_iter]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_gen_for</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nch</name> == 5</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_gen_iter</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>"gen_for"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"for"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_exprlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"in"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_or_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*  list_if:  'if' old_test [list_iter]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_list_if</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nch</name> == 3</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_list_iter</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"list_if"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"if"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_old_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*  gen_if:  'if' old_test [gen_iter]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_gen_if</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nch</name> == 3</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_gen_iter</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"gen_if"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    
    <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"if"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_old_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*  validate_fpdef()
 *
 *  fpdef:
 *      NAME
 *    | '(' fplist ')'
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_fpdef</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>fpdef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>nch</name> == 1</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>nch</name> == 3</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = (<call><name>validate_lparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_fplist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_rparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"fpdef"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_fplist</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_repeating_list</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>fplist</name></expr></argument>,
                                    <argument><expr><name>validate_fpdef</name></expr></argument>, <argument><expr>"fplist"</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<comment type="block">/*  simple_stmt | compound_stmt
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"stmt"</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>tree</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call> == <name>simple_stmt</name></expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_simple_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>res</name> = <call><name>validate_compound_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  small_stmt (';' small_stmt)* [';'] NEWLINE
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_simple_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>simple_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; (<name>nch</name> &gt;= 2)
               &amp;&amp; <call><name>validate_small_stmt</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_newline</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nch</name> &lt; 2</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"simple_stmt"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr>--<name>nch</name></expr>;</expr_stmt>                              <comment type="block">/* forget the NEWLINE    */</comment>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; <call><name>is_even</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_semi</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>--<name>nch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> &gt; 2)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>i</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>)
            <expr_stmt><expr><name>res</name> = (<call><name>validate_semi</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_small_stmt</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_small_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"small_stmt"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>ntype</name> <init>= <expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(  <expr>(<name>ntype</name> == <name>expr_stmt</name>)
              || (<name>ntype</name> == <name>print_stmt</name>)
              || (<name>ntype</name> == <name>del_stmt</name>)
              || (<name>ntype</name> == <name>pass_stmt</name>)
              || (<name>ntype</name> == <name>flow_stmt</name>)
              || (<name>ntype</name> == <name>import_stmt</name>)
              || (<name>ntype</name> == <name>global_stmt</name>)
              || (<name>ntype</name> == <name>assert_stmt</name>)
              || (<name>ntype</name> == <name>exec_stmt</name>)</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_node</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <block>{
            <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal small_stmt child type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>nch</name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>,
                     <argument><expr>"Unrecognized child node of small_stmt: %d."</expr></argument>,
                     <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  compound_stmt:
 *      if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_compound_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>compound_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"compound_stmt"</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ntype</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
        <return>return <expr>(0)</expr>;</return></then></if>

    <expr_stmt><expr><name>tree</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ntype</name> = <call><name>TYPE</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(  <expr>(<name>ntype</name> == <name>if_stmt</name>)
          || (<name>ntype</name> == <name>while_stmt</name>)
          || (<name>ntype</name> == <name>for_stmt</name>)
          || (<name>ntype</name> == <name>try_stmt</name>)
          || (<name>ntype</name> == <name>with_stmt</name>)
          || (<name>ntype</name> == <name>funcdef</name>)
          || (<name>ntype</name> == <name>classdef</name>)
          || (<name>ntype</name> == <name>decorated</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_node</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
        <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>,
                     <argument><expr>"Illegal compound statement type: %d."</expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_yield_or_testlist</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call> == <name>yield_expr</name></expr>)</condition><then> 
		<return>return <expr><call><name>validate_yield_expr</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>validate_testlist</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_expr_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>expr_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_testlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>nch</name> == 3
        &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>augassign</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"augassign"</expr></argument>)</argument_list></call>
		&amp;&amp; <call><name>validate_yield_or_testlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>res</name> = (<call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"+="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"-="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"*="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"/="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"//="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"&amp;="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"|="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"^="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"&lt;&lt;="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"&gt;&gt;="</expr></argument>)</argument_list></call> == 0
                   || <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"**="</expr></argument>)</argument_list></call> == 0)</expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal augmmented assignment operator"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <for>for (<init><expr><name>j</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>j</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>j</name> += 2</expr></incr>)
            <expr_stmt><expr><name>res</name> = <call><name>validate_equal</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_yield_or_testlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  print_stmt:
 *
 *      'print' ( [ test (',' test)* [','] ]
 *              | '&gt;&gt;' test [ (',' test)+ [','] ] )
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_print_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>print_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; (<name>nch</name> &gt; 0)
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"print"</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>nch</name> &gt; 1</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>sym</name> <init>= <expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>allow_trailing_comma</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>sym</name> == <name>test</name></expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>++</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <block>{
            <if>if <condition>(<expr><name>nch</name> &lt; 3</expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>"print_stmt"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <block>{
                <expr_stmt><expr><name>res</name> = (<call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RIGHTSHIFT</name></expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
                <expr_stmt><expr><name>allow_trailing_comma</name> = 0</expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
        <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
            <comment type="block">/*  ... (',' test)* [',']  */</comment>
            <while>while <condition>(<expr><name>res</name> &amp;&amp; <name>i</name>+2 &lt;= <name>nch</name></expr>)</condition> <block>{
                <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                <expr_stmt><expr><name>allow_trailing_comma</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
            }</block></while>
            <if>if <condition>(<expr><name>res</name> &amp;&amp; !<name>allow_trailing_comma</name></expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>"print_stmt"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>i</name> &lt; <name>nch</name></expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_del_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"del_stmt"</expr></argument>)</argument_list></call>
            &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"del"</expr></argument>)</argument_list></call>
            &amp;&amp; <call><name>validate_exprlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_return_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>return_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 1) || (<name>nch</name> == 2))
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"return"</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 2)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_testlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_raise_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>raise_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 1) || (<name>nch</name> == 2) || (<name>nch</name> == 4) || (<name>nch</name> == 6)))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"raise"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> &gt;= 2)</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>nch</name> &gt; 2</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> &gt; 4)</expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></then>
    <else>else
        <expr_stmt><expr>(<name>void</name>) <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"raise"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 4)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/* yield_expr: 'yield' [testlist]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_yield_expr</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>yield_expr</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 1) || (<name>nch</name> == 2))
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"yield"</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 2)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_testlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/* yield_stmt: yield_expr
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_yield_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>yield_stmt</name></expr></argument>)</argument_list></call>
            &amp;&amp; <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"yield_stmt"</expr></argument>)</argument_list></call>
            &amp;&amp; <call><name>validate_yield_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_import_as_name</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>import_as_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>nch</name> == 1</expr>)</condition><then>
            <expr_stmt><expr><name>ok</name> = <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>nch</name> == 3</expr>)</condition><then>
            <expr_stmt><expr><name>ok</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                  &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"as"</expr></argument>)</argument_list></call>
                  &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>ok</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>"import_as_name"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
    }</block></then></if>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>


<comment type="block">/* dotted_name:  NAME ("." NAME)*
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_dotted_name</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>dotted_name</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>i</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
        <expr_stmt><expr><name>res</name> = (<call><name>validate_dot</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>


<comment type="block">/* dotted_as_name:  dotted_name [NAME NAME]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_dotted_as_name</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>dotted_as_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>nch</name> == 1</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_dotted_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>nch</name> == 3</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = (<call><name>validate_dotted_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"as"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
        <else>else <block>{
            <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal number of children for dotted_as_name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></then></if>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>


<comment type="block">/* dotted_as_name (',' dotted_as_name)* */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_dotted_as_names</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>validate_dotted_as_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>i</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>)
	    <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
		   &amp;&amp; <call><name>validate_dotted_as_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>
	<return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/* import_as_name (',' import_as_name)* [','] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_import_as_names</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_import_as_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>i</name> + 1 &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>)
	<expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
	       &amp;&amp; <call><name>validate_import_as_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/* 'import' dotted_as_names */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_import_name</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>import_name</name></expr></argument>)</argument_list></call>
		&amp;&amp; <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"import_name"</expr></argument>)</argument_list></call>
		&amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"import"</expr></argument>)</argument_list></call>
		&amp;&amp; <call><name>validate_dotted_as_names</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<comment type="block">/* Helper function to count the number of leading dots in 
 * 'from ...module import name'
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_from_dots</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
		<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>DOT</name></expr>)</condition><then>
			<break>break;</break></then></if></for>
        <return>return <expr><name>i</name>-1</expr>;</return>
}</block></function>

<comment type="block">/* 'from' ('.'* dotted_name | '.') 'import' ('*' | '(' import_as_names ')' |
 *     import_as_names
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_import_from</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ndots</name> <init>= <expr><call><name>count_from_dots</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>havename</name> <init>= <expr>(<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>ndots</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>dotted_name</name>)</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name>ndots</name> + <name>havename</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>import_from</name></expr></argument>)</argument_list></call>
		&amp;&amp; (<name>nch</name> &gt;= 4 + <name>ndots</name>)
		&amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"from"</expr></argument>)</argument_list></call>
		&amp;&amp; (!<name>havename</name> || <call><name>validate_dotted_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>ndots</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
		&amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name> + 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"import"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>res</name> &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>LPAR</name></expr>)</condition><then>
	    <expr_stmt><expr><name>res</name> = ((<name>nch</name> == <name>offset</name> + 5)
		   &amp;&amp; <call><name>validate_lparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
		   &amp;&amp; <call><name>validate_import_as_names</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name> + 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
		   &amp;&amp; <call><name>validate_rparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name> + 4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>res</name> &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>STAR</name></expr>)</condition><then>
	    <expr_stmt><expr><name>res</name> = <call><name>validate_import_as_names</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
	<return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/* import_stmt: import_name | import_from */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_import_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"import_stmt"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ntype</name> <init>= <expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ntype</name> == <name>import_name</name> || <name>ntype</name> == <name>import_from</name></expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_node</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <block>{
            <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal import_stmt child type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>nch</name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>,
                     <argument><expr>"Unrecognized child node of import_stmt: %d."</expr></argument>,
                     <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_global_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>global_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>is_even</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>nch</name> &gt;= 2))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal global statement"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"global"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
    <for>for (<init><expr><name>j</name> = 2</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>j</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>j</name> += 2</expr></incr>)
        <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  exec_stmt:
 *
 *  'exec' expr ['in' test [',' test]]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_exec_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>exec_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 2) || (<name>nch</name> == 4) || (<name>nch</name> == 6))
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"exec"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal exec statement"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> &gt; 2)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"in"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 6)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  assert_stmt:
 *
 *  'assert' test [',' test]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_assert_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>assert_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 2) || (<name>nch</name> == 4))
               &amp;&amp; (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"assert"</expr></argument>)</argument_list></call>)
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal assert statement"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> &gt; 2)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_while</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>while_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 4) || (<name>nch</name> == 7))
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"while"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 7)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"else"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_for</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>for_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 6) || (<name>nch</name> == 9))
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"for"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_exprlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"in"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_testlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 9)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"else"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  try_stmt:
 *      'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite]
 *    | 'try' ':' suite 'finally' ':' suite
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_try</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>try_stmt</name></expr></argument>)</argument_list></call>
               &amp;&amp; (<name>nch</name> &gt;= 6) &amp;&amp; ((<name>nch</name> % 3) == 0))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"try"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>name</name> <init>= <expr>"except"</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>except_clause</name></expr>)</condition><then>
            <expr_stmt><expr><name>name</name> = <call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>,
                     <argument><expr>"Illegal number of children for try/%s node."</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <comment type="block">/*  Skip past except_clause sections:  */</comment>
    <while>while <condition>(<expr><name>res</name> &amp;&amp; (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>except_clause</name>)</expr>)</condition> <block>{
        <expr_stmt><expr><name>res</name> = (<call><name>validate_except_clause</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>pos</name> += 3</expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>res</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"finally"</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = (<call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>6</expr></argument>, <argument><expr>"try/finally"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>nch</name> == (<name>pos</name> + 3)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>res</name> = ((<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"except"</expr></argument>)</argument_list></call> == 0)
                       || (<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"else"</expr></argument>)</argument_list></call> == 0))</expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>res</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal trailing triple in try statement"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>nch</name> == (<name>pos</name> + 6)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"except"</expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 3</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"else"</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            }</block></then>
            <else>else
                <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 3</expr></argument>, <argument><expr>"try/except"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
        }</block></then></if></else></if>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_except_clause</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>except_clause</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 1) || (<name>nch</name> == 2) || (<name>nch</name> == 4))
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"except"</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> &gt; 1)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 4)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_test</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>lambdef</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = ((<name>nch</name> == 1)
               &amp;&amp; <call><name>validate_lambdef</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = <call><name>validate_or_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> = (<name>res</name> &amp;&amp; (<name>nch</name> == 1 || (<name>nch</name> == 5 &amp;&amp;
            <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"if"</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>validate_or_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"else"</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)))</expr>;</expr_stmt>
    }</block></then></if></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_old_test</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>old_test</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>nch</name> == 1)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>old_lambdef</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_old_lambdef</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = (<call><name>validate_or_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    }</block></then></if></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_or_test</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>or_test</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>res</name> = <call><name>validate_and_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>pos</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>pos</name> += 2</expr></incr>)
            <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"or"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_and_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_and_test</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>and_test</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_not_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>pos</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>pos</name> += 2</expr></incr>)
        <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"and"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_not_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_not_test</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>not_test</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>nch</name> == 1) || (<name>nch</name> == 2))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>nch</name> == 2</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = (<call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"not"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_not_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>nch</name> == 1</expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_comparison</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_comparison</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>comparison</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>pos</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>pos</name> += 2</expr></incr>)
        <expr_stmt><expr><name>res</name> = (<call><name>validate_comp_op</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_comp_op</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>comp_op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>(0)</expr>;</return></then></if>
    <if>if <condition>(<expr><name>nch</name> == 1</expr>)</condition><then> <block>{
        <comment type="block">/*
         *  Only child will be a terminal with a well-defined symbolic name
         *  or a NAME with a string of either 'is' or 'in'
         */</comment>
        <expr_stmt><expr><name>tree</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <case>case <expr><name>LESS</name></expr>:
            </case><case>case <expr><name>GREATER</name></expr>:
            </case><case>case <expr><name>EQEQUAL</name></expr>:
            </case><case>case <expr><name>EQUAL</name></expr>:
            </case><case>case <expr><name>LESSEQUAL</name></expr>:
            </case><case>case <expr><name>GREATEREQUAL</name></expr>:
            </case><case>case <expr><name>NOTEQUAL</name></expr>:
              <expr_stmt><expr><name>res</name> = 1</expr>;</expr_stmt>
              <break>break;</break>
            </case><case>case <expr><name>NAME</name></expr>:
              <expr_stmt><expr><name>res</name> = ((<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"in"</expr></argument>)</argument_list></call> == 0)
                     || (<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"is"</expr></argument>)</argument_list></call> == 0))</expr>;</expr_stmt>
              <if>if <condition>(<expr>!<name>res</name></expr>)</condition><then> <block>{
                  <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>,
                               <argument><expr>"illegal operator '%s'"</expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then></if>
              <break>break;</break>
          </case><default>default:
              <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal comparison operator type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
        </default>}</block></switch>
    }</block></then>
    <else>else <if>if <condition>(<expr>(<name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"comp_op"</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = (<call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call>
               &amp;&amp; (((<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"is"</expr></argument>)</argument_list></call> == 0)
                    &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"not"</expr></argument>)</argument_list></call> == 0))
                   || ((<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"not"</expr></argument>)</argument_list></call> == 0)
                       &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"in"</expr></argument>)</argument_list></call> == 0))))</expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"unknown comparison operator"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_expr</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_xor_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>j</name> = 2</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>j</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>j</name> += 2</expr></incr>)
        <expr_stmt><expr><name>res</name> = (<call><name>validate_xor_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_vbar</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_xor_expr</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>xor_expr</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_and_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>j</name> = 2</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>j</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>j</name> += 2</expr></incr>)
        <expr_stmt><expr><name>res</name> = (<call><name>validate_circumflex</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_and_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_and_expr</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>and_expr</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_shift_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>pos</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>pos</name> += 2</expr></incr>)
        <expr_stmt><expr><name>res</name> = (<call><name>validate_ampersand</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_shift_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_chain_two_ops</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>, <param><function_decl><type><name>int</name></type> (*<name>termvalid</name>)<parameter_list>(<param><decl><type><name>node</name> *</type></decl></param>)</parameter_list></function_decl></param>, <param><decl><type><name>int</name></type> <name>op1</name></decl></param>, <param><decl><type><name>int</name></type> <name>op2</name></decl></param>)</parameter_list>
 <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call>(*<name>termvalid</name>)<argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <for>for ( <init>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>pos</name> += 2</expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>op1</name></expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call>(*<name>termvalid</name>)<argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_shift_expr</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>shift_expr</name></expr></argument>)</argument_list></call>
            &amp;&amp; <call><name>validate_chain_two_ops</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>validate_arith_expr</name></expr></argument>,
                                      <argument><expr><name>LEFTSHIFT</name></expr></argument>, <argument><expr><name>RIGHTSHIFT</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_arith_expr</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>arith_expr</name></expr></argument>)</argument_list></call>
            &amp;&amp; <call><name>validate_chain_two_ops</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>validate_term</name></expr></argument>, <argument><expr><name>PLUS</name></expr></argument>, <argument><expr><name>MINUS</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_term</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>is_odd</name><argument_list>(<argument><expr><name>nch</name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_factor</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <for>for ( <init>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr><name>pos</name> += 2</expr></incr>)
        <expr_stmt><expr><name>res</name> = (((<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>STAR</name>)
               || (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>SLASH</name>)
               || (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>DOUBLESLASH</name>)
               || (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>PERCENT</name>))
               &amp;&amp; <call><name>validate_factor</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  factor:
 *
 *  factor: ('+'|'-'|'~') factor | power
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_factor</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call>
               &amp;&amp; (((<name>nch</name> == 2)
                    &amp;&amp; ((<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>PLUS</name>)
                        || (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>MINUS</name>)
                        || (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>TILDE</name>))
                    &amp;&amp; <call><name>validate_factor</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
                   || ((<name>nch</name> == 1)
                       &amp;&amp; <call><name>validate_power</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)))</expr></init></decl>;</decl_stmt>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  power:
 *
 *  power: atom trailer* ('**' factor)*
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_power</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>power</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>nch</name> &gt;= 1)
               &amp;&amp; <call><name>validate_atom</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>) &amp;&amp; (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>trailer</name>)</expr>)</condition>
        <expr_stmt><expr><name>res</name> = <call><name>validate_trailer</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name>++</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>is_even</name><argument_list>(<argument><expr><name>nch</name> - <name>pos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal number of nodes for 'power'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>(0)</expr>;</return>
        }</block></then></if>
        <for>for ( <init>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; (<name>nch</name> - 1))</expr>;</condition> <incr><expr><name>pos</name> += 2</expr></incr>)
            <expr_stmt><expr><name>res</name> = (<call><name>validate_doublestar</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_factor</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></for>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_atom</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>nch</name> &lt; 1</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name>+1</expr></argument>, <argument><expr>"atom"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
          <case>case <expr><name>LPAR</name></expr>:
            <expr_stmt><expr><name>res</name> = ((<name>nch</name> &lt;= 3)
                   &amp;&amp; (<call><name>validate_rparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>))</expr>;</expr_stmt>

            <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 3)</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>==<name>yield_expr</name></expr>)</condition><then>
			<expr_stmt><expr><name>res</name> = <call><name>validate_yield_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
                	<expr_stmt><expr><name>res</name> = <call><name>validate_testlist_gexp</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	    }</block></then></if>
            <break>break;</break>
          </case><case>case <expr><name>LSQB</name></expr>:
            <if>if <condition>(<expr><name>nch</name> == 2</expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RSQB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>nch</name> == 3</expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = (<call><name>validate_listmaker</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                       &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RSQB</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
            <else>else <block>{
                <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal list display atom"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
            <break>break;</break>
          </case><case>case <expr><name>LBRACE</name></expr>:
            <expr_stmt><expr><name>res</name> = ((<name>nch</name> &lt;= 3)
                   &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RBRACE</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

            <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 3)</expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = <call><name>validate_dictmaker</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <break>break;</break>
          </case><case>case <expr><name>BACKQUOTE</name></expr>:
            <expr_stmt><expr><name>res</name> = ((<name>nch</name> == 3)
                   &amp;&amp; <call><name>validate_testlist1</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKQUOTE</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>NAME</name></expr>:
          </case><case>case <expr><name>NUMBER</name></expr>:
            <expr_stmt><expr><name>res</name> = (<name>nch</name> == 1)</expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>STRING</name></expr>:
            <for>for (<init><expr><name>pos</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr>++<name>pos</name></expr></incr>)
                <expr_stmt><expr><name>res</name> = <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <break>break;</break>
          </case><default>default:
            <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </default>}</block></switch>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  listmaker:
 *    test ( list_for | (',' test)* [','] )
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_listmaker</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><name>nch</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nch</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"missing child nodes of listmaker"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>ok</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <comment type="block">/*
     *  list_for | (',' test)* [',']
     */</comment>
    <if>if <condition>(<expr><name>nch</name> == 2 &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>list_for</name></expr>)</condition><then>
        <expr_stmt><expr><name>ok</name> = <call><name>validate_list_for</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
        <comment type="block">/*  (',' test)* [',']  */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>ok</name> &amp;&amp; <name>nch</name> - <name>i</name> &gt;= 2</expr>)</condition> <block>{
            <expr_stmt><expr><name>ok</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                  &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>ok</name> &amp;&amp; <name>i</name> == <name>nch</name>-1</expr>)</condition><then>
            <expr_stmt><expr><name>ok</name> = <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>i</name> != <name>nch</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal trailing nodes for listmaker"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></else></if>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/*  testlist_gexp:
 *    test ( gen_for | (',' test)* [','] )
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_testlist_gexp</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><name>nch</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nch</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"missing child nodes of testlist_gexp"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
        <expr_stmt><expr><name>ok</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     *  gen_for | (',' test)* [',']
     */</comment>
    <if>if <condition>(<expr><name>nch</name> == 2 &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>gen_for</name></expr>)</condition><then>
        <expr_stmt><expr><name>ok</name> = <call><name>validate_gen_for</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
        <comment type="block">/*  (',' test)* [',']  */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>ok</name> &amp;&amp; <name>nch</name> - <name>i</name> &gt;= 2</expr>)</condition> <block>{
            <expr_stmt><expr><name>ok</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                  &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>ok</name> &amp;&amp; <name>i</name> == <name>nch</name>-1</expr>)</condition><then>
            <expr_stmt><expr><name>ok</name> = <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>i</name> != <name>nch</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal trailing nodes for testlist_gexp"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></else></if>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/*  decorator:
 *    '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_decorator</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>ok</name> = (<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>decorator</name></expr></argument>)</argument_list></call> &amp;&amp;
	  (<name>nch</name> == 3 || <name>nch</name> == 5 || <name>nch</name> == 6) &amp;&amp;
	  <call><name>validate_at</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
	  <call><name>validate_dotted_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
	  <call><name>validate_newline</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>ok</name> &amp;&amp; <name>nch</name> != 3</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>ok</name> = (<call><name>validate_lparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
	      <call><name>validate_rparen</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

	<if>if <condition>(<expr><name>ok</name> &amp;&amp; <name>nch</name> == 6</expr>)</condition><then>
	    <expr_stmt><expr><name>ok</name> = <call><name>validate_arglist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/*  decorators:
 *    decorator+
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_decorators</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nch</name></decl>, <decl><type ref="prev"/><name>ok</name></decl>;</decl_stmt> 
    <expr_stmt><expr><name>nch</name> = <call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>decorators</name></expr></argument>)</argument_list></call> &amp;&amp; <name>nch</name> &gt;= 1</expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>ok</name> &amp;&amp; <name>i</name> &lt; <name>nch</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
	<expr_stmt><expr><name>ok</name> = <call><name>validate_decorator</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/*  with_var
with_var: 'as' expr
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_with_var</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>with_var</name></expr></argument>)</argument_list></call>
        &amp;&amp; (<name>nch</name> == 2)
        &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"as"</expr></argument>)</argument_list></call>
        &amp;&amp; <call><name>validate_expr</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
   <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/*  with_stmt
 *           0      1       2       -2   -1
with_stmt: 'with' test [ with_var ] ':' suite
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_with_stmt</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>with_stmt</name></expr></argument>)</argument_list></call>
        &amp;&amp; ((<name>nch</name> == 4) || (<name>nch</name> == 5))
        &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"with"</expr></argument>)</argument_list></call>
        &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
        &amp;&amp; (<name>nch</name> == 4 || <call><name>validate_with_var</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) 
        &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
        &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
   <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/*  funcdef:
 *      
 *     -5   -4         -3  -2    -1
 *  'def' NAME parameters ':' suite
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_funcdef</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>funcdef</name></expr></argument>)</argument_list></call>
	       &amp;&amp; (<name>nch</name> == 5)
	       &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-5</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"def"</expr></argument>)</argument_list></call>
	       &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-4</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call>
	       &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
	       &amp;&amp; <call><name>validate_parameters</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
	       &amp;&amp; <call><name>validate_suite</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>


<comment type="block">/* decorated
 *   decorators (classdef | funcdef)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_decorated</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>decorated</name></expr></argument>)</argument_list></call>
	    &amp;&amp; (<name>nch</name> == 2)
	    &amp;&amp; <call><name>validate_decorators</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
	    &amp;&amp; (<call><name>validate_funcdef</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
		|| <call><name>validate_class</name><argument_list>(<argument><expr><call><name>RCHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
	    )</expr></init></decl>;</decl_stmt>
  <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_lambdef</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>lambdef</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 3) || (<name>nch</name> == 4))
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"lambda"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 4)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_varargslist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>(<name>void</name>) <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>"lambdef"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_old_lambdef</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>old_lambdef</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 3) || (<name>nch</name> == 4))
               &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"lambda"</expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 4)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_varargslist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>(<name>void</name>) <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>"old_lambdef"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  arglist:
 *
 *  (argument ',')* (argument [','] | '*' test [',' '**' test] | '**' test)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_arglist</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nch</name> &lt;= 0</expr>)</condition><then>
        <comment type="block">/* raise the right error from having an invalid number of children */</comment>
        <return>return <expr><call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> + 1</expr></argument>, <argument><expr>"arglist"</expr></argument>)</argument_list></call></expr>;</return></then></if>

    <if>if <condition>(<expr><name>nch</name> &gt; 1</expr>)</condition><then> <block>{
        <for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nch</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>argument</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>node</name> *</type><name>ch</name> <init>= <expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name>NCH</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> == 2 &amp;&amp; <call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>gen_for</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"need '(', ')' for generator expression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr>0</expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

    <while>while <condition>(<expr><name>ok</name> &amp;&amp; <name>nch</name>-<name>i</name> &gt;= 2</expr>)</condition> <block>{
        <comment type="block">/* skip leading (argument ',') */</comment>
        <expr_stmt><expr><name>ok</name> = (<call><name>validate_argument</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
              &amp;&amp; <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
            <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></while>
    <expr_stmt><expr><name>ok</name> = 1</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nch</name>-<name>i</name> &gt; 0</expr>)</condition><then> <block>{
        <comment type="block">/*
         * argument | '*' test [',' '**' test] | '**' test
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>sym</name> <init>= <expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>sym</name> == <name>argument</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <call><name>validate_argument</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ok</name> &amp;&amp; <name>i</name>+1 != <name>nch</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal arglist specification"
                           " (extra stuff on end)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>sym</name> == <name>STAR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <call><name>validate_star</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ok</name> &amp;&amp; (<name>nch</name>-<name>i</name> == 2)</expr>)</condition><then>
                <expr_stmt><expr><name>ok</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>ok</name> &amp;&amp; (<name>nch</name>-<name>i</name> == 5)</expr>)</condition><then>
                <expr_stmt><expr><name>ok</name> = (<call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                      &amp;&amp; <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                      &amp;&amp; <call><name>validate_doublestar</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                      &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal use of '*' in arglist"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>sym</name> == <name>DOUBLESTAR</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>nch</name>-<name>i</name> == 2</expr>)</condition><then>
                <expr_stmt><expr><name>ok</name> = (<call><name>validate_doublestar</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                      &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal use of '**' in arglist"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal arglist specification"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ok</name> = 0</expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>
    }</block></then></if>
    <return>return <expr>(<name>ok</name>)</expr>;</return>
}</block></function>



<comment type="block">/*  argument:
 *
 *  [test '='] test [gen_for]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_argument</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>argument</name></expr></argument>)</argument_list></call>
               &amp;&amp; ((<name>nch</name> == 1) || (<name>nch</name> == 2) || (<name>nch</name> == 3))
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 2)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_gen_for</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 3)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = (<call><name>validate_equal</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if></else></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>



<comment type="block">/*  trailer:
 *
 *  '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_trailer</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>trailer</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>nch</name> == 2) || (<name>nch</name> == 3))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
          <case>case <expr><name>LPAR</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_rparen</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 3)</expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = <call><name>validate_arglist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <break>break;</break>
          </case><case>case <expr><name>LSQB</name></expr>:
            <expr_stmt><expr><name>res</name> = (<call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>"trailer"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_subscriptlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RSQB</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>DOT</name></expr>:
            <expr_stmt><expr><name>res</name> = (<call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"trailer"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAME</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <break>break;</break>
          </case><default>default:
            <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </default>}</block></switch>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr>(<name>void</name>) <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"trailer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  subscriptlist:
 *
 *  subscript (',' subscript)* [',']
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_subscriptlist</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_repeating_list</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>subscriptlist</name></expr></argument>,
                                    <argument><expr><name>validate_subscript</name></expr></argument>, <argument><expr>"subscriptlist"</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<comment type="block">/*  subscript:
 *
 *  '.' '.' '.' | test | [test] ':' [test] [sliceop]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_subscript</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>subscript</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>nch</name> &gt;= 1) &amp;&amp; (<name>nch</name> &lt;= 4)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"invalid number of arguments for subscript node"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr>(0)</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>DOT</name></expr>)</condition><then>
        <comment type="block">/* take care of ('.' '.' '.') possibility */</comment>
        <return>return <expr>(<call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>"subscript"</expr></argument>)</argument_list></call>
                &amp;&amp; <call><name>validate_dot</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                &amp;&amp; <call><name>validate_dot</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                &amp;&amp; <call><name>validate_dot</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return></then></if>
    <if>if <condition>(<expr><name>nch</name> == 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>test</name></expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>res</name> = <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <return>return <expr>(<name>res</name>)</expr>;</return>
    }</block></then></if>
    <comment type="block">/*  Must be [test] ':' [test] [sliceop],
     *  but at least one of the optional components will
     *  be present, but we don't know which yet.
     */</comment>
    <if>if <condition>(<expr>(<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>COLON</name>) || (<name>nch</name> == 4)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>res</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>rem</name> <init>= <expr><name>nch</name> - ++<name>offset</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>rem</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>test</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>res</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>++<name>offset</name></expr>;</expr_stmt>
                <expr_stmt><expr>--<name>rem</name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>res</name> &amp;&amp; <name>rem</name></expr>)</condition><then>
                <expr_stmt><expr><name>res</name> = <call><name>validate_sliceop</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_sliceop</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>((<name>nch</name> == 1) || <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>"sliceop"</expr></argument>)</argument_list></call>)
              &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>sliceop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>res</name> = <call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"sliceop"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> == 2)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_exprlist</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>validate_repeating_list</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>exprlist</name></expr></argument>,
                                    <argument><expr><name>validate_expr</name></expr></argument>, <argument><expr>"exprlist"</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_dictmaker</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>dictmaker</name></expr></argument>)</argument_list></call>
               &amp;&amp; (<name>nch</name> &gt;= 3)
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; ((<name>nch</name> % 4) == 0)</expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = <call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>--<name>nch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
        <expr_stmt><expr><name>res</name> = ((<name>nch</name> % 4) == 3)</expr>;</expr_stmt></then></if></else></if>

    <if>if <condition>(<expr><name>res</name> &amp;&amp; (<name>nch</name> &gt; 3)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
        <comment type="block">/*  ( ',' test ':' test )*  */</comment>
        <while>while <condition>(<expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; <name>nch</name>)</expr>)</condition> <block>{
            <expr_stmt><expr><name>res</name> = (<call><name>validate_comma</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_colon</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_test</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name> + 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> += 4</expr>;</expr_stmt>
        }</block></while>
    }</block></then></if>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_eval_input</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>(<call><name>validate_ntype</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>eval_input</name></expr></argument>)</argument_list></call>
               &amp;&amp; (<name>nch</name> &gt;= 2)
               &amp;&amp; <call><name>validate_testlist</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name> - 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ENDMARKER</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>pos</name> = 1</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>pos</name> &lt; (<name>nch</name> - 1))</expr>;</condition> <incr><expr>++<name>pos</name></expr></incr>)
        <expr_stmt><expr><name>res</name> = <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NEWLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_node</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type>   <name>nch</name>  <init>= <expr>0</expr></init></decl>;</decl_stmt>                     <comment type="block">/* num. children on current node  */</comment>
    <decl_stmt><decl><type><name>int</name></type>   <name>res</name>  <init>= <expr>1</expr></init></decl>;</decl_stmt>                     <comment type="block">/* result value                   */</comment>
    <decl_stmt><decl><type><name>node</name>*</type> <name>next</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>                     <comment type="block">/* node to process after this one */</comment>

    <while>while <condition>(<expr><name>res</name> &amp;&amp; (<name>tree</name> != 0)</expr>)</condition> <block>{
        <expr_stmt><expr><name>nch</name>  = <call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>next</name> = 0</expr>;</expr_stmt>
        <switch>switch <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <comment type="block">/*
             *  Definition nodes.
             */</comment>
          <case>case <expr><name>funcdef</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_funcdef</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>with_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_with_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>classdef</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_class</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
	  </case><case>case <expr><name>decorated</name></expr>:
	    <expr_stmt><expr><name>res</name> = <call><name>validate_decorated</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
            <comment type="block">/*
             *  "Trivial" parse tree nodes.
             *  (Why did I call these trivial?)
             */</comment>
          </case><case>case <expr><name>stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>small_stmt</name></expr>:
            <comment type="block">/*
             *  expr_stmt | print_stmt | del_stmt | pass_stmt | flow_stmt
             *  | import_stmt | global_stmt | exec_stmt | assert_stmt
             */</comment>
            <expr_stmt><expr><name>res</name> = <call><name>validate_small_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>flow_stmt</name></expr>:
            <expr_stmt><expr><name>res</name>  = (<call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"flow_stmt"</expr></argument>)</argument_list></call>
                    &amp;&amp; ((<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>break_stmt</name>)
                        || (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>continue_stmt</name>)
                        || (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>yield_stmt</name>)
                        || (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>return_stmt</name>)
                        || (<call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>raise_stmt</name>)))</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>res</name></expr>)</condition><then>
                <expr_stmt><expr><name>next</name> = <call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>nch</name> == 1</expr>)</condition><then>
                <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"illegal flow_stmt type"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
            <break>break;</break>
          </case><case>case <expr><name>yield_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_yield_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            <comment type="block">/*
             *  Compound statements.
             */</comment>
          </case><case>case <expr><name>simple_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_simple_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>compound_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_compound_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            <comment type="block">/*
             *  Fundamental statements.
             */</comment>
          </case><case>case <expr><name>expr_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_expr_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>print_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_print_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>del_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_del_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>pass_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = (<call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"pass"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"pass"</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>break_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = (<call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"break"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"break"</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>continue_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = (<call><name>validate_numnodes</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>"continue"</expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>validate_name</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"continue"</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>return_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_return_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>raise_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_raise_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>import_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_import_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
	  </case><case>case <expr><name>import_name</name></expr>:
	    <expr_stmt><expr><name>res</name> = <call><name>validate_import_name</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	  </case><case>case <expr><name>import_from</name></expr>:
	    <expr_stmt><expr><name>res</name> = <call><name>validate_import_from</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
          </case><case>case <expr><name>global_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_global_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>exec_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_exec_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>assert_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_assert_stmt</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>if_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_if</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>while_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_while</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>for_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_for</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>try_stmt</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_try</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>suite</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_suite</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            <comment type="block">/*
             *  Expression nodes.
             */</comment>
          </case><case>case <expr><name>testlist</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_testlist</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>yield_expr</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_yield_expr</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>testlist1</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_testlist1</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>test</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_test</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>and_test</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_and_test</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>not_test</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_not_test</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>comparison</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_comparison</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>exprlist</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_exprlist</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>comp_op</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_comp_op</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>expr</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_expr</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>xor_expr</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_xor_expr</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>and_expr</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_and_expr</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>shift_expr</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_shift_expr</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>arith_expr</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_arith_expr</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>term</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_term</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>factor</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_factor</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>power</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_power</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>atom</name></expr>:
            <expr_stmt><expr><name>res</name> = <call><name>validate_atom</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><default>default:
            <comment type="block">/* Hopefully never reached! */</comment>
            <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"unrecognized node type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </default>}</block></switch>
        <expr_stmt><expr><name>tree</name> = <name>next</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_expr_tree</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>validate_eval_input</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"could not validate expression tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  file_input:
 *      (NEWLINE | stmt)* ENDMARKER
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_file_input</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>((<name>nch</name> &gt;= 0)
               &amp;&amp; <call><name>validate_ntype</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>nch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ENDMARKER</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>res</name> &amp;&amp; (<name>j</name> &lt; <name>nch</name>)</expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>stmt</name></expr>)</condition><then>
            <expr_stmt><expr><name>res</name> = <call><name>validate_stmt</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>res</name> = <call><name>validate_newline</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></for>
    <comment type="block">/*  This stays in to prevent any internal failures from getting to the
     *  user.  Hopefully, this won't be needed.  If a user reports getting
     *  this, we have some debugging to do.
     */</comment>
    <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"VALIDATION FAILURE: report this to the maintainer!"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>res</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_encoding_decl</name><parameter_list>(<param><decl><type><name>node</name> *</type><name>tree</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nch</name> <init>= <expr><call><name>NCH</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>((<name>nch</name> == 1)
        &amp;&amp; <call><name>validate_file_input</name><argument_list>(<argument><expr><call><name>CHILD</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>res</name> &amp;&amp; !<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>err_string</name><argument_list>(<argument><expr>"Error Parsing encoding_decl"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>pickle_constructor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>parser__pickler</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <macro><name>NOTE</name><argument_list>(<argument>ARGUNUSED(self)</argument>)</argument_list></macro>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>st</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>empty_dict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O!:_pickler"</expr></argument>, <argument><expr>&amp;<name>PyST_Type</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>newargs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>tuple</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>(<name>empty_dict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
            <goto>goto <name>finally</name>;</goto></then></if>
        <if>if <condition>(<expr>(<name>newargs</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oi"</expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
            <goto>goto <name>finally</name>;</goto></then></if>
        <expr_stmt><expr><name>tuple</name> = <call><name>parser_st2tuple</name><argument_list>(<argument><expr>(<name>PyST_Object</name>*)<name>NULL</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>empty_dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tuple</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"O(O)"</expr></argument>, <argument><expr><name>pickle_constructor</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>empty_dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <label><name>finally</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>empty_dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr>(<name>result</name>)</expr>;</return>
}</block></function>


<comment type="block">/*  Functions exported by this module.  Most of this should probably
 *  be converted into an ST object with methods, but that is better
 *  done directly in Python, allowing subclasses to be created directly.
 *  We'd really have to write a wrapper around it all anyway to allow
 *  inheritance.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>parser_functions</name><index>[]</index></name> <init>=  <expr><block>{
    <expr><block>{<expr>"ast2tuple"</expr>,       <expr>(<name>PyCFunction</name>)<name>parser_ast2tuple</name></expr>, <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates a tuple-tree representation of an ST."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"ast2list"</expr>,        <expr>(<name>PyCFunction</name>)<name>parser_ast2list</name></expr>,  <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates a list-tree representation of an ST."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"compileast"</expr>,      <expr>(<name>PyCFunction</name>)<name>parser_compileast</name></expr>,<expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Compiles an ST object into a code object."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"compilest"</expr>,      <expr>(<name>PyCFunction</name>)<name>parser_compilest</name></expr>,  <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Compiles an ST object into a code object."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"expr"</expr>,            <expr>(<name>PyCFunction</name>)<name>parser_expr</name></expr>,      <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates an ST object from an expression."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"isexpr"</expr>,          <expr>(<name>PyCFunction</name>)<name>parser_isexpr</name></expr>,    <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Determines if an ST object was created from an expression."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"issuite"</expr>,         <expr>(<name>PyCFunction</name>)<name>parser_issuite</name></expr>,   <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Determines if an ST object was created from a suite."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"suite"</expr>,           <expr>(<name>PyCFunction</name>)<name>parser_suite</name></expr>,     <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates an ST object from a suite."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"sequence2ast"</expr>,    <expr>(<name>PyCFunction</name>)<name>parser_tuple2ast</name></expr>, <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates an ST object from a tree representation."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"sequence2st"</expr>,     <expr>(<name>PyCFunction</name>)<name>parser_tuple2st</name></expr>,  <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates an ST object from a tree representation."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"st2tuple"</expr>,        <expr>(<name>PyCFunction</name>)<name>parser_st2tuple</name></expr>,  <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates a tuple-tree representation of an ST."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"st2list"</expr>,         <expr>(<name>PyCFunction</name>)<name>parser_st2list</name></expr>,   <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates a list-tree representation of an ST."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"tuple2ast"</expr>,       <expr>(<name>PyCFunction</name>)<name>parser_tuple2ast</name></expr>, <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates an ST object from a tree representation."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"tuple2st"</expr>,        <expr>(<name>PyCFunction</name>)<name>parser_tuple2st</name></expr>,  <expr><name>PUBLIC_METHOD_TYPE</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Creates an ST object from a tree representation."</argument>)</argument_list></macro>}</block></expr>,

    <comment type="block">/* private stuff: support pickle module */</comment>
    <expr><block>{<expr>"_pickler"</expr>,        <expr>(<name>PyCFunction</name>)<name>parser__pickler</name></expr>,  <expr><name>METH_VARARGS</name></expr>,
        <macro><name>PyDoc_STR</name><argument_list>(<argument>"Returns the pickle magic to allow ST objects to be pickled."</argument>)</argument_list></macro>}</block></expr>,

    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>


<function_decl><type><name>PyMODINIT_FUNC</name></type> <name>initparser</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>  <comment type="block">/* supply a prototype */</comment>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>initparser</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>module</name></decl>, *<decl><type ref="prev"/><name>copyreg</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>PyST_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>module</name> = <call><name>Py_InitModule</name><argument_list>(<argument><expr>"parser"</expr></argument>, <argument><expr><name>parser_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>module</name> == <name>NULL</name></expr>)</condition><then>
    	<return>return;</return></then></if>

    <if>if <condition>(<expr><name>parser_error</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>parser_error</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"parser.ParserError"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>parser_error</name> == 0</expr>)</condition><then>
        <comment type="block">/* caller will check PyErr_Occurred() */</comment>
        <return>return;</return></then></if>
    <comment type="block">/* CAUTION:  The code next used to skip bumping the refcount on
     * parser_error.  That's a disaster if initparser() gets called more
     * than once.  By incref'ing, we ensure that each module dict that
     * gets created owns its reference to the shared parser_error object,
     * and the file static parser_error vrbl owns a reference too.
     */</comment>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>parser_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"ParserError"</expr></argument>, <argument><expr><name>parser_error</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return;</return></then></if>

    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyST_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"ASTType"</expr></argument>, <argument><expr>(<name>PyObject</name>*)&amp;<name>PyST_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyST_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"STType"</expr></argument>, <argument><expr>(<name>PyObject</name>*)&amp;<name>PyST_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"__copyright__"</expr></argument>,
                               <argument><expr><name>parser_copyright_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"__doc__"</expr></argument>,
                               <argument><expr><name>parser_doc_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"__version__"</expr></argument>,
                               <argument><expr><name>parser_version_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Register to support pickling.
     * If this fails, the import of this module will fail because an
     * exception will be raised here; should we clear the exception?
     */</comment>
    <expr_stmt><expr><name>copyreg</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"copy_reg"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>copyreg</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>pickler</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>func</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>copyreg</name></expr></argument>, <argument><expr>"pickle"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pickle_constructor</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"sequence2st"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pickler</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"_pickler"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>pickle_constructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>func</name> != <name>NULL</name>) &amp;&amp; (<name>pickle_constructor</name> != <name>NULL</name>)
            &amp;&amp; (<name>pickler</name> != <name>NULL</name>)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>res</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr>&amp;<name>PyST_Type</name></expr></argument>, <argument><expr><name>pickler</name></expr></argument>,
                                               <argument><expr><name>pickle_constructor</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pickle_constructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pickler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>copyreg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
</unit>
