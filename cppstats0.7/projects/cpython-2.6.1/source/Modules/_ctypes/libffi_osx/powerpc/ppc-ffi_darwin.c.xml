<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_ctypes/libffi_osx/powerpc/ppc-ffi_darwin.c"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* -----------------------------------------------------------------------
   ffi.c - Copyright (c) 1998 Geoffrey Keating

   PowerPC Foreign Function Interface

   Darwin ABI support (c) 2001 John Hornkvist
   AIX ABI support (c) 2002 Free Software Foundation, Inc.

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   ``Software''), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
   ----------------------------------------------------------------------- */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ffi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ffi_common.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ppc-darwin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;architecture/ppc/mode_independent_asm.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POWERPC_DARWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libkern/OSCacheControl.h&gt;</cpp:file></cpp:include>	<comment type="line">// for sys_icache_invalidate()</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<comment type="block">/* Explicit prototype instead of including a header to allow compilation
 * on Tiger systems.
 */</comment>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> weak sys_icache_invalidate</cpp:pragma>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>sys_icache_invalidate</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>start</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ffi_closure_ASM</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<comment type="line">// The layout of a function descriptor.  A C function pointer really</comment>
<comment type="line">// points to one of these.</comment>
<typedef>typedef <type><struct>struct <name>aix_fd_struct</name> <block>{
  <decl_stmt><decl><type><name>void</name>*</type>	<name>code_pointer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name>*</type>	<name>toc</name></decl>;</decl_stmt>
}</block></struct></type> <name>aix_fd</name>;</typedef>

<comment type="block">/* ffi_prep_args is called by the assembly routine once stack space
   has been allocated for the function's arguments.

   The stack layout we want looks like this:

   |   Return address from ffi_call_DARWIN      |	higher addresses
   |--------------------------------------------|
   |   Previous backchain pointer      4/8      |	    stack pointer here
   |--------------------------------------------|-\ &lt;&lt;&lt; on entry to
   |   Saved r28-r31                 (4/8)*4    | |	    ffi_call_DARWIN
   |--------------------------------------------| |
   |   Parameters      (at least 8*(4/8)=32/64) | | (176) +112 - +288
   |--------------------------------------------| |
   |   Space for GPR2                  4/8      | |
   |--------------------------------------------| |	stack	|
   |   Reserved						 (4/8)*2    | |	grows	|
   |--------------------------------------------| |	down	V
   |   Space for callee's LR           4/8      | |
   |--------------------------------------------| |	lower addresses
   |   Saved CR                        4/8      | |
   |--------------------------------------------| |     stack pointer here
   |   Current backchain pointer       4/8      | |     during
   |--------------------------------------------|-/ &lt;&lt;&lt; ffi_call_DARWIN

	Note: ppc64 CR is saved in the low word of a long on the stack.
*/</comment>

<comment type="block">/*@-exportheader@*/</comment>
<function><type><name>void</name></type>
<name>ffi_prep_args</name><parameter_list>(
	<param><decl><type><name>extended_cif</name>*</type>	<name>inEcif</name></decl></param>,
	<param><decl><type><name>unsigned</name> *<specifier>const</specifier></type>	<name>stack</name></decl></param>)</parameter_list>
<comment type="block">/*@=exportheader@*/</comment>
<block>{
	<comment type="block">/*	Copy the ecif to a local var so we can trample the arg.
		BC note: test this with GP later for possible problems...	*/</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>extended_cif</name>*</type>	<name>ecif</name>	<init>= <expr><name>inEcif</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>bytes</name>	<init>= <expr><name><name>ecif</name>-&gt;<name>cif</name>-&gt;<name>bytes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>flags</name>	<init>= <expr><name><name>ecif</name>-&gt;<name>cif</name>-&gt;<name>flags</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*	Cast the stack arg from int* to long*. sizeof(long) == 4 in 32-bit mode
		and 8 in 64-bit mode.	*/</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name> *<specifier>const</specifier></type> <name>longStack</name>	<init>= <expr>(<name>unsigned</name> <name>long</name> *const)<name>stack</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* 'stacktop' points at the previous backchain pointer.	*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="line">//	In ppc-darwin.s, an extra 96 bytes is reserved for the linkage area,</comment>
	<comment type="line">//	saved registers, and an extra FPR.</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name> *<specifier>const</specifier></type> <name>stacktop</name>	<init>=
		<expr>(<name>unsigned</name> <name>long</name> *)<call>(<name>unsigned</name> <name>long</name>)<argument_list>(<argument><expr>(<name>char</name>*)<name>longStack</name> + <name>bytes</name> + 96</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name> *<specifier>const</specifier></type> <name>stacktop</name>	<init>= <expr><name>longStack</name> + (<name>bytes</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof>)</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* 'fpr_base' points at the space for fpr1, and grows upwards as
		we use FPR registers.  */</comment>
	<decl_stmt><decl><type><name>double</name>*</type>		<name>fpr_base</name> <init>= <expr><call>(<name>double</name>*)<argument_list>(<argument><expr><name>stacktop</name> - <name>ASM_NEEDS_REGISTERS</name></expr></argument>)</argument_list></call> -
		<name>NUM_FPR_ARG_REGISTERS</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="line">//	64-bit saves an extra register, and uses an extra FPR. Knock fpr_base</comment>
	<comment type="line">//	down a couple pegs.</comment>
	<expr_stmt><expr><name>fpr_base</name> -= 2</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>fparg_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* 'next_arg' grows up as we put parameters in it.  */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name>*</type>	<name>next_arg</name> <init>= <expr><name>longStack</name> + 6</expr></init></decl>;</decl_stmt> <comment type="block">/* 6 reserved positions.  */</comment>

	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>double_tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>**</type>			<name>p_argv</name> <init>= <expr><name><name>ecif</name>-&gt;<name>avalue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type>	<name>gprvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ffi_type</name>**</type>		<name>ptr</name> <init>= <expr><name><name>ecif</name>-&gt;<name>cif</name>-&gt;<name>arg_types</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check that everything starts aligned properly.  */</comment>
	<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr><name>stack</name> == <call><name>SF_ROUND</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr><name>stacktop</name> == <call><name>SF_ROUND</name><argument_list>(<argument><expr><name>stacktop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr><name>bytes</name> == <call><name>SF_ROUND</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*	Deal with return values that are actually pass-by-reference.
		Rule:
		Return values are referenced by r3, so r4 is the first parameter.  */</comment>

	<if>if <condition>(<expr><name>flags</name> &amp; <name>FLAG_RETVAL_REFERENCE</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>next_arg</name>++ = (<name>unsigned</name> <name>long</name>)(<name>char</name>*)<name><name>ecif</name>-&gt;<name>rvalue</name></name></expr>;</expr_stmt></then></if>

	<comment type="block">/* Now for the arguments.  */</comment>
	<for>for (<init><expr><name>i</name> = <name><name>ecif</name>-&gt;<name>cif</name>-&gt;<name>nargs</name></name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>ptr</name>++</expr>, <expr><name>p_argv</name>++</expr></incr>)
    <block>{
		<switch>switch <condition>(<expr><name>(*<name>ptr</name>)-&gt;<name>type</name></name></expr>)</condition>
		<block>{
			<comment type="block">/*	If a floating-point parameter appears before all of the general-
				purpose registers are filled, the corresponding GPRs that match
				the size of the floating-point parameter are shadowed for the
				benefit of vararg and pre-ANSI functions.	*/</comment>
			<case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
				<expr_stmt><expr><name>double_tmp</name> = *(<name>float</name>*)*<name>p_argv</name></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fparg_count</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
					<expr_stmt><expr>*<name>fpr_base</name>++ = <name>double_tmp</name></expr>;</expr_stmt></then></if>

				<expr_stmt><expr>*(<name>double</name>*)<name>next_arg</name> = <name>double_tmp</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>next_arg</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>fparg_count</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr><name>flags</name> &amp; <name>FLAG_FP_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
				<expr_stmt><expr><name>double_tmp</name> = *(<name>double</name>*)*<name>p_argv</name></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fparg_count</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
					<expr_stmt><expr>*<name>fpr_base</name>++ = <name>double_tmp</name></expr>;</expr_stmt></then></if>

				<expr_stmt><expr>*(<name>double</name>*)<name>next_arg</name> = <name>double_tmp</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>next_arg</name> += <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>2</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fparg_count</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr><name>flags</name> &amp; <name>FLAG_FP_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FFI_TYPE_LONGDOUBLE</name> != <name>FFI_TYPE_DOUBLE</name></expr></cpp:if>
			</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
				<if>if <condition>(<expr><name>fparg_count</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
					<expr_stmt><expr>*(<name>long</name> <name>double</name>*)<name>fpr_base</name>	= *(<name>long</name> <name>double</name>*)*<name>p_argv</name></expr>;</expr_stmt></then></if>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<if>if <condition>(<expr><name>fparg_count</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name> - 1</expr>)</condition><then>
					<expr_stmt><expr>*(<name>long</name> <name>double</name>*)<name>fpr_base</name>	= *(<name>long</name> <name>double</name>*)*<name>p_argv</name></expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name>fparg_count</name> == <name>NUM_FPR_ARG_REGISTERS</name> - 1</expr>)</condition><then>
					<expr_stmt><expr>*(<name>double</name>*)<name>fpr_base</name>	= *(<name>double</name>*)*<name>p_argv</name></expr>;</expr_stmt></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<expr_stmt><expr>*(<name>long</name> <name>double</name>*)<name>next_arg</name>	= *(<name>long</name> <name>double</name>*)*<name>p_argv</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>fparg_count</name> += 2</expr>;</expr_stmt>
				<expr_stmt><expr><name>fpr_base</name> += 2</expr>;</expr_stmt>
				<expr_stmt><expr><name>next_arg</name> += <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr><name>flags</name> &amp; <name>FLAG_FP_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="line">//	FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</comment>

			</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
				<expr_stmt><expr><name>gprvalue</name> = *(<name>long</name> <name>long</name>*)*<name>p_argv</name></expr>;</expr_stmt>
				<goto>goto <name>putgpr</name>;</goto>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<expr_stmt><expr>*(<name>long</name> <name>long</name>*)<name>next_arg</name> = *(<name>long</name> <name>long</name>*)*<name>p_argv</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>next_arg</name> += 2</expr>;</expr_stmt>
				<break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
				<expr_stmt><expr><name>gprvalue</name> = *(<name>unsigned</name> <name>long</name>*)*<name>p_argv</name></expr>;</expr_stmt>
				<goto>goto <name>putgpr</name>;</goto>

			</case><case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
				<expr_stmt><expr><name>gprvalue</name> = *(<name>unsigned</name> <name>char</name>*)*<name>p_argv</name></expr>;</expr_stmt>
				<goto>goto <name>putgpr</name>;</goto>

			</case><case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
				<expr_stmt><expr><name>gprvalue</name> = *(<name>signed</name> <name>char</name>*)*<name>p_argv</name></expr>;</expr_stmt>
				<goto>goto <name>putgpr</name>;</goto>

			</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
				<expr_stmt><expr><name>gprvalue</name> = *(<name>unsigned</name> <name>short</name>*)*<name>p_argv</name></expr>;</expr_stmt>
				<goto>goto <name>putgpr</name>;</goto>

			</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
				<expr_stmt><expr><name>gprvalue</name> = *(<name>signed</name> <name>short</name>*)*<name>p_argv</name></expr>;</expr_stmt>
				<goto>goto <name>putgpr</name>;</goto>

			</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
			<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
				<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>gprSize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>fprSize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ffi64_struct_to_reg_form</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>, <argument><expr>(<name>char</name>*)*<name>p_argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>fparg_count</name></expr></argument>,
					<argument><expr>(<name>char</name>*)<name>next_arg</name></expr></argument>, <argument><expr>&amp;<name>gprSize</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>fpr_base</name></expr></argument>, <argument><expr>&amp;<name>fprSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>next_arg</name> += <name>gprSize</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>fpr_base</name> += <name>fprSize</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<decl_stmt><decl><type><name>char</name>*</type>	<name>dest_cpy</name> <init>= <expr>(<name>char</name>*)<name>next_arg</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*	Structures that match the basic modes (QI 1 byte, HI 2 bytes,
				SI 4 bytes) are aligned as if they were those modes.
				Structures with 3 byte in size are padded upwards.  */</comment>
				<decl_stmt><decl><type><name>unsigned</name></type> <name>size_al</name> <init>= <expr><name>(*<name>ptr</name>)-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*	If the first member of the struct is a double, then align
				the struct to double-word.  */</comment>
				<if>if <condition>(<expr><name>(*<name>ptr</name>)-&gt;<name>elements</name></name><index>[<expr>0</expr>]</index>-&gt;<name>type</name> == <name>FFI_TYPE_DOUBLE</name></expr>)</condition><then>
					<expr_stmt><expr><name>size_al</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>(*<name>ptr</name>)-&gt;<name>size</name></name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

				<if>if <condition>(<expr><name><name>ecif</name>-&gt;<name>cif</name>-&gt;<name>abi</name></name> == <name>FFI_DARWIN</name></expr>)</condition><then>
				<block>{
					<if>if <condition>(<expr><name>size_al</name> &lt; 3</expr>)</condition><then>
						<expr_stmt><expr><name>dest_cpy</name> += 4 - <name>size_al</name></expr>;</expr_stmt></then></if>
				}</block></then></if>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name>*)<name>dest_cpy</name></expr></argument>, <argument><expr>(<name>char</name>*)*<name>p_argv</name></expr></argument>, <argument><expr><name>size_al</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>next_arg</name> += (<name>size_al</name> + 3) / 4</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<break>break;</break>
			}</block>

			</case><case>case <expr><name>FFI_TYPE_INT</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
				<expr_stmt><expr><name>gprvalue</name> = *(<name>unsigned</name>*)*<name>p_argv</name></expr>;</expr_stmt>

<label><name>putgpr</name>:</label>
				<expr_stmt><expr>*<name>next_arg</name>++ = <name>gprvalue</name></expr>;</expr_stmt>
				<break>break;</break>

			</case><default>default:
				<break>break;</break>
		</default>}</block></switch>
	}</block></for>

  <comment type="block">/* Check that we didn't overrun the stack...  */</comment>
  <comment type="line">//FFI_ASSERT(gpr_base &lt;= stacktop - ASM_NEEDS_REGISTERS);</comment>
  <comment type="line">//FFI_ASSERT((unsigned *)fpr_base</comment>
  <comment type="line">//	     &lt;= stacktop - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);</comment>
  <comment type="line">//FFI_ASSERT(flags &amp; FLAG_4_GPR_ARGUMENTS || intarg_count &lt;= 4);</comment>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>bool</name></type>
<name>ffi64_struct_contains_fp</name><parameter_list>(
	<param><decl><type><specifier>const</specifier> <name>ffi_type</name>*</type>	<name>inType</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>			<name>containsFP</name>	<init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name> &amp;&amp; !<name>containsFP</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<block>{
		<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>type</name> == <name>FFI_TYPE_FLOAT</name>		||
			<name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>type</name> == <name>FFI_TYPE_DOUBLE</name>	||
			<name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>type</name> == <name>FFI_TYPE_LONGDOUBLE</name></expr>)</condition><then>
			<expr_stmt><expr><name>containsFP</name> = <name>true</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>type</name> == <name>FFI_TYPE_STRUCT</name></expr>)</condition><then>
			<expr_stmt><expr><name>containsFP</name> = <call><name>ffi64_struct_contains_fp</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
	}</block></for>

	<return>return <expr><name>containsFP</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="line">// defined(__ppc64__)</comment>

<comment type="block">/* Perform machine dependent cif processing.  */</comment>
<function><type><name>ffi_status</name></type>
<name>ffi_prep_cif_machdep</name><parameter_list>(
	<param><decl><type><name>ffi_cif</name>*</type>	<name>cif</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* All this is for the DARWIN ABI.  */</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ffi_type</name>**</type>		<name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>intarg_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>fparg_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>size_al</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/*	All the machine-independent calculation of cif-&gt;bytes will be wrong.
		Redo the calculation for DARWIN.  */</comment>

	<comment type="block">/*	Space for the frame pointer, callee's LR, CR, etc, and for
		the asm's temp regs.  */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>bytes</name> <init>= <expr>(6 + <name>ASM_NEEDS_REGISTERS</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<comment type="block">/*	Return value handling.  The rules are as follows:
		- 32-bit (or less) integer values are returned in gpr3;
		- Structures of size &lt;= 4 bytes also returned in gpr3;
		- 64-bit integer values and structures between 5 and 8 bytes are
			returned in gpr3 and gpr4;
		- Single/double FP values are returned in fpr1;
		- Long double FP (if not equivalent to double) values are returned in
			fpr1 and fpr2;
		- Larger structures values are allocated space and a pointer is passed
			as the first argument.  */</comment>
	<switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name></expr>)</condition>
	<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FFI_TYPE_LONGDOUBLE</name> != <name>FFI_TYPE_DOUBLE</name></expr></cpp:if>
		<case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
			<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETURNS_128BITS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETURNS_FP</name></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="line">// FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</comment>

		</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
			<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETURNS_64BITS</name></expr>;</expr_stmt>
			<comment type="block">/* Fall through.  */</comment>
		</case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
			<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETURNS_FP</name></expr>;</expr_stmt>
			<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
		</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
		</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
			<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETURNS_64BITS</name></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
		<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>

			<if>if <condition>(<expr><call><name>ffi64_stret_needs_ptr</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<block>{
				<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETVAL_REFERENCE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETURNS_NOTHING</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>intarg_count</name>++</expr>;</expr_stmt>
			}</block></then>
			<else>else
			<block>{
				<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETURNS_STRUCT</name></expr>;</expr_stmt>

				<if>if <condition>(<expr><call><name>ffi64_struct_contains_fp</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<expr_stmt><expr><name>flags</name> |= <name>FLAG_STRUCT_CONTAINS_FP</name></expr>;</expr_stmt></then></if>
			}</block></else></if>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>

			<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETVAL_REFERENCE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETURNS_NOTHING</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>intarg_count</name>++</expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		}</block>

		</case><case>case <expr><name>FFI_TYPE_VOID</name></expr>:
			<expr_stmt><expr><name>flags</name> |= <name>FLAG_RETURNS_NOTHING</name></expr>;</expr_stmt>
			<break>break;</break>

		</case><default>default:
			<comment type="block">/* Returns 32-bit integer, or similar.  Nothing to do here.  */</comment>
			<break>break;</break>
	</default>}</block></switch>

	<comment type="block">/*	The first NUM_GPR_ARG_REGISTERS words of integer arguments, and the
		first NUM_FPR_ARG_REGISTERS fp arguments, go in registers; the rest
		goes on the stack.  Structures are passed as a pointer to a copy of
		the structure. Stuff on the stack needs to keep proper alignment.  */</comment>
	<for>for (<init><expr><name>ptr</name> = <name><name>cif</name>-&gt;<name>arg_types</name></name></expr>, <expr><name>i</name> = <name><name>cif</name>-&gt;<name>nargs</name></name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>ptr</name>++</expr></incr>)
	<block>{
		<switch>switch <condition>(<expr><name>(*<name>ptr</name>)-&gt;<name>type</name></name></expr>)</condition>
		<block>{
			<case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
				<expr_stmt><expr><name>fparg_count</name>++</expr>;</expr_stmt>
				<comment type="block">/*	If this FP arg is going on the stack, it must be
					8-byte-aligned.  */</comment>
				<if>if <condition>(<expr><name>fparg_count</name> &gt; <name>NUM_FPR_ARG_REGISTERS</name>
					&amp;&amp; <name>intarg_count</name> % 2 != 0</expr>)</condition><then>
					<expr_stmt><expr><name>intarg_count</name>++</expr>;</expr_stmt></then></if>
				<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FFI_TYPE_LONGDOUBLE</name> != <name>FFI_TYPE_DOUBLE</name></expr></cpp:if>
			</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
				<expr_stmt><expr><name>fparg_count</name> += 2</expr>;</expr_stmt>
				<comment type="block">/*	If this FP arg is going on the stack, it must be
					8-byte-aligned.  */</comment>

				<if>if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
					<expr><name>fparg_count</name> &gt; <name>NUM_FPR_ARG_REGISTERS</name> + 1
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
					<name>fparg_count</name> &gt; <name>NUM_FPR_ARG_REGISTERS</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					&amp;&amp; <name>intarg_count</name> % 2 != 0</expr>)</condition><then>
					<expr_stmt><expr><name>intarg_count</name>++</expr>;</expr_stmt></then></if>

				<expr_stmt><expr><name>intarg_count</name> += 2</expr>;</expr_stmt>
				<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="line">// FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</comment>

			</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
				<comment type="block">/*	'long long' arguments are passed as two words, but
					either both words must fit in registers or both go
					on the stack.  If they go on the stack, they must
					be 8-byte-aligned.  */</comment>
				<if>if <condition>(<expr><name>intarg_count</name> == <name>NUM_GPR_ARG_REGISTERS</name> - 1
					|| (<name>intarg_count</name> &gt;= <name>NUM_GPR_ARG_REGISTERS</name>
					&amp;&amp; <name>intarg_count</name> % 2 != 0)</expr>)</condition><then>
					<expr_stmt><expr><name>intarg_count</name>++</expr>;</expr_stmt></then></if>

				<expr_stmt><expr><name>intarg_count</name> += <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>2</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
				<expr_stmt><expr><name>size_al</name> = <name>(*<name>ptr</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
				<comment type="block">/*	If the first member of the struct is a double, then align
					the struct to double-word.  */</comment>
				<if>if <condition>(<expr><name>(*<name>ptr</name>)-&gt;<name>elements</name></name><index>[<expr>0</expr>]</index>-&gt;<name>type</name> == <name>FFI_TYPE_DOUBLE</name></expr>)</condition><then>
					<expr_stmt><expr><name>size_al</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>(*<name>ptr</name>)-&gt;<name>size</name></name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
				<comment type="line">// Look for FP struct members.</comment>
				<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>j</name></decl>;</decl_stmt>

				<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>(*<name>ptr</name>)-&gt;<name>elements</name></name><index>[<expr><name>j</name></expr>]</index> != <name>NULL</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
				<block>{
					<if>if <condition>(<expr><name>(*<name>ptr</name>)-&gt;<name>elements</name></name><index>[<expr><name>j</name></expr>]</index>-&gt;<name>type</name> == <name>FFI_TYPE_FLOAT</name>	||
						<name>(*<name>ptr</name>)-&gt;<name>elements</name></name><index>[<expr><name>j</name></expr>]</index>-&gt;<name>type</name> == <name>FFI_TYPE_DOUBLE</name></expr>)</condition><then>
					<block>{
						<expr_stmt><expr><name>fparg_count</name>++</expr>;</expr_stmt>

						<if>if <condition>(<expr><name>fparg_count</name> &gt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
							<expr_stmt><expr><name>intarg_count</name>++</expr>;</expr_stmt></then></if>
					}</block></then>
					<else>else <if>if <condition>(<expr><name>(*<name>ptr</name>)-&gt;<name>elements</name></name><index>[<expr><name>j</name></expr>]</index>-&gt;<name>type</name> == <name>FFI_TYPE_LONGDOUBLE</name></expr>)</condition><then>
					<block>{
						<expr_stmt><expr><name>fparg_count</name> += 2</expr>;</expr_stmt>

						<if>if <condition>(<expr><name>fparg_count</name> &gt; <name>NUM_FPR_ARG_REGISTERS</name> + 1</expr>)</condition><then>
							<expr_stmt><expr><name>intarg_count</name> += 2</expr>;</expr_stmt></then></if>
					}</block></then>
					<else>else
						<expr_stmt><expr><name>intarg_count</name>++</expr>;</expr_stmt></else></if></else></if>
				}</block></for>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<expr_stmt><expr><name>intarg_count</name> += (<name>size_al</name> + 3) / 4</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<break>break;</break>

			</case><default>default:
				<comment type="block">/*	Everything else is passed as a 4/8-byte word in a GPR, either
					the object itself or a pointer to it.  */</comment>
				<expr_stmt><expr><name>intarg_count</name>++</expr>;</expr_stmt>
				<break>break;</break>
		</default>}</block></switch>
	}</block></for>

	<comment type="block">/* Space for the FPR registers, if needed.  */</comment>
	<if>if <condition>(<expr><name>fparg_count</name> != 0</expr>)</condition><then>
	<block>{
		<expr_stmt><expr><name>flags</name> |= <name>FLAG_FP_ARGUMENTS</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr><name>bytes</name> += (<name>NUM_FPR_ARG_REGISTERS</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
		<expr_stmt><expr><name>bytes</name> += <name>NUM_FPR_ARG_REGISTERS</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>

	<comment type="block">/* Stack space.  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr>(<name>intarg_count</name> + <name>fparg_count</name>) &gt; <name>NUM_GPR_ARG_REGISTERS</name></expr>)</condition><then>
		<expr_stmt><expr><name>bytes</name> += (<name>intarg_count</name> + <name>fparg_count</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<if>if <condition>(<expr>(<name>intarg_count</name> + 2 * <name>fparg_count</name>) &gt; <name>NUM_GPR_ARG_REGISTERS</name></expr>)</condition><then>
		<expr_stmt><expr><name>bytes</name> += (<name>intarg_count</name> + 2 * <name>fparg_count</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else
		<expr_stmt><expr><name>bytes</name> += <name>NUM_GPR_ARG_REGISTERS</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></else></if>

	<comment type="block">/* The stack space allocated needs to be a multiple of 16/32 bytes.  */</comment>
	<expr_stmt><expr><name>bytes</name> = <call><name>SF_ROUND</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cif</name>-&gt;<name>bytes</name></name> = <name>bytes</name></expr>;</expr_stmt>

	<return>return <expr><name>FFI_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*@-declundef@*/</comment>
<comment type="block">/*@-exportheader@*/</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>ffi_call_AIX</name><parameter_list>(
<comment type="block">/*@out@*/</comment>	<param><decl><type><name>extended_cif</name>*</type></decl></param>,
			<param><decl><type><name>unsigned</name></type></decl></param>,
			<param><decl><type><name>unsigned</name></type></decl></param>,
<comment type="block">/*@out@*/</comment>	<param><decl><type><name>unsigned</name>*</type></decl></param>,
			<param><function_decl><type><name>void</name></type> (*<name>fn</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>,
			<param><function_decl><type><name>void</name></type> (*<name>fn2</name>)<parameter_list>(<param><decl><type><name>extended_cif</name>*</type></decl></param>, <param><decl><type><name>unsigned</name> *</type><param><decl><type><specifier>const</specifier></type></decl></param></decl></param>)</parameter_list></function_decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>ffi_call_DARWIN</name><parameter_list>(
<comment type="block">/*@out@*/</comment>	<param><decl><type><name>extended_cif</name>*</type></decl></param>,
			<param><decl><type><name>unsigned</name></type> <name>long</name></decl></param>,
			<param><decl><type><name>unsigned</name></type></decl></param>,
<comment type="block">/*@out@*/</comment>	<param><decl><type><name>unsigned</name>*</type></decl></param>,
			<param><function_decl><type><name>void</name></type> (*<name>fn</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>,
			<param><function_decl><type><name>void</name></type> (*<name>fn2</name>)<parameter_list>(<param><decl><type><name>extended_cif</name>*</type></decl></param>, <param><decl><type><name>unsigned</name> *</type><param><decl><type><specifier>const</specifier></type></decl></param></decl></param>)</parameter_list></function_decl></param>)</parameter_list>;</function_decl>
<comment type="block">/*@=declundef@*/</comment>
<comment type="block">/*@=exportheader@*/</comment>

<function><type><name>void</name></type>
<name>ffi_call</name><parameter_list>(
<comment type="block">/*@dependent@*/</comment>	<param><decl><type><name>ffi_cif</name>*</type>	<name>cif</name></decl></param>,
				<param><function_decl><type><name>void</name></type>		(*<name>fn</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>,
<comment type="block">/*@out@*/</comment>		<param><decl><type><name>void</name>*</type>		<name>rvalue</name></decl></param>,
<comment type="block">/*@dependent@*/</comment>	<param><decl><type><name>void</name>**</type>		<name>avalue</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>extended_cif</name></type> <name>ecif</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ecif</name>.<name>cif</name></name> = <name>cif</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ecif</name>.<name>avalue</name></name> = <name>avalue</name></expr>;</expr_stmt>

	<comment type="block">/*	If the return value is a struct and we don't have a return
		value address then we need to make one.  */</comment>
	<if>if <condition>(<expr>(<name>rvalue</name> == <name>NULL</name>) &amp;&amp;
		(<name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_STRUCT</name>)</expr>)</condition><then>
	<block>{
		<comment type="block">/*@-sysunrecog@*/</comment>
		<expr_stmt><expr><name><name>ecif</name>.<name>rvalue</name></name> = <call><name>alloca</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*@=sysunrecog@*/</comment>
	}</block></then>
	<else>else
		<expr_stmt><expr><name><name>ecif</name>.<name>rvalue</name></name> = <name>rvalue</name></expr>;</expr_stmt></else></if>

	<switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>abi</name></name></expr>)</condition>
	<block>{
		<case>case <expr><name>FFI_AIX</name></expr>:
			<comment type="block">/*@-usedef@*/</comment>
			<expr_stmt><expr><call><name>ffi_call_AIX</name><argument_list>(<argument><expr>&amp;<name>ecif</name></expr></argument>, <argument><expr>-<name><name>cif</name>-&gt;<name>bytes</name></name></expr></argument>,
				<argument><expr><name><name>cif</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name><name>ecif</name>.<name>rvalue</name></name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>ffi_prep_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*@=usedef@*/</comment>
			<break>break;</break>

		</case><case>case <expr><name>FFI_DARWIN</name></expr>:
			<comment type="block">/*@-usedef@*/</comment>
			<expr_stmt><expr><call><name>ffi_call_DARWIN</name><argument_list>(<argument><expr>&amp;<name>ecif</name></expr></argument>, <argument><expr>-(<name>long</name>)<name><name>cif</name>-&gt;<name>bytes</name></name></expr></argument>,
				<argument><expr><name><name>cif</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name><name>ecif</name>.<name>rvalue</name></name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>ffi_prep_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*@=usedef@*/</comment>
			<break>break;</break>

		</case><default>default:
			<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
    </default>}</block></switch>
}</block></function>

<comment type="block">/* here I'd like to add the stack frame layout we use in darwin_closure.S
   and aix_clsoure.S

   SP previous -&gt; +---------------------------------------+ &lt;--- child frame
		  | back chain to caller 4                |
		  +---------------------------------------+ 4
		  | saved CR 4                            |
		  +---------------------------------------+ 8
		  | saved LR 4                            |
		  +---------------------------------------+ 12
		  | reserved for compilers 4              |
		  +---------------------------------------+ 16
		  | reserved for binders 4                |
		  +---------------------------------------+ 20
		  | saved TOC pointer 4                   |
		  +---------------------------------------+ 24
		  | always reserved 8*4=32 (previous GPRs)|
		  | according to the linkage convention   |
		  | from AIX                              |
		  +---------------------------------------+ 56
		  | our FPR area 13*8=104                 |
		  | f1                                    |
		  | .                                     |
		  | f13                                   |
		  +---------------------------------------+ 160
		  | result area 8                         |
		  +---------------------------------------+ 168
		  | alignement to the next multiple of 16 |
SP current --&gt;    +---------------------------------------+ 176 &lt;- parent frame
		  | back chain to caller 4                |
		  +---------------------------------------+ 180
		  | saved CR 4                            |
		  +---------------------------------------+ 184
		  | saved LR 4                            |
		  +---------------------------------------+ 188
		  | reserved for compilers 4              |
		  +---------------------------------------+ 192
		  | reserved for binders 4                |
		  +---------------------------------------+ 196
		  | saved TOC pointer 4                   |
		  +---------------------------------------+ 200
		  | always reserved 8*4=32  we store our  |
		  | GPRs here                             |
		  | r3                                    |
		  | .                                     |
		  | r10                                   |
		  +---------------------------------------+ 232
		  | overflow part                         |
		  +---------------------------------------+ xxx
		  | ????                                  |
		  +---------------------------------------+ xxx
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>POWERPC_DARWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_LINE_SIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flush_icache</name><parameter_list>(
	<param><decl><type><name>char</name>*</type>	<name>addr</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_AIX</name></cpp:ifndef>
	<asm>__asm__ <specifier>volatile</specifier> (
		"dcbf 0,%0\n"
		"sync\n"
		"icbi 0,%0\n"
		"sync\n"
		"isync"
		: : "r" (addr) : "memory");</asm>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flush_range</name><parameter_list>(
	<param><decl><type><name>char</name>*</type>	<name>addr</name></decl></param>,
	<param><decl><type><name>int</name></type>		<name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name> += <name>MIN_LINE_SIZE</name></expr></incr>)
		<expr_stmt><expr><call><name>flush_icache</name><argument_list>(<argument><expr><name>addr</name> + <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

	<expr_stmt><expr><call><name>flush_icache</name><argument_list>(<argument><expr><name>addr</name> + <name>size</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="line">// !defined(POWERPC_DARWIN)</comment>

<function><type><name>ffi_status</name></type>
<name>ffi_prep_closure</name><parameter_list>(
	<param><decl><type><name>ffi_closure</name>*</type>	<name>closure</name></decl></param>,
	<param><decl><type><name>ffi_cif</name>*</type>		<name>cif</name></decl></param>,
	<param><function_decl><type><name>void</name></type>			(*<name>fun</name>)<parameter_list>(<param><decl><type><name>ffi_cif</name>*</type></decl></param>, <param><decl><type><name>void</name>*</type></decl></param>, <param><decl><type><name>void</name>**</type></decl></param>, <param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>,
	<param><decl><type><name>void</name>*</type>			<name>user_data</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>abi</name></name></expr>)</condition>
	<block>{
		<case>case <expr><name>FFI_DARWIN</name></expr>:
		<block>{
			<expr_stmt><expr><call><name>FFI_ASSERT</name> <argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>abi</name></name> == <name>FFI_DARWIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>unsigned</name> <name>int</name>*</type>	<name>tramp</name> <init>= <expr>(<name>unsigned</name> <name>int</name>*)&amp;<name><name>closure</name>-&gt;<name>tramp</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>0</expr>]</index></name> = 0x7c0802a6</expr>;</expr_stmt>	<comment type="line">//	mflr	r0</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>1</expr>]</index></name> = 0x429f0005</expr>;</expr_stmt>	<comment type="line">//	bcl		20,31,+0x8</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>2</expr>]</index></name> = 0x7d6802a6</expr>;</expr_stmt>	<comment type="line">//	mflr	r11</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>3</expr>]</index></name> = 0x7c0803a6</expr>;</expr_stmt>	<comment type="line">//	mtlr	r0</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>4</expr>]</index></name> = 0xe98b0018</expr>;</expr_stmt>	<comment type="line">//	ld		r12,24(r11)</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>5</expr>]</index></name> = 0x7d8903a6</expr>;</expr_stmt>	<comment type="line">//	mtctr	r12</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>6</expr>]</index></name> = 0xe96b0020</expr>;</expr_stmt>	<comment type="line">//	ld		r11,32(r11)</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>7</expr>]</index></name> = 0x4e800420</expr>;</expr_stmt>	<comment type="line">//	bctr</comment>
			<expr_stmt><expr>*(<name>unsigned</name> <name>long</name>*)&amp;<name><name>tramp</name><index>[<expr>8</expr>]</index></name> = (<name>unsigned</name> <name>long</name>)<name>ffi_closure_ASM</name></expr>;</expr_stmt>
			<expr_stmt><expr>*(<name>unsigned</name> <name>long</name>*)&amp;<name><name>tramp</name><index>[<expr>10</expr>]</index></name> = (<name>unsigned</name> <name>long</name>)<name>closure</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>0</expr>]</index></name> = 0x7c0802a6</expr>;</expr_stmt>	<comment type="line">//	mflr	r0</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>1</expr>]</index></name> = 0x429f0005</expr>;</expr_stmt>	<comment type="line">//	bcl		20,31,+0x8</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>2</expr>]</index></name> = 0x7d6802a6</expr>;</expr_stmt>	<comment type="line">//	mflr	r11</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>3</expr>]</index></name> = 0x7c0803a6</expr>;</expr_stmt>	<comment type="line">//	mtlr	r0</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>4</expr>]</index></name> = 0x818b0018</expr>;</expr_stmt>	<comment type="line">//	lwz		r12,24(r11)</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>5</expr>]</index></name> = 0x7d8903a6</expr>;</expr_stmt>	<comment type="line">//	mtctr	r12</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>6</expr>]</index></name> = 0x816b001c</expr>;</expr_stmt>	<comment type="line">//	lwz		r11,28(r11)</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>7</expr>]</index></name> = 0x4e800420</expr>;</expr_stmt>	<comment type="line">//	bctr</comment>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>8</expr>]</index></name> = (<name>unsigned</name> <name>long</name>)<name>ffi_closure_ASM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tramp</name><index>[<expr>9</expr>]</index></name> = (<name>unsigned</name> <name>long</name>)<name>closure</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><name><name>closure</name>-&gt;<name>cif</name></name> = <name>cif</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>closure</name>-&gt;<name>fun</name></name> = <name>fun</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>closure</name>-&gt;<name>user_data</name></name> = <name>user_data</name></expr>;</expr_stmt>

			<comment type="line">// Flush the icache. Only necessary on Darwin.</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POWERPC_DARWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<if>if <condition>(<expr><name>sys_icache_invalidate</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>sys_icache_invalidate</name><argument_list>(<argument><expr><name><name>closure</name>-&gt;<name>tramp</name></name></expr></argument>, <argument><expr><name>FFI_TRAMPOLINE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>flush_range</name><argument_list>(<argument><expr><name><name>closure</name>-&gt;<name>tramp</name></name></expr></argument>, <argument><expr><name>FFI_TRAMPOLINE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<break>break;</break>
		}</block>

		</case><case>case <expr><name>FFI_AIX</name></expr>:
		<block>{
			<expr_stmt><expr><call><name>FFI_ASSERT</name> <argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>abi</name></name> == <name>FFI_AIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>ffi_aix_trampoline_struct</name>*</type>	<name>tramp_aix</name> <init>=
				<expr><call>(<name>ffi_aix_trampoline_struct</name>*)<argument_list>(<argument><expr><name><name>closure</name>-&gt;<name>tramp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>aix_fd</name>*</type>	<name>fd</name> <init>= <expr>(<name>aix_fd</name>*)(<name>void</name>*)<name>ffi_closure_ASM</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>tramp_aix</name>-&gt;<name>code_pointer</name></name> = <name><name>fd</name>-&gt;<name>code_pointer</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tramp_aix</name>-&gt;<name>toc</name></name> = <name><name>fd</name>-&gt;<name>toc</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tramp_aix</name>-&gt;<name>static_chain</name></name> = <name>closure</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>closure</name>-&gt;<name>cif</name></name> = <name>cif</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>closure</name>-&gt;<name>fun</name></name> = <name>fun</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>closure</name>-&gt;<name>user_data</name></name> = <name>user_data</name></expr>;</expr_stmt>
			<break>break;</break>
		}</block>

		</case><default>default:
			<return>return <expr><name>FFI_BAD_ABI</name></expr>;</return>
	</default>}</block></switch>

	<return>return <expr><name>FFI_OK</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<typedef>typedef <type><name>double</name></type> <name><name>ldbits</name><index>[<expr>2</expr>]</index></name>;</typedef>

	<typedef>typedef <type><union>union
	<block>{
		<decl_stmt><decl><type><name>ldbits</name></type> <name>lb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>ld</name></decl>;</decl_stmt>
	}</block></union></type> <name>ldu</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*	The trampoline invokes ffi_closure_ASM, and on entry, r11 holds the
	address of the closure. After storing the registers that could possibly
	contain parameters to be passed into the stack frame and setting up space
	for a return value, ffi_closure_ASM invokes the following helper function
	to do most of the work.  */</comment>
<function><type><name>int</name></type>
<name>ffi_closure_helper_DARWIN</name><parameter_list>(
	<param><decl><type><name>ffi_closure</name>*</type>	<name>closure</name></decl></param>,
	<param><decl><type><name>void</name>*</type>			<name>rvalue</name></decl></param>,
	<param><decl><type><name>unsigned</name> <name>long</name>*</type>	<name>pgr</name></decl></param>,
	<param><decl><type><name>ffi_dblfl</name>*</type>		<name>pfr</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/*	rvalue is the pointer to space for return value in closure assembly
		pgr is the pointer to where r3-r10 are stored in ffi_closure_ASM
		pfr is the pointer to where f1-f13 are stored in ffi_closure_ASM.  */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>ldu</name></type>	<name>temp_ld</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>double</name></type>				<name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>		<name>nf</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* number of FPRs already used.  */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>		<name>ng</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>	<comment type="block">/* number of GPRs already used.  */</comment>
	<decl_stmt><decl><type><name>ffi_cif</name>*</type>			<name>cif</name> <init>= <expr><name><name>closure</name>-&gt;<name>cif</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>				<name>avn</name> <init>= <expr><name><name>cif</name>-&gt;<name>nargs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>**</type>				<name>avalue</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>nargs</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ffi_type</name>**</type>			<name>arg_types</name> <init>= <expr><name><name>cif</name>-&gt;<name>arg_types</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*	Copy the caller's structure return value address so that the closure
		returns the data directly to the caller.  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_STRUCT</name> &amp;&amp;
		<call><name>ffi64_stret_needs_ptr</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<if>if <condition>(<expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_STRUCT</name></expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{
		<expr_stmt><expr><name>rvalue</name> = (<name>void</name>*)*<name>pgr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pgr</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>ng</name>++</expr>;</expr_stmt>
	}</block></then></if></then></if>

	<comment type="block">/* Grab the addresses of the arguments from the stack frame.  */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>avn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<block>{
		<switch>switch <condition>(<expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>type</name></expr>)</condition>
		<block>{
			<case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
				<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>*)<name>pgr</name> + <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>3</expr></argument>,<argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ng</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>pgr</name>++</expr>;</expr_stmt>
				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
				<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>*)<name>pgr</name> + <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>2</expr></argument>,<argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ng</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>pgr</name>++</expr>;</expr_stmt>
				<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:if>
			</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
				<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>*)<name>pgr</name> + <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ng</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>pgr</name>++</expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
				<if>if <condition>(<expr><name><name>cif</name>-&gt;<name>abi</name></name> == <name>FFI_DARWIN</name></expr>)</condition><then>
				<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
					<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>gprSize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>fprSize</name>	<init>= <expr>0</expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>savedFPRSize</name> <init>= <expr><name>fprSize</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>alloca</name><argument_list>(<argument><expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ffi64_struct_to_ram_form</name><argument_list>(<argument><expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>(const <name>char</name>*)<name>pgr</name></expr></argument>,
						<argument><expr>&amp;<name>gprSize</name></expr></argument>, <argument><expr>(const <name>char</name>*)<name>pfr</name></expr></argument>, <argument><expr>&amp;<name>fprSize</name></expr></argument>, <argument><expr>&amp;<name>nf</name></expr></argument>, <argument><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
					<expr_stmt><expr><name>ng</name>	+= <name>gprSize</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><name>pgr</name>	+= <name>gprSize</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><name>pfr</name>	+= (<name>fprSize</name> - <name>savedFPRSize</name>) / <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
					<comment type="block">/*	Structures that match the basic modes (QI 1 byte, HI 2 bytes,
						SI 4 bytes) are aligned as if they were those modes.  */</comment>
					<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>size_al</name>	<init>= <expr><name>size_al</name> = <name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>size</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*	If the first member of the struct is a double, then align
						the struct to double-word.  */</comment>
					<if>if <condition>(<expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name><name>elements</name><index>[<expr>0</expr>]</index></name>-&gt;<name>type</name> == <name>FFI_TYPE_DOUBLE</name></expr>)</condition><then>
						<expr_stmt><expr><name>size_al</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>size</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

					<if>if <condition>(<expr><name>size_al</name> &lt; 3</expr>)</condition><then>
						<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>*)<name>pgr</name> + <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr>8</expr></argument>)</argument_list></call> - <name>size_al</name></expr>;</expr_stmt></then>
					<else>else
						<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>*)<name>pgr</name></expr>;</expr_stmt></else></if>

					<expr_stmt><expr><name>ng</name>	+= (<name>size_al</name> + 3) / <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><name>pgr</name> += (<name>size_al</name> + 3) / <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				}</block></then></if>

				<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
			</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
				<comment type="block">/* Long long ints are passed in 1 or 2 GPRs.  */</comment>
				<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pgr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ng</name> += <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>2</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pgr</name> += <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>2</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
				<comment type="block">/*	A float value consumes a GPR.
					There are 13 64-bit floating point registers.  */</comment>
				<if>if <condition>(<expr><name>nf</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr><name>temp</name> = <name><name>pfr</name>-&gt;<name>d</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pfr</name>-&gt;<name>f</name></name> = (<name>float</name>)<name>temp</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pfr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pfr</name>++</expr>;</expr_stmt>
				}</block></then>
				<else>else
					<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pgr</name></expr>;</expr_stmt></else></if>

				<expr_stmt><expr><name>nf</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>ng</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>pgr</name>++</expr>;</expr_stmt>
				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
				<comment type="block">/*	A double value consumes one or two GPRs.
					There are 13 64bit floating point registers.  */</comment>
				<if>if <condition>(<expr><name>nf</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pfr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pfr</name>++</expr>;</expr_stmt>
				}</block></then>
				<else>else
					<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pgr</name></expr>;</expr_stmt></else></if>

				<expr_stmt><expr><name>nf</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>ng</name> += <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>2</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pgr</name> += <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>2</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FFI_TYPE_LONGDOUBLE</name> != <name>FFI_TYPE_DOUBLE</name></expr></cpp:if>

			</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
				<if>if <condition>(<expr><name>nf</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pfr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pfr</name> += 2</expr>;</expr_stmt>
				}</block></then></if>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<comment type="block">/*	A long double value consumes 2/4 GPRs and 2 FPRs.
					There are 13 64bit floating point registers.  */</comment>
				<if>if <condition>(<expr><name>nf</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name> - 1</expr>)</condition><then>
				<block>{
					<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pfr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pfr</name> += 2</expr>;</expr_stmt>
				}</block></then>
				<comment type="block">/*	Here we have the situation where one part of the long double
					is stored in fpr13 and the other part is already on the stack.
					We use a union to pass the long double to avalue[i].  */</comment>
				<else>else <if>if <condition>(<expr><name>nf</name> == <name>NUM_FPR_ARG_REGISTERS</name> - 1</expr>)</condition><then>
				<block>{
					<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr>&amp;<name><name>temp_ld</name>.<name>lb</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>pfr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ldbits</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr>&amp;<name><name>temp_ld</name>.<name>lb</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>pgr</name> + 2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ldbits</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = &amp;<name><name>temp_ld</name>.<name>ld</name></name></expr>;</expr_stmt>
				}</block></then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> undefined architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<else>else
					<expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pgr</name></expr>;</expr_stmt></else></if></else></if>

				<expr_stmt><expr><name>nf</name> += 2</expr>;</expr_stmt>
				<expr_stmt><expr><name>ng</name> += <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pgr</name> += <call><name>MODE_CHOICE</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/*	FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE	*/</comment>

			</case><default>default:
				<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</default>}</block></switch>
	}</block></for>

	<expr_stmt><expr><call>(<name><name>closure</name>-&gt;<name>fun</name></name>)<argument_list>(<argument><expr><name>cif</name></expr></argument>, <argument><expr><name>rvalue</name></expr></argument>, <argument><expr><name>avalue</name></expr></argument>, <argument><expr><name><name>closure</name>-&gt;<name>user_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Tell ffi_closure_ASM to perform return type promotions.  */</comment>
	<return>return <expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/*	ffi64_struct_to_ram_form

	Rebuild a struct's natural layout from buffers of concatenated registers.
	Return the number of registers used.
	inGPRs[0-7] == r3, inFPRs[0-7] == f1 ...
*/</comment>
<function><type><name>void</name></type>
<name>ffi64_struct_to_ram_form</name><parameter_list>(
	<param><decl><type><specifier>const</specifier> <name>ffi_type</name>*</type>	<name>inType</name></decl></param>,
	<param><decl><type><specifier>const</specifier> <name>char</name>*</type>		<name>inGPRs</name></decl></param>,
	<param><decl><type><name>unsigned</name> <name>int</name>*</type>	<name>ioGPRMarker</name></decl></param>,
	<param><decl><type><specifier>const</specifier> <name>char</name>*</type>		<name>inFPRs</name></decl></param>,
	<param><decl><type><name>unsigned</name> <name>int</name>*</type>	<name>ioFPRMarker</name></decl></param>,
	<param><decl><type><name>unsigned</name> <name>int</name>*</type>	<name>ioFPRsUsed</name></decl></param>,
	<param><decl><type><name>char</name>*</type>			<name>outStruct</name></decl></param>,	<comment type="line">// caller-allocated</comment>
	<param><decl><type><name>unsigned</name> <name>int</name>*</type>	<name>ioStructMarker</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>srcGMarker</name>		<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>srcFMarker</name>		<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>savedFMarker</name>	<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>fprsUsed</name>		<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>savedFPRsUsed</name>	<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>destMarker</name>		<init>= <expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>	<name>recurseCount</name>	<init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ioGPRMarker</name></expr>)</condition><then>
		<expr_stmt><expr><name>srcGMarker</name>	= *<name>ioGPRMarker</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioFPRMarker</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><name>srcFMarker</name>		= *<name>ioFPRMarker</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>savedFMarker</name>	= <name>srcFMarker</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>ioFPRsUsed</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><name>fprsUsed</name>		= *<name>ioFPRsUsed</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>savedFPRsUsed</name>	= <name>fprsUsed</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>ioStructMarker</name></expr>)</condition><then>
		<expr_stmt><expr><name>destMarker</name>	= *<name>ioStructMarker</name></expr>;</expr_stmt></then></if>

	<decl_stmt><decl><type><name>size_t</name></type>			<name>i</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>inType</name>-&gt;<name>size</name></name></expr>)</condition>
	<block>{
		<case>case <expr>1</expr>: </case><case>case <expr>2</expr>: </case><case>case <expr>4</expr>:
			<expr_stmt><expr><name>srcGMarker</name> += 8 - <name><name>inType</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
			<break>break;</break>

		</case><default>default:
			<break>break;</break>
	</default>}</block></switch>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<block>{
		<switch>switch <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>type</name></expr>)</condition>
		<block>{
			<case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
				<expr_stmt><expr><name>srcFMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcFMarker</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>srcGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destMarker</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fprsUsed</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr>*(<name>float</name>*)&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name>	=
						(<name>float</name>)*(<name>double</name>*)&amp;<name><name>inFPRs</name><index>[<expr><name>srcFMarker</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>srcFMarker</name> += 8</expr>;</expr_stmt>
					<expr_stmt><expr><name>fprsUsed</name>++</expr>;</expr_stmt>
				}</block></then>
				<else>else
					<expr_stmt><expr>*(<name>float</name>*)&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name>	=
						(<name>float</name>)*(<name>double</name>*)&amp;<name><name>inGPRs</name><index>[<expr><name>srcGMarker</name></expr>]</index></name></expr>;</expr_stmt></else></if>

				<expr_stmt><expr><name>srcGMarker</name> += 4</expr>;</expr_stmt>
				<expr_stmt><expr><name>destMarker</name> += 4</expr>;</expr_stmt>

				<comment type="line">// Skip to next GPR if next element won't fit and we're</comment>
				<comment type="line">// not already at a register boundary.</comment>
				<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name> != <name>NULL</name> &amp;&amp; (<name>destMarker</name> % 8)</expr>)</condition><then>
				<block>{
					<if>if <condition>(<expr>!<call><name>FFI_TYPE_1_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> &amp;&amp;
						(!<call><name>FFI_TYPE_2_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> ||
						(<call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> - <name>srcGMarker</name>) &lt; 2) &amp;&amp;
						(!<call><name>FFI_TYPE_4_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> ||
						(<call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> - <name>srcGMarker</name>) &lt; 4)</expr>)</condition><then>
						<expr_stmt><expr><name>srcGMarker</name>	= <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				}</block></then></if>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
				<expr_stmt><expr><name>srcFMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcFMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fprsUsed</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr>*(<name>double</name>*)&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name>	=
						*(<name>double</name>*)&amp;<name><name>inFPRs</name><index>[<expr><name>srcFMarker</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>srcFMarker</name> += 8</expr>;</expr_stmt>
					<expr_stmt><expr><name>fprsUsed</name>++</expr>;</expr_stmt>
				}</block></then>
				<else>else
					<expr_stmt><expr>*(<name>double</name>*)&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name>	=
						*(<name>double</name>*)&amp;<name><name>inGPRs</name><index>[<expr><name>srcGMarker</name></expr>]</index></name></expr>;</expr_stmt></else></if>

				<expr_stmt><expr><name>destMarker</name> += 8</expr>;</expr_stmt>

				<comment type="line">// Skip next GPR</comment>
				<expr_stmt><expr><name>srcGMarker</name> += 8</expr>;</expr_stmt>
				<expr_stmt><expr><name>srcGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
				<expr_stmt><expr><name>destMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destMarker</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fprsUsed</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr><name>srcFMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcFMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>srcGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr>*(<name>long</name> <name>double</name>*)&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name>	=
						*(<name>long</name> <name>double</name>*)&amp;<name><name>inFPRs</name><index>[<expr><name>srcFMarker</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>srcFMarker</name> += 16</expr>;</expr_stmt>
					<expr_stmt><expr><name>fprsUsed</name> += 2</expr>;</expr_stmt>
				}</block></then>
				<else>else
				<block>{
					<expr_stmt><expr><name>srcFMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcFMarker</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>srcGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr>*(<name>long</name> <name>double</name>*)&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name>	=
						*(<name>long</name> <name>double</name>*)&amp;<name><name>inGPRs</name><index>[<expr><name>srcGMarker</name></expr>]</index></name></expr>;</expr_stmt>
				}</block></else></if>

				<expr_stmt><expr><name>destMarker</name> += 16</expr>;</expr_stmt>

				<comment type="line">// Skip next 2 GPRs</comment>
				<expr_stmt><expr><name>srcGMarker</name> += 16</expr>;</expr_stmt>
				<expr_stmt><expr><name>srcGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
			<block>{
				<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>alignment</name></name> == 1</expr>)</condition><then>	<comment type="line">// chars only</comment>
				<block>{
					<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>size</name></name> == 1</expr>)</condition><then>
						<expr_stmt><expr><name><name>outStruct</name><index>[<expr><name>destMarker</name>++</expr>]</index></name> = <name><name>inGPRs</name><index>[<expr><name>srcGMarker</name>++</expr>]</index></name></expr>;</expr_stmt></then>
					<else>else <if>if <condition>(<expr><name><name>inType</name>-&gt;<name>size</name></name> == 2</expr>)</condition><then>
					<block>{
						<expr_stmt><expr><name><name>outStruct</name><index>[<expr><name>destMarker</name>++</expr>]</index></name> = <name><name>inGPRs</name><index>[<expr><name>srcGMarker</name>++</expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>outStruct</name><index>[<expr><name>destMarker</name>++</expr>]</index></name> = <name><name>inGPRs</name><index>[<expr><name>srcGMarker</name>++</expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
					}</block></then>
					<else>else
					<block>{
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name></expr></argument>,
							<argument><expr>&amp;<name><name>inGPRs</name><index>[<expr><name>srcGMarker</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>inType</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>srcGMarker</name> += <name><name>inType</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>destMarker</name> += <name><name>inType</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>i</name> += <name><name>inType</name>-&gt;<name>size</name></name> - 1</expr>;</expr_stmt>
					}</block></else></if></else></if>
				}</block></then>
				<else>else	<comment type="line">// chars and other stuff</comment>
				<block>{
					<expr_stmt><expr><name><name>outStruct</name><index>[<expr><name>destMarker</name>++</expr>]</index></name> = <name><name>inGPRs</name><index>[<expr><name>srcGMarker</name>++</expr>]</index></name></expr>;</expr_stmt>

					<comment type="line">// Skip to next GPR if next element won't fit and we're</comment>
					<comment type="line">// not already at a register boundary.</comment>
					<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name> != <name>NULL</name> &amp;&amp; (<name>srcGMarker</name> % 8)</expr>)</condition><then>
					<block>{
						<if>if <condition>(<expr>!<call><name>FFI_TYPE_1_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> &amp;&amp;
							(!<call><name>FFI_TYPE_2_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> ||
							(<call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> - <name>srcGMarker</name>) &lt; 2) &amp;&amp;
							(!<call><name>FFI_TYPE_4_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> ||
							(<call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> - <name>srcGMarker</name>) &lt; 4)</expr>)</condition><then>
							<expr_stmt><expr><name>srcGMarker</name>	= <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr><name><name>inType</name>-&gt;<name>alignment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>	<comment type="line">// was 8</comment>
					}</block></then></if>
				}</block></else></if>

				<break>break;</break>
			}</block>

			</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
				<expr_stmt><expr><name>srcGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destMarker</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr>*(<name>short</name>*)&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name> =
					*(<name>short</name>*)&amp;<name><name>inGPRs</name><index>[<expr><name>srcGMarker</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>srcGMarker</name> += 2</expr>;</expr_stmt>
				<expr_stmt><expr><name>destMarker</name> += 2</expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_INT</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
				<expr_stmt><expr><name>srcGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destMarker</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr>*(<name>int</name>*)&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name> =
					*(<name>int</name>*)&amp;<name><name>inGPRs</name><index>[<expr><name>srcGMarker</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>srcGMarker</name> += 4</expr>;</expr_stmt>
				<expr_stmt><expr><name>destMarker</name> += 4</expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
				<expr_stmt><expr><name>srcGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr>*(<name>long</name> <name>long</name>*)&amp;<name><name>outStruct</name><index>[<expr><name>destMarker</name></expr>]</index></name> =
					*(<name>long</name> <name>long</name>*)&amp;<name><name>inGPRs</name><index>[<expr><name>srcGMarker</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>srcGMarker</name> += 8</expr>;</expr_stmt>
				<expr_stmt><expr><name>destMarker</name> += 8</expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
				<expr_stmt><expr><name>recurseCount</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ffi64_struct_to_ram_form</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>inGPRs</name></expr></argument>,
					<argument><expr>&amp;<name>srcGMarker</name></expr></argument>, <argument><expr><name>inFPRs</name></expr></argument>, <argument><expr>&amp;<name>srcFMarker</name></expr></argument>, <argument><expr>&amp;<name>fprsUsed</name></expr></argument>,
					<argument><expr><name>outStruct</name></expr></argument>, <argument><expr>&amp;<name>destMarker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>recurseCount</name>--</expr>;</expr_stmt>
				<break>break;</break>

			</case><default>default:
				<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="line">// unknown element type</comment>
				<break>break;</break>
		</default>}</block></switch>
	}</block></for>

	<expr_stmt><expr><name>srcGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr><name><name>inType</name>-&gt;<name>alignment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Take care of the special case for 16-byte structs, but not for</comment>
	<comment type="line">// nested structs.</comment>
	<if>if <condition>(<expr><name>recurseCount</name> == 0 &amp;&amp; <name>srcGMarker</name> == 16</expr>)</condition><then>
	<block>{
		<expr_stmt><expr>*(<name>long</name> <name>double</name>*)&amp;<name><name>outStruct</name><index>[<expr>0</expr>]</index></name> = *(<name>long</name> <name>double</name>*)&amp;<name><name>inGPRs</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>srcFMarker</name>	= <name>savedFMarker</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fprsUsed</name>	= <name>savedFPRsUsed</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>ioGPRMarker</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioGPRMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioFPRMarker</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioFPRMarker</name> = <name>srcFMarker</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioFPRsUsed</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioFPRsUsed</name>	= <name>fprsUsed</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioStructMarker</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioStructMarker</name>	= <call><name>ALIGN</name><argument_list>(<argument><expr><name>destMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/*	ffi64_struct_to_reg_form

	Copy a struct's elements into buffers that can be sliced into registers.
	Return the sizes of the output buffers in bytes. Pass NULL buffer pointers
	to calculate size only.
	outGPRs[0-7] == r3, outFPRs[0-7] == f1 ...
*/</comment>
<function><type><name>void</name></type>
<name>ffi64_struct_to_reg_form</name><parameter_list>(
	<param><decl><type><specifier>const</specifier> <name>ffi_type</name>*</type>	<name>inType</name></decl></param>,
	<param><decl><type><specifier>const</specifier> <name>char</name>*</type>		<name>inStruct</name></decl></param>,
	<param><decl><type><name>unsigned</name> <name>int</name>*</type>	<name>ioStructMarker</name></decl></param>,
	<param><decl><type><name>unsigned</name> <name>int</name>*</type>	<name>ioFPRsUsed</name></decl></param>,
	<param><decl><type><name>char</name>*</type>			<name>outGPRs</name></decl></param>,	<comment type="line">// caller-allocated</comment>
	<param><decl><type><name>unsigned</name> <name>int</name>*</type>	<name>ioGPRSize</name></decl></param>,
	<param><decl><type><name>char</name>*</type>			<name>outFPRs</name></decl></param>,	<comment type="line">// caller-allocated</comment>
	<param><decl><type><name>unsigned</name> <name>int</name>*</type>	<name>ioFPRSize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>size_t</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>srcMarker</name>		<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>destGMarker</name>		<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>destFMarker</name>		<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>savedFMarker</name>	<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>fprsUsed</name>		<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>savedFPRsUsed</name>	<init>= <expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>	<name>recurseCount</name>	<init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ioStructMarker</name></expr>)</condition><then>
		<expr_stmt><expr><name>srcMarker</name>	= *<name>ioStructMarker</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioFPRsUsed</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><name>fprsUsed</name>		= *<name>ioFPRsUsed</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>savedFPRsUsed</name>	= <name>fprsUsed</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>ioGPRSize</name></expr>)</condition><then>
		<expr_stmt><expr><name>destGMarker</name>	= *<name>ioGPRSize</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioFPRSize</name></expr>)</condition><then>
	<block>{
		<expr_stmt><expr><name>destFMarker</name>		= *<name>ioFPRSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>savedFMarker</name>	= <name>destFMarker</name></expr>;</expr_stmt>
	}</block></then></if>

	<switch>switch <condition>(<expr><name><name>inType</name>-&gt;<name>size</name></name></expr>)</condition>
	<block>{
		<case>case <expr>1</expr>: </case><case>case <expr>2</expr>: </case><case>case <expr>4</expr>:
			<expr_stmt><expr><name>destGMarker</name> += 8 - <name><name>inType</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
			<break>break;</break>

		</case><default>default:
			<break>break;</break>
	</default>}</block></switch>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<block>{
		<switch>switch <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>type</name></expr>)</condition>
		<block>{
			<comment type="line">// Shadow floating-point types in GPRs for vararg and pre-ANSI</comment>
			<comment type="line">// functions.</comment>
			<case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
				<comment type="line">// Nudge markers to next 4/8-byte boundary</comment>
				<expr_stmt><expr><name>srcMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcMarker</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destFMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destFMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fprsUsed</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
				<block>{
					<if>if <condition>(<expr><name>outFPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
						<expr_stmt><expr>*(<name>double</name>*)&amp;<name><name>outFPRs</name><index>[<expr><name>destFMarker</name></expr>]</index></name> =
							(<name>double</name>)*(<name>float</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

					<expr_stmt><expr><name>destFMarker</name> += 8</expr>;</expr_stmt>
					<expr_stmt><expr><name>fprsUsed</name>++</expr>;</expr_stmt>
				}</block></then></if>

				<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr>*(<name>double</name>*)&amp;<name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> =
						(<name>double</name>)*(<name>float</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

				<expr_stmt><expr><name>srcMarker</name> += 4</expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> += 4</expr>;</expr_stmt>

				<comment type="line">// Skip to next GPR if next element won't fit and we're</comment>
				<comment type="line">// not already at a register boundary.</comment>
				<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name> != <name>NULL</name> &amp;&amp; (<name>srcMarker</name> % 8)</expr>)</condition><then>
				<block>{
					<if>if <condition>(<expr>!<call><name>FFI_TYPE_1_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> &amp;&amp;
						(!<call><name>FFI_TYPE_2_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> ||
						(<call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> - <name>destGMarker</name>) &lt; 2) &amp;&amp;
						(!<call><name>FFI_TYPE_4_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> ||
						(<call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> - <name>destGMarker</name>) &lt; 4)</expr>)</condition><then>
						<expr_stmt><expr><name>destGMarker</name>	= <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				}</block></then></if>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
				<expr_stmt><expr><name>srcMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destFMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destFMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fprsUsed</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
				<block>{
					<if>if <condition>(<expr><name>outFPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
						<expr_stmt><expr>*(<name>double</name>*)&amp;<name><name>outFPRs</name><index>[<expr><name>destFMarker</name></expr>]</index></name> =
							*(<name>double</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

					<expr_stmt><expr><name>destFMarker</name> += 8</expr>;</expr_stmt>
					<expr_stmt><expr><name>fprsUsed</name>++</expr>;</expr_stmt>
				}</block></then></if>

				<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr>*(<name>double</name>*)&amp;<name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> =
						*(<name>double</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

				<expr_stmt><expr><name>srcMarker</name> += 8</expr>;</expr_stmt>

				<comment type="line">// Skip next GPR</comment>
				<expr_stmt><expr><name>destGMarker</name> += 8</expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
				<expr_stmt><expr><name>srcMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcMarker</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fprsUsed</name> &lt; <name>NUM_FPR_ARG_REGISTERS</name></expr>)</condition><then>
				<block>{
					<expr_stmt><expr><name>destFMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destFMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>destGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if>if <condition>(<expr><name>outFPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
						<expr_stmt><expr>*(<name>long</name> <name>double</name>*)&amp;<name><name>outFPRs</name><index>[<expr><name>destFMarker</name></expr>]</index></name> =
							*(<name>long</name> <name>double</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

					<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
						<expr_stmt><expr>*(<name>long</name> <name>double</name>*)&amp;<name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> =
							*(<name>long</name> <name>double</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

					<expr_stmt><expr><name>destFMarker</name> += 16</expr>;</expr_stmt>
					<expr_stmt><expr><name>fprsUsed</name> += 2</expr>;</expr_stmt>
				}</block></then>
				<else>else
				<block>{
				 	<expr_stmt><expr><name>destGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>

					 <if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
						<expr_stmt><expr>*(<name>long</name> <name>double</name>*)&amp;<name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> =
							*(<name>long</name> <name>double</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>
				}</block></else></if>

				<expr_stmt><expr><name>srcMarker</name> += 16</expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> += 16</expr>;</expr_stmt>	<comment type="line">// Skip next 2 GPRs</comment>
				<expr_stmt><expr><name>destGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="line">// was 16</comment>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
				<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>alignment</name></name> == 1</expr>)</condition><then>	<comment type="line">// bytes only</comment>
				<block>{
					<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>size</name></name> == 1</expr>)</condition><then>
					<block>{
						<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
							<expr_stmt><expr><name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> = <name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

						<expr_stmt><expr><name>srcMarker</name>++</expr>;</expr_stmt>
						<expr_stmt><expr><name>destGMarker</name>++</expr>;</expr_stmt>
					}</block></then>
					<else>else <if>if <condition>(<expr><name><name>inType</name>-&gt;<name>size</name></name> == 2</expr>)</condition><then>
					<block>{
						<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
						<block>{
							<expr_stmt><expr><name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> = <name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>outGPRs</name><index>[<expr><name>destGMarker</name> + 1</expr>]</index></name> = <name><name>inStruct</name><index>[<expr><name>srcMarker</name> + 1</expr>]</index></name></expr>;</expr_stmt>
						}</block></then></if>

						<expr_stmt><expr><name>srcMarker</name> += 2</expr>;</expr_stmt>
						<expr_stmt><expr><name>destGMarker</name> += 2</expr>;</expr_stmt>

						<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
					}</block></then>
					<else>else
					<block>{
						<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
						<block>{
							<comment type="line">// Avoid memcpy for small chunks.</comment>
							<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>size</name></name> &lt;= <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
								<expr_stmt><expr>*(<name>long</name>*)&amp;<name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> =
									*(<name>long</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then>
							<else>else
								<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name></expr></argument>,
									<argument><expr>&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>inType</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
						}</block></then></if>
						
						<expr_stmt><expr><name>srcMarker</name> += <name><name>inType</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>destGMarker</name> += <name><name>inType</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>i</name> += <name><name>inType</name>-&gt;<name>size</name></name> - 1</expr>;</expr_stmt>
					}</block></else></if></else></if>
				}</block></then>
				<else>else	<comment type="line">// bytes and other stuff</comment>
				<block>{
					<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
						<expr_stmt><expr><name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> = <name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

					<expr_stmt><expr><name>srcMarker</name>++</expr>;</expr_stmt>
					<expr_stmt><expr><name>destGMarker</name>++</expr>;</expr_stmt>

					<comment type="line">// Skip to next GPR if next element won't fit and we're</comment>
					<comment type="line">// not already at a register boundary.</comment>
					<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name> != <name>NULL</name> &amp;&amp; (<name>destGMarker</name> % 8)</expr>)</condition><then>
					<block>{
						<if>if <condition>(<expr>!<call><name>FFI_TYPE_1_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> &amp;&amp;
							(!<call><name>FFI_TYPE_2_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> ||
							(<call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> - <name>destGMarker</name>) &lt; 2) &amp;&amp;
							(!<call><name>FFI_TYPE_4_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call> ||
							(<call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> - <name>destGMarker</name>) &lt; 4)</expr>)</condition><then>
							<expr_stmt><expr><name>destGMarker</name>	= <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr><name><name>inType</name>-&gt;<name>alignment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>	<comment type="line">// was 8</comment>
					}</block></then></if>
				}</block></else></if>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
				<expr_stmt><expr><name>srcMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcMarker</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr>*(<name>short</name>*)&amp;<name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> =
						*(<name>short</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

				<expr_stmt><expr><name>srcMarker</name> += 2</expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> += 2</expr>;</expr_stmt>

				<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name> == <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><name>destGMarker</name>	= <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr><name><name>inType</name>-&gt;<name>alignment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_INT</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
				<expr_stmt><expr><name>srcMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcMarker</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr>*(<name>int</name>*)&amp;<name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> =
						*(<name>int</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

				<expr_stmt><expr><name>srcMarker</name> += 4</expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> += 4</expr>;</expr_stmt>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
				<expr_stmt><expr><name>srcMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr>*(<name>long</name> <name>long</name>*)&amp;<name><name>outGPRs</name><index>[<expr><name>destGMarker</name></expr>]</index></name> =
						*(<name>long</name> <name>long</name>*)&amp;<name><name>inStruct</name><index>[<expr><name>srcMarker</name></expr>]</index></name></expr>;</expr_stmt></then></if>

				<expr_stmt><expr><name>srcMarker</name> += 8</expr>;</expr_stmt>
				<expr_stmt><expr><name>destGMarker</name> += 8</expr>;</expr_stmt>

				<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name> == <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><name>destGMarker</name>	= <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr><name><name>inType</name>-&gt;<name>alignment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
				<expr_stmt><expr><name>recurseCount</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ffi64_struct_to_reg_form</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
					<argument><expr><name>inStruct</name></expr></argument>, <argument><expr>&amp;<name>srcMarker</name></expr></argument>, <argument><expr>&amp;<name>fprsUsed</name></expr></argument>, <argument><expr><name>outGPRs</name></expr></argument>, 
					<argument><expr>&amp;<name>destGMarker</name></expr></argument>, <argument><expr><name>outFPRs</name></expr></argument>, <argument><expr>&amp;<name>destFMarker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>recurseCount</name>--</expr>;</expr_stmt>
				<break>break;</break>

			</case><default>default:
				<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</default>}</block></switch>
	}</block></for>

	<expr_stmt><expr><name>destGMarker</name>	= <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr><name><name>inType</name>-&gt;<name>alignment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Take care of the special case for 16-byte structs, but not for</comment>
	<comment type="line">// nested structs.</comment>
	<if>if <condition>(<expr><name>recurseCount</name> == 0 &amp;&amp; <name>destGMarker</name> == 16</expr>)</condition><then>
	<block>{
		<if>if <condition>(<expr><name>outGPRs</name> != <name>NULL</name> &amp;&amp; <name>inStruct</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr>*(<name>long</name> <name>double</name>*)&amp;<name><name>outGPRs</name><index>[<expr>0</expr>]</index></name> = *(<name>long</name> <name>double</name>*)&amp;<name><name>inStruct</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>destFMarker</name>	= <name>savedFMarker</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fprsUsed</name>	= <name>savedFPRsUsed</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>ioStructMarker</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioStructMarker</name>	= <call><name>ALIGN</name><argument_list>(<argument><expr><name>srcMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioFPRsUsed</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioFPRsUsed</name>	= <name>fprsUsed</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioGPRSize</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioGPRSize</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destGMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioFPRSize</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioFPRSize</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>destFMarker</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/*	ffi64_stret_needs_ptr

	Determine whether a returned struct needs a pointer in r3 or can fit
	in registers.
*/</comment>

<function><type><name>bool</name></type>
<name>ffi64_stret_needs_ptr</name><parameter_list>(
	<param><decl><type><specifier>const</specifier> <name>ffi_type</name>*</type>	<name>inType</name></decl></param>,
	<param><decl><type><name>unsigned</name> <name>short</name>*</type>	<name>ioGPRCount</name></decl></param>,
	<param><decl><type><name>unsigned</name> <name>short</name>*</type>	<name>ioFPRCount</name></decl></param>)</parameter_list>
<block>{
	<comment type="line">// Obvious case first- struct is larger than combined FPR size.</comment>
	<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>size</name></name> &gt; 14 * 8</expr>)</condition><then>
		<return>return <expr><name>true</name></expr>;</return></then></if>

	<comment type="line">// Now the struct can physically fit in registers, determine if it</comment>
	<comment type="line">// also fits logically.</comment>
	<decl_stmt><decl><type><name>bool</name></type>			<name>needsPtr</name>	<init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type>	<name>gprsUsed</name>	<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type>	<name>fprsUsed</name>	<init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>			<name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ioGPRCount</name></expr>)</condition><then>
		<expr_stmt><expr><name>gprsUsed</name> = *<name>ioGPRCount</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioFPRCount</name></expr>)</condition><then>
		<expr_stmt><expr><name>fprsUsed</name> = *<name>ioFPRCount</name></expr>;</expr_stmt></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name> &amp;&amp; !<name>needsPtr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	<block>{
		<switch>switch <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>type</name></expr>)</condition>
		<block>{
			<case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
				<expr_stmt><expr><name>gprsUsed</name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name>fprsUsed</name>++</expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fprsUsed</name> &gt; 13</expr>)</condition><then>
					<expr_stmt><expr><name>needsPtr</name> = <name>true</name></expr>;</expr_stmt></then></if>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
				<expr_stmt><expr><name>gprsUsed</name> += 2</expr>;</expr_stmt>
				<expr_stmt><expr><name>fprsUsed</name> += 2</expr>;</expr_stmt>

				<if>if <condition>(<expr><name>fprsUsed</name> &gt; 14</expr>)</condition><then>
					<expr_stmt><expr><name>needsPtr</name> = <name>true</name></expr>;</expr_stmt></then></if>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
			<block>{
				<expr_stmt><expr><name>gprsUsed</name>++</expr>;</expr_stmt>

				<if>if <condition>(<expr><name>gprsUsed</name> &gt; 8</expr>)</condition><then>
				<block>{
					<expr_stmt><expr><name>needsPtr</name> = <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				}</block></then></if>

				<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + 1</expr>]</index></name> == <name>NULL</name></expr>)</condition><then>	<comment type="line">// last byte in the struct</comment>
					<break>break;</break></then></if>

				<comment type="line">// Count possible contiguous bytes ahead, up to 8.</comment>
				<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>j</name></decl>;</decl_stmt>

				<for>for (<init><expr><name>j</name> = 1</expr>;</init> <condition><expr><name>j</name> &lt; 8</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
				<block>{
					<if>if <condition>(<expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + <name>j</name></expr>]</index></name> == <name>NULL</name> ||
						!<call><name>FFI_TYPE_1_BYTE</name><argument_list>(<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name> + <name>j</name></expr>]</index></name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
						<break>break;</break></then></if>
				}</block></for>

				<expr_stmt><expr><name>i</name> += <name>j</name> - 1</expr>;</expr_stmt>	<comment type="line">// allow for i++ before the test condition</comment>

				<break>break;</break>
			}</block>

			</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_INT</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
			</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
				<expr_stmt><expr><name>gprsUsed</name>++</expr>;</expr_stmt>

				<if>if <condition>(<expr><name>gprsUsed</name> &gt; 8</expr>)</condition><then>
					<expr_stmt><expr><name>needsPtr</name> = <name>true</name></expr>;</expr_stmt></then></if>

				<break>break;</break>

			</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
				<expr_stmt><expr><name>needsPtr</name> = <call><name>ffi64_stret_needs_ptr</name><argument_list>(
					<argument><expr><name><name>inType</name>-&gt;<name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>gprsUsed</name></expr></argument>, <argument><expr>&amp;<name>fprsUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

			</case><default>default:
				<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</default>}</block></switch>
	}</block></for>

	<if>if <condition>(<expr><name>ioGPRCount</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioGPRCount</name> = <name>gprsUsed</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>ioFPRCount</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>ioFPRCount</name> = <name>fprsUsed</name></expr>;</expr_stmt></then></if>

	<return>return <expr><name>needsPtr</name></expr>;</return>
}</block></function>

<comment type="block">/*	ffi64_data_size

	Calculate the size in bytes of an ffi type.
*/</comment>

<function><type><name>unsigned</name> <name>int</name></type>
<name>ffi64_data_size</name><parameter_list>(
	<param><decl><type><specifier>const</specifier> <name>ffi_type</name>*</type>	<name>inType</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>	<name>size</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>inType</name>-&gt;<name>type</name></name></expr>)</condition>
	<block>{
		<case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
		</case><case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
			<expr_stmt><expr><name>size</name> = 1</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
		</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
			<expr_stmt><expr><name>size</name> = 2</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>FFI_TYPE_INT</name></expr>:
		</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
		</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
		</case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
			<expr_stmt><expr><name>size</name> = 4</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
		</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
		</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
		</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
			<expr_stmt><expr><name>size</name> = 8</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
			<expr_stmt><expr><name>size</name> = 16</expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
			<expr_stmt><expr><call><name>ffi64_struct_to_reg_form</name><argument_list>(
				<argument><expr><name>inType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		</case><case>case <expr><name>FFI_TYPE_VOID</name></expr>:
			<break>break;</break>

		</case><default>default:
			<expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</default>}</block></switch>

	<return>return <expr><name>size</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/*	defined(__ppc64__)	*/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* __ppc__ || __ppc64__ */</comment>
</unit>
