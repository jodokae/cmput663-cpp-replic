<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_ctypes/cfield.c"><comment type="block">/*****************************************************************
  This file should be kept compatible with Python 2.3, see PEP 291.
 *****************************************************************/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ctypes.h"</cpp:file></cpp:include>

<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  CField_Type
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CField_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CFieldObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>obj</name> = (<name>CFieldObject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>obj</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Expects the size, index and offset for the current field in *psize and
 * *poffset, stores the total size so far in *psize, the offset for the next
 * field in *poffset, the alignment requirements for the current field in
 * *palign, and returns a field desriptor for this field.
 */</comment>
<comment type="block">/*
 * bitfields extension:
 * bitsize != 0: this is a bit field.
 * pbitofs points to the current bit offset, this will be updated.
 * prev_desc points to the type of the previous bitfield, if any.
 */</comment>
<function><type><name>PyObject</name> *</type>
<name>CField_FromDesc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>desc</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>,
		<param><decl><type><name>Py_ssize_t</name> *</type><name>pfield_size</name></decl></param>, <param><decl><type><name>int</name></type> <name>bitsize</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pbitofs</name></decl></param>,
		<param><decl><type><name>Py_ssize_t</name> *</type><name>psize</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>poffset</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>palign</name></decl></param>,
		<param><decl><type><name>int</name></type> <name>pack</name></decl></param>, <param><decl><type><name>int</name></type> <name>big_endian</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CFieldObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>align</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SETFUNC</name></type> <name>setfunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GETFUNC</name></type> <name>getfunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fieldtype</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_BITFIELD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_BITFIELD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONT_BITFIELD</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPAND_BITFIELD</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

	<expr_stmt><expr><name>self</name> = (<name>CFieldObject</name> *)<call><name>PyObject_CallObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>CField_Type</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"has no _stginfo_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>bitsize</name> <comment type="block">/* this is a bitfield request */</comment>
	    &amp;&amp; *<name>pfield_size</name> <comment type="block">/* we have a bitfield open */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	    <comment type="block">/* MSVC, GCC with -mms-bitfields */</comment>
	    &amp;&amp; <name><name>dict</name>-&gt;<name>size</name></name> * 8 == *<name>pfield_size</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <comment type="block">/* GCC */</comment>
	    &amp;&amp; <name><name>dict</name>-&gt;<name>size</name></name> * 8 &lt;= *<name>pfield_size</name> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    &amp;&amp; (*<name>pbitofs</name> + <name>bitsize</name>) &lt;= *<name>pfield_size</name></expr>)</condition><then> <block>{
		<comment type="block">/* continue bit field */</comment>
		<expr_stmt><expr><name>fieldtype</name> = <name>CONT_BITFIELD</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WIN32</name></cpp:ifndef>
	}</block></then> <else>else <if>if <condition>(<expr><name>bitsize</name> <comment type="block">/* this is a bitfield request */</comment>
	    &amp;&amp; *<name>pfield_size</name> <comment type="block">/* we have a bitfield open */</comment>
	    &amp;&amp; <name><name>dict</name>-&gt;<name>size</name></name> * 8 &gt;= *<name>pfield_size</name>
	    &amp;&amp; (*<name>pbitofs</name> + <name>bitsize</name>) &lt;= <name><name>dict</name>-&gt;<name>size</name></name> * 8</expr>)</condition><then> <block>{
		<comment type="block">/* expand bit field */</comment>
		<expr_stmt><expr><name>fieldtype</name> = <name>EXPAND_BITFIELD</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <if>if <condition>(<expr><name>bitsize</name></expr>)</condition><then> <block>{
		<comment type="block">/* start new bitfield */</comment>
		<expr_stmt><expr><name>fieldtype</name> = <name>NEW_BITFIELD</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>pbitofs</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>pfield_size</name> = <name><name>dict</name>-&gt;<name>size</name></name> * 8</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<comment type="block">/* not a bit field */</comment>
		<expr_stmt><expr><name>fieldtype</name> = <name>NO_BITFIELD</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>pbitofs</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>pfield_size</name> = 0</expr>;</expr_stmt>
	}</block></else></if></else></if></else></if>

	<expr_stmt><expr><name>size</name> = <name><name>dict</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>length</name> = <name><name>dict</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>proto</name> = <name>desc</name></expr>;</expr_stmt>

	<comment type="block">/*  Field descriptors for 'c_char * n' are be scpecial cased to
	    return a Python string instead of an Array object instance...
	*/</comment>
	<if>if <condition>(<expr><call><name>ArrayTypeObject_Check</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>adict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>idict</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>adict</name> &amp;&amp; <name><name>adict</name>-&gt;<name>proto</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>idict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name><name>adict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>idict</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
						<argument><expr>"has no _stginfo_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><name><name>idict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"c"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fd</name> <init>= <expr><call><name>getentry</name><argument_list>(<argument><expr>"s"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>getfunc</name> = <name><name>fd</name>-&gt;<name>getfunc</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>setfunc</name> = <name><name>fd</name>-&gt;<name>setfunc</name></name></expr>;</expr_stmt>
			}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
			<if>if <condition>(<expr><name><name>idict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fd</name> <init>= <expr><call><name>getentry</name><argument_list>(<argument><expr>"U"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>getfunc</name> = <name><name>fd</name>-&gt;<name>getfunc</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>setfunc</name> = <name><name>fd</name>-&gt;<name>setfunc</name></name></expr>;</expr_stmt>
			}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>setfunc</name></name> = <name>setfunc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>getfunc</name></name> = <name>getfunc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name> = <name>index</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>proto</name></name> = <name>proto</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>fieldtype</name></expr>)</condition> <block>{
	<case>case <expr><name>NEW_BITFIELD</name></expr>:
		<if>if <condition>(<expr><name>big_endian</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = (<name>bitsize</name> &lt;&lt; 16) + *<name>pfield_size</name> - *<name>pbitofs</name> - <name>bitsize</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = (<name>bitsize</name> &lt;&lt; 16) + *<name>pbitofs</name></expr>;</expr_stmt></else></if>
		<expr_stmt><expr>*<name>pbitofs</name> = <name>bitsize</name></expr>;</expr_stmt>
		<comment type="block">/* fall through */</comment>
	</case><case>case <expr><name>NO_BITFIELD</name></expr>:
		<if>if <condition>(<expr><name>pack</name></expr>)</condition><then>
			<expr_stmt><expr><name>align</name> = <call><name>min</name><argument_list>(<argument><expr><name>pack</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>align</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>align</name> = <name><name>dict</name>-&gt;<name>align</name></name></expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>align</name> &amp;&amp; *<name>poffset</name> % <name>align</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>delta</name> <init>= <expr><name>align</name> - (*<name>poffset</name> % <name>align</name>)</expr></init></decl>;</decl_stmt>
			<expr_stmt><expr>*<name>psize</name> += <name>delta</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>poffset</name> += <name>delta</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>bitsize</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = <name>size</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr>*<name>psize</name> += <name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>self</name>-&gt;<name>offset</name></name> = *<name>poffset</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>poffset</name> += <name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>palign</name> = <name>align</name></expr>;</expr_stmt>
		<break>break;</break>

	</case><case>case <expr><name>EXPAND_BITFIELD</name></expr>:
		<expr_stmt><expr>*<name>poffset</name> += <name><name>dict</name>-&gt;<name>size</name></name> - *<name>pfield_size</name>/8</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>psize</name> += <name><name>dict</name>-&gt;<name>size</name></name> - *<name>pfield_size</name>/8</expr>;</expr_stmt>

		<expr_stmt><expr>*<name>pfield_size</name> = <name><name>dict</name>-&gt;<name>size</name></name> * 8</expr>;</expr_stmt>

		<if>if <condition>(<expr><name>big_endian</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = (<name>bitsize</name> &lt;&lt; 16) + *<name>pfield_size</name> - *<name>pbitofs</name> - <name>bitsize</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = (<name>bitsize</name> &lt;&lt; 16) + *<name>pbitofs</name></expr>;</expr_stmt></else></if>

		<expr_stmt><expr><name><name>self</name>-&gt;<name>offset</name></name> = *<name>poffset</name> - <name>size</name></expr>;</expr_stmt> <comment type="block">/* poffset is already updated for the NEXT field */</comment>
		<expr_stmt><expr>*<name>pbitofs</name> += <name>bitsize</name></expr>;</expr_stmt>
		<break>break;</break>

	</case><case>case <expr><name>CONT_BITFIELD</name></expr>:
		<if>if <condition>(<expr><name>big_endian</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = (<name>bitsize</name> &lt;&lt; 16) + *<name>pfield_size</name> - *<name>pbitofs</name> - <name>bitsize</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name><name>self</name>-&gt;<name>size</name></name> = (<name>bitsize</name> &lt;&lt; 16) + *<name>pbitofs</name></expr>;</expr_stmt></else></if>

		<expr_stmt><expr><name><name>self</name>-&gt;<name>offset</name></name> = *<name>poffset</name> - <name>size</name></expr>;</expr_stmt> <comment type="block">/* poffset is already updated for the NEXT field */</comment>
		<expr_stmt><expr>*<name>pbitofs</name> += <name>bitsize</name></expr>;</expr_stmt>
		<break>break;</break>
	</case>}</block></switch>

	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CField_set</name><parameter_list>(<param><decl><type><name>CFieldObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>dst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dst</name> = (<name>CDataObject</name> *)<name>inst</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> = <name><name>dst</name>-&gt;<name>b_ptr</name></name> + <name><name>self</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"can't delete attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>CData_set</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>proto</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>setfunc</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
			 <argument><expr><name><name>self</name>-&gt;<name>index</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>size</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CField_get</name><parameter_list>(<param><decl><type><name>CFieldObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>inst</name></decl></param>, <param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>src</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>inst</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>src</name> = (<name>CDataObject</name> *)<name>inst</name></expr>;</expr_stmt>
	<return>return <expr><call><name>CData_get</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>proto</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>getfunc</name></name></expr></argument>, <argument><expr><name>inst</name></expr></argument>,
			 <argument><expr><name><name>self</name>-&gt;<name>index</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>size</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>b_ptr</name></name> + <name><name>self</name>-&gt;<name>offset</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CField_get_offset</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr>((<name>CFieldObject</name> *)<name>self</name>)-&gt;<name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CField_get_size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr>((<name>CFieldObject</name> *)<name>self</name>)-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>CField_getset</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"offset"</expr>, <expr><name>CField_get_offset</name></expr>, <expr><name>NULL</name></expr>, <expr>"offset in bytes of this field"</expr> }</block></expr>,
	<expr><block>{ <expr>"size"</expr>, <expr><name>CField_get_size</name></expr>, <expr><name>NULL</name></expr>, <expr>"size in bytes of this field"</expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CField_traverse</name><parameter_list>(<param><decl><type><name>CFieldObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CField_clear</name><parameter_list>(<param><decl><type><name>CFieldObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CField_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>CField_clear</name><argument_list>(<argument><expr>(<name>CFieldObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>self</name>-&gt;<name>ob_type</name>-&gt;<name>tp_free</name></name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CField_repr</name><parameter_list>(<param><decl><type><name>CFieldObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bits</name> <init>= <expr><name><name>self</name>-&gt;<name>size</name></name> &gt;&gt; 16</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><name><name>self</name>-&gt;<name>size</name></name> &amp; 0xFFFF</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>name</name> = ((<name>PyTypeObject</name> *)<name><name>self</name>-&gt;<name>proto</name></name>)-&gt;<name>tp_name</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>bits</name></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = <call><name>PyString_FromFormat</name><argument_list>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
			<argument><expr>"&lt;Field type=%s, ofs=%d:%d, bits=%d&gt;"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<argument><expr>"&lt;Field type=%s, ofs=%zd:%zd, bits=%zd&gt;"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>result</name> = <call><name>PyString_FromFormat</name><argument_list>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
			<argument><expr>"&lt;Field type=%s, ofs=%d, size=%d&gt;"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<argument><expr>"&lt;Field type=%s, ofs=%zd, size=%zd&gt;"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>CField_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.CField"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CFieldObject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr><name>CField_dealloc</name></expr>,				<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>CField_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"Structure/Union member"</expr>,		<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CField_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CField_clear</name></expr>,			<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr><name>CField_getset</name></expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>(<name>descrgetfunc</name>)<name>CField_get</name></expr>,		<comment type="block">/* tp_descr_get */</comment>
	<expr>(<name>descrsetfunc</name>)<name>CField_set</name></expr>,		<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>CField_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  Accessor functions
*/</comment>

<comment type="block">/* Derived from Modules/structmodule.c:
   Helper routine to get a Python integer and raise the appropriate error
   if it isn't one */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>long</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"int expected instead of float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>x</name> = <call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>p</name> = <name>x</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Same, but handling unsigned long */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_ulong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"int expected instead of float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>x</name> = <call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>p</name> = <name>x</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>

<comment type="block">/* Same, but handling native long long. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_longlong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PY_LONG_LONG</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"int expected instead of float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>x</name> = <call><name>PyInt_AsUnsignedLongLongMask</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>p</name> = <name>x</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Same, but handling native unsigned long long. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_ulonglong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"int expected instead of float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		<return>return <expr>-1</expr>;</return>
 	}</block></then></if>
	<expr_stmt><expr><name>x</name> = <call><name>PyInt_AsUnsignedLongLongMask</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr>*<name>p</name> = <name>x</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*****************************************************************
 * Integer fields, with bitfield support
 */</comment>

<comment type="block">/* how to decode the size field, for integer get/set functions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOW_BIT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((x) &amp; 0xFFFF)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_BITS</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &gt;&gt; 16)</cpp:value></cpp:define>

<comment type="block">/* This seems nore a compiler issue than a Windows/non-Windows one */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_MASK</name><parameter_list>(<param><type><name>size</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((1 &lt;&lt; NUM_BITS(size))-1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_MASK</name><parameter_list>(<param><type><name>size</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((1LL &lt;&lt; NUM_BITS(size))-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This macro CHANGES the first parameter IN PLACE. For proper sign handling,
   we must first shift left, then right.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_BITFIELD</name><parameter_list>(<param><type><name>v</name></type></param>, <param><type><name>size</name></type></param>)</parameter_list></cpp:macro>						\
	<cpp:value>if (NUM_BITS(size)) {						\
		v &lt;&lt;= (sizeof(v)*8 - LOW_BIT(size) - NUM_BITS(size));	\
		v &gt;&gt;= (sizeof(v)*8 - NUM_BITS(size));			\
	}</cpp:value></cpp:define>

<comment type="block">/* This macro RETURNS the first parameter with the bit field CHANGED. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>v</name></type></param>, <param><type><name>size</name></type></param>)</parameter_list></cpp:macro>							\
	<cpp:value>(NUM_BITS(size) ?						\
	 ( ( x &amp; ~(BIT_MASK(size) &lt;&lt; LOW_BIT(size)) ) | ( (v &amp; BIT_MASK(size)) &lt;&lt; LOW_BIT(size) ) ) \
	 : v)</cpp:value></cpp:define>

<comment type="block">/* byte swapping macros */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP_2</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>				\
	<cpp:value>( ( (v &gt;&gt; 8) &amp; 0x00FF) |		\
	  ( (v &lt;&lt; 8) &amp; 0xFF00) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP_4</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>			\
	<cpp:value>( ( (v &amp; 0x000000FF) &lt;&lt; 24 ) |  \
	  ( (v &amp; 0x0000FF00) &lt;&lt;  8 ) |  \
	  ( (v &amp; 0x00FF0000) &gt;&gt;  8 ) |  \
	  ( ((v &gt;&gt; 24) &amp; 0xFF)) )</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP_8</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>				\
	<cpp:value>( ( (v &amp; 0x00000000000000FFL) &lt;&lt; 56 ) |  \
	  ( (v &amp; 0x000000000000FF00L) &lt;&lt; 40 ) |  \
	  ( (v &amp; 0x0000000000FF0000L) &lt;&lt; 24 ) |  \
	  ( (v &amp; 0x00000000FF000000L) &lt;&lt;  8 ) |  \
	  ( (v &amp; 0x000000FF00000000L) &gt;&gt;  8 ) |  \
	  ( (v &amp; 0x0000FF0000000000L) &gt;&gt; 24 ) |  \
	  ( (v &amp; 0x00FF000000000000L) &gt;&gt; 40 ) |  \
	  ( ((v &gt;&gt; 56) &amp; 0xFF)) )</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP_8</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>				\
	<cpp:value>( ( (v &amp; 0x00000000000000FFLL) &lt;&lt; 56 ) |  \
	  ( (v &amp; 0x000000000000FF00LL) &lt;&lt; 40 ) |  \
	  ( (v &amp; 0x0000000000FF0000LL) &lt;&lt; 24 ) |  \
	  ( (v &amp; 0x00000000FF000000LL) &lt;&lt;  8 ) |  \
	  ( (v &amp; 0x000000FF00000000LL) &gt;&gt;  8 ) |  \
	  ( (v &amp; 0x0000FF0000000000LL) &gt;&gt; 24 ) |  \
	  ( (v &amp; 0x00FF000000000000LL) &gt;&gt; 40 ) |  \
	  ( ((v &gt;&gt; 56) &amp; 0xFF)) )</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP_INT</name></cpp:macro> <cpp:value>SWAP_4</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> == 4</expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP_LONG</name></cpp:macro> <cpp:value>SWAP_4</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG</name> == 8</expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP_LONG</name></cpp:macro> <cpp:value>SWAP_8</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*****************************************************************
 * The setter methods return an object which must be kept alive, to keep the
 * data valid which has been stored in the memory block.  The ctypes object
 * instance inserts this object into its 'b_objects' list.
 *
 * For simple Python types like integers or characters, there is nothing that
 * has to been kept alive, so Py_None is returned in these cases.  But this
 * makes inspecting the 'b_objects' list, which is accessible from Python for
 * debugging, less useful.
 *
 * So, defining the _CTYPES_DEBUG_KEEP symbol returns the original value
 * instead of Py_None.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_CTYPES_DEBUG_KEEP</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_RET</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Py_INCREF(x); return x</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_RET</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Py_INCREF(Py_None); return Py_None</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*****************************************************************
 * integer accessor methods, supporting bit fields
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>b_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr>*(<name>signed</name> <name>char</name> *)<name>ptr</name> = (<name>signed</name> <name>char</name>)<call><name>SET</name><argument_list>(<argument><expr>*(<name>signed</name> <name>char</name> *)<name>ptr</name></expr></argument>, <argument><expr>(<name>signed</name> <name>char</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>b_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>val</name> <init>= <expr>*(<name>signed</name> <name>char</name> *)<name>ptr</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>B_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_ulong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr>*(<name>unsigned</name> <name>char</name> *)<name>ptr</name> = (<name>unsigned</name> <name>char</name>)<call><name>SET</name><argument_list>(<argument><expr>*(<name>unsigned</name> <name>char</name>*)<name>ptr</name></expr></argument>,
						   <argument><expr>(<name>unsigned</name> <name>short</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>B_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>val</name> <init>= <expr>*(<name>unsigned</name> <name>char</name> *)<name>ptr</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>h_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>short</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>short</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>h_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>short</name></type> <name>field</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_2</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SET</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr>(<name>short</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_2</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>h_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>short</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>h_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>short</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> = <call><name>SWAP_2</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>H_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_ulong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>short</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>H_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>field</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_ulong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_2</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SET</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>short</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_2</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>H_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>H_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> = <call><name>SWAP_2</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>i_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>int</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>i_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>field</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_INT</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SET</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr>(<name>int</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_INT</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>i_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>i_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> = <call><name>SWAP_INT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<comment type="block">/* short BOOL - VARIANT_BOOL */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>vBOOL_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<case>case <expr>-1</expr>:
		<return>return <expr><name>NULL</name></expr>;</return>
	</case><case>case <expr>0</expr>:
		<expr_stmt><expr>*(<name>short</name> <name>int</name> *)<name>ptr</name> = <name>VARIANT_FALSE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</case><default>default:
		<expr_stmt><expr>*(<name>short</name> <name>int</name> *)<name>ptr</name> = <name>VARIANT_TRUE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>vBOOL_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)*(<name>short</name> <name>int</name> *)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_C99_BOOL</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOOL_TYPE</name></cpp:macro> <cpp:value>_Bool</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOOL_TYPE</name></cpp:macro> <cpp:value>char</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SIZEOF__BOOL</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF__BOOL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bool_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<case>case <expr>-1</expr>:
		<return>return <expr><name>NULL</name></expr>;</return>
	</case><case>case <expr>0</expr>:
		<expr_stmt><expr>*(<name>BOOL_TYPE</name> *)<name>ptr</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</case><default>default:
		<expr_stmt><expr>*(<name>BOOL_TYPE</name> *)<name>ptr</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bool_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)*(<name>BOOL_TYPE</name> *)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>I_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_ulong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return  <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>int</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>I_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>field</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_ulong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return  <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = (<name>unsigned</name> <name>int</name>)<call><name>SET</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>int</name>)<name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_INT</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>I_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>I_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> = <call><name>SWAP_INT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>l_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>l_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>field</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_LONG</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = (<name>long</name>)<call><name>SET</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_LONG</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>l_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>l_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> = <call><name>SWAP_LONG</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>L_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_ulong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return  <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>L_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>field</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_ulong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return  <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_LONG</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = (<name>unsigned</name> <name>long</name>)<call><name>SET</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_LONG</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>L_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>L_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> = <call><name>SWAP_LONG</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>q_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_longlong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>q_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>field</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_longlong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_8</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = (<name>PY_LONG_LONG</name>)<call><name>SET</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_8</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>q_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>q_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> = <call><name>SWAP_8</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Q_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_ulonglong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>SET</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Q_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>field</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>get_ulonglong</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_8</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = (<name>unsigned</name> <name>PY_LONG_LONG</name>)<call><name>SET</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> = <call><name>SWAP_8</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Q_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyLong_FromUnsignedLongLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Q_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> = <call><name>SWAP_8</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_BITFIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyLong_FromUnsignedLongLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*****************************************************************
 * non-integer accessor methods, not supporting bit fields
 */</comment>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>g_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>" float expected instead of %s instance"</expr></argument>,
			     <argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>sizeof(<name>long</name> <name>double</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>g_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr>sizeof(<name>long</name> <name>double</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>d_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>" float expected instead of %s instance"</expr></argument>,
			     <argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>d_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>d_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>" float expected instead of %s instance"</expr></argument>,
			     <argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>_PyFloat_Pack8</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>ptr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><call><name>_PyFloat_Pack8</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>ptr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>d_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>_PyFloat_Unpack8</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>_PyFloat_Unpack8</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>f_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>float</name></type> <name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = (<name>float</name>)<call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>" float expected instead of %s instance"</expr></argument>,
			     <argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>f_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>float</name></type> <name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>f_set_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>float</name></type> <name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> = (<name>float</name>)<call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>" float expected instead of %s instance"</expr></argument>,
			     <argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>_PyFloat_Pack4</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>ptr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><call><name>_PyFloat_Pack4</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>ptr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>f_get_sw</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>_PyFloat_Unpack4</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>_PyFloat_Unpack4</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
  py_object refcounts:

  1. If we have a py_object instance, O_get must Py_INCREF the returned
  object, of course.  If O_get is called from a function result, no py_object
  instance is created - so callproc.c::GetResult has to call Py_DECREF.

  2. The memory block in py_object owns a refcount.  So, py_object must call
  Py_DECREF on destruction.  Maybe only when b_needsfree is non-zero.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>O_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ob</name> <init>= <expr>*(<name>PyObject</name> **)<name>ptr</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>ob</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<comment type="block">/* Set an error if not yet set */</comment>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"PyObject is NULL"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ob</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>O_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Hm, does the memory block need it's own refcount or not? */</comment>
	<expr_stmt><expr>*(<name>PyObject</name> **)<name>ptr</name> = <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>value</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>c_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || (1 != <call><name>PyString_Size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"one character string expected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>*(<name>char</name> *)<name>ptr</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>c_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>ptr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
<comment type="block">/* u - a single wchar_t character */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>u_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
						    <argument><expr><name>conversion_mode_encoding</name></expr></argument>,
						    <argument><expr><name>conversion_mode_errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then> <else>else <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"unicode string expected instead of %s instance"</expr></argument>,
				<argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

	<expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> != 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"one character unicode string expected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr>*(<name>wchar_t</name> *)<name>ptr</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>u_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr>(<name>wchar_t</name> *)<name>ptr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* U - a unicode string */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>U_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> /= <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt> <comment type="block">/* we count character units here, not bytes */</comment>

	<expr_stmt><expr><name>result</name> = <call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr>(<name>wchar_t</name> *)<name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* We need 'result' to be able to count the characters with wcslen,
	   since ptr may not be NUL terminated.  If the length is smaller (if
	   it was actually NUL terminated, we construct a new one and throw
	   away the result.
	*/</comment>
	<comment type="block">/* chop off at the first NUL character, if any. */</comment>
	<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt; <name>size</name></expr>;</condition> <incr><expr>++<name>len</name></expr></incr>)
		<if>if <condition>(<expr>!<name><name>p</name><index>[<expr><name>len</name></expr>]</index></name></expr>)</condition><then>
			<break>break;</break></then></if></for>

	<if>if <condition>(<expr><name>len</name> &lt; <name>size</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>ob</name> <init>= <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr>(<name>wchar_t</name> *)<name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ob</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>U_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>

	<comment type="block">/* It's easier to calculate in characters than in bytes */</comment>
	<expr_stmt><expr><name>length</name> /= <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
						    <argument><expr><name>conversion_mode_encoding</name></expr></argument>,
						    <argument><expr><name>conversion_mode_errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then> <else>else <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"unicode string expected instead of %s instance"</expr></argument>,
				<argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	<expr_stmt><expr><name>size</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> &gt; <name>length</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
			     <argument><expr>"string too long (%d, maximum length %d)"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			     <argument><expr>"string too long (%zd, maximum length %zd)"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			     <argument><expr><name>size</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><name>size</name> &lt; <name>length</name>-1</expr>)</condition><then>
		<comment type="block">/* copy terminating NUL character if there is space */</comment>
		<expr_stmt><expr><name>size</name> += 1</expr>;</expr_stmt></then></if></else></if>
	<expr_stmt><expr><call><name>PyUnicode_AsWideChar</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>value</name></expr></argument>, <argument><expr>(<name>wchar_t</name> *)<name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>value</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>slen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>(<name>char</name> *)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* chop off at the first NUL character, if any.
	 * On error, result will be deallocated and set to NULL.
	 */</comment>
	<expr_stmt><expr><name>slen</name> = <call><name>strlen</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> = <call><name>min</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr>(<name>Py_ssize_t</name>)<name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>result</name>-&gt;<name>ob_refcnt</name></name> == 1</expr>)</condition><then> <block>{
		<comment type="block">/* shorten the result */</comment>
		<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then> <else>else
		<comment type="block">/* cannot shorten the result */</comment>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>data</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>size</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> &lt; <name>length</name></expr>)</condition><then> <block>{
		<comment type="block">/* This will copy the leading NUL character
		 * if there is space for it.
		 */</comment>
		<expr_stmt><expr>++<name>size</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>size</name> &gt; <name>length</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
			     <argument><expr>"string too long (%d, maximum length %d)"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			     <argument><expr>"string too long (%zd, maximum length %zd)"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			     <argument><expr><name>size</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if></else></if>
	<comment type="block">/* Also copy the terminating NUL character if there is space */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)<name>ptr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>z_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*(<name>char</name> **)<name>ptr</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*(<name>char</name> **)<name>ptr</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name> <init>= <expr><call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
							  <argument><expr><name>conversion_mode_encoding</name></expr></argument>,
							  <argument><expr><name>conversion_mode_errors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr>*(<name>char</name> **)<name>ptr</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>str</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOID_P</name> == <name>SIZEOF_LONG_LONG</name></expr></cpp:if>
		<expr_stmt><expr>*(<name>char</name> **)<name>ptr</name> = (<name>char</name> *)<call><name>PyInt_AsUnsignedLongLongMask</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr>*(<name>char</name> **)<name>ptr</name> = (<name>char</name> *)<call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if></else></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"string or integer address expected instead of %s instance"</expr></argument>,
		     <argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>z_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX What about invalid pointers ??? */</comment>
	<if>if <condition>(<expr>*(<name>void</name> **)<name>ptr</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<if>if <condition>(<expr><call><name>IsBadStringPtrA</name><argument_list>(<argument><expr>*(<name>char</name> **)<name>ptr</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				     <argument><expr>"invalid string pointer %p"</expr></argument>,
				     <argument><expr>*(<name>char</name> **)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>*(<name>char</name> **)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></else></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Z_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*(<name>wchar_t</name> **)<name>ptr</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
						    <argument><expr><name>conversion_mode_encoding</name></expr></argument>,
						    <argument><expr><name>conversion_mode_errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOID_P</name> == <name>SIZEOF_LONG_LONG</name></expr></cpp:if>
		<expr_stmt><expr>*(<name>wchar_t</name> **)<name>ptr</name> = (<name>wchar_t</name> *)<call><name>PyInt_AsUnsignedLongLongMask</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr>*(<name>wchar_t</name> **)<name>ptr</name> = (<name>wchar_t</name> *)<call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"unicode string or integer address expected instead of %s instance"</expr></argument>,
			     <argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_USABLE_WCHAR_T</name></cpp:ifdef>
	<comment type="block">/* HAVE_USABLE_WCHAR_T means that Py_UNICODE and wchar_t is the same
	   type.  So we can copy directly.  Hm, are unicode objects always NUL
	   terminated in Python, internally?
	 */</comment>
	<expr_stmt><expr>*(<name>wchar_t</name> **)<name>ptr</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>value</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<block>{
		<comment type="block">/* We must create a wchar_t* buffer from the unicode object,
		   and keep it alive */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>keep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>wchar_t</name> *</type><name>buffer</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>size</name> += 1</expr>;</expr_stmt> <comment type="block">/* terminating NUL */</comment>
		<expr_stmt><expr><name>size</name> *= <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>buffer</name> = (<name>wchar_t</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>buffer</name></expr>)</condition><then>
			<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>keep</name> = <call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>PyMem_Free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>keep</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr>*(<name>wchar_t</name> **)<name>ptr</name> = (<name>wchar_t</name> *)<name>buffer</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>-1 == <call><name>PyUnicode_AsWideChar</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>value</name></expr></argument>,
					       <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>keep</name></expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Z_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>wchar_t</name> *</type><name>p</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>p</name> = *(<name>wchar_t</name> **)<name>ptr</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<if>if <condition>(<expr><call><name>IsBadStringPtrW</name><argument_list>(<argument><expr>*(<name>wchar_t</name> **)<name>ptr</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				     <argument><expr>"invalid string pointer %p"</expr></argument>,
				     <argument><expr>*(<name>wchar_t</name> **)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>wcslen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BSTR_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>BSTR</name></type> <name>bstr</name></decl>;</decl_stmt>

	<comment type="block">/* convert value into a PyUnicodeObject or NULL */</comment>
	<if>if <condition>(<expr><name>Py_None</name> == <name>value</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
						    <argument><expr><name>conversion_mode_encoding</name></expr></argument>,
						    <argument><expr><name>conversion_mode_errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* for the descref below */</comment>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"unicode string expected instead of %s instance"</expr></argument>,
				<argument><expr><name><name>value</name>-&gt;<name>ob_type</name>-&gt;<name>tp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if></else></if>

	<comment type="block">/* create a BSTR from value */</comment>
	<if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>(<name>unsigned</name>) <name>size</name> != <name>size</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"String too long for BSTR"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>bstr</name> = <call><name>SysAllocStringLen</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr>(<name>unsigned</name>)<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else
		<expr_stmt><expr><name>bstr</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

	<comment type="block">/* free the previous contents, if any */</comment>
	<if>if <condition>(<expr>*(<name>BSTR</name> *)<name>ptr</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>SysFreeString</name><argument_list>(<argument><expr>*(<name>BSTR</name> *)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	
	<comment type="block">/* and store it */</comment>
	<expr_stmt><expr>*(<name>BSTR</name> *)<name>ptr</name> = <name>bstr</name></expr>;</expr_stmt>

	<comment type="block">/* We don't need to keep any other object */</comment>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>BSTR_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>BSTR</name></type> <name>p</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>p</name> = *(<name>BSTR</name> *)<name>ptr</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p</name></expr>)</condition><then>
		<return>return <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>SysStringLen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
	<else>else <block>{
		<comment type="block">/* Hm, it seems NULL pointer and zero length string are the
		   same in BSTR, see Don Box, p 81
		*/</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>P_set</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>void</name> *</type><name>v</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*(<name>void</name> **)<name>ptr</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"cannot be converted to pointer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOID_P</name> &lt;= <name>SIZEOF_LONG</name></expr></cpp:if>
	<expr_stmt><expr><name>v</name> = (<name>void</name> *)<call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifndef>
<cpp:error>#   <cpp:directive>error</cpp:directive> "PyLong_AsVoidPtr: sizeof(void*) &gt; sizeof(long), but no long long"</cpp:error>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> &lt; <name>SIZEOF_VOID_P</name></expr></cpp:elif>
<cpp:error>#   <cpp:directive>error</cpp:directive> "PyLong_AsVoidPtr: sizeof(PY_LONG_LONG) &lt; sizeof(void*)"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>v</name> = (<name>void</name> *)<call><name>PyInt_AsUnsignedLongLongMask</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr>*(<name>void</name> **)<name>ptr</name> = <name>v</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_RET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>P_get</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>*(<name>void</name> **)<name>ptr</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr>*(<name>void</name> **)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>fielddesc</name></type> <name><name>formattable</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>'s'</expr>, <expr><name>s_set</name></expr>, <expr><name>s_get</name></expr>, <expr>&amp;<name>ffi_type_pointer</name></expr>}</block></expr>,
	<expr><block>{ <expr>'b'</expr>, <expr><name>b_set</name></expr>, <expr><name>b_get</name></expr>, <expr>&amp;<name>ffi_type_schar</name></expr>}</block></expr>,
	<expr><block>{ <expr>'B'</expr>, <expr><name>B_set</name></expr>, <expr><name>B_get</name></expr>, <expr>&amp;<name>ffi_type_uchar</name></expr>}</block></expr>,
	<expr><block>{ <expr>'c'</expr>, <expr><name>c_set</name></expr>, <expr><name>c_get</name></expr>, <expr>&amp;<name>ffi_type_schar</name></expr>}</block></expr>,
	<expr><block>{ <expr>'d'</expr>, <expr><name>d_set</name></expr>, <expr><name>d_get</name></expr>, <expr>&amp;<name>ffi_type_double</name></expr>, <expr><name>d_set_sw</name></expr>, <expr><name>d_get_sw</name></expr>}</block></expr>,
	<expr><block>{ <expr>'g'</expr>, <expr><name>g_set</name></expr>, <expr><name>g_get</name></expr>, <expr>&amp;<name>ffi_type_longdouble</name></expr>}</block></expr>,
	<expr><block>{ <expr>'f'</expr>, <expr><name>f_set</name></expr>, <expr><name>f_get</name></expr>, <expr>&amp;<name>ffi_type_float</name></expr>, <expr><name>f_set_sw</name></expr>, <expr><name>f_get_sw</name></expr>}</block></expr>,
	<expr><block>{ <expr>'h'</expr>, <expr><name>h_set</name></expr>, <expr><name>h_get</name></expr>, <expr>&amp;<name>ffi_type_sshort</name></expr>, <expr><name>h_set_sw</name></expr>, <expr><name>h_get_sw</name></expr>}</block></expr>,
	<expr><block>{ <expr>'H'</expr>, <expr><name>H_set</name></expr>, <expr><name>H_get</name></expr>, <expr>&amp;<name>ffi_type_ushort</name></expr>, <expr><name>H_set_sw</name></expr>, <expr><name>H_get_sw</name></expr>}</block></expr>,
	<expr><block>{ <expr>'i'</expr>, <expr><name>i_set</name></expr>, <expr><name>i_get</name></expr>, <expr>&amp;<name>ffi_type_sint</name></expr>, <expr><name>i_set_sw</name></expr>, <expr><name>i_get_sw</name></expr>}</block></expr>,
	<expr><block>{ <expr>'I'</expr>, <expr><name>I_set</name></expr>, <expr><name>I_get</name></expr>, <expr>&amp;<name>ffi_type_uint</name></expr>, <expr><name>I_set_sw</name></expr>, <expr><name>I_get_sw</name></expr>}</block></expr>,
<comment type="block">/* XXX Hm, sizeof(int) == sizeof(long) doesn't hold on every platform */</comment>
<comment type="block">/* As soon as we can get rid of the type codes, this is no longer a problem */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> == 4</expr></cpp:if>
	<expr><block>{ <expr>'l'</expr>, <expr><name>l_set</name></expr>, <expr><name>l_get</name></expr>, <expr>&amp;<name>ffi_type_sint32</name></expr>, <expr><name>l_set_sw</name></expr>, <expr><name>l_get_sw</name></expr>}</block></expr>,
	<expr><block>{ <expr>'L'</expr>, <expr><name>L_set</name></expr>, <expr><name>L_get</name></expr>, <expr>&amp;<name>ffi_type_uint32</name></expr>, <expr><name>L_set_sw</name></expr>, <expr><name>L_get_sw</name></expr>}</block></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG</name> == 8</expr></cpp:elif>
	<expr><block>{ <expr>'l'</expr>, <expr><name>l_set</name></expr>, <expr><name>l_get</name></expr>, <expr>&amp;<name>ffi_type_sint64</name></expr>, <expr><name>l_set_sw</name></expr>, <expr><name>l_get_sw</name></expr>}</block></expr>,
	<expr><block>{ <expr>'L'</expr>, <expr><name>L_set</name></expr>, <expr><name>L_get</name></expr>, <expr>&amp;<name>ffi_type_uint64</name></expr>, <expr><name>L_set_sw</name></expr>, <expr><name>L_get_sw</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error># <cpp:directive>error</cpp:directive></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> == 8</expr></cpp:if>
	<expr><block>{ <expr>'q'</expr>, <expr><name>q_set</name></expr>, <expr><name>q_get</name></expr>, <expr>&amp;<name>ffi_type_sint64</name></expr>, <expr><name>q_set_sw</name></expr>, <expr><name>q_get_sw</name></expr>}</block></expr>,
	<expr><block>{ <expr>'Q'</expr>, <expr><name>Q_set</name></expr>, <expr><name>Q_get</name></expr>, <expr>&amp;<name>ffi_type_uint64</name></expr>, <expr><name>Q_set_sw</name></expr>, <expr><name>Q_get_sw</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error># <cpp:directive>error</cpp:directive></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{ <expr>'P'</expr>, <expr><name>P_set</name></expr>, <expr><name>P_get</name></expr>, <expr>&amp;<name>ffi_type_pointer</name></expr>}</block></expr>,
	<expr><block>{ <expr>'z'</expr>, <expr><name>z_set</name></expr>, <expr><name>z_get</name></expr>, <expr>&amp;<name>ffi_type_pointer</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
	<expr><block>{ <expr>'u'</expr>, <expr><name>u_set</name></expr>, <expr><name>u_get</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <comment type="block">/* ffi_type set later */</comment>
	<expr><block>{ <expr>'U'</expr>, <expr><name>U_set</name></expr>, <expr><name>U_get</name></expr>, <expr>&amp;<name>ffi_type_pointer</name></expr>}</block></expr>,
	<expr><block>{ <expr>'Z'</expr>, <expr><name>Z_set</name></expr>, <expr><name>Z_get</name></expr>, <expr>&amp;<name>ffi_type_pointer</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<expr><block>{ <expr>'X'</expr>, <expr><name>BSTR_set</name></expr>, <expr><name>BSTR_get</name></expr>, <expr>&amp;<name>ffi_type_pointer</name></expr>}</block></expr>,
	<expr><block>{ <expr>'v'</expr>, <expr><name>vBOOL_set</name></expr>, <expr><name>vBOOL_get</name></expr>, <expr>&amp;<name>ffi_type_sshort</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF__BOOL</name> == 1</expr></cpp:if>
	<expr><block>{ <expr>'?'</expr>, <expr><name>bool_set</name></expr>, <expr><name>bool_get</name></expr>, <expr>&amp;<name>ffi_type_uchar</name></expr>}</block></expr>, <comment type="block">/* Also fallback for no native _Bool support */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF__BOOL</name> == <name>SIZEOF_SHORT</name></expr></cpp:elif>
	<expr><block>{ <expr>'?'</expr>, <expr><name>bool_set</name></expr>, <expr><name>bool_get</name></expr>, <expr>&amp;<name>ffi_type_ushort</name></expr>}</block></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF__BOOL</name> == <name>SIZEOF_INT</name></expr></cpp:elif>
	<expr><block>{ <expr>'?'</expr>, <expr><name>bool_set</name></expr>, <expr><name>bool_get</name></expr>, <expr>&amp;<name>ffi_type_uint</name></expr>, <expr><name>I_set_sw</name></expr>, <expr><name>I_get_sw</name></expr>}</block></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF__BOOL</name> == <name>SIZEOF_LONG</name></expr></cpp:elif>
	<expr><block>{ <expr>'?'</expr>, <expr><name>bool_set</name></expr>, <expr><name>bool_get</name></expr>, <expr>&amp;<name>ffi_type_ulong</name></expr>, <expr><name>L_set_sw</name></expr>, <expr><name>L_get_sw</name></expr>}</block></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF__BOOL</name> == <name>SIZEOF_LONG_LONG</name></expr></cpp:elif>
	<expr><block>{ <expr>'?'</expr>, <expr><name>bool_set</name></expr>, <expr><name>bool_get</name></expr>, <expr>&amp;<name>ffi_type_ulong</name></expr>, <expr><name>Q_set_sw</name></expr>, <expr><name>Q_get_sw</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIZEOF__BOOL */</comment>
	<expr><block>{ <expr>'O'</expr>, <expr><name>O_set</name></expr>, <expr><name>O_get</name></expr>, <expr>&amp;<name>ffi_type_pointer</name></expr>}</block></expr>,
	<expr><block>{ <expr>0</expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
  Ideas: Implement VARIANT in this table, using 'V' code.
  Use '?' as code for BOOL.
*/</comment>

<function><type>struct <name>fielddesc</name> *</type>
<name>getentry</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>fmt</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>table</name> <init>= <expr><name>formattable</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
			<expr_stmt><expr><call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>pffi_type</name> = &amp;<name>ffi_type_sshort</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
			<expr_stmt><expr><call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>pffi_type</name> = &amp;<name>ffi_type_sint</name></expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
			<expr_stmt><expr><call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>pffi_type</name> = &amp;<name>ffi_type_slong</name></expr>;</expr_stmt></then></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>

	<for>for (<init>;</init> <condition><expr><name><name>table</name>-&gt;<name>code</name></name></expr>;</condition> <incr><expr>++<name>table</name></expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>table</name>-&gt;<name>code</name></name> == <name><name>fmt</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
			<return>return <expr><name>table</name></expr>;</return></then></if>
	}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>char</name></type> <name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_char</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>short</name></type> <name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_short</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_int</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_long</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>float</name></type> <name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_float</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_double</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_long_double</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>char</name> *</type><name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_char_p</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>void</name> *</type><name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_void_p</name>;</typedef>

<comment type="block">/*
#define CHAR_ALIGN (sizeof(s_char) - sizeof(char))
#define SHORT_ALIGN (sizeof(s_short) - sizeof(short))
#define INT_ALIGN (sizeof(s_int) - sizeof(int))
#define LONG_ALIGN (sizeof(s_long) - sizeof(long))
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT_ALIGN</name></cpp:macro> <cpp:value>(sizeof(s_float) - sizeof(float))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLE_ALIGN</name></cpp:macro> <cpp:value>(sizeof(s_double) - sizeof(double))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONGDOUBLE_ALIGN</name></cpp:macro> <cpp:value>(sizeof(s_long_double) - sizeof(long double))</cpp:value></cpp:define>

<comment type="block">/* #define CHAR_P_ALIGN (sizeof(s_char_p) - sizeof(char*)) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VOID_P_ALIGN</name></cpp:macro> <cpp:value>(sizeof(s_void_p) - sizeof(void*))</cpp:value></cpp:define>

<comment type="block">/*
#ifdef HAVE_USABLE_WCHAR_T
typedef struct { char c; wchar_t x; } s_wchar;
typedef struct { char c; wchar_t *x; } s_wchar_p;

#define WCHAR_ALIGN (sizeof(s_wchar) - sizeof(wchar_t))
#define WCHAR_P_ALIGN (sizeof(s_wchar_p) - sizeof(wchar_t*))
#endif
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
<typedef>typedef <type><struct>struct <block>{ <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt> }</block></struct></type> <name>s_long_long</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_LONG_ALIGN</name></cpp:macro> <cpp:value>(sizeof(s_long_long) - sizeof(PY_LONG_LONG))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* from ffi.h:
typedef struct _ffi_type
{
	size_t size;
	unsigned short alignment;
	unsigned short type;
	struct _ffi_type **elements;
} ffi_type;
*/</comment>

<comment type="block">/* align and size are bogus for void, but they must not be zero */</comment>
<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_void</name> <init>= <expr><block>{ <expr>1</expr>, <expr>1</expr>, <expr><name>FFI_TYPE_VOID</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_uint8</name> <init>= <expr><block>{ <expr>1</expr>, <expr>1</expr>, <expr><name>FFI_TYPE_UINT8</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_sint8</name> <init>= <expr><block>{ <expr>1</expr>, <expr>1</expr>, <expr><name>FFI_TYPE_SINT8</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_uint16</name> <init>= <expr><block>{ <expr>2</expr>, <expr>2</expr>, <expr><name>FFI_TYPE_UINT16</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_sint16</name> <init>= <expr><block>{ <expr>2</expr>, <expr>2</expr>, <expr><name>FFI_TYPE_SINT16</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_uint32</name> <init>= <expr><block>{ <expr>4</expr>, <expr>4</expr>, <expr><name>FFI_TYPE_UINT32</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_sint32</name> <init>= <expr><block>{ <expr>4</expr>, <expr>4</expr>, <expr><name>FFI_TYPE_SINT32</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_uint64</name> <init>= <expr><block>{ <expr>8</expr>, <expr><name>LONG_LONG_ALIGN</name></expr>, <expr><name>FFI_TYPE_UINT64</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_sint64</name> <init>= <expr><block>{ <expr>8</expr>, <expr><name>LONG_LONG_ALIGN</name></expr>, <expr><name>FFI_TYPE_SINT64</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_float</name> <init>= <expr><block>{ <expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>FLOAT_ALIGN</name></expr>, <expr><name>FFI_TYPE_FLOAT</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_double</name> <init>= <expr><block>{ <expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>DOUBLE_ALIGN</name></expr>, <expr><name>FFI_TYPE_DOUBLE</name></expr> }</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ffi_type_longdouble</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ffi_type_longdouble</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* This is already defined on OSX */</comment>
<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_longdouble</name> <init>= <expr><block>{ <expr>sizeof(<name>long</name> <name>double</name>)</expr>, <expr><name>LONGDOUBLE_ALIGN</name></expr>,
				 <expr><name>FFI_TYPE_LONGDOUBLE</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_pointer</name> <init>= <expr><block>{ <expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr>, <expr><name>VOID_P_ALIGN</name></expr>, <expr><name>FFI_TYPE_POINTER</name></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*---------------- EOF ----------------*/</comment>
</unit>
