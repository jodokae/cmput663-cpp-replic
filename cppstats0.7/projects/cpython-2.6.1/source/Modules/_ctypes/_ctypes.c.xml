<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_ctypes/_ctypes.c"><comment type="block">/*****************************************************************
  This file should be kept compatible with Python 2.3, see PEP 291.
 *****************************************************************/</comment>


<comment type="block">/*
  ToDo:

  Get rid of the checker (and also the converters) field in CFuncPtrObject and
  StgDictObject, and replace them by slot functions in StgDictObject.

  think about a buffer-like object (memory? bytes?)

  Should POINTER(c_char) and POINTER(c_wchar) have a .value property?
  What about c_char and c_wchar arrays then?

  Add from_mmap, from_file, from_string metaclass methods.

  Maybe we can get away with from_file (calls read) and with a from_buffer
  method?

  And what about the to_mmap, to_file, to_str(?) methods?  They would clobber
  the namespace, probably. So, functions instead? And we already have memmove...
*/</comment>

<comment type="block">/*

Name			methods, members, getsets
==============================================================================

StructType_Type		__new__(), from_address(), __mul__(), from_param()
UnionType_Type		__new__(), from_address(), __mul__(), from_param()
PointerType_Type	__new__(), from_address(), __mul__(), from_param(), set_type()
ArrayType_Type		__new__(), from_address(), __mul__(), from_param()
SimpleType_Type		__new__(), from_address(), __mul__(), from_param()

CData_Type
  Struct_Type		__new__(), __init__()
  Pointer_Type		__new__(), __init__(), _as_parameter_, contents
  Array_Type		__new__(), __init__(), _as_parameter_, __get/setitem__(), __len__()
  Simple_Type		__new__(), __init__(), _as_parameter_

CField_Type
StgDict_Type

==============================================================================

class methods
-------------

It has some similarity to the byref() construct compared to pointer()
from_address(addr)
	- construct an instance from a given memory block (sharing this memory block)

from_param(obj)
	- typecheck and convert a Python object into a C function call parameter
	  the result may be an instance of the type, or an integer or tuple
	  (typecode, value[, obj])

instance methods/properties
---------------------------

_as_parameter_
	- convert self into a C function call parameter
	  This is either an integer, or a 3-tuple (typecode, value, obj)

functions
---------

sizeof(cdata)
	- return the number of bytes the buffer contains

sizeof(ctype)
	- return the number of bytes the buffer of an instance would contain

byref(cdata)

addressof(cdata)

pointer(cdata)

POINTER(ctype)

bytes(cdata)
	- return the buffer contents as a sequence of bytes (which is currently a string)

*/</comment>

<comment type="block">/*
 * StgDict_Type
 * StructType_Type
 * UnionType_Type
 * PointerType_Type
 * ArrayType_Type
 * SimpleType_Type
 *
 * CData_Type
 * Struct_Type
 * Union_Type
 * Array_Type
 * Simple_Type
 * Pointer_Type
 * CField_Type
 *
 */</comment>
<escape char="0xc"/>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>IS_INTRESOURCE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INTRESOURCE</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((size_t)(x) &gt;&gt; 16) == 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>_WIN32_WCE</name></cpp:ifdef>
<comment type="block">/* Unlike desktop Windows, WinCE has both W and A variants of
   GetProcAddress, but the default W version is not what we want */</comment>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>GetProcAddress</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>GetProcAddress</name></cpp:macro> <cpp:value>GetProcAddressA</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ctypes_dlfcn.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ctypes.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>PyObject</name> *</type><name>PyExc_ArgError</name></decl>;</decl_stmt>

<comment type="block">/* This dict maps ctypes types to POINTER types */</comment>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>_pointer_type_cache</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Simple_Type</name></decl>;</decl_stmt>

<comment type="block">/* a callable object used for unpickling */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_unpickle</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> *</type><name>conversion_mode_encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>conversion_mode_errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/****************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02040000)</expr></cpp:if>
<comment type="block">/* Only in Python 2.4 and up */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PyTuple_Pack</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> **</type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>items</name> = ((<name>PyTupleObject</name> *)<name>result</name>)-&gt;<name>ob_item</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>o</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name> = <name>o</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/****************************************************************/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
}</block></struct></type> <name>DictRemoverObject</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_DictRemover_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>DictRemoverObject</name> *</type><name>self</name> <init>= <expr>(<name>DictRemoverObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_DictRemover_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>DictRemoverObject</name> *</type><name>self</name> <init>= <expr>(<name>DictRemoverObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>key</name></name> &amp;&amp; <name><name>self</name>-&gt;<name>dict</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>-1 == <call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<comment type="block">/* XXX Error context */</comment>
			<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>key</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>DictRemover_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.DictRemover"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>DictRemoverObject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr><name>_DictRemover_dealloc</name></expr>,			<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,			       		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr><name>_DictRemover_call</name></expr>,			<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
<comment type="block">/* XXX should participate in GC? */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,			<comment type="block">/* tp_flags */</comment>
	<expr>"deletes a key from a dictionary"</expr>,	<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>PyDict_SetItemProxy</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DictRemoverObject</name> *</type><name>remover</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proxy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>obj</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>DictRemover_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<expr_stmt><expr><name>remover</name> = (<name>DictRemoverObject</name> *)<name>obj</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>remover</name>-&gt;<name>key</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>remover</name>-&gt;<name>dict</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remover</name>-&gt;<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remover</name>-&gt;<name>dict</name></name> = <name>dict</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>proxy</name> = <call><name>PyWeakref_NewProxy</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>proxy</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>proxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>proxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>PyDict_GetItemProxy</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>dict</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyWeakref_CheckProxy</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>item</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyWeakref_GET_OBJECT</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  Allocate a memory block for a pep3118 format string, copy prefix (if
  non-null) and suffix into it.  Returns NULL on failure, with the error
  indicator set.  If called with a suffix of NULL the error indicator must
  already be set.
 */</comment>
<function><type><name>char</name> *</type>
<name>alloc_format_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>suffix</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>suffix</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>prefix</name></expr>)</condition><then>
		<expr_stmt><expr><name>len</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>prefix</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name><name>result</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
  StructType_Type - a meta type/class.  Creating a new class using this one as
  __metaclass__ will call the contructor StructUnionType_new.  It replaces the
  tp_dict member with a new instance of StgDict, and initializes the C
  accessible fields somehow.
*/</comment>

<function><type><specifier>static</specifier> <name>PyCArgObject</name> *</type>
<name>StructUnionType_paramfunc</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'V'</expr>;</expr_stmt>
	<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for structure/union instances */</comment>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name><name>stgdict</name>-&gt;<name>ffi_type_pointer</name></name></expr>;</expr_stmt>
	<comment type="block">/* For structure parameters (by value), parg-&gt;value doesn't contain the structure
	   data itself, instead parg-&gt;value.p *points* to the structure's data
	   See also _ctypes.c, function _call_function_pointer().
	*/</comment>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>value</name>.<name>p</name></name> = <name><name>self</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>size</name></name> = <name><name>self</name>-&gt;<name>b_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = (<name>PyObject</name> *)<name>self</name></expr>;</expr_stmt>
	<return>return <expr><name>parg</name></expr>;</return>	
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>StructUnionType_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>, <param><decl><type><name>int</name></type> <name>isStruct</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>fields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>

	<comment type="block">/* create the new instance (which is a class,
	   since we are a metatype!) */</comment>
	<expr_stmt><expr><name>result</name> = (<name>PyTypeObject</name> *)<call><name><name>PyType_Type</name>.<name>tp_new</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* keep this for bw compatibility */</comment>
	<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>, <argument><expr>"_abstract_"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return></then></if>

	<expr_stmt><expr><name>dict</name> = (<name>StgDictObject</name> *)<call><name>PyObject_CallObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>StgDict_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* replace the class dict by our updated stgdict, which holds info
	   about storage requirements of the instances */</comment>
	<if>if <condition>(<expr>-1 == <call><name>PyDict_Update</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dict</name></expr></argument>, <argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>tp_dict</name></name> = (<name>PyObject</name> *)<name>dict</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dict</name>-&gt;<name>format</name></name> = <call><name>alloc_format_string</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>"B"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>dict</name>-&gt;<name>format</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name><name>dict</name>-&gt;<name>paramfunc</name></name> = <name>StructUnionType_paramfunc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>fields</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dict</name></expr></argument>, <argument><expr>"_fields_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>fields</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>basedict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name><name>result</name>-&gt;<name>tp_base</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>basedict</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return></then></if>
		<comment type="block">/* copy base dict */</comment>
		<if>if <condition>(<expr>-1 == <call><name>StgDict_clone</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>basedict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name><name>dict</name>-&gt;<name>flags</name></name> &amp;= ~<name>DICTFLAG_FINAL</name></expr>;</expr_stmt> <comment type="block">/* clear the 'final' flag in the subclass dict */</comment>
		<expr_stmt><expr><name><name>basedict</name>-&gt;<name>flags</name></name> |= <name>DICTFLAG_FINAL</name></expr>;</expr_stmt> <comment type="block">/* set the 'final' flag in the baseclass dict */</comment>
		<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>-1 == <call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>, <argument><expr>"_fields_"</expr></argument>, <argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>StructType_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>StructUnionType_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>UnionType_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>StructUnionType_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>from_address_doc</name><index>[]</index></name> <init>=
<expr>"C.from_address(integer) -&gt; C instance\naccess a C instance at the specified address"</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CDataType_from_address</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>void</name> *</type><name>buf</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"integer expected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>buf</name> = (<name>void</name> *)<call><name>PyLong_AsVoidPtr</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>CData_AtAddress</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>from_buffer_doc</name><index>[]</index></name> <init>=
<expr>"C.from_buffer(object, offset=0) -&gt; C instance\ncreate a C instance from a writeable buffer"</expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>KeepRef</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>target</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>keep</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CDataType_from_buffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>void</name> *</type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buffer_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
			      <argument><expr>"O|i:from_buffer"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			      <argument><expr>"O|n:from_buffer"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			      <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>-1 == <call><name>PyObject_AsWriteBuffer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>buffer_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"offset cannit be negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>dict</name>-&gt;<name>size</name></name> &gt; <name>buffer_len</name> - <name>offset</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
			     <argument><expr>"Buffer size too small (%d instead of at least %d bytes)"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			     <argument><expr>"Buffer size too small (%zd instead of at least %zd bytes)"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			     <argument><expr><name>buffer_len</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>size</name></name> + <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>CData_AtAddress</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>buffer</name> + <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>-1 == <call><name>KeepRef</name><argument_list>(<argument><expr>(<name>CDataObject</name> *)<name>result</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>from_buffer_copy_doc</name><index>[]</index></name> <init>=
<expr>"C.from_buffer_copy(object, offset=0) -&gt; C instance\ncreate a C instance from a readable buffer"</expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>GenericCData_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CDataType_from_buffer_copy</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buffer_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
			      <argument><expr>"O|i:from_buffer"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			      <argument><expr>"O|n:from_buffer"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			      <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>-1 == <call><name>PyObject_AsReadBuffer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>buffer_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"offset cannit be negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>dict</name>-&gt;<name>size</name></name> &gt; <name>buffer_len</name> - <name>offset</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
			     <argument><expr>"Buffer size too small (%d instead of at least %d bytes)"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			     <argument><expr>"Buffer size too small (%zd instead of at least %zd bytes)"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			     <argument><expr><name>buffer_len</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>size</name></name> + <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>GenericCData_new</name><argument_list>(<argument><expr>(<name>PyTypeObject</name> *)<name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>((<name>CDataObject</name> *)<name>result</name>)-&gt;<name>b_ptr</name></expr></argument>,
	       <argument><expr>(<name>char</name> *)<name>buffer</name>+<name>offset</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>in_dll_doc</name><index>[]</index></name> <init>=
<expr>"C.in_dll(dll, name) -&gt; C instance\naccess a C instance in a dll"</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CDataType_in_dll</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dll</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> *</type><name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> *</type><name>address</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Os:in_dll"</expr></argument>, <argument><expr>&amp;<name>dll</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>obj</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>dll</name></expr></argument>, <argument><expr>"_handle"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"the _handle attribute of the second argument must be an integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>handle</name> = (<name>void</name> *)<call><name>PyLong_AsVoidPtr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"could not convert the _handle attribute to a pointer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name>address</name> = (<name>void</name> *)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>address</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			     <argument><expr>"symbol '%s' not found"</expr></argument>,
			     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>address</name> = (<name>void</name> *)<call><name>ctypes_dlsym</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>address</name></expr>)</condition><then> <block>{
		<macro><name>PyErr_Format</name><argument_list>(<argument>PyExc_ValueError</argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__CYGWIN__</name></cpp:ifdef>
<comment type="block">/* dlerror() isn't very helpful on cygwin */</comment>
			     <argument>"symbol '%s' not found (%s) "</argument>,
			     <argument>name</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			     <argument>ctypes_dlerror()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><call><name>CData_AtAddress</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>from_param_doc</name><index>[]</index></name> <init>=
<expr>"Convert a Python object into a function call parameter."</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CDataType_from_param</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>as_parameter</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>1 == <call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyCArg_CheckExact</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>p</name> <init>= <expr>(<name>PyCArgObject</name> *)<name>value</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>ob</name> <init>= <expr><name><name>p</name>-&gt;<name>obj</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ob_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we got a PyCArgObject, we must check if the object packed in it
		   is an instance of the type's dict-&gt;proto */</comment>
		<if>if<condition>(<expr><name>dict</name> &amp;&amp; <name>ob</name>
		   &amp;&amp; <call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>value</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>ob_name</name> = (<name>ob</name>) ? <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name> : "???"</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"expected %s instance instead of pointer to %s"</expr></argument>,
			     <argument><expr>((<name>PyTypeObject</name> *)<name>type</name>)-&gt;<name>tp_name</name></expr></argument>, <argument><expr><name>ob_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>as_parameter</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"_as_parameter_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>as_parameter</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>CDataType_from_param</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"expected %s instance instead of %s"</expr></argument>,
		     <argument><expr>((<name>PyTypeObject</name> *)<name>type</name>)-&gt;<name>tp_name</name></expr></argument>,
		     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>CDataType_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"from_param"</expr>, <expr><name>CDataType_from_param</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>from_param_doc</name></expr> }</block></expr>,
	<expr><block>{ <expr>"from_address"</expr>, <expr><name>CDataType_from_address</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>from_address_doc</name></expr> }</block></expr>,
	<expr><block>{ <expr>"from_buffer"</expr>, <expr><name>CDataType_from_buffer</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>from_buffer_doc</name></expr>, }</block></expr>,
	<expr><block>{ <expr>"from_buffer_copy"</expr>, <expr><name>CDataType_from_buffer_copy</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>from_buffer_copy_doc</name></expr>, }</block></expr>,
	<expr><block>{ <expr>"in_dll"</expr>, <expr><name>CDataType_in_dll</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>in_dll_doc</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CDataType_repeat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>length</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
				    <argument><expr>"Array length must be &gt;= 0, not %d"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				    <argument><expr>"Array length must be &gt;= 0, not %zd"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				    <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>CreateArrayType</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>CDataType_as_sequence</name> <init>= <expr><block>{
	<expr>0</expr>,			<comment type="block">/* inquiry sq_length; */</comment>
	<expr>0</expr>,			<comment type="block">/* binaryfunc sq_concat; */</comment>
	<expr><name>CDataType_repeat</name></expr>,	<comment type="block">/* intargfunc sq_repeat; */</comment>
	<expr>0</expr>,			<comment type="block">/* intargfunc sq_item; */</comment>
	<expr>0</expr>,			<comment type="block">/* intintargfunc sq_slice; */</comment>
	<expr>0</expr>,			<comment type="block">/* intobjargproc sq_ass_item; */</comment>
	<expr>0</expr>,			<comment type="block">/* intintobjargproc sq_ass_slice; */</comment>
	<expr>0</expr>,			<comment type="block">/* objobjproc sq_contains; */</comment>
	
	<expr>0</expr>,			<comment type="block">/* binaryfunc sq_inplace_concat; */</comment>
	<expr>0</expr>,			<comment type="block">/* intargfunc sq_inplace_repeat; */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CDataType_clear</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>dict</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name><name>PyType_Type</name>.<name>tp_clear</name></name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CDataType_traverse</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>dict</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name><name>PyType_Type</name>.<name>tp_traverse</name></name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>visit</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>StructType_setattro</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX Should we disallow deleting _fields_? */</comment>
	<if>if <condition>(<expr>-1 == <call><name><name>PyType_Type</name>.<name>tp_setattro</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	
	<if>if <condition>(<expr><name>value</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> &amp;&amp;
	    0 == <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"_fields_"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>StructUnionType_update_stgdict</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>UnionType_setattro</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* XXX Should we disallow deleting _fields_? */</comment>
	<if>if <condition>(<expr>-1 == <call><name>PyObject_GenericSetAttr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> &amp;&amp;
	    0 == <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"_fields_"</expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>StructUnionType_update_stgdict</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>


<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>StructType_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.StructType"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,			       		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>CDataType_as_sequence</name></expr>,			<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr><name>StructType_setattro</name></expr>,			<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"metatype for the CData Objects"</expr>,	<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CDataType_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CDataType_clear</name></expr>,		<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>CDataType_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>StructType_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>UnionType_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.UnionType"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,			       		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>CDataType_as_sequence</name></expr>,		<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr><name>UnionType_setattro</name></expr>,			<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"metatype for the CData Objects"</expr>,	<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CDataType_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CDataType_clear</name></expr>,		<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>CDataType_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>UnionType_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/******************************************************************/</comment>

<comment type="block">/*

The PointerType_Type metaclass must ensure that the subclass of Pointer can be
created. It must check for a _type_ attribute in the class. Since are no
runtime created properties, a CField is probably *not* needed ?

class IntPointer(Pointer):
    _type_ = "i"

The Pointer_Type provides the functionality: a contents method/property, a
size property/method, and the sequence protocol.

*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>PointerType_SetProto</name><parameter_list>(<param><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>proto</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>!<name>proto</name> || !<call><name>PyType_Check</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"_type_ must be a type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"_type_ must have storage info"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>stgdict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>proto</name></name> = <name>proto</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyCArgObject</name> *</type>
<name>PointerType_paramfunc</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'P'</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = (<name>PyObject</name> *)<name>self</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>value</name>.<name>p</name></name> = *(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
	<return>return <expr><name>parg</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PointerType_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>typedict</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typedict</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>typedict</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<comment type="block">/*
  stgdict items size, align, length contain info about pointers itself,
  stgdict-&gt;proto has info about the pointed to type!
*/</comment>
	<expr_stmt><expr><name>stgdict</name> = (<name>StgDictObject</name> *)<call><name>PyObject_CallObject</name><argument_list>(
		<argument><expr>(<name>PyObject</name> *)&amp;<name>StgDict_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>stgdict</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>size</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>align</name></name> = <call><name>getentry</name><argument_list>(<argument><expr>"P"</expr></argument>)</argument_list></call>-&gt;<name><name>pffi_type</name>-&gt;<name>alignment</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>length</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>ffi_type_pointer</name></name> = <name>ffi_type_pointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>paramfunc</name></name> = <name>PointerType_paramfunc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>flags</name></name> |= <name>TYPEFLAG_ISPOINTER</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>proto</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>typedict</name></expr></argument>, <argument><expr>"_type_"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Borrowed ref */</comment>
	<if>if <condition>(<expr><name>proto</name> &amp;&amp; -1 == <call><name>PointerType_SetProto</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>proto</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>itemdict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>itemdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If itemdict-&gt;format is NULL, then this is a pointer to an
		   incomplete type.  We create a generic format string
		   'pointer to bytes' in this case.  XXX Better would be to
		   fix the format string later...
		*/</comment>
		<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>format</name></name> = <call><name>alloc_format_string</name><argument_list>(<argument><expr>"&amp;"</expr></argument>,
			      <argument><expr><name><name>itemdict</name>-&gt;<name>format</name></name> ? <name><name>itemdict</name>-&gt;<name>format</name></name> : "B"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>stgdict</name>-&gt;<name>format</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>

	<comment type="block">/* create the new instance (which is a class,
	   since we are a metatype!) */</comment>
	<expr_stmt><expr><name>result</name> = (<name>PyTypeObject</name> *)<call><name><name>PyType_Type</name>.<name>tp_new</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* replace the class dict by our updated spam dict */</comment>
	<if>if <condition>(<expr>-1 == <call><name>PyDict_Update</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>, <argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>tp_dict</name></name> = (<name>PyObject</name> *)<name>stgdict</name></expr>;</expr_stmt>

	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PointerType_set_type</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>-1 == <call><name>PointerType_SetProto</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>-1 == <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dict</name></expr></argument>, <argument><expr>"_type_"</expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function_decl><type><name>staticforward</name> <name>PyObject</name> *</type><name>_byref</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>PointerType_from_param</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>typedict</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then>
		<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if> <comment type="block">/* NULL pointer */</comment>

	<expr_stmt><expr><name>typedict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>typedict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for pointer types */</comment>

	<comment type="block">/* If we expect POINTER(&lt;type&gt;), but receive a &lt;type&gt; instance, accept
	   it by calling byref(&lt;type&gt;).
	*/</comment>
	<switch>switch <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>typedict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<case>case <expr>1</expr>:
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* _byref steals a refcount */</comment>
		<return>return <expr><call><name>_byref</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
	</case><case>case <expr>-1</expr>:
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><default>default:
 		<break>break;</break>
	</default>}</block></switch>

 	<if>if <condition>(<expr><call><name>PointerObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>ArrayObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
 		<comment type="block">/* Array instances are also pointers when
 		   the item types are the same.
 		*/</comment>
 		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>v</name> <init>= <expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for pointer or array objects */</comment>
 		<if>if <condition>(<expr><call><name>PyObject_IsSubclass</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>proto</name></name></expr></argument>, <argument><expr><name><name>typedict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
  			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  			<return>return <expr><name>value</name></expr>;</return>
  		}</block></then></if>
  	}</block></then></if>
     	<return>return <expr><call><name>CDataType_from_param</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>PointerType_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"from_address"</expr>, <expr><name>CDataType_from_address</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>from_address_doc</name></expr> }</block></expr>,
	<expr><block>{ <expr>"from_buffer"</expr>, <expr><name>CDataType_from_buffer</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>from_buffer_doc</name></expr>, }</block></expr>,
	<expr><block>{ <expr>"from_buffer_copy"</expr>, <expr><name>CDataType_from_buffer_copy</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>from_buffer_copy_doc</name></expr>, }</block></expr>,
	<expr><block>{ <expr>"in_dll"</expr>, <expr><name>CDataType_in_dll</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>in_dll_doc</name></expr>}</block></expr>,
	<expr><block>{ <expr>"from_param"</expr>, <expr>(<name>PyCFunction</name>)<name>PointerType_from_param</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>from_param_doc</name></expr>}</block></expr>,
	<expr><block>{ <expr>"set_type"</expr>, <expr>(<name>PyCFunction</name>)<name>PointerType_set_type</name></expr>, <expr><name>METH_O</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PointerType_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.PointerType"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,			       		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>CDataType_as_sequence</name></expr>,		<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"metatype for the Pointer Objects"</expr>,	<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CDataType_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CDataType_clear</name></expr>,		<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>PointerType_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>PointerType_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  ArrayType_Type
*/</comment>
<comment type="block">/*
  ArrayType_new ensures that the new Array subclass created has a _length_
  attribute, and a _type_ attribute.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CharArray_set_raw</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyBuffer_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>size</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<call><name><name>tp_as_buffer</name>-&gt;<name>bf_getreadbuffer</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>void</name> *)&amp;<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then> <else>else <if>if <condition>(<expr>-1 == <call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>ptr</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr>-1</expr>;</return>
	}</block></then></if></else></if>
	<if>if <condition>(<expr><name>size</name> &gt; <name><name>self</name>-&gt;<name>b_size</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"string too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CharArray_get_raw</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>b_size</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CharArray_get_value</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name> <init>= <expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>self</name>-&gt;<name>b_size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
		<if>if <condition>(<expr>*<name>ptr</name>++ == '\0'</expr>)</condition><then>
			<break>break;</break></then></if></for>
	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CharArray_set_value</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"can't delete attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
						  <argument><expr><name>conversion_mode_encoding</name></expr></argument>,
						  <argument><expr><name>conversion_mode_errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then> <else>else <if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"string expected instead of %s instance"</expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	<expr_stmt><expr><name>size</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> &gt; <name><name>self</name>-&gt;<name>b_size</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"string too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>ptr</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>size</name> &lt; <name><name>self</name>-&gt;<name>b_size</name></name></expr>)</condition><then>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>b_ptr</name><index>[<expr><name>size</name></expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>CharArray_getsets</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"raw"</expr>, <expr>(<name>getter</name>)<name>CharArray_get_raw</name></expr>, <expr>(<name>setter</name>)<name>CharArray_set_raw</name></expr>,
	  <expr>"value"</expr>, <expr><name>NULL</name></expr> }</block></expr>,
	<expr><block>{ <expr>"value"</expr>, <expr>(<name>getter</name>)<name>CharArray_get_value</name></expr>, <expr>(<name>setter</name>)<name>CharArray_set_value</name></expr>,
	  <expr>"string value"</expr>}</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>WCharArray_get_value</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>wchar_t</name> *</type><name>ptr</name> <init>= <expr>(<name>wchar_t</name> *)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>self</name>-&gt;<name>b_size</name></name>/<sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
		<if>if <condition>(<expr>*<name>ptr</name>++ == (<name>wchar_t</name>)0</expr>)</condition><then>
			<break>break;</break></then></if></for>
	<return>return <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr>(<name>wchar_t</name> *)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>WCharArray_set_value</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"can't delete attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
						    <argument><expr><name>conversion_mode_encoding</name></expr></argument>,
						    <argument><expr><name>conversion_mode_errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then> <else>else <if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"unicode string expected instead of %s instance"</expr></argument>,
				<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then> <else>else
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	<if>if <condition>(<expr>(<name>unsigned</name>)<call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> &gt; <name><name>self</name>-&gt;<name>b_size</name></name>/<sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"string too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyUnicode_AsWideChar</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>value</name></expr></argument>,
				      <argument><expr>(<name>wchar_t</name> *)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>,
				      <argument><expr><name><name>self</name>-&gt;<name>b_size</name></name>/<sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> &gt;= 0 &amp;&amp; (<name>size_t</name>)<name>result</name> &lt; <name><name>self</name>-&gt;<name>b_size</name></name>/<sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
		<expr_stmt><expr>((<name>wchar_t</name> *)<name><name>self</name>-&gt;<name>b_ptr</name></name>)<index>[<expr><name>result</name></expr>]</index> = (<name>wchar_t</name>)0</expr>;</expr_stmt></then></if>
  <label><name>done</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name> &gt;= 0 ? 0 : -1</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>WCharArray_getsets</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"value"</expr>, <expr>(<name>getter</name>)<name>WCharArray_get_value</name></expr>, <expr>(<name>setter</name>)<name>WCharArray_set_value</name></expr>,
	  <expr>"string value"</expr>}</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
  The next three functions copied from Python's typeobject.c.

  They are used to attach methods, members, or getsets to a type *after* it
  has been created: Arrays of characters have additional getsets to treat them
  as strings.
 */</comment>
<comment type="block">/*
static int
add_methods(PyTypeObject *type, PyMethodDef *meth)
{
	PyObject *dict = type-&gt;tp_dict;
	for (; meth-&gt;ml_name != NULL; meth++) {
		PyObject *descr;
		descr = PyDescr_NewMethod(type, meth);
		if (descr == NULL)
			return -1;
		if (PyDict_SetItemString(dict,meth-&gt;ml_name, descr) &lt; 0)
			return -1;
		Py_DECREF(descr);
	}
	return 0;
}

static int
add_members(PyTypeObject *type, PyMemberDef *memb)
{
	PyObject *dict = type-&gt;tp_dict;
	for (; memb-&gt;name != NULL; memb++) {
		PyObject *descr;
		descr = PyDescr_NewMember(type, memb);
		if (descr == NULL)
			return -1;
		if (PyDict_SetItemString(dict, memb-&gt;name, descr) &lt; 0)
			return -1;
		Py_DECREF(descr);
	}
	return 0;
}
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_getset</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyGetSetDef</name> *</type><name>gsp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name><name>type</name>-&gt;<name>tp_dict</name></name></expr></init></decl>;</decl_stmt>
	<for>for (<init>;</init> <condition><expr><name><name>gsp</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>gsp</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>descr</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>descr</name> = <call><name>PyDescr_NewGetSet</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>gsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>descr</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>gsp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>descr</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyCArgObject</name> *</type>
<name>ArrayType_paramfunc</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>p</name> <init>= <expr><call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>p</name>-&gt;<name>tag</name></name> = 'P'</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name>-&gt;<name>value</name>.<name>p</name></name> = (<name>char</name> *)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name>-&gt;<name>obj</name></name> = (<name>PyObject</name> *)<name>self</name></expr>;</expr_stmt>
	<return>return <expr><name>p</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ArrayType_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>itemdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>typedict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>length</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>itemsize</name></decl>, <decl><type ref="prev"/><name>itemalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typedict</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>typedict</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>proto</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>typedict</name></expr></argument>, <argument><expr>"_length_"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Borrowed ref */</comment>
	<if>if <condition>(<expr>!<name>proto</name> || !<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				<argument><expr>"class must define a '_length_' attribute, "
				"which must be a positive integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>length</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proto</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>typedict</name></expr></argument>, <argument><expr>"_type_"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Borrowed ref */</comment>
	<if>if <condition>(<expr>!<name>proto</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				<argument><expr>"class must define a '_type_' attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>stgdict</name> = (<name>StgDictObject</name> *)<call><name>PyObject_CallObject</name><argument_list>(
		<argument><expr>(<name>PyObject</name> *)&amp;<name>StgDict_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>stgdict</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>itemdict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>itemdict</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"_type_ must have storage info"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>itemdict</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>format</name><index>[<expr>0</expr>]</index></name> == '('</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"(%ld,"</expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>format</name></name> = <call><name>alloc_format_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>itemdict</name>-&gt;<name>format</name></name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"(%ld)"</expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>format</name></name> = <call><name>alloc_format_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>itemdict</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name><name>stgdict</name>-&gt;<name>format</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>ndim</name></name> = <name><name>itemdict</name>-&gt;<name>ndim</name></name> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>shape</name></name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name> *</expr></argument>)</argument_list></sizeof> * <name><name>stgdict</name>-&gt;<name>ndim</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>stgdict</name>-&gt;<name>shape</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>shape</name><index>[<expr>0</expr>]</index></name> = <name>length</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr>&amp;<name><name>stgdict</name>-&gt;<name>shape</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>itemdict</name>-&gt;<name>shape</name></name></expr></argument>,
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof> * (<name><name>stgdict</name>-&gt;<name>ndim</name></name> - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itemsize</name> = <name><name>itemdict</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>length</name> * <name>itemsize</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"array too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>itemalign</name> = <name><name>itemdict</name>-&gt;<name>align</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>flags</name></name> &amp; (<name>TYPEFLAG_ISPOINTER</name> | <name>TYPEFLAG_HASPOINTER</name>)</expr>)</condition><then>
		<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>flags</name></name> |= <name>TYPEFLAG_HASPOINTER</name></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>size</name></name> = <name>itemsize</name> * <name>length</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>align</name></name> = <name>itemalign</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>length</name></name> = <name>length</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>proto</name></name> = <name>proto</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>paramfunc</name></name> = &amp;<name>ArrayType_paramfunc</name></expr>;</expr_stmt>

	<comment type="block">/* Arrays are passed as pointers to function calls. */</comment>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>ffi_type_pointer</name></name> = <name>ffi_type_pointer</name></expr>;</expr_stmt>

	<comment type="block">/* create the new instance (which is a class,
	   since we are a metatype!) */</comment>
	<expr_stmt><expr><name>result</name> = (<name>PyTypeObject</name> *)<call><name><name>PyType_Type</name>.<name>tp_new</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* replace the class dict by our updated spam dict */</comment>
	<if>if <condition>(<expr>-1 == <call><name>PyDict_Update</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>, <argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>tp_dict</name></name> = (<name>PyObject</name> *)<name>stgdict</name></expr>;</expr_stmt>

	<comment type="block">/* Special case for character arrays.
	   A permanent annoyance: char arrays are also strings!
	*/</comment>
	<if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"c"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>-1 == <call><name>add_getset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>CharArray_getsets</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
	}</block></then> <else>else <if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>-1 == <call><name>add_getset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>WCharArray_getsets</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if></else></if>

	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>ArrayType_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.ArrayType"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,			       		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>CDataType_as_sequence</name></expr>,			<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"metatype for the Array Objects"</expr>,	<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>CDataType_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>ArrayType_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  SimpleType_Type
*/</comment>
<comment type="block">/*

SimpleType_new ensures that the new Simple_Type subclass created has a valid
_type_ attribute.

*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>SIMPLE_TYPE_CHARS</name> <init>= <expr>"cbBhHiIlLdfuzZqQPXOv?g"</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>c_wchar_p_from_param</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>as_parameter</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PYTHON_API_VERSION</name> &lt; 1012)</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> not supported</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fd</name> <init>= <expr><call><name>getentry</name><argument_list>(<argument><expr>"Z"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'Z'</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <call><name><name>fd</name>-&gt;<name>setfunc</name></name><argument_list>(<argument><expr>&amp;<name><name>parg</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>parg</name>-&gt;<name>obj</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>ArrayObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>PointerObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* c_wchar array instance or pointer(c_wchar(...)) */</comment>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dt</name> <init>= <expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for pointer or array objects */</comment>
		<expr_stmt><expr><name>dict</name> = <name>dt</name> &amp;&amp; <name><name>dt</name>-&gt;<name>proto</name></name> ? <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name><name>dt</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dict</name> &amp;&amp; (<name><name>dict</name>-&gt;<name>setfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>setfunc</name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>value</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyCArg_CheckExact</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* byref(c_char(...)) */</comment>
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>a</name> <init>= <expr>(<name>PyCArgObject</name> *)<name>value</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>obj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>dict</name> &amp;&amp; (<name><name>dict</name>-&gt;<name>setfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>setfunc</name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>value</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>as_parameter</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"_as_parameter_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>as_parameter</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>c_wchar_p_from_param</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* XXX better message */</comment>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"wrong type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>c_char_p_from_param</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>as_parameter</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PYTHON_API_VERSION</name> &lt; 1012)</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> not supported</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fd</name> <init>= <expr><call><name>getentry</name><argument_list>(<argument><expr>"z"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'z'</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <call><name><name>fd</name>-&gt;<name>setfunc</name></name><argument_list>(<argument><expr>&amp;<name><name>parg</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>parg</name>-&gt;<name>obj</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>ArrayObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>PointerObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* c_char array instance or pointer(c_char(...)) */</comment>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dt</name> <init>= <expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for pointer or array objects */</comment>
		<expr_stmt><expr><name>dict</name> = <name>dt</name> &amp;&amp; <name><name>dt</name>-&gt;<name>proto</name></name> ? <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name><name>dt</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dict</name> &amp;&amp; (<name><name>dict</name>-&gt;<name>setfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"c"</expr></argument>)</argument_list></call>-&gt;<name>setfunc</name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>value</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyCArg_CheckExact</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* byref(c_char(...)) */</comment>
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>a</name> <init>= <expr>(<name>PyCArgObject</name> *)<name>value</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>obj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>dict</name> &amp;&amp; (<name><name>dict</name>-&gt;<name>setfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"c"</expr></argument>)</argument_list></call>-&gt;<name>setfunc</name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>value</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>as_parameter</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"_as_parameter_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>as_parameter</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>c_char_p_from_param</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* XXX better message */</comment>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"wrong type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>c_void_p_from_param</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>as_parameter</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PYTHON_API_VERSION</name> &lt; 1012)</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> not supported</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* None */</comment>
	<if>if <condition>(<expr><name>value</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* Should probably allow buffer interface as well */</comment>
<comment type="block">/* int, long */</comment>
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fd</name> <init>= <expr><call><name>getentry</name><argument_list>(<argument><expr>"P"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'P'</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <call><name><name>fd</name>-&gt;<name>setfunc</name></name><argument_list>(<argument><expr>&amp;<name><name>parg</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>parg</name>-&gt;<name>obj</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return>
	}</block></then></if>
<comment type="block">/* string */</comment>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fd</name> <init>= <expr><call><name>getentry</name><argument_list>(<argument><expr>"z"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'z'</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <call><name><name>fd</name>-&gt;<name>setfunc</name></name><argument_list>(<argument><expr>&amp;<name><name>parg</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>parg</name>-&gt;<name>obj</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return>
	}</block></then></if>
<comment type="block">/* unicode */</comment>
	<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fd</name> <init>= <expr><call><name>getentry</name><argument_list>(<argument><expr>"Z"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'Z'</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <call><name><name>fd</name>-&gt;<name>setfunc</name></name><argument_list>(<argument><expr>&amp;<name><name>parg</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>parg</name>-&gt;<name>obj</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return>
	}</block></then></if>
<comment type="block">/* c_void_p instance (or subclass) */</comment>
	<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* c_void_p instances */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
<comment type="block">/* ctypes array or pointer instance */</comment>
	<if>if <condition>(<expr><call><name>ArrayObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> || <call><name>PointerObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Any array or pointer is accepted */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
<comment type="block">/* byref(...) */</comment>
	<if>if <condition>(<expr><call><name>PyCArg_CheckExact</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* byref(c_xxx()) */</comment>
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>a</name> <init>= <expr>(<name>PyCArgObject</name> *)<name>value</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>a</name>-&gt;<name>tag</name></name> == 'P'</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>value</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
<comment type="block">/* function pointer */</comment>
	<if>if <condition>(<expr><call><name>CFuncPtrObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CFuncPtrObject</name> *</type><name>func</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>func</name> = (<name>CFuncPtrObject</name> *)<name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'P'</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>value</name>.<name>p</name></name> = *(<name>void</name> **)<name><name>func</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <name>value</name></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return>
	}</block></then></if>
<comment type="block">/* c_char_p, c_wchar_p */</comment>
	<expr_stmt><expr><name>stgd</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>stgd</name> &amp;&amp; <call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>stgd</name>-&gt;<name>proto</name></name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name><name>stgd</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>stgd</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>)</condition> <block>{
		<case>case <expr>'z'</expr>: <comment type="block">/* c_char_p */</comment>
		</case><case>case <expr>'Z'</expr>: <comment type="block">/* c_wchar_p */</comment>
			<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'Z'</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <name>value</name></expr>;</expr_stmt>
			<comment type="block">/* Remember: b_ptr points to where the pointer is stored! */</comment>
			<expr_stmt><expr><name><name>parg</name>-&gt;<name>value</name>.<name>p</name></name> = *<call>(<name>void</name> **)<argument_list>(<argument><expr>((<name>CDataObject</name> *)<name>value</name>)-&gt;<name>b_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return>
		</case>}</block></switch>
	}</block></then></if>

	<expr_stmt><expr><name>as_parameter</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"_as_parameter_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>as_parameter</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>c_void_p_from_param</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* XXX better message */</comment>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"wrong type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PYTHON_API_VERSION</name> &gt;= 1012)</expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name>c_void_p_method</name> <init>= <expr><block>{ <expr>"from_param"</expr>, <expr><name>c_void_p_from_param</name></expr>, <expr><name>METH_O</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name>c_char_p_method</name> <init>= <expr><block>{ <expr>"from_param"</expr>, <expr><name>c_char_p_from_param</name></expr>, <expr><name>METH_O</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name>c_wchar_p_method</name> <init>= <expr><block>{ <expr>"from_param"</expr>, <expr><name>c_wchar_p_from_param</name></expr>, <expr><name>METH_O</name></expr> }</block></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive></cpp:error>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name>c_void_p_method</name> <init>= <expr><block>{ <expr>"from_param"</expr>, <expr><name>c_void_p_from_param</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name>c_char_p_method</name> <init>= <expr><block>{ <expr>"from_param"</expr>, <expr><name>c_char_p_from_param</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name>c_wchar_p_method</name> <init>= <expr><block>{ <expr>"from_param"</expr>, <expr><name>c_wchar_p_from_param</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>CreateSwappedType</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>,
				   <param><decl><type><name>PyObject</name> *</type><name>proto</name></decl></param>, <param><decl><type>struct <name>fielddesc</name> *</type><name>fmt</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>swapped_args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>suffix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>swapped_args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>swapped_args</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>suffix</name> == <name>NULL</name></expr>)</condition><then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
		<expr_stmt><expr><name>suffix</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"_le"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>suffix</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"_be"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyString_Concat</name><argument_list>(<argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>swapped_args</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>swapped_args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<comment type="block">/* create the new instance (which is a class,
	   since we are a metatype!) */</comment>
	<expr_stmt><expr><name>result</name> = (<name>PyTypeObject</name> *)<call><name><name>PyType_Type</name>.<name>tp_new</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>swapped_args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>swapped_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>stgdict</name> = (<name>StgDictObject</name> *)<call><name>PyObject_CallObject</name><argument_list>(
		<argument><expr>(<name>PyObject</name> *)&amp;<name>StgDict_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>stgdict</name></expr>)</condition><then> <comment type="block">/* XXX leaks result! */</comment>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>ffi_type_pointer</name></name> = *<name><name>fmt</name>-&gt;<name>pffi_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>align</name></name> = <name><name>fmt</name>-&gt;<name>pffi_type</name>-&gt;<name>alignment</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>length</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>size</name></name> = <name><name>fmt</name>-&gt;<name>pffi_type</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>setfunc</name></name> = <name><name>fmt</name>-&gt;<name>setfunc_swapped</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>getfunc</name></name> = <name><name>fmt</name>-&gt;<name>getfunc_swapped</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>proto</name></name> = <name>proto</name></expr>;</expr_stmt>

	<comment type="block">/* replace the class dict by our updated spam dict */</comment>
	<if>if <condition>(<expr>-1 == <call><name>PyDict_Update</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>, <argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>tp_dict</name></name> = (<name>PyObject</name> *)<name>stgdict</name></expr>;</expr_stmt>

	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyCArgObject</name> *</type>
<name>SimpleType_paramfunc</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>fmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fd</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>dict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for CDataObject instances */</comment>
	<expr_stmt><expr><name>fmt</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> = <call><name>getentry</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = <name><name>fmt</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = <name><name>fd</name>-&gt;<name>pffi_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = (<name>PyObject</name> *)<name>self</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>parg</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>b_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>parg</name></expr>;</return>	
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SimpleType_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proto_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>proto_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyMethodDef</name> *</type><name>ml</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fmt</name></decl>;</decl_stmt>

	<comment type="block">/* create the new instance (which is a class,
	   since we are a metatype!) */</comment>
	<expr_stmt><expr><name>result</name> = (<name>PyTypeObject</name> *)<call><name><name>PyType_Type</name>.<name>tp_new</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>proto</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>, <argument><expr>"_type_"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* new ref */</comment>
	<if>if <condition>(<expr>!<name>proto</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				<argument><expr>"class must define a '_type_' attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>error</name>:</label>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>proto_str</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proto_len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"class must define a '_type_' string attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></else></if>
	<if>if <condition>(<expr><name>proto_len</name> != 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"class must define a '_type_' attribute "
				"which must be a string of length 1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>strchr</name><argument_list>(<argument><expr><name>SIMPLE_TYPE_CHARS</name></expr></argument>, <argument><expr>*<name>proto_str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
			     <argument><expr>"class must define a '_type_' attribute which must be\n"
			     "a single character string containing one of '%s'."</expr></argument>,
			     <argument><expr><name>SIMPLE_TYPE_CHARS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>fmt</name> = <call><name>getentry</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fmt</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			     <argument><expr>"_type_ '%s' not supported"</expr></argument>,
			     <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>stgdict</name> = (<name>StgDictObject</name> *)<call><name>PyObject_CallObject</name><argument_list>(
		<argument><expr>(<name>PyObject</name> *)&amp;<name>StgDict_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>stgdict</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>ffi_type_pointer</name></name> = *<name><name>fmt</name>-&gt;<name>pffi_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>align</name></name> = <name><name>fmt</name>-&gt;<name>pffi_type</name>-&gt;<name>alignment</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>length</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>size</name></name> = <name><name>fmt</name>-&gt;<name>pffi_type</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>setfunc</name></name> = <name><name>fmt</name>-&gt;<name>setfunc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>getfunc</name></name> = <name><name>fmt</name>-&gt;<name>getfunc</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>format</name></name> = <call><name>alloc_format_string</name><argument_list>(<argument><expr>"&gt;"</expr></argument>, <argument><expr><name>proto_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>format</name></name> = <call><name>alloc_format_string</name><argument_list>(<argument><expr>"&lt;"</expr></argument>, <argument><expr><name>proto_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name><name>stgdict</name>-&gt;<name>format</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>paramfunc</name></name> = <name>SimpleType_paramfunc</name></expr>;</expr_stmt>
<comment type="block">/*
	if (result-&gt;tp_base != &amp;Simple_Type) {
		stgdict-&gt;setfunc = NULL;
		stgdict-&gt;getfunc = NULL;
	}
*/</comment>

	<comment type="block">/* This consumes the refcount on proto which we have */</comment>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>proto</name></name> = <name>proto</name></expr>;</expr_stmt>

	<comment type="block">/* replace the class dict by our updated spam dict */</comment>
	<if>if <condition>(<expr>-1 == <call><name>PyDict_Update</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>, <argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>tp_dict</name></name> = (<name>PyObject</name> *)<name>stgdict</name></expr>;</expr_stmt>

	<comment type="block">/* Install from_param class methods in ctypes base classes.
	   Overrides the SimpleType_from_param generic method.
	 */</comment>
	<if>if <condition>(<expr><name><name>result</name>-&gt;<name>tp_base</name></name> == &amp;<name>Simple_Type</name></expr>)</condition><then> <block>{
		<switch>switch <condition>(<expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>)</condition> <block>{
		<case>case <expr>'z'</expr>: <comment type="block">/* c_char_p */</comment>
			<expr_stmt><expr><name>ml</name> = &amp;<name>c_char_p_method</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>flags</name></name> |= <name>TYPEFLAG_ISPOINTER</name></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>'Z'</expr>: <comment type="block">/* c_wchar_p */</comment>
			<expr_stmt><expr><name>ml</name> = &amp;<name>c_wchar_p_method</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>flags</name></name> |= <name>TYPEFLAG_ISPOINTER</name></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>'P'</expr>: <comment type="block">/* c_void_p */</comment>
			<expr_stmt><expr><name>ml</name> = &amp;<name>c_void_p_method</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>flags</name></name> |= <name>TYPEFLAG_ISPOINTER</name></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>'u'</expr>:
		</case><case>case <expr>'X'</expr>:
		</case><case>case <expr>'O'</expr>:
			<expr_stmt><expr><name>ml</name> = <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>flags</name></name> |= <name>TYPEFLAG_ISPOINTER</name></expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><name>ml</name> = <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		</default>}</block></switch>
			
		<if>if <condition>(<expr><name>ml</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PYTHON_API_VERSION</name> &gt;= 1012)</expr></cpp:if>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>meth</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>meth</name> = <call><name>PyDescr_NewClassMethod</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>meth</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive></cpp:error>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>meth</name></decl>, *<decl><type ref="prev"/><name>func</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>func</name> = <call><name>PyCFunction_New</name><argument_list>(<argument><expr><name>ml</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>func</name></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<expr_stmt><expr><name>meth</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(
				<argument><expr>(<name>PyObject</name> *)&amp;<name>PyClassMethod_Type</name></expr></argument>,
				<argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>meth</name></expr>)</condition><then> <block>{
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>x</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>,
						 <argument><expr><name><name>ml</name>-&gt;<name>ml_name</name></name></expr></argument>,
						 <argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>type</name> == &amp;<name>SimpleType_Type</name> &amp;&amp; <name><name>fmt</name>-&gt;<name>setfunc_swapped</name></name> &amp;&amp; <name><name>fmt</name>-&gt;<name>getfunc_swapped</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>swapped</name> <init>= <expr><call><name>CreateSwappedType</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>,
						      <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>sw_dict</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>swapped</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>sw_dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>swapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
		<expr_stmt><expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>, <argument><expr>"__ctype_le__"</expr></argument>, <argument><expr><name>swapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>, <argument><expr>"__ctype_be__"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>swapped</name></expr></argument>, <argument><expr>"__ctype_be__"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>swapped</name></expr></argument>, <argument><expr>"__ctype_le__"</expr></argument>, <argument><expr><name>swapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We are creating the type for the OTHER endian */</comment>
		<expr_stmt><expr><name><name>sw_dict</name>-&gt;<name>format</name></name> = <call><name>alloc_format_string</name><argument_list>(<argument><expr>"&lt;"</expr></argument>, <argument><expr><name><name>stgdict</name>-&gt;<name>format</name></name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>, <argument><expr>"__ctype_be__"</expr></argument>, <argument><expr><name>swapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>, <argument><expr>"__ctype_le__"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>swapped</name></expr></argument>, <argument><expr>"__ctype_le__"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>swapped</name></expr></argument>, <argument><expr>"__ctype_be__"</expr></argument>, <argument><expr><name>swapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We are creating the type for the OTHER endian */</comment>
		<expr_stmt><expr><name><name>sw_dict</name>-&gt;<name>format</name></name> = <call><name>alloc_format_string</name><argument_list>(<argument><expr>"&gt;"</expr></argument>, <argument><expr><name><name>stgdict</name>-&gt;<name>format</name></name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>swapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then></if><empty_stmt>;</empty_stmt>

	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This is a *class method*.
 * Convert a parameter into something that ConvParam can handle.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>SimpleType_from_param</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>fmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>fielddesc</name> *</type><name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>as_parameter</name></decl>;</decl_stmt>

	<comment type="block">/* If the value is already an instance of the requested type,
	   we can use it as is */</comment>
	<if>if <condition>(<expr>1 == <call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* I think we can rely on this being a one-character string */</comment>
	<expr_stmt><expr><name>fmt</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>fd</name> = <call><name>getentry</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = <name><name>fmt</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = <name><name>fd</name>-&gt;<name>pffi_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <call><name><name>fd</name>-&gt;<name>setfunc</name></name><argument_list>(<argument><expr>&amp;<name><name>parg</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>parg</name>-&gt;<name>obj</name></name></expr>)</condition><then>
		<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>as_parameter</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"_as_parameter_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>as_parameter</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>value</name> = <call><name>SimpleType_from_param</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>as_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"wrong type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>SimpleType_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"from_param"</expr>, <expr><name>SimpleType_from_param</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>from_param_doc</name></expr> }</block></expr>,
	<expr><block>{ <expr>"from_address"</expr>, <expr><name>CDataType_from_address</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>from_address_doc</name></expr> }</block></expr>,
	<expr><block>{ <expr>"from_buffer"</expr>, <expr><name>CDataType_from_buffer</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>from_buffer_doc</name></expr>, }</block></expr>,
	<expr><block>{ <expr>"from_buffer_copy"</expr>, <expr><name>CDataType_from_buffer_copy</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>from_buffer_copy_doc</name></expr>, }</block></expr>,
	<expr><block>{ <expr>"in_dll"</expr>, <expr><name>CDataType_in_dll</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>in_dll_doc</name></expr>}</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>SimpleType_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.SimpleType"</expr>,				<comment type="block">/* tp_name */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,			       		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>CDataType_as_sequence</name></expr>,		<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"metatype for the SimpleType Objects"</expr>,	<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>SimpleType_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>SimpleType_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  CFuncPtrType_Type
 */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>converters_from_argtypes</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>ob</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>converters</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nArgs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ob</name> = <call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* new reference */</comment>
	<if>if <condition>(<expr>!<name>ob</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"_argtypes_ must be a sequence of types"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>nArgs</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>converters</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>nArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>converters</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
		
	<comment type="block">/* I have to check if this is correct. Using c_char, which has a size
	   of 1, will be assumed to be pushed as only one byte!
	   Aren't these promoted to integers by the C compiler and pushed as 4 bytes?
	*/</comment>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nArgs</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tp</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>cnv</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr>"from_param"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>cnv</name></expr>)</condition><then>
			<goto>goto <name>argtypes_error_1</name>;</goto></then></if>
		<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>converters</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>cnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>converters</name></expr>;</return>

  <label><name>argtypes_error_1</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>converters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
		     <argument><expr>"item %d in _argtypes_ has no from_param method"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		     <argument><expr>"item %zd in _argtypes_ has no from_param method"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		     <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>make_funcptrtype_dict</name><parameter_list>(<param><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>converters</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>align</name></name> = <call><name>getentry</name><argument_list>(<argument><expr>"P"</expr></argument>)</argument_list></call>-&gt;<name><name>pffi_type</name>-&gt;<name>alignment</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>length</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>size</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>setfunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>getfunc</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>ffi_type_pointer</name></name> = <name>ffi_type_pointer</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ob</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>, <argument><expr>"_flags_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>ob</name> || !<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		    <argument><expr>"class must define _flags_ which must be an integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>flags</name></name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> | <name>TYPEFLAG_ISPOINTER</name></expr>;</expr_stmt>

	<comment type="block">/* _argtypes_ is optional... */</comment>
	<expr_stmt><expr><name>ob</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>, <argument><expr>"_argtypes_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ob</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>converters</name> = <call><name>converters_from_argtypes</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>converters</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>argtypes</name></name> = <name>ob</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>converters</name></name> = <name>converters</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>ob</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>, <argument><expr>"_restype_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ob</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>ob</name> != <name>Py_None</name> &amp;&amp; !<call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"_restype_ must be a type, a callable, or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>restype</name></name> = <name>ob</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>checker</name></name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr>"_check_retval_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>stgdict</name>-&gt;<name>checker</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
<comment type="block">/* XXX later, maybe.
	ob = PyDict_GetItemString((PyObject *)stgdict, "_errcheck_");
	if (ob) {
		if (!PyCallable_Check(ob)) {
			PyErr_SetString(PyExc_TypeError,
				"_errcheck_ must be callable");
			return -1;
		}
		Py_INCREF(ob);
		stgdict-&gt;errcheck = ob;
	}
*/</comment>
	<return>return <expr>0</expr>;</return>

  <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>converters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>

}</block></function>

<function><type><specifier>static</specifier> <name>PyCArgObject</name> *</type>
<name>CFuncPtrType_paramfunc</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'P'</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = (<name>PyObject</name> *)<name>self</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>value</name>.<name>p</name></name> = *(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
	<return>return <expr><name>parg</name></expr>;</return>	
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CFuncPtrType_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>stgdict</name> = (<name>StgDictObject</name> *)<call><name>PyObject_CallObject</name><argument_list>(
		<argument><expr>(<name>PyObject</name> *)&amp;<name>StgDict_Type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>stgdict</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>paramfunc</name></name> = <name>CFuncPtrType_paramfunc</name></expr>;</expr_stmt>
	<comment type="block">/* We do NOT expose the function signature in the format string.  It
	   is impossible, generally, because the only requirement for the
	   argtypes items is that they have a .from_param method - we do not
	   know the types of the arguments (although, in practice, most
	   argtypes would be a ctypes type).
	*/</comment>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>format</name></name> = <call><name>alloc_format_string</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>"X{}"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stgdict</name>-&gt;<name>flags</name></name> |= <name>TYPEFLAG_ISPOINTER</name></expr>;</expr_stmt>

	<comment type="block">/* create the new instance (which is a class,
	   since we are a metatype!) */</comment>
	<expr_stmt><expr><name>result</name> = (<name>PyTypeObject</name> *)<call><name><name>PyType_Type</name>.<name>tp_new</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* replace the class dict by our updated storage dict */</comment>
	<if>if <condition>(<expr>-1 == <call><name>PyDict_Update</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>, <argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>tp_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name>-&gt;<name>tp_dict</name></name> = (<name>PyObject</name> *)<name>stgdict</name></expr>;</expr_stmt>

	<if>if <condition>(<expr>-1 == <call><name>make_funcptrtype_dict</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>CFuncPtrType_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.CFuncPtrType"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,			       		<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>CDataType_as_sequence</name></expr>,			<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"metatype for C function pointers"</expr>,	<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CDataType_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CDataType_clear</name></expr>,		<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>CDataType_methods</name></expr>,			<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>CFuncPtrType_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/*****************************************************************
 * Code to keep needed objects alive
 */</comment>

<function><type><specifier>static</specifier> <name>CDataObject</name> *</type>
<name>CData_GetContainer</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<while>while <condition>(<expr><name><name>self</name>-&gt;<name>b_base</name></name></expr>)</condition>
		<expr_stmt><expr><name>self</name> = <name><name>self</name>-&gt;<name>b_base</name></name></expr>;</expr_stmt></while>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>b_objects</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>self</name>-&gt;<name>b_length</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>self</name>-&gt;<name>b_objects</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>self</name>-&gt;<name>b_objects</name></name> = <name>Py_None</name></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>GetKeepedObjects</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>target</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>CData_GetContainer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name>b_objects</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unique_key</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>target</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>string</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>cp</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>bytes_left</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></sizeof> - 1 &gt; <sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
	<expr_stmt><expr><name>cp</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>"%x"</expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>cp</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>"%x"</expr></argument>, <argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<while>while <condition>(<expr><name><name>target</name>-&gt;<name>b_base</name></name></expr>)</condition> <block>{
		<expr_stmt><expr><name>bytes_left</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></sizeof> - (<name>cp</name> - <name>string</name>) - 1</expr>;</expr_stmt>
		<comment type="block">/* Hex format needs 2 characters per byte */</comment>
		<if>if <condition>(<expr><name>bytes_left</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof> * 2</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"ctypes object structure too deep"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
		<expr_stmt><expr><name>cp</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>":%x"</expr></argument>, <argument><expr>(<name>int</name>)<name><name>target</name>-&gt;<name>b_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>cp</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>":%x"</expr></argument>, <argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name><name>target</name>-&gt;<name>b_index</name></name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>target</name> = <name><name>target</name>-&gt;<name>b_base</name></name></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>cp</name>-<name>string</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Keep a reference to 'keep' in the 'target', at index 'index'.
 *
 * If 'keep' is None, do nothing.
 *
 * Otherwise create a dictionary (if it does not yet exist) id the root
 * objects 'b_objects' item, which will store the 'keep' object under a unique
 * key.
 *
 * The unique_key helper travels the target's b_base pointer down to the root,
 * building a string containing hex-formatted indexes found during traversal,
 * separated by colons.
 *
 * The index tuple is used as a key into the root object's b_objects dict.
 *
 * Note: This function steals a refcount of the third argument, even if it
 * fails!
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>KeepRef</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>target</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>keep</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>ob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>

<comment type="block">/* Optimization: no need to store None */</comment>
	<if>if <condition>(<expr><name>keep</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>ob</name> = <call><name>CData_GetContainer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>ob</name>-&gt;<name>b_objects</name></name> == <name>NULL</name> || !<call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name><name>ob</name>-&gt;<name>b_objects</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ob</name>-&gt;<name>b_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ob</name>-&gt;<name>b_objects</name></name> = <name>keep</name></expr>;</expr_stmt> <comment type="block">/* refcount consumed */</comment>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>key</name> = <call><name>unique_key</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>ob</name>-&gt;<name>b_objects</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  CData_Type
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CData_traverse</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name><name>self</name>-&gt;<name>b_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CData_clear</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for CDataObject instances */</comment>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name><name>self</name>-&gt;<name>b_needsfree</name></name>)
	    &amp;&amp; ((<name>size_t</name>)<name><name>dict</name>-&gt;<name>size</name></name> &gt; <sizeof>sizeof<argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_value</name></name></expr></argument>)</argument_list></sizeof>)</expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>b_ptr</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CData_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>CData_clear</name><argument_list>(<argument><expr>(<name>CDataObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>CData_members</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"_b_base_"</expr>, <expr><name>T_OBJECT</name></expr>,
	  <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>CDataObject</name></expr></argument>, <argument><expr><name>b_base</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
	  <expr>"the base object"</expr> }</block></expr>,
	<expr><block>{ <expr>"_b_needsfree_"</expr>, <expr><name>T_INT</name></expr>,
	  <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>CDataObject</name></expr></argument>, <argument><expr><name>b_needsfree</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
	  <expr>"whether the object owns the memory or not"</expr> }</block></expr>,
	<expr><block>{ <expr>"_objects"</expr>, <expr><name>T_OBJECT</name></expr>,
	  <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>CDataObject</name></expr></argument>, <argument><expr><name>b_objects</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>,
	  <expr>"internal objects tree (NEVER CHANGE THIS OBJECT!)"</expr>}</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &gt;= 0x02060000)</expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>CData_NewGetBuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_buffer</name> *</type><name>view</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>_self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>view</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name><name>view</name>-&gt;<name>buf</name></name> = <name><name>self</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>obj</name></name> = <name>_self</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>len</name></name> = <name><name>self</name>-&gt;<name>b_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>readonly</name></name> = 0</expr>;</expr_stmt>
	<comment type="block">/* use default format character if not set */</comment>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>format</name></name> = <name><name>dict</name>-&gt;<name>format</name></name> ? <name><name>dict</name>-&gt;<name>format</name></name> : "B"</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>ndim</name></name> = <name><name>dict</name>-&gt;<name>ndim</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>shape</name></name> = <name><name>dict</name>-&gt;<name>shape</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>itemsize</name></name> = <name><name>self</name>-&gt;<name>b_size</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>view</name>-&gt;<name>ndim</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name><name>view</name>-&gt;<name>itemsize</name></name> /= <name><name>dict</name>-&gt;<name>shape</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>strides</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>suboffsets</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view</name>-&gt;<name>internal</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type> <name>CData_GetSegcount</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>lenp</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>lenp</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>lenp</name> = 1</expr>;</expr_stmt></then></if>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type> <name>CData_GetBuffer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>seg</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pptr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>seg</name> != 0</expr>)</condition><then> <block>{
		<comment type="block">/* Hm. Must this set an exception? */</comment>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>*<name>pptr</name> = <name><name>self</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>self</name>-&gt;<name>b_size</name></name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyBufferProcs</name></type> <name>CData_as_buffer</name> <init>= <expr><block>{
	<expr>(<name>readbufferproc</name>)<name>CData_GetBuffer</name></expr>,
	<expr>(<name>writebufferproc</name>)<name>CData_GetBuffer</name></expr>,
	<expr>(<name>segcountproc</name>)<name>CData_GetSegcount</name></expr>,
	<expr>(<name>charbufferproc</name>)<name>NULL</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &gt;= 0x02060000)</expr></cpp:if>
	<expr>(<name>getbufferproc</name>)<name>CData_NewGetBuffer</name></expr>,
	<expr>(<name>releasebufferproc</name>)<name>NULL</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * CData objects are mutable, so they cannot be hashable!
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>CData_nohash</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"unhashable type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CData_reduce</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>_self</name></expr></argument>)</argument_list></call>-&gt;<name>flags</name> &amp; (<name>TYPEFLAG_ISPOINTER</name>|<name>TYPEFLAG_HASPOINTER</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"ctypes objects containing pointers cannot be pickled"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"O(O(NN))"</expr></argument>,
			     <argument><expr><name>_unpickle</name></expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>_self</name></expr></argument>)</argument_list></call></expr></argument>,
			     <argument><expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr></argument>,
			     <argument><expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>b_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CData_setstate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>void</name> *</type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>, *<decl><type ref="prev"/><name>mydict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Os#"</expr></argument>, <argument><expr>&amp;<name>dict</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>len</name> &gt; <name><name>self</name>-&gt;<name>b_size</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>len</name> = <name><name>self</name>-&gt;<name>b_size</name></name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mydict</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>PyDict_Update</name><argument_list>(<argument><expr><name>mydict</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mydict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * default __ctypes_from_outparam__ method returns self.
 */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CData_from_outparam</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>CData_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"__ctypes_from_outparam__"</expr>, <expr><name>CData_from_outparam</name></expr>, <expr><name>METH_NOARGS</name></expr>, }</block></expr>,
	<expr><block>{ <expr>"__reduce__"</expr>, <expr><name>CData_reduce</name></expr>, <expr><name>METH_NOARGS</name></expr>, }</block></expr>,
	<expr><block>{ <expr>"__setstate__"</expr>, <expr><name>CData_setstate</name></expr>, <expr><name>METH_VARARGS</name></expr>, }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>CData_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes._CData"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CDataObject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr><name>CData_dealloc</name></expr>,				<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr><name>CData_nohash</name></expr>,				<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>&amp;<name>CData_as_buffer</name></expr>,			<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_NEWBUFFER</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"XXX to be provided"</expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CData_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CData_clear</name></expr>,			<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>CData_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr><name>CData_members</name></expr>,				<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>CData_MallocBuffer</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr>(<name>size_t</name>)<name><name>dict</name>-&gt;<name>size</name></name> &lt;= <sizeof>sizeof<argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>b_value</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
		<comment type="block">/* No need to call malloc, can use the default buffer */</comment>
		<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_ptr</name></name> = (<name>char</name> *)&amp;<name><name>obj</name>-&gt;<name>b_value</name></name></expr>;</expr_stmt>
		<comment type="block">/* The b_needsfree flag does not mean that we actually did
		   call PyMem_Malloc to allocate the memory block; instead it
		   means we are the *owner* of the memory and are responsible
		   for freeing resources associated with the memory.  This is
		   also the reason that b_needsfree is exposed to Python.
		 */</comment>
		<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_needsfree</name></name> = 1</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<comment type="block">/* In python 2.4, and ctypes 0.9.6, the malloc call took about
		   33% of the creation time for c_int().
		*/</comment>
		<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_ptr</name></name> = (<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>obj</name>-&gt;<name>b_ptr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_needsfree</name></name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_size</name></name> = <name><name>dict</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>CData_FromBaseObj</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>base</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>char</name> *</type><name>adr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>cmem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"abstract class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>dict</name>-&gt;<name>flags</name></name> |= <name>DICTFLAG_FINAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmem</name> = <call>(<name>CDataObject</name> *)<argument_list>(<argument><expr>(<name>PyTypeObject</name> *)<name>type</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_alloc</name><argument_list>(<argument><expr>(<name>PyTypeObject</name> *)<name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cmem</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>cmem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cmem</name>-&gt;<name>b_length</name></name> = <name><name>dict</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cmem</name>-&gt;<name>b_size</name></name> = <name><name>dict</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>base</name></expr>)</condition><then> <block>{ <comment type="block">/* use base's buffer */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmem</name>-&gt;<name>b_ptr</name></name> = <name>adr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmem</name>-&gt;<name>b_needsfree</name></name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmem</name>-&gt;<name>b_base</name></name> = (<name>CDataObject</name> *)<name>base</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmem</name>-&gt;<name>b_index</name></name> = <name>index</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{ <comment type="block">/* copy contents of adr */</comment>
		<if>if <condition>(<expr>-1 == <call><name>CData_MallocBuffer</name><argument_list>(<argument><expr><name>cmem</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<return>return <expr><name>NULL</name></expr>;</return>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cmem</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name>adr</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmem</name>-&gt;<name>b_index</name></name> = <name>index</name></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr>(<name>PyObject</name> *)<name>cmem</name></expr>;</return>
}</block></function>

<comment type="block">/*
 Box a memory block into a CData instance.
*/</comment>
<function><type><name>PyObject</name> *</type>
<name>CData_AtAddress</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>buf</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>pd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"abstract class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>dict</name>-&gt;<name>flags</name></name> |= <name>DICTFLAG_FINAL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pd</name> = <call>(<name>CDataObject</name> *)<argument_list>(<argument><expr>(<name>PyTypeObject</name> *)<name>type</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_alloc</name><argument_list>(<argument><expr>(<name>PyTypeObject</name> *)<name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>pd</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>pd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name>-&gt;<name>b_ptr</name></name> = (<name>char</name> *)<name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name>-&gt;<name>b_length</name></name> = <name><name>dict</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name>-&gt;<name>b_size</name></name> = <name><name>dict</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>pd</name></expr>;</return>
}</block></function>

<comment type="block">/*
  This function returns TRUE for c_int, c_void_p, and these kind of
  classes.  FALSE otherwise FALSE also for subclasses of c_int and
  such.
*/</comment>
<function><type><name>int</name></type> <name>IsSimpleSubType</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>type</name> <init>= <expr>(<name>PyTypeObject</name> *)<name>obj</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>SimpleTypeObject_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name><name>type</name>-&gt;<name>tp_base</name></name> != &amp;<name>Simple_Type</name></expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PyObject</name> *</type>
<name>CData_get</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>GETFUNC</name></type> <name>getfunc</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>src</name></decl></param>,
	  <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>char</name> *</type><name>adr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>getfunc</name></expr>)</condition><then>
		<return>return <expr><call><name>getfunc</name><argument_list>(<argument><expr><name>adr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name> &amp;&amp; <name><name>dict</name>-&gt;<name>getfunc</name></name> &amp;&amp; !<call><name>IsSimpleSubType</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name><name>dict</name>-&gt;<name>getfunc</name></name><argument_list>(<argument><expr><name>adr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>CData_FromBaseObj</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>adr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
  Helper function for CData_set below.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_CData_set</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>SETFUNC</name></type> <name>setfunc</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>,
	   <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>src</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>setfunc</name></expr>)</condition><then>
		<return>return <expr><call><name>setfunc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	
	<if>if <condition>(<expr>!<call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>dict</name> &amp;&amp; <name><name>dict</name>-&gt;<name>setfunc</name></name></expr>)</condition><then>
			<return>return <expr><call><name><name>dict</name>-&gt;<name>setfunc</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<comment type="block">/*
		   If value is a tuple, we try to call the type with the tuple
		   and use the result!
		*/</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>ob</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>ob</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ob</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Extend_Error_Info</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"(%s) "</expr></argument>,
						  <argument><expr>((<name>PyTypeObject</name> *)<name>type</name>)-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>result</name> = <call><name>_CData_set</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>setfunc</name></expr></argument>, <argument><expr><name>ob</name></expr></argument>,
					    <argument><expr><name>size</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		}</block></then> <else>else <if>if <condition>(<expr><name>value</name> == <name>Py_None</name> &amp;&amp; <call><name>PointerTypeObject_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr>*(<name>void</name> **)<name>ptr</name> = <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>Py_None</name></expr>;</return>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"expected %s instance, got %s"</expr></argument>,
				     <argument><expr>((<name>PyTypeObject</name> *)<name>type</name>)-&gt;<name>tp_name</name></expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></else></if></else></if>
	}</block></then></if>
	<expr_stmt><expr><name>src</name> = (<name>CDataObject</name> *)<name>value</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>,
		       <argument><expr><name><name>src</name>-&gt;<name>b_ptr</name></name></expr></argument>,
		       <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>PointerTypeObject_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<comment type="block">/* XXX */</comment><empty_stmt>;</empty_stmt></then></if>

		<expr_stmt><expr><name>value</name> = <call><name>GetKeepedObjects</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PointerTypeObject_Check</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <call><name>ArrayObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>keep</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>p1</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for array instances */</comment>
		<expr_stmt><expr><name>p2</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for pointer types */</comment>

		<if>if <condition>(<expr><name><name>p1</name>-&gt;<name>proto</name></name> != <name><name>p2</name>-&gt;<name>proto</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"incompatible types, %s instance instead of %s instance"</expr></argument>,
				     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
				     <argument><expr>((<name>PyTypeObject</name> *)<name>type</name>)-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr>*(<name>void</name> **)<name>ptr</name> = <name><name>src</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>keep</name> = <call><name>GetKeepedObjects</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		  We are assigning an array object to a field which represents
		  a pointer. This has the same effect as converting an array
		  into a pointer. So, again, we have to keep the whole object
		  pointed to (which is the array in this case) alive, and not
		  only it's object list.  So we create a tuple, containing
		  b_objects list PLUS the array itself, and return that!
		*/</comment>
		<return>return <expr><call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>keep</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"incompatible types, %s instance instead of %s instance"</expr></argument>,
		     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
		     <argument><expr>((<name>PyTypeObject</name> *)<name>type</name>)-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Set a slice in object 'dst', which has the type 'type',
 * to the value 'value'.
 */</comment>
<function><type><name>int</name></type>
<name>CData_set</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>SETFUNC</name></type> <name>setfunc</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>,
	  <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>mem</name> <init>= <expr>(<name>CDataObject</name> *)<name>dst</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"not a ctype instance"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>_CData_set</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>setfunc</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
			    <argument><expr><name>size</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<comment type="block">/* KeepRef steals a refcount from it's last argument */</comment>
	<comment type="block">/* If KeepRef fails, we are stumped.  The dst memory block has already
	   been changed */</comment>
	<return>return <expr><call><name>KeepRef</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/******************************************************************/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>GenericCData_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"abstract class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>dict</name>-&gt;<name>flags</name></name> |= <name>DICTFLAG_FINAL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>obj</name> = (<name>CDataObject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_base</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_index</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_objects</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_length</name></name> = <name><name>dict</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
			
	<if>if <condition>(<expr>-1 == <call><name>CData_MallocBuffer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>obj</name></expr>;</return>
}</block></function>
<comment type="block">/*****************************************************************/</comment>
<comment type="block">/*
  CFuncPtr_Type
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CFuncPtr_set_errcheck</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>ob</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>ob</name> &amp;&amp; !<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"the errcheck attribute must be callable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>errcheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>errcheck</name></name> = <name>ob</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CFuncPtr_get_errcheck</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>errcheck</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>errcheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>self</name>-&gt;<name>errcheck</name></name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CFuncPtr_set_restype</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>ob</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>ob</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>restype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>restype</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>checker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>checker</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>ob</name> != <name>Py_None</name> &amp;&amp; !<call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"restype must be a type, a callable, or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>checker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>restype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>restype</name></name> = <name>ob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>checker</name></name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr>"_check_retval_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>checker</name></name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CFuncPtr_get_restype</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>restype</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>restype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>self</name>-&gt;<name>restype</name></name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>dict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for CFuncPtrObject instances */</comment>
	<if>if <condition>(<expr><name><name>dict</name>-&gt;<name>restype</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>restype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>dict</name>-&gt;<name>restype</name></name></expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CFuncPtr_set_argtypes</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>ob</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>converters</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ob</name> == <name>NULL</name> || <name>ob</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>converters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>converters</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>argtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>argtypes</name></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>converters</name> = <call><name>converters_from_argtypes</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>converters</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>converters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>converters</name></name> = <name>converters</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>argtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>argtypes</name></name> = <name>ob</name></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CFuncPtr_get_argtypes</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>argtypes</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>argtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>self</name>-&gt;<name>argtypes</name></name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>dict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for CFuncPtrObject instances */</comment>
	<if>if <condition>(<expr><name><name>dict</name>-&gt;<name>argtypes</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>argtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>dict</name>-&gt;<name>argtypes</name></name></expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></else></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>CFuncPtr_getsets</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"errcheck"</expr>, <expr>(<name>getter</name>)<name>CFuncPtr_get_errcheck</name></expr>, <expr>(<name>setter</name>)<name>CFuncPtr_set_errcheck</name></expr>,
	  <expr>"a function to check for errors"</expr>, <expr><name>NULL</name></expr> }</block></expr>,
	<expr><block>{ <expr>"restype"</expr>, <expr>(<name>getter</name>)<name>CFuncPtr_get_restype</name></expr>, <expr>(<name>setter</name>)<name>CFuncPtr_set_restype</name></expr>,
	  <expr>"specify the result type"</expr>, <expr><name>NULL</name></expr> }</block></expr>,
	<expr><block>{ <expr>"argtypes"</expr>, <expr>(<name>getter</name>)<name>CFuncPtr_get_argtypes</name></expr>,
	  <expr>(<name>setter</name>)<name>CFuncPtr_set_argtypes</name></expr>,
	  <expr>"specify the argument types"</expr>, <expr><name>NULL</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PPROC</name></type> <name>FindAddress</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>handle</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN64</name></cpp:ifdef>
	<comment type="block">/* win64 has no stdcall calling conv, so it should
	   also not have the name mangling of it.
	*/</comment>
	<return>return <expr>(<name>PPROC</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>PPROC</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mangled_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>address</name> = (<name>PPROC</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>address</name></expr>)</condition><then>
		<return>return <expr><name>address</name></expr>;</return></then></if>
	<if>if <condition>(<expr>((<name>size_t</name>)<name>name</name> &amp; ~0xFFFF) == 0</expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* It should not happen that dict is NULL, but better be safe */</comment>
	<if>if <condition>(<expr><name>dict</name>==<name>NULL</name> || <name><name>dict</name>-&gt;<name>flags</name></name> &amp; <name>FUNCFLAG_CDECL</name></expr>)</condition><then>
		<return>return <expr><name>address</name></expr>;</return></then></if>

	<comment type="block">/* for stdcall, try mangled names:
	   funcname -&gt; _funcname@&lt;n&gt;
	   where n is 0, 4, 8, 12, ..., 128
	 */</comment>
	<expr_stmt><expr><name>mangled_name</name> = <call><name>alloca</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> + 1 + 1 + 1 + 3</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* \0 _ @ %d */</comment>
	<if>if <condition>(<expr>!<name>mangled_name</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 32</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>mangled_name</name></expr></argument>, <argument><expr>"_%s@%d"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>i</name>*4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>address</name> = (<name>PPROC</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>mangled_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>address</name></expr>)</condition><then>
			<return>return <expr><name>address</name></expr>;</return></then></if>
	}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Return 1 if usable, 0 else and exception set. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_check_outarg_type</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PointerTypeObject_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>ArrayTypeObject_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name>
	    <comment type="block">/* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */</comment>
	    &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call>
<comment type="block">/* We only allow c_void_p, c_char_p and c_wchar_p as a simple output parameter type */</comment>
	    &amp;&amp; (<call><name>strchr</name><argument_list>(<argument><expr>"PzZ"</expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<return>return <expr>1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"'out' parameter %d must be a pointer type, not %s"</expr></argument>,
		     <argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> ?
		     ((<name>PyTypeObject</name> *)<name>arg</name>)-&gt;<name>tp_name</name> :
		     <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Returns 1 on success, 0 on error */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_validate_paramflags</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>paramflags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argtypes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL. 'type' is a CFuncPtr type. */</comment>
	<expr_stmt><expr><name>argtypes</name> = <name><name>dict</name>-&gt;<name>argtypes</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>paramflags</name> == <name>NULL</name> || <name><name>dict</name>-&gt;<name>argtypes</name></name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>paramflags</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"paramflags must be a tuple or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>len</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>paramflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> != <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>argtypes</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"paramflags must have the same length as argtypes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>paramflags</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>defval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>typ</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>"i|zO"</expr></argument>, <argument><expr>&amp;<name>flag</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>defval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			       <argument><expr>"paramflags must be a sequence of (int [,string [,value]]) tuples"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>typ</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>flag</name> &amp; (<name>PARAMFLAG_FIN</name> | <name>PARAMFLAG_FOUT</name> | <name>PARAMFLAG_FLCID</name>)</expr>)</condition> <block>{
		<case>case <expr>0</expr>:
		</case><case>case <expr><name>PARAMFLAG_FIN</name></expr>:
		</case><case>case <expr><name>PARAMFLAG_FIN</name> | <name>PARAMFLAG_FLCID</name></expr>:
		</case><case>case <expr><name>PARAMFLAG_FIN</name> | <name>PARAMFLAG_FOUT</name></expr>:
			<break>break;</break>
		</case><case>case <expr><name>PARAMFLAG_FOUT</name></expr>:
			<if>if <condition>(<expr>!<call><name>_check_outarg_type</name><argument_list>(<argument><expr><name>typ</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>
			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				     <argument><expr>"paramflag value %d not supported"</expr></argument>,
				     <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		</default>}</block></switch>
	}</block></for>
	<return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_get_name</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>char</name> **</type><name>pname</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> || <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* We have to use MAKEINTRESOURCEA for Windows CE.
		   Works on Windows as well, of course.
		*/</comment>
		<expr_stmt><expr>*<name>pname</name> = <call><name>MAKEINTRESOURCEA</name><argument_list>(<argument><expr><call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> &amp; 0xFFFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>pname</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>*<name>pname</name> ? 1 : 0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			<argument><expr>"function name must be string or integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CFuncPtr_FromDll</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<function_decl><type><name>int</name></type> (* <name>address</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dll</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> *</type><name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>paramflags</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"(O&amp;O)|O"</expr></argument>, <argument><expr><name>_get_name</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>dll</name></expr></argument>, <argument><expr>&amp;<name>paramflags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>paramflags</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>paramflags</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>obj</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>dll</name></expr></argument>, <argument><expr>"_handle"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"the _handle attribute of the second argument must be an integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>handle</name> = (<name>void</name> *)<call><name>PyLong_AsVoidPtr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"could not convert the _handle attribute to a pointer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name>address</name> = <call><name>FindAddress</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>address</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>IS_INTRESOURCE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				     <argument><expr>"function '%s' not found"</expr></argument>,
				     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>,
				     <argument><expr>"function ordinal %d not found"</expr></argument>,
				     <argument><expr>(<name>WORD</name>)(<name>size_t</name>)<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>address</name> = (<name>PPROC</name>)<call><name>ctypes_dlsym</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>address</name></expr>)</condition><then> <block>{
		<macro><name>PyErr_Format</name><argument_list>(<argument>PyExc_AttributeError</argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__CYGWIN__</name></cpp:ifdef>
<comment type="block">/* dlerror() isn't very helpful on cygwin */</comment>
			     <argument>"function '%s' not found (%s) "</argument>,
			     <argument>name</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			     <argument>ctypes_dlerror()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>!<call><name>_validate_paramflags</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>paramflags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>self</name> = (<name>CFuncPtrObject</name> *)<call><name>GenericCData_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>self</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>paramflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>paramflags</name></name> = <name>paramflags</name></expr>;</expr_stmt>

	<expr_stmt><expr>*(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name> = <name>address</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* for KeepRef */</comment>
	<if>if <condition>(<expr>-1 == <call><name>KeepRef</name><argument_list>(<argument><expr>(<name>CDataObject</name> *)<name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>dll</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>callable</name></name> = (<name>PyObject</name> *)<name>self</name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CFuncPtr_FromVtblIndex</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>paramflags</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GUID</name> *</type><name>iid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>iid_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"is|Oz#"</expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>paramflags</name></expr></argument>, <argument><expr>&amp;<name>iid</name></expr></argument>, <argument><expr>&amp;<name>iid_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>paramflags</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>paramflags</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr>!<call><name>_validate_paramflags</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>paramflags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>self</name> = (<name>CFuncPtrObject</name> *)<call><name>GenericCData_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>index</name></name> = <name>index</name> + 0x1000</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>paramflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>paramflags</name></name> = <name>paramflags</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>iid_len</name> == <sizeof>sizeof<argument_list>(<argument><expr><name>GUID</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>iid</name></name> = <name>iid</name></expr>;</expr_stmt></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
  CFuncPtr_new accepts different argument lists in addition to the standard
  _basespec_ keyword arg:

  one argument form
  "i" - function address
  "O" - must be a callable, creates a C callable function

  two or more argument forms (the third argument is a paramflags tuple)
  "(sO)|..." - (function name, dll object (with an integer handle)), paramflags
  "(iO)|..." - (function ordinal, dll object (with an integer handle)), paramflags
  "is|..." - vtable index, method name, creates callable calling COM vtbl
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CFuncPtr_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>callable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CThunkObject</name> *</type><name>thunk</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<return>return <expr><call><name>GenericCData_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<if>if <condition>(<expr>1 &lt;= <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyTuple_Check</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>CFuncPtr_FromDll</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<if>if <condition>(<expr>2 &lt;= <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyInt_Check</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>CFuncPtr_FromVtblIndex</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>1 == <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>
	    &amp;&amp; (<call><name>PyInt_Check</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
		|| <call><name>PyLong_Check</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>CDataObject</name> *</type><name>ob</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> *</type><name>ptr</name> <init>= <expr><call><name>PyLong_AsVoidPtr</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>ptr</name> == <name>NULL</name> &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>ob</name> = (<name>CDataObject</name> *)<call><name>GenericCData_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ob</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr>*(<name>void</name> **)<name><name>ob</name>-&gt;<name>b_ptr</name></name> = <name>ptr</name></expr>;</expr_stmt>
		<return>return <expr>(<name>PyObject</name> *)<name>ob</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr>&amp;<name>callable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"argument must be callable or integer function address"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* XXX XXX This would allow to pass additional options.  For COM
	   method *implementations*, we would probably want different
	   behaviour than in 'normal' callback functions: return a HRESULT if
	   an exception occurrs in the callback, and print the traceback not
	   only on the console, but also to OutputDebugString() or something
	   like that.
	*/</comment>
<comment type="block">/*
	if (kwds &amp;&amp; PyDict_GetItemString(kwds, "options")) {
		...
	}
*/</comment>

	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* XXXX Fails if we do: 'CFuncPtr(lambda x: x)' */</comment>
	<if>if <condition>(<expr>!<name>dict</name> || !<name><name>dict</name>-&gt;<name>argtypes</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		       <argument><expr>"cannot construct instance of this class:"
			" no argtypes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>thunk</name> = <call><name>AllocFunctionCallback</name><argument_list>(<argument><expr><name>callable</name></expr></argument>,
				      <argument><expr><name><name>dict</name>-&gt;<name>argtypes</name></name></expr></argument>,
				      <argument><expr><name><name>dict</name>-&gt;<name>restype</name></name></expr></argument>,
				      <argument><expr><name><name>dict</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>thunk</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>self</name> = (<name>CFuncPtrObject</name> *)<call><name>GenericCData_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>thunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>callable</name></name> = <name>callable</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>self</name>-&gt;<name>thunk</name></name> = <name>thunk</name></expr>;</expr_stmt>
	<expr_stmt><expr>*(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name> = (<name>void</name> *)<name><name>thunk</name>-&gt;<name>pcl</name></name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>thunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* for KeepRef */</comment>
	<if>if <condition>(<expr>-1 == <call><name>KeepRef</name><argument_list>(<argument><expr>(<name>CDataObject</name> *)<name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>thunk</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>


<comment type="block">/*
  _byref consumes a refcount to its argument
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_byref</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCArgObject</name> *</type><name>parg</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"expected CData instance"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>parg</name> = <call><name>new_CArgObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>parg</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name><name>parg</name>-&gt;<name>tag</name></name> = 'P'</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>pffi_type</name></name> = &amp;<name>ffi_type_pointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>obj</name></name> = <name>obj</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parg</name>-&gt;<name>value</name>.<name>p</name></name> = ((<name>CDataObject</name> *)<name>obj</name>)-&gt;<name>b_ptr</name></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>parg</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_get_arg</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>pindex</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>defval</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>inargs</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>*<name>pindex</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>inargs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>inargs</name></expr></argument>, <argument><expr>*<name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>++*<name>pindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>kwds</name> &amp;&amp; (<name>v</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<expr_stmt><expr>++*<name>pindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>defval</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>defval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>defval</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* we can't currently emit a better error message */</comment>
	<if>if <condition>(<expr><name>name</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"required argument '%s' missing"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"not enough arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 This function implements higher level functionality plus the ability to call
 functions with keyword arguments by looking at parameter flags.  parameter
 flags is a tuple of 1, 2 or 3-tuples.  The first entry in each is an integer
 specifying the direction of the data transfer for this parameter - 'in',
 'out' or 'inout' (zero means the same as 'in').  The second entry is the
 parameter name, and the third is the default value if the parameter is
 missing in the function call.

 This function builds and returns a new tuple 'callargs' which contains the
 parameters to use in the call.  Items on this tuple are copied from the
 'inargs' tuple for 'in' and 'in, out' parameters, and constructed from the
 'argtypes' tuple for 'out' parameters.  It also calculates numretvals which
 is the number of return values for the function, outmask/inoutmask are
 bitmasks containing indexes into the callargs tuple specifying which
 parameters have to be returned.  _build_result builds the return value of the
 function.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_build_callargs</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>argtypes</name></decl></param>,
		<param><decl><type><name>PyObject</name> *</type><name>inargs</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>,
		<param><decl><type><name>int</name> *</type><name>poutmask</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pinoutmask</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name> *</type><name>pnumretvals</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>paramflags</name> <init>= <expr><name><name>self</name>-&gt;<name>paramflags</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>callargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>inargs_index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<comment type="block">/* It's a little bit difficult to determine how many arguments the
	function call requires/accepts.  For simplicity, we count the consumed
	args and compare this to the number of supplied args. */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>actual_args</name></decl>;</decl_stmt>

	<expr_stmt><expr>*<name>poutmask</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr>*<name>pinoutmask</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr>*<name>pnumretvals</name> = 0</expr>;</expr_stmt>

	<comment type="block">/* Trivial cases, where we either return inargs itself, or a slice of it. */</comment>
	<if>if <condition>(<expr><name>argtypes</name> == <name>NULL</name> || <name>paramflags</name> == <name>NULL</name> || <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
		<if>if <condition>(<expr><name><name>self</name>-&gt;<name>index</name></name></expr>)</condition><then>
			<return>return <expr><call><name>PyTuple_GetSlice</name><argument_list>(<argument><expr><name>inargs</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>inargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>inargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>inargs</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>len</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>callargs</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* the argument tuple we build */</comment>
	<if>if <condition>(<expr><name>callargs</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<comment type="block">/* For a COM method, skip the first arg */</comment>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>index</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>inargs_index</name> = 1</expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>paramflags</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>ob</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>defval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* This way seems to be ~2 us faster than the PyArg_ParseTuple
		   calls below. */</comment>
		<comment type="block">/* We HAVE already checked that the tuple can be parsed with "i|zO", so... */</comment>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>tsize</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>flag</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>name</name> = <name>tsize</name> &gt; 1 ? <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>defval</name> = <name>tsize</name> &gt; 2 ? <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>flag</name> &amp; (<name>PARAMFLAG_FIN</name> | <name>PARAMFLAG_FOUT</name> | <name>PARAMFLAG_FLCID</name>)</expr>)</condition> <block>{
		<case>case <expr><name>PARAMFLAG_FIN</name> | <name>PARAMFLAG_FLCID</name></expr>:
			<comment type="block">/* ['in', 'lcid'] parameter.  Always taken from defval,
			 if given, else the integer 0. */</comment>
			<if>if <condition>(<expr><name>defval</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>defval</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>defval</name> == <name>NULL</name></expr>)</condition><then>
					<goto>goto <name>error</name>;</goto></then></if>
			}</block></then> <else>else
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>defval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>defval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>(<name>PARAMFLAG_FIN</name> | <name>PARAMFLAG_FOUT</name>)</expr>:
			<expr_stmt><expr>*<name>pinoutmask</name> |= (1 &lt;&lt; <name>i</name>)</expr>;</expr_stmt> <comment type="block">/* mark as inout arg */</comment>
			<expr_stmt><expr>(*<name>pnumretvals</name>)++</expr>;</expr_stmt>
			<comment type="block">/* fall through to PARAMFLAG_FIN... */</comment>
		</case><case>case <expr>0</expr>:
		</case><case>case <expr><name>PARAMFLAG_FIN</name></expr>:
			<comment type="block">/* 'in' parameter.  Copy it from inargs. */</comment>
			<expr_stmt><expr><name>ob</name> =<call><name>_get_arg</name><argument_list>(<argument><expr>&amp;<name>inargs_index</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>defval</name></expr></argument>, <argument><expr><name>inargs</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ob</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>PARAMFLAG_FOUT</name></expr>:
			<comment type="block">/* XXX Refactor this code into a separate function. */</comment>
			<comment type="block">/* 'out' parameter.
			   argtypes[i] must be a POINTER to a c type.

			   Cannot by supplied in inargs, but a defval will be used
			   if available.  XXX Should we support getting it from kwds?
			*/</comment>
			<if>if <condition>(<expr><name>defval</name></expr>)</condition><then> <block>{
				<comment type="block">/* XXX Using mutable objects as defval will
				   make the function non-threadsafe, unless we
				   copy the object in each invocation */</comment>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>defval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>defval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>poutmask</name> |= (1 &lt;&lt; <name>i</name>)</expr>;</expr_stmt> <comment type="block">/* mark as out arg */</comment>
				<expr_stmt><expr>(*<name>pnumretvals</name>)++</expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><name>ob</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<comment type="block">/* Cannot happen: _validate_paramflags()
				  would not accept such an object */</comment>
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
					     <argument><expr>"NULL stgdict unexpected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
					<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"%s 'out' parameter must be passed as default value"</expr></argument>,
					<argument><expr>((<name>PyTypeObject</name> *)<name>ob</name>)-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>ArrayTypeObject_Check</name><argument_list>(<argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>ob</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>ob</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<comment type="block">/* Create an instance of the pointed-to type */</comment>
				<expr_stmt><expr><name>ob</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<comment type="block">/*			   
			   XXX Is the following correct any longer?
			   We must not pass a byref() to the array then but
			   the array instance itself. Then, we cannot retrive
			   the result from the PyCArgObject.
			*/</comment>
			<if>if <condition>(<expr><name>ob</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>error</name>;</goto></then></if>
			<comment type="block">/* The .from_param call that will ocurr later will pass this
			   as a byref parameter. */</comment>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>poutmask</name> |= (1 &lt;&lt; <name>i</name>)</expr>;</expr_stmt> <comment type="block">/* mark as out arg */</comment>
			<expr_stmt><expr>(*<name>pnumretvals</name>)++</expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				     <argument><expr>"paramflag %d not yet implemented"</expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
			<break>break;</break>
		</default>}</block></switch>
	}</block></for>

	<comment type="block">/* We have counted the arguments we have consumed in 'inargs_index'.  This
	   must be the same as len(inargs) + len(kwds), otherwise we have
	   either too much or not enough arguments. */</comment>

	<expr_stmt><expr><name>actual_args</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>inargs</name></expr></argument>)</argument_list></call> + (<name>kwds</name> ? <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> : 0)</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>actual_args</name> != <name>inargs_index</name></expr>)</condition><then> <block>{
		<comment type="block">/* When we have default values or named parameters, this error
		   message is misleading.  See unittests/test_paramflags.py
		 */</comment>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
			     <argument><expr>"call takes exactly %d arguments (%d given)"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			     <argument><expr>"call takes exactly %d arguments (%zd given)"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			     <argument><expr><name>inargs_index</name></expr></argument>, <argument><expr><name>actual_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	}</block></then></if>

	<comment type="block">/* outmask is a bitmask containing indexes into callargs.  Items at
	   these indexes contain values to return.
	 */</comment>
	<return>return <expr><name>callargs</name></expr>;</return>
  <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* See also:
   http://msdn.microsoft.com/library/en-us/com/html/769127a1-1a14-4ed4-9d38-7cf3e571b661.asp
*/</comment>
<comment type="block">/*
  Build return value of a function.

  Consumes the refcount on result and callargs.
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_build_result</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>result</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>callargs</name></decl></param>,
	      <param><decl><type><name>int</name></type> <name>outmask</name></decl></param>, <param><decl><type><name>int</name></type> <name>inoutmask</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name></type> <name>numretvals</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>callargs</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>result</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name> || <name>numretvals</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tup will not be allocated if numretvals == 1 */</comment>
	<comment type="block">/* allocate tuple to hold the result */</comment>
	<if>if <condition>(<expr><name>numretvals</name> &gt; 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>tup</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>numretvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tup</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt>
	<for>for (<init><expr><name>bit</name> = 1</expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 32</expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr><name>bit</name> &lt;&lt;= 1</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>bit</name> &amp; <name>inoutmask</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>numretvals</name> == 1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>v</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>index</name>++</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>bit</name> &amp; <name>outmask</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>"__ctypes_from_outparam__"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <name>numretvals</name> == 1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>v</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>index</name>++</expr>;</expr_stmt>
		}</block></then></if></else></if>
		<if>if <condition>(<expr><name>index</name> == <name>numretvals</name></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tup</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CFuncPtr_call</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>inargs</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>converters</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>checker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>callargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>errcheck</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>IUnknown</name> *</type><name>piunk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>void</name> *</type><name>pProc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>inoutmask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>outmask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>numretvals</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for CFuncPtrObject instances */</comment>
	<expr_stmt><expr><name>restype</name> = <name><name>self</name>-&gt;<name>restype</name></name> ? <name><name>self</name>-&gt;<name>restype</name></name> : <name><name>dict</name>-&gt;<name>restype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>converters</name> = <name><name>self</name>-&gt;<name>converters</name></name> ? <name><name>self</name>-&gt;<name>converters</name></name> : <name><name>dict</name>-&gt;<name>converters</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>checker</name> = <name><name>self</name>-&gt;<name>checker</name></name> ? <name><name>self</name>-&gt;<name>checker</name></name> : <name><name>dict</name>-&gt;<name>checker</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>argtypes</name> = <name><name>self</name>-&gt;<name>argtypes</name></name> ? <name><name>self</name>-&gt;<name>argtypes</name></name> : <name><name>dict</name>-&gt;<name>argtypes</name></name></expr>;</expr_stmt>
<comment type="block">/* later, we probably want to have an errcheck field in stgdict */</comment>
	<expr_stmt><expr><name>errcheck</name> = <name><name>self</name>-&gt;<name>errcheck</name></name></expr> <comment type="block">/* ? self-&gt;errcheck : dict-&gt;errcheck */</comment>;</expr_stmt>


	<expr_stmt><expr><name>pProc</name> = *(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>index</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* It's a COM method */</comment>
		<decl_stmt><decl><type><name>CDataObject</name> *</type><name>this</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>this</name> = (<name>CDataObject</name> *)<call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>inargs</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* borrowed ref! */</comment>
		<if>if <condition>(<expr>!<name>this</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"native com method call without 'this' parameter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"Expected a COM this pointer as first argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<comment type="block">/* there should be more checks? No, in Python */</comment>
		<comment type="block">/* First arg is an pointer to an interface instance */</comment>
		<if>if <condition>(<expr>!<name><name>this</name>-&gt;<name>b_ptr</name></name> || *(<name>void</name> **)<name><name>this</name>-&gt;<name>b_ptr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"NULL COM pointer access"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>piunk</name> = *(<name>IUnknown</name> **)<name><name>this</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>NULL</name> == <name><name>piunk</name>-&gt;<name>lpVtbl</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"COM method call without VTable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>pProc</name> = ((<name>void</name> **)<name><name>piunk</name>-&gt;<name>lpVtbl</name></name>)<index>[<expr><name><name>self</name>-&gt;<name>index</name></name> - 0x1000</expr>]</index></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>callargs</name> = <call><name>_build_callargs</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
				   <argument><expr><name>inargs</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>,
				   <argument><expr>&amp;<name>outmask</name></expr></argument>, <argument><expr>&amp;<name>inoutmask</name></expr></argument>, <argument><expr>&amp;<name>numretvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>callargs</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>converters</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>required</name> <init>= <expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>converters</name></expr></argument>)</argument_list></call></expr></argument>,
					        <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>actual</name> <init>= <expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr></argument>,
					      <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name><name>dict</name>-&gt;<name>flags</name></name> &amp; <name>FUNCFLAG_CDECL</name>) == <name>FUNCFLAG_CDECL</name></expr>)</condition><then> <block>{
			<comment type="block">/* For cdecl functions, we allow more actual arguments
			   than the length of the argtypes tuple.
			*/</comment>
			<if>if <condition>(<expr><name>required</name> &gt; <name>actual</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			  <argument><expr>"this function takes at least %d argument%s (%d given)"</expr></argument>,
					     <argument><expr><name>required</name></expr></argument>,
					     <argument><expr><name>required</name> == 1 ? "" : "s"</expr></argument>,
					     <argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></then> <else>else <if>if <condition>(<expr><name>required</name> != <name>actual</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"this function takes %d argument%s (%d given)"</expr></argument>,
				     <argument><expr><name>required</name></expr></argument>,
				     <argument><expr><name>required</name> == 1 ? "" : "s"</expr></argument>,
				     <argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if></else></if>
	}</block></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>_CallProc</name><argument_list>(<argument><expr><name>pProc</name></expr></argument>,
			   <argument><expr><name>callargs</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
			   <argument><expr><name>piunk</name></expr></argument>,
			   <argument><expr><name><name>self</name>-&gt;<name>iid</name></name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			   <argument><expr><name><name>dict</name>-&gt;<name>flags</name></name></expr></argument>,
			   <argument><expr><name>converters</name></expr></argument>,
			   <argument><expr><name>restype</name></expr></argument>,
			   <argument><expr><name>checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* The 'errcheck' protocol */</comment>
	<if>if <condition>(<expr><name>result</name> != <name>NULL</name> &amp;&amp; <name>errcheck</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>errcheck</name></expr></argument>,
							   <argument><expr><name>result</name></expr></argument>,
							   <argument><expr><name>self</name></expr></argument>,
							   <argument><expr><name>callargs</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* If the errcheck funtion failed, return NULL.
		   If the errcheck function returned callargs unchanged,
		   continue normal processing.
		   If the errcheck function returned something else,
		   use that as result.
		*/</comment>
		<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <name>v</name> != <name>callargs</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>callargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>v</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><call><name>_build_result</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>callargs</name></expr></argument>,
			     <argument><expr><name>outmask</name></expr></argument>, <argument><expr><name>inoutmask</name></expr></argument>, <argument><expr><name>numretvals</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CFuncPtr_traverse</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>restype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>checker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>errcheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>argtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>converters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>paramflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>thunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>CData_traverse</name><argument_list>(<argument><expr>(<name>CDataObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>visit</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CFuncPtr_clear</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>callable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>restype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>checker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>errcheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>argtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>converters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>paramflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>thunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>CData_clear</name><argument_list>(<argument><expr>(<name>CDataObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CFuncPtr_dealloc</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>CFuncPtr_clear</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>CFuncPtr_repr</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>index</name></name></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;COM method offset %d: %s at %p&gt;"</expr></argument>,
					   <argument><expr><name><name>self</name>-&gt;<name>index</name></name> - 0x1000</expr></argument>,
					   <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
					   <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s object at %p&gt;"</expr></argument>,
				   <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>,
				   <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CFuncPtr_nonzero</name><parameter_list>(<param><decl><type><name>CFuncPtrObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>((*(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name> != <name>NULL</name>)
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
		|| (<name><name>self</name>-&gt;<name>index</name></name> != 0)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>CFuncPtr_as_number</name> <init>= <expr><block>{
	<expr>0</expr>, <comment type="block">/* nb_add */</comment>
	<expr>0</expr>, <comment type="block">/* nb_subtract */</comment>
	<expr>0</expr>, <comment type="block">/* nb_multiply */</comment>
	<expr>0</expr>, <comment type="block">/* nb_divide */</comment>
	<expr>0</expr>, <comment type="block">/* nb_remainder */</comment>
	<expr>0</expr>, <comment type="block">/* nb_divmod */</comment>
	<expr>0</expr>, <comment type="block">/* nb_power */</comment>
	<expr>0</expr>, <comment type="block">/* nb_negative */</comment>
	<expr>0</expr>, <comment type="block">/* nb_positive */</comment>
	<expr>0</expr>, <comment type="block">/* nb_absolute */</comment>
	<expr>(<name>inquiry</name>)<name>CFuncPtr_nonzero</name></expr>, <comment type="block">/* nb_nonzero */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>CFuncPtr_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.CFuncPtr"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CFuncPtrObject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>(<name>destructor</name>)<name>CFuncPtr_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>CFuncPtr_repr</name></expr>,		<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>CFuncPtr_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>(<name>ternaryfunc</name>)<name>CFuncPtr_call</name></expr>,		<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>&amp;<name>CData_as_buffer</name></expr>,			<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_NEWBUFFER</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"Function Pointer"</expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CFuncPtr_traverse</name></expr>,	<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CFuncPtr_clear</name></expr>,		<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr><name>CFuncPtr_getsets</name></expr>,			<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
        <expr><name>CFuncPtr_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>
<escape char="0xc"/>
<comment type="block">/*****************************************************************/</comment>
<comment type="block">/*
  Struct_Type
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>IBUG</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>msg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
			<argument><expr>"inconsistent state in CDataObject (%s)"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Struct_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>fields</name></decl>;</decl_stmt>

<comment type="block">/* Optimization possible: Store the attribute names _fields_[x][0]
 * in C accessible fields somewhere ?
 */</comment>

<comment type="block">/* Check this code again for correctness! */</comment>

	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"args not a tuple?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>fields</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"_fields_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>fields</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fields</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>fields</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>

		<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &gt; <call><name>PySequence_Length</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"too many initializers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>pair</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>val</name></decl>;</decl_stmt>
			<if>if <condition>(<expr>!<name>pair</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>IBUG</name><argument_list>(<argument><expr>"_fields_[i] failed"</expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>

			<expr_stmt><expr><name>name</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>IBUG</name><argument_list>(<argument><expr>"_fields_[i][0] failed"</expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>

			<if>if <condition>(<expr><name>kwds</name> &amp;&amp; <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name> *</type><name>field</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>field</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>field</name> = "???"</expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					     <argument><expr>"duplicate values for field %s"</expr></argument>,
					     <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>

			<expr_stmt><expr><name>val</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>-1 == <call><name>PyObject_SetAttr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>

			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>kwds</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<while>while<condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<if>if <condition>(<expr>-1 == <call><name>PyObject_SetAttr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></while>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Struct_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.Structure"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CDataObject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>&amp;<name>CData_as_buffer</name></expr>,			<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_NEWBUFFER</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"Structure base class"</expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CData_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CData_clear</name></expr>,			<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr><name>Struct_init</name></expr>,				<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>GenericCData_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Union_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.Union"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CDataObject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>&amp;<name>CData_as_buffer</name></expr>,			<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_NEWBUFFER</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"Union base class"</expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CData_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CData_clear</name></expr>,			<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr><name>Struct_init</name></expr>,				<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>GenericCData_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  Array_Type
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>Array_init</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"args not a tuple?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>-1 == <call><name>PySequence_SetItem</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Array_item</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>


	<if>if <condition>(<expr><name>index</name> &lt; 0 || <name>index</name> &gt;= <name><name>self</name>-&gt;<name>b_length</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
				<argument><expr>"invalid index"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for array instances */</comment>
	<comment type="block">/* Would it be clearer if we got the item size from
	   stgdict-&gt;proto's stgdict?
	*/</comment>
	<expr_stmt><expr><name>size</name> = <name><name>stgdict</name>-&gt;<name>size</name></name> / <name><name>stgdict</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> = <name>index</name> * <name>size</name></expr>;</expr_stmt>

	<return>return <expr><call><name>CData_get</name><argument_list>(<argument><expr><name><name>stgdict</name>-&gt;<name>proto</name></name></expr></argument>, <argument><expr><name><name>stgdict</name>-&gt;<name>getfunc</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
			 <argument><expr><name>index</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name> + <name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Array_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ilow</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>, *<decl><type ref="prev"/><name>itemdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>np</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ilow</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>ilow</name> = 0</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>ilow</name> &gt; <name><name>self</name>-&gt;<name>b_length</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>ilow</name> = <name><name>self</name>-&gt;<name>b_length</name></name></expr>;</expr_stmt></then></if></else></if>
	<if>if <condition>(<expr><name>ihigh</name> &lt; <name>ilow</name></expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = <name>ilow</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>ihigh</name> &gt; <name><name>self</name>-&gt;<name>b_length</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = <name><name>self</name>-&gt;<name>b_length</name></name></expr>;</expr_stmt></then></if></else></if>
	<expr_stmt><expr><name>len</name> = <name>ihigh</name> - <name>ilow</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for array object instances */</comment>
	<expr_stmt><expr><name>proto</name> = <name><name>stgdict</name>-&gt;<name>proto</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemdict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>itemdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* proto is the item type of the array, a ctypes
			     type, so this cannot be NULL */</comment>
	<if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"c"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name> <init>= <expr>(<name>char</name> *)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>ptr</name> + <name>ilow</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
	}</block></then> <else>else <if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>wchar_t</name> *</type><name>ptr</name> <init>= <expr>(<name>wchar_t</name> *)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>ptr</name> + <name>ilow</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if></else></if>

	<expr_stmt><expr><name>np</name> = (<name>PyListObject</name> *) <call><name>PyList_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>Array_item</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr><name>i</name>+<name>ilow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>(<name>PyObject</name> *)<name>np</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Array_subscript</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		
		<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>i</name> += <name><name>self</name>-&gt;<name>b_length</name></name></expr>;</expr_stmt></then></if>
		<return>return <expr><call><name>Array_item</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <if>if PySlice_Check<condition>(<expr><name>item</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>, *<decl><type ref="prev"/><name>itemdict</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>np</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelen</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
		
		<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name> *)<name>item</name></expr></argument>,
					 <argument><expr><name><name>self</name>-&gt;<name>b_length</name></name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>,
					 <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		
		<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for array object instances */</comment>
		<expr_stmt><expr><name>proto</name> = <name><name>stgdict</name>-&gt;<name>proto</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemdict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>itemdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* proto is the item type of the array, a
				     ctypes type, so this cannot be NULL */</comment>

		<if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"c"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name> <init>= <expr>(<name>char</name> *)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>dest</name></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>slicelen</name> &lt;= 0</expr>)</condition><then>
				<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return></then></if>
			<if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
				<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>ptr</name> + <name>start</name></expr></argument>,
								  <argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>dest</name> = (<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><name>dest</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>

			<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelen</name></expr>;</condition>
			     <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>ptr</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></for>

			<expr_stmt><expr><name>np</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>np</name></expr>;</return>
		}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>wchar_t</name> *</type><name>ptr</name> <init>= <expr>(<name>wchar_t</name> *)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>wchar_t</name> *</type><name>dest</name></decl>;</decl_stmt>
			
			<if>if <condition>(<expr><name>slicelen</name> &lt;= 0</expr>)</condition><then>
				<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
			<if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
				<return>return <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>ptr</name> + <name>start</name></expr></argument>,
							      <argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>

			<expr_stmt><expr><name>dest</name> = (<name>wchar_t</name> *)<call><name>PyMem_Malloc</name><argument_list>(
						<argument><expr><name>slicelen</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelen</name></expr>;</condition>
			     <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>ptr</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></for>
			
			<expr_stmt><expr><name>np</name> = <call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>np</name></expr>;</return>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>np</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>slicelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelen</name></expr>;</condition>
		     <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>Array_item</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<return>return <expr><name>np</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, 
				<argument><expr>"indices must be integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>

}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Array_ass_item</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"Array does not support item deletion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	
	<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for array object instances */</comment>
	<if>if <condition>(<expr><name>index</name> &lt; 0 || <name>index</name> &gt;= <name><name>stgdict</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>,
				<argument><expr>"invalid index"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>size</name> = <name><name>stgdict</name>-&gt;<name>size</name></name> / <name><name>stgdict</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> = <name>index</name> * <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> = <name><name>self</name>-&gt;<name>b_ptr</name></name> + <name>offset</name></expr>;</expr_stmt>

	<return>return <expr><call><name>CData_set</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name><name>stgdict</name>-&gt;<name>proto</name></name></expr></argument>, <argument><expr><name><name>stgdict</name>-&gt;<name>setfunc</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
			 <argument><expr><name>index</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Array_ass_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ilow</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"Array does not support item deletion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>ilow</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>ilow</name> = 0</expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>ilow</name> &gt; <name><name>self</name>-&gt;<name>b_length</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>ilow</name> = <name><name>self</name>-&gt;<name>b_length</name></name></expr>;</expr_stmt></then></if></else></if>
	<if>if <condition>(<expr><name>ihigh</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = 0</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>ihigh</name> &lt; <name>ilow</name></expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = <name>ilow</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>ihigh</name> &gt; <name><name>self</name>-&gt;<name>b_length</name></name></expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = <name><name>self</name>-&gt;<name>b_length</name></name></expr>;</expr_stmt></then></if></else></if>

	<expr_stmt><expr><name>len</name> = <call><name>PySequence_Length</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> != <name>ihigh</name> - <name>ilow</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"Can only assign sequence of same size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>result</name> = <call><name>Array_ass_item</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr><name>i</name>+<name>ilow</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></for>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Array_ass_subscript</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"Array does not support item deletion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		
		<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>i</name> += <name><name>self</name>-&gt;<name>b_length</name></name></expr>;</expr_stmt></then></if>
		<return>return <expr><call><name>Array_ass_item</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelen</name></decl>, <decl><type ref="prev"/><name>otherlen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>;</decl_stmt>
		
		<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name> *)<name>item</name></expr></argument>,
					 <argument><expr><name><name>self</name>-&gt;<name>b_length</name></name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>,
					 <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>(<name>step</name> &lt; 0 &amp;&amp; <name>start</name> &lt; <name>stop</name>) ||
		    (<name>step</name> &gt; 0 &amp;&amp; <name>start</name> &gt; <name>stop</name>)</expr>)</condition><then>
			<expr_stmt><expr><name>stop</name> = <name>start</name></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>otherlen</name> = <call><name>PySequence_Length</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>otherlen</name> != <name>slicelen</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"Can only assign sequence of same size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>otherlen</name></expr>;</condition> <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><name>result</name> = <call><name>Array_ass_item</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
				<return>return <expr>-1</expr>;</return></then></if>
		}</block></for>
		<return>return <expr>0</expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"indices must be integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>Array_length</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>self</name>-&gt;<name>b_length</name></name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>Array_as_sequence</name> <init>= <expr><block>{
	<expr><name>Array_length</name></expr>,				<comment type="block">/* sq_length; */</comment>
	<expr>0</expr>,					<comment type="block">/* sq_concat; */</comment>
	<expr>0</expr>,					<comment type="block">/* sq_repeat; */</comment>
	<expr><name>Array_item</name></expr>,				<comment type="block">/* sq_item; */</comment>
	<expr><name>Array_slice</name></expr>,				<comment type="block">/* sq_slice; */</comment>
	<expr><name>Array_ass_item</name></expr>,				<comment type="block">/* sq_ass_item; */</comment>
	<expr><name>Array_ass_slice</name></expr>,			<comment type="block">/* sq_ass_slice; */</comment>
	<expr>0</expr>,					<comment type="block">/* sq_contains; */</comment>
	
	<expr>0</expr>,					<comment type="block">/* sq_inplace_concat; */</comment>
	<expr>0</expr>,					<comment type="block">/* sq_inplace_repeat; */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>Array_as_mapping</name> <init>= <expr><block>{
	<expr><name>Array_length</name></expr>,
	<expr><name>Array_subscript</name></expr>,
	<expr><name>Array_ass_subscript</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>Array_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes.Array"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CDataObject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>Array_as_sequence</name></expr>,			<comment type="block">/* tp_as_sequence */</comment>
	<expr>&amp;<name>Array_as_mapping</name></expr>,			<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>&amp;<name>CData_as_buffer</name></expr>,			<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_NEWBUFFER</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"XXX to be provided"</expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CData_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CData_clear</name></expr>,			<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>(<name>initproc</name>)<name>Array_init</name></expr>,			<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
        <expr><name>GenericCData_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyObject</name> *</type>
<name>CreateArrayType</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>itemtype</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>cache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>cache</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>cache</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cache</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>len</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>key</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>itemtype</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>key</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = <call><name>PyDict_GetItemProxy</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>PyType_Check</name><argument_list>(<argument><expr><name>itemtype</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"Expected a type object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN64</name></cpp:ifdef>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"%.200s_Array_%Id"</expr></argument>,
		<argument><expr>((<name>PyTypeObject</name> *)<name>itemtype</name>)-&gt;<name>tp_name</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"%.200s_Array_%ld"</expr></argument>,
		<argument><expr>((<name>PyTypeObject</name> *)<name>itemtype</name>)-&gt;<name>tp_name</name></expr></argument>, <argument><expr>(<name>long</name>)<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>ArrayType_Type</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
				       <argument><expr>"s(O){s:i,s:O}"</expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				       <argument><expr>"s(O){s:n,s:O}"</expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				       <argument><expr><name>name</name></expr></argument>,
				       <argument><expr>&amp;<name>Array_Type</name></expr></argument>,
				       <argument><expr>"_length_"</expr></argument>,
				       <argument><expr><name>length</name></expr></argument>,
				       <argument><expr>"_type_"</expr></argument>,
				       <argument><expr><name>itemtype</name></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr>-1 == <call><name>PyDict_SetItemProxy</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  Simple_Type
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Simple_set_value</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"can't delete attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for CDataObject instances */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>setfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name><name>dict</name>-&gt;<name>setfunc</name></name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>dict</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<comment type="block">/* consumes the refcount the setfunc returns */</comment>
	<return>return <expr><call><name>KeepRef</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Simple_init</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"__init__"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>value</name></expr>)</condition><then>
		<return>return <expr><call><name>Simple_set_value</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Simple_get_value</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>dict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for CDataObject instances */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>getfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name><name>dict</name>-&gt;<name>getfunc</name></name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>b_size</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>Simple_getsets</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"value"</expr>, <expr>(<name>getter</name>)<name>Simple_get_value</name></expr>, <expr>(<name>setter</name>)<name>Simple_set_value</name></expr>,
	  <expr>"current value"</expr>, <expr><name>NULL</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Simple_from_outparm</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>IsSimpleSubType</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>self</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* call stgdict-&gt;getfunc */</comment>
	<return>return <expr><call><name>Simple_get_value</name><argument_list>(<argument><expr>(<name>CDataObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>Simple_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"__ctypes_from_outparam__"</expr>, <expr><name>Simple_from_outparm</name></expr>, <expr><name>METH_NOARGS</name></expr>, }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>Simple_nonzero</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr>"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"</expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>b_size</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>Simple_as_number</name> <init>= <expr><block>{
	<expr>0</expr>, <comment type="block">/* nb_add */</comment>
	<expr>0</expr>, <comment type="block">/* nb_subtract */</comment>
	<expr>0</expr>, <comment type="block">/* nb_multiply */</comment>
	<expr>0</expr>, <comment type="block">/* nb_divide */</comment>
	<expr>0</expr>, <comment type="block">/* nb_remainder */</comment>
	<expr>0</expr>, <comment type="block">/* nb_divmod */</comment>
	<expr>0</expr>, <comment type="block">/* nb_power */</comment>
	<expr>0</expr>, <comment type="block">/* nb_negative */</comment>
	<expr>0</expr>, <comment type="block">/* nb_positive */</comment>
	<expr>0</expr>, <comment type="block">/* nb_absolute */</comment>
	<expr>(<name>inquiry</name>)<name>Simple_nonzero</name></expr>, <comment type="block">/* nb_nonzero */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* "%s(%s)" % (self.__class__.__name__, self.value) */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Simple_repr</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>val</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>format</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_base</name> != &amp;<name>Simple_Type</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s object at %p&gt;"</expr></argument>,
					   <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>format</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>format</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"%s(%r)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>format</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>val</name> = <call><name>Simple_get_value</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>name</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>result</name> = <call><name>PyString_Format</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Simple_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes._SimpleCData"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CDataObject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)&amp;<name>Simple_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>Simple_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>&amp;<name>CData_as_buffer</name></expr>,			<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_NEWBUFFER</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"XXX to be provided"</expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CData_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CData_clear</name></expr>,			<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>Simple_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr><name>Simple_getsets</name></expr>,				<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>(<name>initproc</name>)<name>Simple_init</name></expr>,			<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
        <expr><name>GenericCData_new</name></expr>,			<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>
<escape char="0xc"/>
<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
  Pointer_Type
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Pointer_item</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>, *<decl><type ref="prev"/><name>itemdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>*(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"NULL pointer access"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for pointer object instances */</comment>
	
	<expr_stmt><expr><name>proto</name> = <name><name>stgdict</name>-&gt;<name>proto</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemdict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>itemdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* proto is the item type of the pointer, a ctypes
			     type, so this cannot be NULL */</comment>

	<expr_stmt><expr><name>size</name> = <name><name>itemdict</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> = <name>index</name> * <name><name>itemdict</name>-&gt;<name>size</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>CData_get</name><argument_list>(<argument><expr><name>proto</name></expr></argument>, <argument><expr><name><name>stgdict</name>-&gt;<name>getfunc</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>,
			 <argument><expr><name>index</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>(*(<name>char</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name>) + <name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Pointer_ass_item</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>, *<decl><type ref="prev"/><name>itemdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"Pointer does not support item deletion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>*(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"NULL pointer access"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	
	<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL fr pointer instances */</comment>

	<expr_stmt><expr><name>proto</name> = <name><name>stgdict</name>-&gt;<name>proto</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itemdict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>itemdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL because the itemtype of a pointer
			     is always a ctypes type */</comment>

	<expr_stmt><expr><name>size</name> = <name><name>itemdict</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> = <name>index</name> * <name><name>itemdict</name>-&gt;<name>size</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>CData_set</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name><name>stgdict</name>-&gt;<name>setfunc</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
			 <argument><expr><name>index</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>(*(<name>char</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name>) + <name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Pointer_get_contents</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>*(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"NULL pointer access"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL fr pointer instances */</comment>
	<return>return <expr><call><name>CData_FromBaseObj</name><argument_list>(<argument><expr><name><name>stgdict</name>-&gt;<name>proto</name></name></expr></argument>,
				 <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr>0</expr></argument>,
				 <argument><expr>*(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Pointer_set_contents</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>dst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>keep</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"Pointer does not support item deletion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL fr pointer instances */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>stgdict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> 
	    || 0 == <call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>stgdict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* XXX PyObject_IsInstance could return -1! */</comment>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
			     <argument><expr>"expected %s instead of %s"</expr></argument>,
			     <argument><expr>(<call>(<name>PyTypeObject</name> *)<argument_list>(<argument><expr><name><name>stgdict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call>)-&gt;<name>tp_name</name></expr></argument>,
			     <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>dst</name> = (<name>CDataObject</name> *)<name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr>*(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name> = <name><name>dst</name>-&gt;<name>b_ptr</name></name></expr>;</expr_stmt>

	<comment type="block">/* 
	   A Pointer instance must keep a the value it points to alive.  So, a
	   pointer instance has b_length set to 2 instead of 1, and we set
	   'value' itself as the second item of the b_objects list, additionally.
	*/</comment>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>-1 == <call><name>KeepRef</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<expr_stmt><expr><name>keep</name> = <call><name>GetKeepedObjects</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>KeepRef</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>Pointer_getsets</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"contents"</expr>, <expr>(<name>getter</name>)<name>Pointer_get_contents</name></expr>,
	  <expr>(<name>setter</name>)<name>Pointer_set_contents</name></expr>,
	  <expr>"the object this pointer points to (read-write)"</expr>, <expr><name>NULL</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Pointer_init</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"POINTER"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<return>return <expr><call><name>Pointer_set_contents</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Pointer_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyType_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>dict</name> || !<name><name>dict</name>-&gt;<name>proto</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"Cannot create instance: has no _type_"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>GenericCData_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Pointer_slice</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ilow</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>ihigh</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyListObject</name> *</type><name>np</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>, *<decl><type ref="prev"/><name>itemdict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>ilow</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>ilow</name> = 0</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>ihigh</name> &lt; <name>ilow</name></expr>)</condition><then>
		<expr_stmt><expr><name>ihigh</name> = <name>ilow</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>len</name> = <name>ihigh</name> - <name>ilow</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL fr pointer instances */</comment>
	<expr_stmt><expr><name>proto</name> = <name><name>stgdict</name>-&gt;<name>proto</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemdict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>itemdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"c"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name> <init>= <expr>*(<name>char</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>ptr</name> + <name>ilow</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
	}</block></then> <else>else <if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>wchar_t</name> *</type><name>ptr</name> <init>= <expr>*(<name>wchar_t</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>ptr</name> + <name>ilow</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if></else></if>

	<expr_stmt><expr><name>np</name> = (<name>PyListObject</name> *) <call><name>PyList_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>Pointer_item</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr><name>i</name>+<name>ilow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr>(<name>PyObject</name> *)<name>np</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>Pointer_subscript</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>_self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>self</name> <init>= <expr>(<name>CDataObject</name> *)<name>_self</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<return>return <expr><call><name>Pointer_item</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PySliceObject</name> *</type><name>slice</name> <init>= <expr>(<name>PySliceObject</name> *)<name>item</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>np</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>stgdict</name></decl>, *<decl><type ref="prev"/><name>itemdict</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>;</decl_stmt>

		<comment type="block">/* Since pointers have no length, and we want to apply
		   different semantics to negative indices than normal
		   slicing, we have to dissect the slice object ourselves.*/</comment>
		<if>if <condition>(<expr><name><name>slice</name>-&gt;<name>step</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>step</name> = 1</expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>step</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name><name>slice</name>-&gt;<name>step</name></name></expr></argument>,
						  <argument><expr><name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>step</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
			<if>if <condition>(<expr><name>step</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"slice step cannot be zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
		}</block></else></if>
		<if>if <condition>(<expr><name><name>slice</name>-&gt;<name>start</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>step</name> &lt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"slice start is required "
						"for step &lt; 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>start</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name><name>slice</name>-&gt;<name>start</name></name></expr></argument>,
						   <argument><expr><name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>start</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<return>return <expr><name>NULL</name></expr>;</return></then></if>
		}</block></else></if>
		<if>if <condition>(<expr><name><name>slice</name>-&gt;<name>stop</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
					<argument><expr>"slice stop is required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>stop</name> = <call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name><name>slice</name>-&gt;<name>stop</name></name></expr></argument>,
					  <argument><expr><name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>stop</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>step</name> &gt; 0 &amp;&amp; <name>start</name> &gt; <name>stop</name>) ||
		    (<name>step</name> &lt; 0 &amp;&amp; <name>start</name> &lt; <name>stop</name>)</expr>)</condition><then>
			<expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><name>step</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><name>len</name> = (<name>stop</name> - <name>start</name> - 1) / <name>step</name> + 1</expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>len</name> = (<name>stop</name> - <name>start</name> + 1) / <name>step</name> + 1</expr>;</expr_stmt></else></if></else></if>

		<expr_stmt><expr><name>stgdict</name> = <call><name>PyObject_stgdict</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stgdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot be NULL for pointer instances */</comment>
		<expr_stmt><expr><name>proto</name> = <name><name>stgdict</name>-&gt;<name>proto</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemdict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>itemdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"c"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name> <init>= <expr>*(<name>char</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>dest</name></decl>;</decl_stmt>
			
			<if>if <condition>(<expr><name>len</name> &lt;= 0</expr>)</condition><then>
                        	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return></then></if>
			<if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
				<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>ptr</name> + <name>start</name></expr></argument>,
								  <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>dest</name> = (<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>dest</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
			<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>ptr</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><name>np</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>np</name></expr>;</return>
		}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
		<if>if <condition>(<expr><name><name>itemdict</name>-&gt;<name>getfunc</name></name> == <call><name>getentry</name><argument_list>(<argument><expr>"u"</expr></argument>)</argument_list></call>-&gt;<name>getfunc</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>wchar_t</name> *</type><name>ptr</name> <init>= <expr>*(<name>wchar_t</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>wchar_t</name> *</type><name>dest</name></decl>;</decl_stmt>
			
			<if>if <condition>(<expr><name>len</name> &lt;= 0</expr>)</condition><then>
                        	<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
			<if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
				<return>return <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>ptr</name> + <name>start</name></expr></argument>,
							      <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>dest</name> = (<name>wchar_t</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>dest</name> == <name>NULL</name></expr>)</condition><then>
				<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
			<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>ptr</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><name>np</name> = <call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>np</name></expr>;</return>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>np</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>np</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>

		<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>Pointer_item</name><argument_list>(<argument><expr><name>_self</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<return>return <expr><name>np</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"Pointer indices must be integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>Pointer_as_sequence</name> <init>= <expr><block>{
	<expr>0</expr>,					<comment type="block">/* inquiry sq_length; */</comment>
	<expr>0</expr>,					<comment type="block">/* binaryfunc sq_concat; */</comment>
	<expr>0</expr>,					<comment type="block">/* intargfunc sq_repeat; */</comment>
	<expr><name>Pointer_item</name></expr>,				<comment type="block">/* intargfunc sq_item; */</comment>
	<expr><name>Pointer_slice</name></expr>,				<comment type="block">/* intintargfunc sq_slice; */</comment>
	<expr><name>Pointer_ass_item</name></expr>,			<comment type="block">/* intobjargproc sq_ass_item; */</comment>
	<expr>0</expr>,					<comment type="block">/* intintobjargproc sq_ass_slice; */</comment>
	<expr>0</expr>,					<comment type="block">/* objobjproc sq_contains; */</comment>
	<comment type="block">/* Added in release 2.0 */</comment>
	<expr>0</expr>,					<comment type="block">/* binaryfunc sq_inplace_concat; */</comment>
	<expr>0</expr>,					<comment type="block">/* intargfunc sq_inplace_repeat; */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>Pointer_as_mapping</name> <init>= <expr><block>{
	<expr>0</expr>,
	<expr><name>Pointer_subscript</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Pointer_nonzero</name><parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>(*(<name>void</name> **)<name><name>self</name>-&gt;<name>b_ptr</name></name> != <name>NULL</name>)</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>Pointer_as_number</name> <init>= <expr><block>{
	<expr>0</expr>, <comment type="block">/* nb_add */</comment>
	<expr>0</expr>, <comment type="block">/* nb_subtract */</comment>
	<expr>0</expr>, <comment type="block">/* nb_multiply */</comment>
	<expr>0</expr>, <comment type="block">/* nb_divide */</comment>
	<expr>0</expr>, <comment type="block">/* nb_remainder */</comment>
	<expr>0</expr>, <comment type="block">/* nb_divmod */</comment>
	<expr>0</expr>, <comment type="block">/* nb_power */</comment>
	<expr>0</expr>, <comment type="block">/* nb_negative */</comment>
	<expr>0</expr>, <comment type="block">/* nb_positive */</comment>
	<expr>0</expr>, <comment type="block">/* nb_absolute */</comment>
	<expr>(<name>inquiry</name>)<name>Pointer_nonzero</name></expr>, <comment type="block">/* nb_nonzero */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>Pointer_Type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
	"_ctypes._Pointer"</expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CDataObject</name></expr></argument>)</argument_list></sizeof></expr>,			<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_repr */</comment>
	<expr>&amp;<name>Pointer_as_number</name></expr>,			<comment type="block">/* tp_as_number */</comment>
	<expr>&amp;<name>Pointer_as_sequence</name></expr>,			<comment type="block">/* tp_as_sequence */</comment>
	<expr>&amp;<name>Pointer_as_mapping</name></expr>,			<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>&amp;<name>CData_as_buffer</name></expr>,			<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_NEWBUFFER</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr>"XXX to be provided"</expr>,			<comment type="block">/* tp_doc */</comment>
	<expr>(<name>traverseproc</name>)<name>CData_traverse</name></expr>,		<comment type="block">/* tp_traverse */</comment>
	<expr>(<name>inquiry</name>)<name>CData_clear</name></expr>,			<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_members */</comment>
	<expr><name>Pointer_getsets</name></expr>,			<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr>(<name>initproc</name>)<name>Pointer_init</name></expr>,			<comment type="block">/* tp_init */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_alloc */</comment>
	<expr><name>Pointer_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/******************************************************************/</comment>
<comment type="block">/*
 *  Module initialization.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>module_docs</name> <init>=
<expr>"Create and manipulate C compatible data types in Python."</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>comerror_doc</name><index>[]</index></name> <init>= <expr>"Raised when a COM method call failed."</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>comerror_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>hresult</name></decl>, *<decl><type ref="prev"/><name>text</name></decl>, *<decl><type ref="prev"/><name>details</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OOOO:COMError"</expr></argument>, <argument><expr>&amp;<name>self</name></expr></argument>, <argument><expr>&amp;<name>hresult</name></expr></argument>, <argument><expr>&amp;<name>text</name></expr></argument>, <argument><expr>&amp;<name>details</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>a</name> = <call><name>PySequence_GetSlice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>PySequence_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>a</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>status</name> = <call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"args"</expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"hresult"</expr></argument>, <argument><expr><name>hresult</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"text"</expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>"details"</expr></argument>, <argument><expr><name>details</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
	    <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>comerror_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr>"__init__"</expr>, <expr><name>comerror_init</name></expr>, <expr><name>METH_VARARGS</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>create_comerror</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyMethodDef</name> *</type><name>methods</name> <init>= <expr><name>comerror_methods</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<while>while <condition>(<expr><name><name>methods</name>-&gt;<name>ml_name</name></name></expr>)</condition> <block>{
		<comment type="block">/* get a wrapper for the built-in function */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr><call><name>PyCFunction_New</name><argument_list>(<argument><expr><name>methods</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>meth</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<expr_stmt><expr><name>meth</name> = <call><name>PyMethod_New</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ComError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>meth</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>error</name>;</goto></then></if>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>methods</name>-&gt;<name>ml_name</name></name></expr></argument>, <argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>++<name>methods</name></expr>;</expr_stmt>
	}</block></while>

	<expr_stmt><expr><name>s</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>comerror_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>
	<expr_stmt><expr><name>status</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"__doc__"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>status</name> == -1</expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<expr_stmt><expr><name>ComError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"_ctypes.COMError"</expr></argument>,
				      <argument><expr><name>NULL</name></expr></argument>,
				      <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ComError</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error</name>;</goto></then></if>

	<return>return <expr>0</expr>;</return>
  <label><name>error</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>string_at</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>size</name> == -1</expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cast_check_pointertype</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>StgDictObject</name> *</type><name>dict</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PointerTypeObject_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>CFuncPtrTypeObject_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<expr_stmt><expr><name>dict</name> = <call><name>PyType_stgdict</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>dict</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call>
		    &amp;&amp; (<call><name>strchr</name><argument_list>(<argument><expr>"sPzUZXO"</expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>dict</name>-&gt;<name>proto</name></name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
			<comment type="block">/* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */</comment>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
		     <argument><expr>"cast() argument 2 must be a pointer type, not %s"</expr></argument>,
		     <argument><expr><call><name>PyType_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>
		     ? ((<name>PyTypeObject</name> *)<name>arg</name>)-&gt;<name>tp_name</name>
		     : <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cast</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>src</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>ctype</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>result</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>0 == <call><name>cast_check_pointertype</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>result</name> = (<name>CDataObject</name> *)<call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/*
	  The casted objects '_objects' member:

	  It must certainly contain the source objects one.
	  It must contain the source object itself.
	 */</comment>
	<if>if <condition>(<expr><call><name>CDataObject_Check</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>CDataObject</name> *</type><name>obj</name> <init>= <expr>(<name>CDataObject</name> *)<name>src</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* CData_GetContainer will initialize src.b_objects, we need
		   this so it can be shared */</comment>
		<expr_stmt><expr><call><name>CData_GetContainer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* But we need a dictionary! */</comment>
		<if>if <condition>(<expr><name><name>obj</name>-&gt;<name>b_objects</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>obj</name>-&gt;<name>b_objects</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>obj</name>-&gt;<name>b_objects</name></name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>failed</name>;</goto></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>b_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name>-&gt;<name>b_objects</name></name> = <name><name>obj</name>-&gt;<name>b_objects</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>result</name>-&gt;<name>b_objects</name></name> &amp;&amp; <call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>b_objects</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>index</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>index</name> = <call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr>(<name>void</name> *)<name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>index</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>failed</name>;</goto></then></if>
			<expr_stmt><expr><name>rc</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>b_objects</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>rc</name> == -1</expr>)</condition><then>
				<goto>goto <name>failed</name>;</goto></then></if>
		}</block></then></if>
	}</block></then></if>
	<comment type="block">/* Should we assert that result is a pointer type? */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>b_ptr</name></name></expr></argument>, <argument><expr>&amp;<name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>

  <label><name>failed</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>wstring_at</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>wchar_t</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ssize</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>ssize</name> == -1</expr>)</condition><then>
		<expr_stmt><expr><name>ssize</name> = <call><name>wcslen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><call><name>PyUnicode_FromWideChar</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ssize</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_ctypes</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

<comment type="block">/* Note:
   ob_type is the metatype (the 'type'), defaults to PyType_Type,
   tp_base is the base type, defaults to 'object' aka PyBaseObject_Type.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyEval_InitThreads</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"_ctypes"</expr></argument>, <argument><expr><name>module_methods</name></expr></argument>, <argument><expr><name>module_docs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>m</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>_pointer_type_cache</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>_pointer_type_cache</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_pointer_type_cache"</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>_pointer_type_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>_unpickle</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_unpickle"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>_unpickle</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyCArg_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>CThunk_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* StgDict is derived from PyDict_Type */</comment>
	<expr_stmt><expr><name><name>StgDict_Type</name>.<name>tp_base</name></name> = &amp;<name>PyDict_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>StgDict_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/*************************************************
	 *
	 * Metaclasses
	 */</comment>

	<expr_stmt><expr><name><name>StructType_Type</name>.<name>tp_base</name></name> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>StructType_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name><name>UnionType_Type</name>.<name>tp_base</name></name> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>UnionType_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name><name>PointerType_Type</name>.<name>tp_base</name></name> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PointerType_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name><name>ArrayType_Type</name>.<name>tp_base</name></name> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>ArrayType_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name><name>SimpleType_Type</name>.<name>tp_base</name></name> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>SimpleType_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name><name>CFuncPtrType_Type</name>.<name>tp_base</name></name> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>CFuncPtrType_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/*************************************************
	 *
	 * Classes using a custom metaclass
	 */</comment>

	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>CData_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Struct_Type</name></expr></argument>)</argument_list></call> = &amp;<name>StructType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Struct_Type</name>.<name>tp_base</name></name> = &amp;<name>CData_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>Struct_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"Structure"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>Struct_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Union_Type</name></expr></argument>)</argument_list></call> = &amp;<name>UnionType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Union_Type</name>.<name>tp_base</name></name> = &amp;<name>CData_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>Union_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"Union"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>Union_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Pointer_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PointerType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Pointer_Type</name>.<name>tp_base</name></name> = &amp;<name>CData_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>Pointer_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_Pointer"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>Pointer_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Array_Type</name></expr></argument>)</argument_list></call> = &amp;<name>ArrayType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Array_Type</name>.<name>tp_base</name></name> = &amp;<name>CData_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>Array_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"Array"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>Array_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>Simple_Type</name></expr></argument>)</argument_list></call> = &amp;<name>SimpleType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Simple_Type</name>.<name>tp_base</name></name> = &amp;<name>CData_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>Simple_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_SimpleCData"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>Simple_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>CFuncPtr_Type</name></expr></argument>)</argument_list></call> = &amp;<name>CFuncPtrType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CFuncPtr_Type</name>.<name>tp_base</name></name> = &amp;<name>CData_Type</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>CFuncPtr_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"CFuncPtr"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>CFuncPtr_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*************************************************
	 *
	 * Simple classes
	 */</comment>

	<comment type="block">/* CField_Type is derived from PyBaseObject_Type */</comment>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>CField_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/*************************************************
	 *
	 * Other stuff
	 */</comment>

	<expr_stmt><expr><name><name>DictRemover_Type</name>.<name>tp_new</name></name> = <name>PyType_GenericNew</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>DictRemover_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>create_comerror</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"COMError"</expr></argument>, <argument><expr><name>ComError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"FUNCFLAG_HRESULT"</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>FUNCFLAG_HRESULT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"FUNCFLAG_STDCALL"</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>FUNCFLAG_STDCALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"FUNCFLAG_CDECL"</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>FUNCFLAG_CDECL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"FUNCFLAG_USE_ERRNO"</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>FUNCFLAG_USE_ERRNO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"FUNCFLAG_USE_LASTERROR"</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>FUNCFLAG_USE_LASTERROR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"FUNCFLAG_PYTHONAPI"</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>FUNCFLAG_PYTHONAPI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"__version__"</expr></argument>, <argument><expr>"1.1.0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_memmove_addr"</expr></argument>, <argument><expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>memmove</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_memset_addr"</expr></argument>, <argument><expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>memset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_string_at_addr"</expr></argument>, <argument><expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>string_at</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_cast_addr"</expr></argument>, <argument><expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>cast</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_wstring_at_addr"</expr></argument>, <argument><expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>wstring_at</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If RTLD_LOCAL is not defined (Windows!), set it to zero. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RTLD_LOCAL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTLD_LOCAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If RTLD_GLOBAL is not defined (cygwin), set it to the same value as
   RTLD_LOCAL.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RTLD_GLOBAL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTLD_GLOBAL</name></cpp:macro> <cpp:value>RTLD_LOCAL</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RTLD_LOCAL"</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>RTLD_LOCAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RTLD_GLOBAL"</expr></argument>, <argument><expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>RTLD_GLOBAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>PyExc_ArgError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"ctypes.ArgumentError"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>PyExc_ArgError</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>PyExc_ArgError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"ArgumentError"</expr></argument>, <argument><expr><name>PyExc_ArgError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/*************************************************
	 *
	 * Others...
	 */</comment>
	<expr_stmt><expr><call><name>init_callbacks_in_module</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*****************************************************************
 * replacements for broken Python api functions (in Python 2.3).
 * See #1047269 Buffer overwrite in PyUnicode_AsWideChar
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCHAR_H</name></cpp:ifdef>

<function><type><name>PyObject</name> *</type><name>My_PyUnicode_FromWideChar</name><parameter_list>(<param><decl><type><name>register</name> <specifier>const</specifier> <name>wchar_t</name> *</type><name>w</name></decl></param>,
				    <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>unicode</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Copy the wchar_t data into the new object */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_USABLE_WCHAR_T</name></cpp:ifdef>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* In Python, the following line has a one-off error */</comment>
	<for>for (<init><expr><name>i</name> = <name>size</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
	    <expr_stmt><expr>*<name>u</name>++ = *<name>w</name>++</expr>;</expr_stmt></for>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></function>

<function><type><name>Py_ssize_t</name></type> <name>My_PyUnicode_AsWideChar</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl></param>,
			    <param><decl><type><name>register</name> <name>wchar_t</name> *</type><name>w</name></decl></param>,
			    <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>size</name> &gt; <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>size</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_USABLE_WCHAR_T</name></cpp:ifdef>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{
	<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* In Python, the following line has a one-off error */</comment>
	<for>for (<init><expr><name>i</name> = <name>size</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
	    <expr_stmt><expr>*<name>w</name>++ = *<name>u</name>++</expr>;</expr_stmt></for>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>size</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 Local Variables:
 compile-command: "cd .. &amp;&amp; python setup.py -q build -g &amp;&amp; python setup.py -q build install --home ~"
 End:
*/</comment>
</unit>
