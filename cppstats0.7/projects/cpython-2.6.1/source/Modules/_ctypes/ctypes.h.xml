<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_ctypes/ctypes.h"><comment type="block">/*****************************************************************
  This file should be kept compatible with Python 2.3, see PEP 291.
 *****************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__SVR4</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name> <argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02040000)</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDict_CheckExact</name><parameter_list>(<param><type><name>ob</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(ob) == &amp;PyDict_Type)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
<typedef>typedef <type><name>int</name></type> <name>Py_ssize_t</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyInt_FromSsize_t</name></cpp:macro> <cpp:value>PyInt_FromLong</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyNumber_AsSsize_t</name><parameter_list>(<param><type><name>ob</name></type></param>, <param><type><name>exc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyInt_AsLong(ob)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyIndex_Check</name><parameter_list>(<param><type><name>ob</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyInt_Check(ob)</cpp:value></cpp:define>
<typedef>typedef <function_decl><type><name>Py_ssize_t</name></type> (*<name>readbufferproc</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>, <param><decl><type><name>void</name> **</type></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>Py_ssize_t</name></type> (*<name>writebufferproc</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>, <param><decl><type><name>void</name> **</type></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>Py_ssize_t</name></type> (*<name>segcountproc</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>Py_ssize_t</name></type> (*<name>charbufferproc</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>, <param><decl><type><name>char</name> **</type></decl></param>)</parameter_list>;</function_decl></typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02060000)</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_TYPE</name><parameter_list>(<param><type><name>ob</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((PyObject*)(ob))-&gt;ob_type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyVarObject_HEAD_INIT</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>size</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>PyObject_HEAD_INIT(type) size,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyImport_ImportModuleNoBlock</name></cpp:macro> <cpp:value>PyImport_ImportModule</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyLong_FromSsize_t</name></cpp:macro> <cpp:value>PyInt_FromLong</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_TPFLAGS_HAVE_NEWBUFFER</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>max</name><parameter_list>(<param><type><name>a</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((a) &gt; (b) ? (a) : (b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>min</name><parameter_list>(<param><type><name>a</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((a) &lt; (b) ? (a) : (b))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAMFLAG_FIN</name></cpp:macro> <cpp:value>0x1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAMFLAG_FOUT</name></cpp:macro> <cpp:value>0x2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAMFLAG_FLCID</name></cpp:macro> <cpp:value>0x4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
  Backwards compatibility:
  Python2.2 used LONG_LONG instead of PY_LONG_LONG
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PY_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LONG_LONG</name></cpp:macro> <cpp:value>LONG_LONG</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type>struct <name>tagPyCArgObject</name></type> <name>PyCArgObject</name>;</typedef>
<typedef>typedef <type>struct <name>tagCDataObject</name></type> <name>CDataObject</name>;</typedef>
<typedef>typedef <function_decl><type><name>PyObject</name> *</type>(* <name>GETFUNC</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>PyObject</name> *</type>(* <name>SETFUNC</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>PyCArgObject</name> *</type>(* <name>PARAMFUNC</name>)<parameter_list>(<param><decl><type><name>CDataObject</name> *</type><name>obj</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* A default buffer in CDataObject, which can be used for small C types.  If
this buffer is too small, PyMem_Malloc will be called to create a larger one,
and this one is not used.

Making CDataObject a variable size object would be a better solution, but more
difficult in the presence of CFuncPtrObject.  Maybe later.
*/</comment>
<union>union <name>value</name> <block>{
		<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>short</name></type> <name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float</name></type> <name>f</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
		<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>ll</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>D</name></decl>;</decl_stmt>
}</block>;</union>

<comment type="block">/*
  Hm. Are there CDataObject's which do not need the b_objects member?  In
  this case we probably should introduce b_flags to mark it as present...  If
  b_objects is not present/unused b_length is unneeded as well.
*/</comment>

<struct>struct <name>tagCDataObject</name> <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>char</name> *</type><name>b_ptr</name></decl>;</decl_stmt>		<comment type="block">/* pointer to memory block */</comment>
	<decl_stmt><decl><type><name>int</name></type>  <name>b_needsfree</name></decl>;</decl_stmt>	<comment type="block">/* need _we_ free the memory? */</comment>
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>b_base</name></decl>;</decl_stmt>	<comment type="block">/* pointer to base object or NULL */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>b_size</name></decl>;</decl_stmt>	<comment type="block">/* size of memory block in bytes */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>b_length</name></decl>;</decl_stmt>	<comment type="block">/* number of references we need */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>b_index</name></decl>;</decl_stmt>	<comment type="block">/* index of this object into base's
				   b_object list */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>b_objects</name></decl>;</decl_stmt>	<comment type="block">/* dictionary of references we need to keep, or Py_None */</comment>
	<decl_stmt><decl><type>union <name>value</name></type> <name>b_value</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_VAR_HEAD</name>
	<name>ffi_closure</name> *</type><name>pcl</name></decl>;</decl_stmt> <comment type="block">/* the C callable */</comment>
	<decl_stmt><decl><type><name>ffi_cif</name></type> <name>cif</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>converters</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>callable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SETFUNC</name></type> <name>setfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ffi_type</name> *</type><name>ffi_restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ffi_type</name> *</type><name><name>atypes</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>CThunkObject</name>;</typedef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>CThunk_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CThunk_CheckExact</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	    <cpp:value>((v)-&gt;ob_type == &amp;CThunk_Type)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
	<comment type="block">/* First part identical to tagCDataObject */</comment>
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>char</name> *</type><name>b_ptr</name></decl>;</decl_stmt>		<comment type="block">/* pointer to memory block */</comment>
	<decl_stmt><decl><type><name>int</name></type>  <name>b_needsfree</name></decl>;</decl_stmt>	<comment type="block">/* need _we_ free the memory? */</comment>
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>b_base</name></decl>;</decl_stmt>	<comment type="block">/* pointer to base object or NULL */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>b_size</name></decl>;</decl_stmt>	<comment type="block">/* size of memory block in bytes */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>b_length</name></decl>;</decl_stmt>	<comment type="block">/* number of references we need */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>b_index</name></decl>;</decl_stmt>	<comment type="block">/* index of this object into base's
				   b_object list */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>b_objects</name></decl>;</decl_stmt>	<comment type="block">/* list of references we need to keep */</comment>
	<decl_stmt><decl><type>union <name>value</name></type> <name>b_value</name></decl>;</decl_stmt>
	<comment type="block">/* end of tagCDataObject, additional fields follow */</comment>

	<decl_stmt><decl><type><name>CThunkObject</name> *</type><name>thunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>callable</name></decl>;</decl_stmt>

	<comment type="block">/* These two fields will override the ones in the type's stgdict if
	   they are set */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>converters</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>checker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>errcheck</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GUID</name> *</type><name>iid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>paramflags</name></decl>;</decl_stmt>
}</block></struct></type> <name>CFuncPtrObject</name>;</typedef>

<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>StgDict_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StgDict_CheckExact</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	    <cpp:value>((v)-&gt;ob_type == &amp;StgDict_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StgDict_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	    <cpp:value>PyObject_TypeCheck(v, &amp;StgDict_Type)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>StructUnionType_update_stgdict</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>fields</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>int</name></type> <name>isStruct</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>PyType_stginfo</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>psize</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>palign</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>plength</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>PyObject_stginfo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>psize</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>palign</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>plength</name></decl></param>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>CData_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CDataObject_CheckExact</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((v)-&gt;ob_type == &amp;CData_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CDataObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>PyObject_TypeCheck(v, &amp;CData_Type)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>SimpleType_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SimpleTypeObject_CheckExact</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((v)-&gt;ob_type == &amp;SimpleType_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SimpleTypeObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>PyObject_TypeCheck(v, &amp;SimpleType_Type)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>CField_Type</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> struct <name>fielddesc</name> *</type><name>getentry</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>fmt</name></decl></param>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type>
<name>CField_FromDesc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>desc</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>,
		<param><decl><type><name>Py_ssize_t</name> *</type><name>pfield_size</name></decl></param>, <param><decl><type><name>int</name></type> <name>bitsize</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pbitofs</name></decl></param>,
		<param><decl><type><name>Py_ssize_t</name> *</type><name>psize</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>poffset</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>palign</name></decl></param>,
		<param><decl><type><name>int</name></type> <name>pack</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_big_endian</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>CData_AtAddress</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>buf</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>CData_FromBytes</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>ArrayType_Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>Array_Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>PointerType_Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>Pointer_Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>CFuncPtr_Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>CFuncPtrType_Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>StructType_Type</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ArrayTypeObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>PyObject_TypeCheck(v, &amp;ArrayType_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ArrayObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>PyObject_TypeCheck(v, &amp;Array_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PointerObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>PyObject_TypeCheck(v, &amp;Pointer_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PointerTypeObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>PyObject_TypeCheck(v, &amp;PointerType_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CFuncPtrObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>PyObject_TypeCheck(v, &amp;CFuncPtr_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CFuncPtrTypeObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>PyObject_TypeCheck(v, &amp;CFuncPtrType_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StructTypeObject_Check</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>PyObject_TypeCheck(v, &amp;StructType_Type)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type>
<name>CreateArrayType</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>itemtype</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>init_callbacks_in_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>m</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>extern</specifier> <name>PyMethodDef</name></type> <name><name>module_methods</name><index>[]</index></name></decl>;</decl_stmt>

<function_decl><type><specifier>extern</specifier> <name>CThunkObject</name> *</type><name>AllocFunctionCallback</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>callable</name></decl></param>,
					   <param><decl><type><name>PyObject</name> *</type><name>converters</name></decl></param>,
					   <param><decl><type><name>PyObject</name> *</type><name>restype</name></decl></param>,
					   <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/* a table entry describing a predefined ctypes type */</comment>
<struct>struct <name>fielddesc</name> <block>{
	<decl_stmt><decl><type><name>char</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SETFUNC</name></type> <name>setfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GETFUNC</name></type> <name>getfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ffi_type</name> *</type><name>pffi_type</name></decl>;</decl_stmt> <comment type="block">/* always statically allocated */</comment>
	<decl_stmt><decl><type><name>SETFUNC</name></type> <name>setfunc_swapped</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GETFUNC</name></type> <name>getfunc_swapped</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>Py_ssize_t</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl>;</decl_stmt>		<comment type="block">/* Index into CDataObject's
					   object array */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>		<comment type="block">/* a type or NULL */</comment>
	<decl_stmt><decl><type><name>GETFUNC</name></type> <name>getfunc</name></decl>;</decl_stmt>		<comment type="block">/* getter function if proto is NULL */</comment>
	<decl_stmt><decl><type><name>SETFUNC</name></type> <name>setfunc</name></decl>;</decl_stmt>		<comment type="block">/* setter function if proto is NULL */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>anonymous</name></decl>;</decl_stmt>
}</block></struct></type> <name>CFieldObject</name>;</typedef>

<comment type="block">/* A subclass of PyDictObject, used as the instance dictionary of ctypes
   metatypes */</comment>
<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyDictObject</name></type> <name>dict</name></decl>;</decl_stmt>	<comment type="block">/* first part identical to PyDictObject */</comment>
<comment type="block">/* The size and align fields are unneeded, they are in ffi_type as well.  As
   an experiment shows, it's trivial to get rid of them, the only thing to
   remember is that in ArrayType_new the ffi_type fields must be filled in -
   so far it was unneeded because libffi doesn't support arrays at all
   (because they are passed as pointers to function calls anyway).  But it's
   too much risk to change that now, and there are other fields which doen't
   belong into this structure anyway.  Maybe in ctypes 2.0... (ctypes 2000?)
*/</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>	<comment type="block">/* number of bytes */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>align</name></decl>;</decl_stmt>	<comment type="block">/* alignment requirements */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl>;</decl_stmt>	<comment type="block">/* number of fields */</comment>
	<decl_stmt><decl><type><name>ffi_type</name></type> <name>ffi_type_pointer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>proto</name></decl>;</decl_stmt>	<comment type="block">/* Only for Pointer/ArrayObject */</comment>
	<decl_stmt><decl><type><name>SETFUNC</name></type> <name>setfunc</name></decl>;</decl_stmt>	<comment type="block">/* Only for simple objects */</comment>
	<decl_stmt><decl><type><name>GETFUNC</name></type> <name>getfunc</name></decl>;</decl_stmt>	<comment type="block">/* Only for simple objects */</comment>
	<decl_stmt><decl><type><name>PARAMFUNC</name></type> <name>paramfunc</name></decl>;</decl_stmt>

	<comment type="block">/* Following fields only used by CFuncPtrType_Type instances */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>argtypes</name></decl>;</decl_stmt>	<comment type="block">/* tuple of CDataObjects */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>converters</name></decl>;</decl_stmt>	<comment type="block">/* tuple([t.from_param for t in argtypes]) */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>restype</name></decl>;</decl_stmt>	<comment type="block">/* CDataObject or NULL */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>checker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>		<comment type="block">/* calling convention and such */</comment>

	<comment type="block">/* pep3118 fields, pointers neeed PyMem_Free */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ndim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>shape</name></decl>;</decl_stmt>
<comment type="block">/*	Py_ssize_t *strides;	*/</comment> <comment type="block">/* unused in ctypes */</comment>
<comment type="block">/*	Py_ssize_t *suboffsets;	*/</comment> <comment type="block">/* unused in ctypes */</comment>

}</block></struct></type> <name>StgDictObject</name>;</typedef>

<comment type="block">/****************************************************************
 StgDictObject fields

 setfunc and getfunc is only set for simple data types, it is copied from the
 corresponding fielddesc entry.  These are functions to set and get the value
 in a memory block.
 They should probably by used by other types as well.

 proto is only used for Pointer and Array types - it points to the item type
 object.

 Probably all the magic ctypes methods (like from_param) should have C
 callable wrappers in the StgDictObject.  For simple data type, for example,
 the fielddesc table could have entries for C codec from_param functions or
 other methods as well, if a subtype overrides this method in Python at
 construction time, or assigns to it later, tp_setattro should update the
 StgDictObject function to a generic one.

 Currently, CFuncPtr types have 'converters' and 'checker' entries in their
 type dict.  They are only used to cache attributes from other entries, whihc
 is wrong.

 One use case is the .value attribute that all simple types have.  But some
 complex structures, like VARIANT, represent a single value also, and should
 have this attribute.

 Another use case is a _check_retval_ function, which is called when a ctypes
 type is used as return type of a function to validate and compute the return
 value.

 Common ctypes protocol:

  - setfunc: store a python value in a memory block
  - getfunc: convert data from a memory block into a python value

  - checkfunc: validate and convert a return value from a function call
  - toparamfunc: convert a python value into a function argument

*****************************************************************/</comment>

<comment type="block">/* May return NULL, but does not set an exception! */</comment>
<function_decl><type><specifier>extern</specifier> <name>StgDictObject</name> *</type><name>PyType_stgdict</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* May return NULL, but does not set an exception! */</comment>
<function_decl><type><specifier>extern</specifier> <name>StgDictObject</name> *</type><name>PyObject_stgdict</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>StgDict_clone</name><parameter_list>(<param><decl><type><name>StgDictObject</name> *</type><name>src</name></decl></param>, <param><decl><type><name>StgDictObject</name> *</type><name>dst</name></decl></param>)</parameter_list>;</function_decl>

<typedef>typedef <function_decl><type><name>int</name></type>(* <name>PPROC</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl></typedef>

<function_decl><type><name>PyObject</name> *</type><name>_CallProc</name><parameter_list>(<param><decl><type><name>PPROC</name></type> <name>pProc</name></decl></param>,
		    <param><decl><type><name>PyObject</name> *</type><name>arguments</name></decl></param>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
		    <param><decl><type><name>IUnknown</name> *</type><name>pIUnk</name></decl></param>,
		    <param><decl><type><name>GUID</name> *</type><name>iid</name></decl></param>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		    <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
		    <param><decl><type><name>PyObject</name> *</type><name>argtypes</name></decl></param>,
		    <param><decl><type><name>PyObject</name> *</type><name>restype</name></decl></param>,
		    <param><decl><type><name>PyObject</name> *</type><name>checker</name></decl></param>)</parameter_list>;</function_decl>
 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCFLAG_STDCALL</name></cpp:macro> <cpp:value>0x0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCFLAG_CDECL</name></cpp:macro>   <cpp:value>0x1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCFLAG_HRESULT</name></cpp:macro> <cpp:value>0x2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCFLAG_PYTHONAPI</name></cpp:macro> <cpp:value>0x4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCFLAG_USE_ERRNO</name></cpp:macro> <cpp:value>0x8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCFLAG_USE_LASTERROR</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPEFLAG_ISPOINTER</name></cpp:macro> <cpp:value>0x100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPEFLAG_HASPOINTER</name></cpp:macro> <cpp:value>0x200</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DICTFLAG_FINAL</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define>

<struct>struct <name>tagPyCArgObject</name> <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>ffi_type</name> *</type><name>pffi_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>tag</name></decl>;</decl_stmt>
	<union>union <block>{
		<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>b</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>short</name></type> <name>h</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
		<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>q</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>D</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float</name></type> <name>f</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
	}</block> <decl><name>value</name></decl>;</union>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt> <comment type="block">/* for the 'V' tag */</comment>
}</block>;</struct>

<decl_stmt><decl><type><specifier>extern</specifier> <name>PyTypeObject</name></type> <name>PyCArg_Type</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>PyCArgObject</name> *</type><name>new_CArgObject</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyCArg_CheckExact</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>	    <cpp:value>((v)-&gt;ob_type == &amp;PyCArg_Type)</cpp:value></cpp:define>
<function_decl><type><specifier>extern</specifier> <name>PyCArgObject</name> *</type><name>new_CArgObject</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type>
<name>CData_get</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>GETFUNC</name></type> <name>getfunc</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>src</name></decl></param>,
	  <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ptr</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>int</name></type>
<name>CData_set</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>SETFUNC</name></type> <name>setfunc</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>,
	  <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ptr</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>Extend_Error_Info</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc_class</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>

<struct>struct <name>basespec</name> <block>{
	<decl_stmt><decl><type><name>CDataObject</name> *</type><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>adr</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name><name>basespec_string</name><index>[]</index></name></decl>;</decl_stmt>

<function_decl><type><specifier>extern</specifier> <name>ffi_type</name> *</type><name>GetType</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* exception classes */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>PyExc_ArgError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> *</type><name>conversion_mode_encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> *</type><name>conversion_mode_errors</name></decl>;</decl_stmt>

<comment type="block">/* Python 2.4 macros, which are not available in Python 2.3 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_CLEAR</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_CLEAR</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>				\
        <cpp:value>do {                            	\
                if (op) {			\
                        PyObject *tmp = (PyObject *)(op);	\
                        (op) = NULL;		\
                        Py_DECREF(tmp);		\
                }				\
        } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_VISIT</name></cpp:ifndef>
<comment type="block">/* Utility macro to help write tp_traverse functions.
 * To use this macro, the tp_traverse function must name its arguments
 * "visit" and "arg".  This is intended to keep tp_traverse functions
 * looking as much alike as possible.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_VISIT</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>					\
        <cpp:value>do { 						\
                if (op) {				\
                        int vret = visit((op), arg);	\
                        if (vret)			\
                                return vret;		\
                }					\
        } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Python's PyUnicode_*WideChar functions are broken ... */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCHAR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CTYPES_UNICODE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CTYPES_UNICODE</name></cpp:ifdef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>PyUnicode_FromWideChar</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromWideChar</name></cpp:macro> <cpp:value>My_PyUnicode_FromWideChar</cpp:value></cpp:define>

<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>PyUnicode_AsWideChar</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsWideChar</name></cpp:macro> <cpp:value>My_PyUnicode_AsWideChar</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>My_PyUnicode_FromWideChar</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>wchar_t</name> *</decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Py_ssize_t</name></type> <name>My_PyUnicode_AsWideChar</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type></decl></param>, <param><decl><type><name>wchar_t</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>FreeClosure</name><parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name> *</type><name>MallocClosure</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_AddTraceback</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>CData_FromBaseObj</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>base</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>, <param><decl><type><name>char</name> *</type><name>adr</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>alloc_format_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>suffix</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* XXX better name needed! */</comment>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>IsSimpleSubType</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>_pointer_type_cache</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type><name>get_error_object</name><parameter_list>(<param><decl><type><name>int</name> **</type><name>pspace</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PyObject</name> *</type><name>ComError</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 Local Variables:
 compile-command: "python setup.py -q build install --home ~"
 End:
*/</comment>
</unit>
