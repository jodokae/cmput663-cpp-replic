<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_ctypes/libffi_msvc/fficonfig.h"><comment type="block">/* fficonfig.h.  Originally created by configure, now hand_maintained for MSVC. */</comment>

<comment type="block">/* fficonfig.h.  Generated automatically by configure.  */</comment>
<comment type="block">/* fficonfig.h.in.  Generated automatically from configure.in by autoheader.  */</comment>

<comment type="block">/* Define this for MSVC, but not for mingw32! */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__attribute__</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>alloca</name></cpp:macro> <cpp:value>_alloca</cpp:value></cpp:define>

<comment type="block">/*----------------------------------------------------------------*/</comment>

<comment type="block">/* Define if using alloca.c.  */</comment>
<comment type="block">/* #undef C_ALLOCA */</comment>

<comment type="block">/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
   This function is required for alloca.c support on those systems.  */</comment>
<comment type="block">/* #undef CRAY_STACKSEG_END */</comment>

<comment type="block">/* Define if you have alloca, as a function or macro.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_ALLOCA</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* Define if you have &lt;alloca.h&gt; and it should be used (not on Ultrix).  */</comment>
<comment type="block">/* #define HAVE_ALLOCA_H 1 */</comment>

<comment type="block">/* If using the C implementation of alloca, define if you know the
   direction of stack growth for your system; otherwise it will be
   automatically deduced at run-time.
 STACK_DIRECTION &gt; 0 =&gt; grows toward higher addresses
 STACK_DIRECTION &lt; 0 =&gt; grows toward lower addresses
 STACK_DIRECTION = 0 =&gt; direction of growth unknown
 */</comment>
<comment type="block">/* #undef STACK_DIRECTION */</comment>

<comment type="block">/* Define if you have the ANSI C header files.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STDC_HEADERS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* Define if you have the memcpy function.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MEMCPY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* Define if read-only mmap of a plain file works. */</comment>
<comment type="line">//#define HAVE_MMAP_FILE 1</comment>

<comment type="block">/* Define if mmap of /dev/zero works. */</comment>
<comment type="line">//#define HAVE_MMAP_DEV_ZERO 1</comment>

<comment type="block">/* Define if mmap with MAP_ANON(YMOUS) works. */</comment>
<comment type="line">//#define HAVE_MMAP_ANON 1</comment>

<comment type="block">/* The number of bytes in type double */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_DOUBLE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/* The number of bytes in type long double */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_LONG_DOUBLE</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<comment type="block">/* Define if you have the long double type and it is bigger than a double */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_LONG_DOUBLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* whether byteorder is bigendian */</comment>
<comment type="block">/* #undef WORDS_BIGENDIAN */</comment>

<comment type="block">/* Define if the host machine stores words of multi-word integers in
   big-endian order. */</comment>
<comment type="block">/* #undef HOST_WORDS_BIG_ENDIAN */</comment>

<comment type="block">/* 1234 = LIL_ENDIAN, 4321 = BIGENDIAN */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTEORDER</name></cpp:macro> <cpp:value>1234</cpp:value></cpp:define>

<comment type="block">/* Define if your assembler and linker support unaligned PC relative relocs. */</comment>
<comment type="block">/* #undef HAVE_AS_SPARC_UA_PCREL */</comment>

<comment type="block">/* Define if your assembler supports .register. */</comment>
<comment type="block">/* #undef HAVE_AS_REGISTER_PSEUDO_OP */</comment>

<comment type="block">/* Define if .eh_frame sections should be read-only. */</comment>
<comment type="block">/* #undef HAVE_RO_EH_FRAME */</comment>

<comment type="block">/* Define to the flags needed for the .section .eh_frame directive. */</comment>
<comment type="block">/* #define EH_FRAME_FLAGS "aw" */</comment>

<comment type="block">/* Define to the flags needed for the .section .eh_frame directive. */</comment>
<comment type="block">/* #define EH_FRAME_FLAGS "aw" */</comment>

<comment type="block">/* Define this if you want extra debugging. */</comment>
<comment type="block">/* #undef FFI_DEBUG */</comment>

<comment type="block">/* Define this is you do not want support for aggregate types. */</comment>
<comment type="block">/* #undef FFI_NO_STRUCTS */</comment>

<comment type="block">/* Define this is you do not want support for the raw API. */</comment>
<comment type="block">/* #undef FFI_NO_RAW_API */</comment>

<comment type="block">/* Define this if you are using Purify and want to suppress spurious messages. */</comment>
<comment type="block">/* #undef USING_PURIFY */</comment>

</unit>
