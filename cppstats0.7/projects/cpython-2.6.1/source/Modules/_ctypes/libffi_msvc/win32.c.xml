<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_ctypes/libffi_msvc/win32.c"><comment type="block">/* -----------------------------------------------------------------------
   win32.S - Copyright (c) 1996, 1998, 2001, 2002  Red Hat, Inc.
	     Copyright (c) 2001  John Beniton
	     Copyright (c) 2002  Ranjit Mathew
			
 
   X86 Foreign Function Interface
 
   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   ``Software''), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:
 
   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.
 
   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
   ----------------------------------------------------------------------- */</comment>

<comment type="block">/* theller: almost verbatim translation from gas syntax to MSVC inline
   assembler code. */</comment>

<comment type="block">/* theller: ffi_call_SYSV and ffi_call_STDCALL now return an integer - the
   difference of the stack pointer before and after the function call.  If
   everything is ok, zero is returned.  If stdcall functions are passed the
   wrong number of arguments, the difference will be nonzero. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi_common.h&gt;</cpp:file></cpp:include>

<macro><name>__declspec</name><argument_list>(<argument>naked</argument>)</argument_list></macro> <function><type><name>int</name></type>
<name>ffi_call_SYSV</name><parameter_list>(<param><function_decl><type><name>void</name></type> (* <name>prepfunc</name>)<parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>extended_cif</name> *</type></decl></param>)</parameter_list></function_decl></param>, <comment type="block">/* 8 */</comment>
		 <param><decl><type><name>extended_cif</name> *</type><name>ecif</name></decl></param>, <comment type="block">/* 12 */</comment>
		 <param><decl><type><name>unsigned</name></type> <name>bytes</name></decl></param>, <comment type="block">/* 16 */</comment>
		 <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>, <comment type="block">/* 20 */</comment>
		 <param><decl><type><name>unsigned</name> *</type><name>rvalue</name></decl></param>, <comment type="block">/* 24 */</comment>
		 <param><function_decl><type><name>void</name></type> (*<name>fn</name>)<parameter_list>()</parameter_list></function_decl></param>)</parameter_list> <comment type="block">/* 28 */</comment>
<block>{
	<macro><name>_asm</name></macro> <block>{
		<decl_stmt><decl><type><name>push</name> <name>ebp</name>
		<name>mov</name></type> <name>ebp</name></decl>, <decl><type ref="prev"/><name>esp</name>

		<name>push</name> <name>esi</name> <comment type="line">// NEW: this register must be preserved across function calls</comment>
<comment type="line">// XXX SAVE ESP NOW!</comment>
		<name>mov</name> <name>esi</name></decl>, <decl><type ref="prev"/><name>esp</name>		<comment type="line">// save stack pointer before the call</comment>

<comment type="line">// Make room for all of the new args.</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+16]
		<name>sub</name> <name>esp</name></decl>, <decl><type ref="prev"/><name>ecx</name>		<comment type="line">// sub esp, bytes</comment>
		
		<name>mov</name> <name>eax</name></decl>, <decl><type ref="prev"/><name>esp</name>

<comment type="line">// Place all of the ffi_prep_args in position</comment>
		<name><name>push</name> <index>[<expr><name>ebp</name> + 12</expr>]</index></name> <comment type="line">// ecif</comment>
		<name>push</name> <name>eax</name>
		<name><name>call</name> <index>[<expr><name>ebp</name> + 8</expr>]</index></name> <comment type="line">// prepfunc</comment>

<comment type="line">// Return stack to previous state and call the function</comment>
		<name>add</name> <name>esp</name></decl>, 8
<comment type="line">// FIXME: Align the stack to a 128-bit boundary to avoid</comment>
<comment type="line">// potential performance hits.</comment>
		<decl><type ref="prev"/><name><name>call</name> <index>[<expr><name>ebp</name> + 28</expr>]</index></name>
<comment type="line">// Remove the space we pushed for the args</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name> + 16]
		<name>add</name> <name>esp</name></decl>, <decl><type ref="prev"/><name>ecx</name>

<comment type="line">// XXX ASSERT THAT ESP IS THE SAME NOW THAN BEFORE!</comment>
		<name>sub</name> <name>esi</name></decl>, <decl><type ref="prev"/><name>esp</name>

<comment type="line">// Load %ecx with the return type code</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name> + 20]

<comment type="line">// If the return value pointer is NULL, assume no return value.</comment>
<comment type="block">/*
  Intel asm is weird. We have to explicitely specify 'DWORD PTR' in the nexr instruction,
  otherwise only one BYTE will be compared (instead of a DWORD)!
 */</comment>
		<name>cmp</name> <name>DWORD</name> <name><name>PTR</name> <index>[<expr><name>ebp</name> + 24</expr>]</index></name></decl>, 0
		<decl><type ref="prev"/><name>jne</name> <name>sc_retint</name>

<comment type="line">// Even if there is no space for the return value, we are</comment>
<comment type="line">// obliged to handle floating-point values.</comment>
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_FLOAT</name>
		<name>jne</name> <name>sc_noretval</name>
<comment type="line">//        fstp  %st(0)</comment>
		<name>fstp</name> <name>st</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list>

		<name>jmp</name> <name>sc_epilogue</name>

<name>sc_retint</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_INT</name>
		<name>jne</name> <name>sc_retfloat</name>
<comment type="line">//        # Load %ecx with the pointer to storage for the return value</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name> + 24]
		<name><name>mov</name> <index>[<expr><name>ecx</name> + 0</expr>]</index></name></decl>, <decl><type ref="prev"/><name>eax</name>
		<name>jmp</name> <name>sc_epilogue</name>

<name>sc_retfloat</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_FLOAT</name>
		<name>jne</name> <name>sc_retdouble</name>
<comment type="line">// Load %ecx with the pointer to storage for the return value</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+24]
<comment type="line">//        fstps (%ecx)</comment>
		<name>fstp</name> <name>DWORD</name> <name><name>PTR</name> <index>[<expr><name>ecx</name></expr>]</index></name>
		<name>jmp</name> <name>sc_epilogue</name>

<name>sc_retdouble</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_DOUBLE</name>
		<name>jne</name> <name>sc_retlongdouble</name>
<comment type="line">//        movl  24(%ebp),%ecx</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+24]
		<name>fstp</name> <name>QWORD</name> <name><name>PTR</name> <index>[<expr><name>ecx</name></expr>]</index></name>
		<name>jmp</name> <name>sc_epilogue</name>

		<name>jmp</name> <name>sc_retlongdouble</name> <comment type="line">// avoid warning about unused label</comment>
<name>sc_retlongdouble</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_LONGDOUBLE</name>
		<name>jne</name> <name>sc_retint64</name>
<comment type="line">// Load %ecx with the pointer to storage for the return value</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+24]
<comment type="line">//        fstpt (%ecx)</comment>
		<name>fstp</name> <name>QWORD</name> <name><name>PTR</name> <index>[<expr><name>ecx</name></expr>]</index></name> <comment type="block">/* XXX ??? */</comment>
		<name>jmp</name> <name>sc_epilogue</name>

<name>sc_retint64</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_SINT64</name>
		<name>jne</name> <name>sc_retstruct</name>
<comment type="line">// Load %ecx with the pointer to storage for the return value</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+24]
		<name><name>mov</name> <index>[<expr><name>ecx</name>+0</expr>]</index></name></decl>, <decl><type ref="prev"/><name>eax</name>
		<name><name>mov</name> <index>[<expr><name>ecx</name>+4</expr>]</index></name></decl>, <decl><type ref="prev"/><name>edx</name>

<name>sc_retstruct</name>:
<comment type="line">// Nothing to do!</comment>

<name>sc_noretval</name>:
<name>sc_epilogue</name>:
		<name>mov</name> <name>eax</name></decl>, <decl><type ref="prev"/><name>esi</name>
		<name>pop</name> <name>esi</name> <comment type="line">// NEW restore: must be preserved across function calls</comment>
		<name>mov</name> <name>esp</name></decl>, <decl><type ref="prev"/><name>ebp</name>
		<name>pop</name> <name>ebp</name>
		<name>ret</name></decl></decl_stmt>
	}</block>
}</block></function>

<macro><name>__declspec</name><argument_list>(<argument>naked</argument>)</argument_list></macro> <function><type><name>int</name></type>
<name>ffi_call_STDCALL</name><parameter_list>(<param><function_decl><type><name>void</name></type> (* <name>prepfunc</name>)<parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>extended_cif</name> *</type></decl></param>)</parameter_list></function_decl></param>, <comment type="block">/* 8 */</comment>
		 <param><decl><type><name>extended_cif</name> *</type><name>ecif</name></decl></param>, <comment type="block">/* 12 */</comment>
		 <param><decl><type><name>unsigned</name></type> <name>bytes</name></decl></param>, <comment type="block">/* 16 */</comment>
		 <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>, <comment type="block">/* 20 */</comment>
		 <param><decl><type><name>unsigned</name> *</type><name>rvalue</name></decl></param>, <comment type="block">/* 24 */</comment>
		 <param><function_decl><type><name>void</name></type> (*<name>fn</name>)<parameter_list>()</parameter_list></function_decl></param>)</parameter_list> <comment type="block">/* 28 */</comment>
<block>{
	<macro><name>_asm</name></macro> <block>{
		<decl_stmt><decl><type><name>push</name> <name>ebp</name>
		<name>mov</name></type> <name>ebp</name></decl>, <decl><type ref="prev"/><name>esp</name>

		<name>push</name> <name>esi</name> <comment type="line">// NEW: this register must be preserved across function calls</comment>

<comment type="line">// XXX SAVE ESP NOW!</comment>
		<name>mov</name> <name>esi</name></decl>, <decl><type ref="prev"/><name>esp</name>

<comment type="line">// Make room for all of the new args.</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+16]
		<name>sub</name> <name>esp</name></decl>, <decl><type ref="prev"/><name>ecx</name>
		
		<name>mov</name> <name>eax</name></decl>, <decl><type ref="prev"/><name>esp</name>

<comment type="line">// Place all of the ffi_prep_args in position</comment>
		<name><name>push</name> <index>[<expr><name>ebp</name> + 12</expr>]</index></name> <comment type="line">// ecif</comment>
		<name>push</name> <name>eax</name>
		<name><name>call</name> <index>[<expr><name>ebp</name> + 8</expr>]</index></name> <comment type="line">// prepfunc</comment>

<comment type="line">// Return stack to previous state and call the function</comment>
		<name>add</name> <name>esp</name></decl>, 8
<comment type="line">// FIXME: Align the stack to a 128-bit boundary to avoid</comment>
<comment type="line">// potential performance hits.</comment>
		<decl><type ref="prev"/><name><name>call</name> <index>[<expr><name>ebp</name> + 28</expr>]</index></name>
<comment type="line">// stdcall functions pop arguments off the stack themselves</comment>

<comment type="line">// XXX IS ESP NOW THE SAME AS BEFORE?</comment>
		<name>sub</name> <name>esi</name></decl>, <decl><type ref="prev"/><name>esp</name>

<comment type="line">// Load %ecx with the return type code</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name> + 20]

<comment type="line">// If the return value pointer is NULL, assume no return value.</comment>
<comment type="block">/*
  Intel asm is weird. We have to explicitely specify 'DWORD PTR' in the nexr instruction,
  otherwise only one BYTE will be compared (instead of a DWORD)!
 */</comment>
		<name>cmp</name> <name>DWORD</name> <name><name>PTR</name> <index>[<expr><name>ebp</name> + 24</expr>]</index></name></decl>, 0
		<decl><type ref="prev"/><name>jne</name> <name>sc_retint</name>

<comment type="line">// Even if there is no space for the return value, we are</comment>
<comment type="line">// obliged to handle floating-point values.</comment>
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_FLOAT</name>
		<name>jne</name> <name>sc_noretval</name>
<comment type="line">//        fstp  %st(0)</comment>
		<name>fstp</name> <name>st</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list>

		<name>jmp</name> <name>sc_epilogue</name>

<name>sc_retint</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_INT</name>
		<name>jne</name> <name>sc_retfloat</name>
<comment type="line">//        # Load %ecx with the pointer to storage for the return value</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name> + 24]
		<name><name>mov</name> <index>[<expr><name>ecx</name> + 0</expr>]</index></name></decl>, <decl><type ref="prev"/><name>eax</name>
		<name>jmp</name> <name>sc_epilogue</name>

<name>sc_retfloat</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_FLOAT</name>
		<name>jne</name> <name>sc_retdouble</name>
<comment type="line">// Load %ecx with the pointer to storage for the return value</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+24]
<comment type="line">//        fstps (%ecx)</comment>
		<name>fstp</name> <name>DWORD</name> <name><name>PTR</name> <index>[<expr><name>ecx</name></expr>]</index></name>
		<name>jmp</name> <name>sc_epilogue</name>

<name>sc_retdouble</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_DOUBLE</name>
		<name>jne</name> <name>sc_retlongdouble</name>
<comment type="line">//        movl  24(%ebp),%ecx</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+24]
		<name>fstp</name> <name>QWORD</name> <name><name>PTR</name> <index>[<expr><name>ecx</name></expr>]</index></name>
		<name>jmp</name> <name>sc_epilogue</name>

		<name>jmp</name> <name>sc_retlongdouble</name> <comment type="line">// avoid warning about unused label</comment>
<name>sc_retlongdouble</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_LONGDOUBLE</name>
		<name>jne</name> <name>sc_retint64</name>
<comment type="line">// Load %ecx with the pointer to storage for the return value</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+24]
<comment type="line">//        fstpt (%ecx)</comment>
		<name>fstp</name> <name>QWORD</name> <name><name>PTR</name> <index>[<expr><name>ecx</name></expr>]</index></name> <comment type="block">/* XXX ??? */</comment>
		<name>jmp</name> <name>sc_epilogue</name>

<name>sc_retint64</name>:
		<name>cmp</name> <name>ecx</name></decl>, <decl><type ref="prev"/><name>FFI_TYPE_SINT64</name>
		<name>jne</name> <name>sc_retstruct</name>
<comment type="line">// Load %ecx with the pointer to storage for the return value</comment>
		<name>mov</name> <name>ecx</name></decl>, [<decl><type ref="prev"/><name>ebp</name>+24]
		<name><name>mov</name> <index>[<expr><name>ecx</name>+0</expr>]</index></name></decl>, <decl><type ref="prev"/><name>eax</name>
		<name><name>mov</name> <index>[<expr><name>ecx</name>+4</expr>]</index></name></decl>, <decl><type ref="prev"/><name>edx</name>

<name>sc_retstruct</name>:
<comment type="line">// Nothing to do!</comment>

<name>sc_noretval</name>:
<name>sc_epilogue</name>:
		<name>mov</name> <name>eax</name></decl>, <decl><type ref="prev"/><name>esi</name>
		<name>pop</name> <name>esi</name> <comment type="line">// NEW restore: must be preserved across function calls</comment>
		<name>mov</name> <name>esp</name></decl>, <decl><type ref="prev"/><name>ebp</name>
		<name>pop</name> <name>ebp</name>
		<name>ret</name></decl></decl_stmt>
	}</block>
}</block></function>
</unit>
