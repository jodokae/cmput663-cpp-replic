<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_ctypes/libffi/src/pa/ffi.c"><comment type="block">/* -----------------------------------------------------------------------
   ffi.c - (c) 2003-2004 Randolph Chung &lt;tausq@debian.org&gt;
           (c) 2008 Red Hat, Inc.

   HPPA Foreign Function Interface
   HP-UX PA ABI support (c) 2006 Free Software Foundation, Inc.

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   ``Software''), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
   ----------------------------------------------------------------------- */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi_common.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROUND_UP</name><parameter_list>(<param><type><name>v</name></type></param>, <param><type><name>a</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>(((size_t)(v) + (a) - 1) &amp; ~((a) - 1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_STACK_SIZE</name></cpp:macro>  <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIRST_ARG_SLOT</name></cpp:macro>  <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_LEVEL</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fldw</name><parameter_list>(<param><type><name>addr</name></type></param>, <param><type><name>fpreg</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>__asm__ volatile ("fldw 0(%0), %%" #fpreg "L" : : "r"(addr) : #fpreg)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fstw</name><parameter_list>(<param><type><name>fpreg</name></type></param>, <param><type><name>addr</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>__asm__ volatile ("fstw %%" #fpreg "L, 0(%0)" : : "r"(addr))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fldd</name><parameter_list>(<param><type><name>addr</name></type></param>, <param><type><name>fpreg</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>__asm__ volatile ("fldd 0(%0), %%" #fpreg : : "r"(addr) : #fpreg)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fstd</name><parameter_list>(<param><type><name>fpreg</name></type></param>, <param><type><name>addr</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>__asm__ volatile ("fstd %%" #fpreg "L, 0(%0)" : : "r"(addr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug</name><parameter_list>(<param><type><name>lvl</name></type></param>, <param><type><name>x</name>...</type></param>)</parameter_list></cpp:macro> <cpp:value>do { if (lvl &lt;= DEBUG_LEVEL) { printf(x); } } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ffi_struct_type</name><parameter_list>(<param><decl><type><name>ffi_type</name> *</type><name>t</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><name><name>t</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Small structure results are passed in registers,
     larger ones are passed by pointer.  Note that
     small structures of size 2, 4 and 8 differ from
     the corresponding integer types in that they have
     different alignment requirements.  */</comment>

  <if>if <condition>(<expr><name>sz</name> &lt;= 1</expr>)</condition><then>
    <return>return <expr><name>FFI_TYPE_UINT8</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>sz</name> == 2</expr>)</condition><then>
    <return>return <expr><name>FFI_TYPE_SMALL_STRUCT2</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>sz</name> == 3</expr>)</condition><then>
    <return>return <expr><name>FFI_TYPE_SMALL_STRUCT3</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>sz</name> == 4</expr>)</condition><then>
    <return>return <expr><name>FFI_TYPE_SMALL_STRUCT4</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>sz</name> == 5</expr>)</condition><then>
    <return>return <expr><name>FFI_TYPE_SMALL_STRUCT5</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>sz</name> == 6</expr>)</condition><then>
    <return>return <expr><name>FFI_TYPE_SMALL_STRUCT6</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>sz</name> == 7</expr>)</condition><then>
    <return>return <expr><name>FFI_TYPE_SMALL_STRUCT7</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>sz</name> &lt;= 8</expr>)</condition><then>
    <return>return <expr><name>FFI_TYPE_SMALL_STRUCT8</name></expr>;</return></then>
  <else>else
    <return>return <expr><name>FFI_TYPE_STRUCT</name></expr>;</return></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if> <comment type="block">/* else, we pass it by pointer.  */</comment>
}</block></function>

<comment type="block">/* PA has a downward growing stack, which looks like this:

   Offset
	[ Variable args ]
   SP = (4*(n+9))       arg word N
   ...
   SP-52                arg word 4
	[ Fixed args ]
   SP-48                arg word 3
   SP-44                arg word 2
   SP-40                arg word 1
   SP-36                arg word 0
	[ Frame marker ]
   ...
   SP-20                RP
   SP-4                 previous SP

   The first four argument words on the stack are reserved for use by
   the callee.  Instead, the general and floating registers replace
   the first four argument slots.  Non FP arguments are passed solely
   in the general registers.  FP arguments are passed in both general
   and floating registers when using libffi.

   Non-FP 32-bit args are passed in gr26, gr25, gr24 and gr23.
   Non-FP 64-bit args are passed in register pairs, starting
   on an odd numbered register (i.e. r25+r26 and r23+r24).
   FP 32-bit arguments are passed in fr4L, fr5L, fr6L and fr7L.
   FP 64-bit arguments are passed in fr5 and fr7.

   The registers are allocated in the same manner as stack slots.
   This allows the callee to save its arguments on the stack if
   necessary:

   arg word 3 -&gt; gr23 or fr7L
   arg word 2 -&gt; gr24 or fr6L or fr7R
   arg word 1 -&gt; gr25 or fr5L
   arg word 0 -&gt; gr26 or fr4L or fr5R

   Note that fr4R and fr6R are never used for arguments (i.e.,
   doubles are not passed in fr4 or fr6).

   The rest of the arguments are passed on the stack starting at SP-52,
   but 64-bit arguments need to be aligned to an 8-byte boundary

   This means we can have holes either in the register allocation,
   or in the stack.  */</comment>

<comment type="block">/* ffi_prep_args is called by the assembly routine once stack space
   has been allocated for the function's arguments

   The following code will put everything into the stack frame
   (which was allocated by the asm routine), and on return
   the asm routine will load the arguments that should be
   passed by register into the appropriate registers

   NOTE: We load floating point args in this function... that means we
   assume gcc will not mess with fp regs in here.  */</comment>

<function><type><name>void</name></type> <name>ffi_prep_args_pa32</name><parameter_list>(<param><decl><type><name>UINT32</name> *</type><name>stack</name></decl></param>, <param><decl><type><name>extended_cif</name> *</type><name>ecif</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>bytes</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>register</name> <name>ffi_type</name> **</type><name>p_arg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>register</name> <name>void</name> **</type><name>p_argv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>slot</name> <init>= <expr><name>FIRST_ARG_SLOT</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>dest_cpy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>"%s: stack = %p, ecif = %p, bytes = %u\n"</expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>,
	<argument><expr><name>ecif</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>p_arg</name> = <name><name>ecif</name>-&gt;<name>cif</name>-&gt;<name>arg_types</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p_argv</name> = <name><name>ecif</name>-&gt;<name>avalue</name></name></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ecif</name>-&gt;<name>cif</name>-&gt;<name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><name>(*<name>p_arg</name>)-&gt;<name>type</name></name></expr></init></decl>;</decl_stmt>

      <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{
	<case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
	  <expr_stmt><expr>*<call>(<name>SINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>SINT8</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
	  <expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT8</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
	  <expr_stmt><expr>*<call>(<name>SINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>SINT16</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
	  <expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT16</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
	  <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Storing UINT32 %u in slot %u\n"</expr></argument>, <argument><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT32</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
	  <comment type="block">/* Align slot for 64-bit type.  */</comment>
	  <expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
	  <expr_stmt><expr>*<call>(<name>UINT64</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT64</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
	  <comment type="block">/* First 4 args go in fr4L - fr7L.  */</comment>
	  <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Storing UINT32(float) in slot %u\n"</expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT32</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <switch>switch <condition>(<expr><name>slot</name> - <name>FIRST_ARG_SLOT</name></expr>)</condition>
	    <block>{
	    <comment type="block">/* First 4 args go in fr4L - fr7L.  */</comment>
	    <case>case <expr>0</expr>: <expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case><case>case <expr>1</expr>: <expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case><case>case <expr>2</expr>: <expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case><case>case <expr>3</expr>: <expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case>}</block></switch>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
	  <comment type="block">/* Align slot for 64-bit type.  */</comment>
	  <expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Storing UINT64(double) at slot %u\n"</expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr>*<call>(<name>UINT64</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = *<call>(<name>UINT64</name> *)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <switch>switch <condition>(<expr><name>slot</name> - <name>FIRST_ARG_SLOT</name></expr>)</condition>
	    <block>{
	      <comment type="block">/* First 2 args go in fr5, fr7.  */</comment>
	      <case>case <expr>1</expr>: <expr_stmt><expr><call><name>fldd</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	      </case><case>case <expr>3</expr>: <expr_stmt><expr><call><name>fldd</name><argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>, <argument><expr><name>fr7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case>}</block></switch>
	  <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PA_HPUX</name></cpp:ifdef>
	</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
	  <comment type="block">/* Long doubles are passed in the same manner as structures
	     larger than 8 bytes.  */</comment>
	  <expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = <call>(<name>UINT32</name>)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:

	  <comment type="block">/* Structs smaller or equal than 4 bytes are passed in one
	     register. Structs smaller or equal 8 bytes are passed in two
	     registers. Larger structures are passed by pointer.  */</comment>

	  <expr_stmt><expr><name>len</name> = <name>(*<name>p_arg</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
	  <if>if <condition>(<expr><name>len</name> &lt;= 4</expr>)</condition><then>
	    <block>{
	      <expr_stmt><expr><name>dest_cpy</name> = <call>(<name>char</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + 4 - <name>len</name></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest_cpy</name></expr></argument>, <argument><expr>(<name>char</name> *)*<name>p_argv</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then>
	  <else>else <if>if <condition>(<expr><name>len</name> &lt;= 8</expr>)</condition><then>
	    <block>{
	      <expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
	      <expr_stmt><expr><name>dest_cpy</name> = <call>(<name>char</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + 8 - <name>len</name></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest_cpy</name></expr></argument>, <argument><expr>(<name>char</name> *)*<name>p_argv</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then>
	  <else>else
	    <expr_stmt><expr>*<call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> = <call>(<name>UINT32</name>)<argument_list>(<argument><expr>*<name>p_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	  <break>break;</break>

	</case><default>default:
	  <expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</default>}</block></switch>

      <expr_stmt><expr><name>slot</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>p_arg</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>p_argv</name>++</expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Make sure we didn't mess up and scribble on the stack.  */</comment>
  <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr>"Stack setup:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (<name>bytes</name> + 3) / 4</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)
      <block>{
	<if>if <condition>(<expr>(<name>n</name>%4) == 0</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr>"\n%08x: "</expr></argument>, <argument><expr><call>(<name>unsigned</name> <name>int</name>)<argument_list>(<argument><expr><name>stack</name> - <name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
	<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr>"%08x "</expr></argument>, <argument><expr>*(<name>stack</name> - <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
    <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>5</expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>

  <expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr><name>slot</name> * 4 &lt;= <name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ffi_size_stack_pa32</name><parameter_list>(<param><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>ffi_type</name> **</type><name>ptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>z</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* # stack slots */</comment>

  <for>for (<init><expr><name>ptr</name> = <name><name>cif</name>-&gt;<name>arg_types</name></name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>cif</name>-&gt;<name>nargs</name></name></expr>;</condition> <incr><expr><name>ptr</name>++</expr>, <expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><name>(*<name>ptr</name>)-&gt;<name>type</name></name></expr></init></decl>;</decl_stmt>

      <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{
	<case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
	  <expr_stmt><expr><name>z</name> += 2 + (<name>z</name> &amp; 1)</expr>;</expr_stmt> <comment type="block">/* must start on even regs, so we may waste one */</comment>
	  <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PA_HPUX</name></cpp:ifdef>
	</case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
	  <expr_stmt><expr><name>z</name> += 1</expr>;</expr_stmt> <comment type="block">/* pass by ptr, callee will copy */</comment>
	  <break>break;</break>

	</case><default>default: <comment type="block">/* &lt;= 32-bit values */</comment>
	  <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt>
	</default>}</block></switch>
    }</block></for>

  <comment type="block">/* We can fit up to 6 args in the default 64-byte stack frame,
     if we need more, we need more stack.  */</comment>
  <if>if <condition>(<expr><name>z</name> &lt;= 6</expr>)</condition><then>
    <expr_stmt><expr><name><name>cif</name>-&gt;<name>bytes</name></name> = <name>MIN_STACK_SIZE</name></expr>;</expr_stmt></then> <comment type="block">/* min stack size */</comment>
  <else>else
    <expr_stmt><expr><name><name>cif</name>-&gt;<name>bytes</name></name> = 64 + <call><name>ROUND_UP</name><argument_list>(<argument><expr>(<name>z</name> - 6) * <sizeof>sizeof<argument_list>(<argument><expr><name>UINT32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>MIN_STACK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Calculated stack size is %u bytes\n"</expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Perform machine dependent cif processing.  */</comment>
<function><type><name>ffi_status</name></type> <name>ffi_prep_cif_machdep</name><parameter_list>(<param><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Set the return type flag */</comment>
  <switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>FFI_TYPE_VOID</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
      <expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = (<name>unsigned</name>) <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name></expr>;</expr_stmt>
      <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PA_HPUX</name></cpp:ifdef>
    </case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
      <comment type="block">/* Long doubles are treated like a structure.  */</comment>
      <expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <name>FFI_TYPE_STRUCT</name></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
      <comment type="block">/* For the return type we have to check the size of the structures.
	 If the size is smaller or equal 4 bytes, the result is given back
	 in one register. If the size is smaller or equal 8 bytes than we
	 return the result in two registers. But if the size is bigger than
	 8 bytes, we work with pointers.  */</comment>
      <expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <call><name>ffi_struct_type</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
      <expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <name>FFI_TYPE_UINT64</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <name>FFI_TYPE_INT</name></expr>;</expr_stmt>
      <break>break;</break>
    </default>}</block></switch>

  <comment type="block">/* Lucky us, because of the unique PA ABI we get to do our
     own stack sizing.  */</comment>
  <switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>abi</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>FFI_PA32</name></expr>:
      <expr_stmt><expr><call><name>ffi_size_stack_pa32</name><argument_list>(<argument><expr><name>cif</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </default>}</block></switch>

  <return>return <expr><name>FFI_OK</name></expr>;</return>
}</block></function>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ffi_call_pa32</name><parameter_list>(<param><function_decl><type><name>void</name></type> (*)<parameter_list>(<param><decl><type><name>UINT32</name> *</type></decl></param>, <param><decl><type><name>extended_cif</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type></decl></param>)</parameter_list></function_decl></param>,
			  <param><decl><type><name>extended_cif</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type></decl></param>, <param><decl><type><name>unsigned</name></type></decl></param>, <param><decl><type><name>unsigned</name> *</type></decl></param>,
			  <param><function_decl><type><name>void</name></type> (*<name>fn</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>ffi_call</name><parameter_list>(<param><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>fn</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>, <param><decl><type><name>void</name> *</type><name>rvalue</name></decl></param>, <param><decl><type><name>void</name> **</type><name>avalue</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>extended_cif</name></type> <name>ecif</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>ecif</name>.<name>cif</name></name> = <name>cif</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ecif</name>.<name>avalue</name></name> = <name>avalue</name></expr>;</expr_stmt>

  <comment type="block">/* If the return value is a struct and we don't have a return
     value address then we need to make one.  */</comment>

  <if>if <condition>(<expr><name>rvalue</name> == <name>NULL</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PA_HPUX</name></cpp:ifdef>
      &amp;&amp; (<name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_STRUCT</name>
	  || <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_LONGDOUBLE</name>)</expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr>&amp;&amp; <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_STRUCT</name></expr></expr_stmt></then></if>)</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
      <expr_stmt><expr><name><name>ecif</name>.<name>rvalue</name></name> = <call><name>alloca</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>
  <else>else
    <expr_stmt><expr><name><name>ecif</name>.<name>rvalue</name></name> = <name>rvalue</name></expr>;</expr_stmt></else>


  <switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>abi</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>FFI_PA32</name></expr>:
      <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"Calling ffi_call_pa32: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\n"</expr></argument>, <argument><expr>&amp;<name>ecif</name></expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>bytes</name></name></expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name><name>ecif</name>.<name>rvalue</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ffi_call_pa32</name><argument_list>(<argument><expr><name>ffi_prep_args_pa32</name></expr></argument>, <argument><expr>&amp;<name>ecif</name></expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>bytes</name></name></expr></argument>,
		     <argument><expr><name><name>cif</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name><name>ecif</name>.<name>rvalue</name></name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </default>}</block></switch>
}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FFI_CLOSURES</name></expr></cpp:if>
<comment type="block">/* This is more-or-less an inverse of ffi_call -- we have arguments on
   the stack, and we need to fill them into a cif structure and invoke
   the user function. This really ought to be in asm to make sure
   the compiler doesn't do things we don't expect.  */</comment>
ffi_status <macro><name>ffi_closure_inner_pa32</name><argument_list>(<argument>ffi_closure *closure</argument>, <argument>UINT32 *stack</argument>)</argument_list></macro>
<block>{
  <decl_stmt><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> **</type><name>avalue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>rvalue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UINT32</name></type> <name><name>ret</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* function can return up to 64-bits in registers */</comment>
  <decl_stmt><decl><type><name>ffi_type</name> **</type><name>p_arg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>avn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>slot</name> <init>= <expr><name>FIRST_ARG_SLOT</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>register</name> <name>UINT32</name> <name>r28</name></type> <name>asm</name><argument_list>(<argument><expr>"r28"</expr></argument>)</argument_list></decl>;</decl_stmt>

  <expr_stmt><expr><name>cif</name> = <name><name>closure</name>-&gt;<name>cif</name></name></expr>;</expr_stmt>

  <comment type="block">/* If returning via structure, callee will write to our pointer.  */</comment>
  <if>if <condition>(<expr><name><name>cif</name>-&gt;<name>flags</name></name> == <name>FFI_TYPE_STRUCT</name></expr>)</condition><then>
    <expr_stmt><expr><name>rvalue</name> = (<name>void</name> *)<name>r28</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>rvalue</name> = &amp;<name><name>ret</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>avalue</name> = (<name>void</name> **)<call><name>alloca</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>nargs</name></name> * <name>FFI_SIZEOF_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>avn</name> = <name><name>cif</name>-&gt;<name>nargs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p_arg</name> = <name><name>cif</name>-&gt;<name>arg_types</name></name></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>avn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><name>(*<name>p_arg</name>)-&gt;<name>type</name></name></expr></init></decl>;</decl_stmt>

      <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{
	<case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
	  <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>char</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + <sizeof>sizeof<argument_list>(<argument><expr><name>UINT32</name></expr></argument>)</argument_list></sizeof> - <name>(*<name>p_arg</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
	</case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
	  <expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PA_LINUX</name></cpp:ifdef>
	  <comment type="block">/* The closure call is indirect.  In Linux, floating point
	     arguments in indirect calls with a prototype are passed
	     in the floating point registers instead of the general
	     registers.  So, we need to replace what was previously
	     stored in the current slot with the value in the
	     corresponding floating point register.  */</comment>
	  <switch>switch <condition>(<expr><name>slot</name> - <name>FIRST_ARG_SLOT</name></expr>)</condition>
	    <block>{
	    <case>case <expr>0</expr>: <expr_stmt><expr><call><name>fstw</name><argument_list>(<argument><expr><name>fr4</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case><case>case <expr>1</expr>: <expr_stmt><expr><call><name>fstw</name><argument_list>(<argument><expr><name>fr5</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case><case>case <expr>2</expr>: <expr_stmt><expr><call><name>fstw</name><argument_list>(<argument><expr><name>fr6</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case><case>case <expr>3</expr>: <expr_stmt><expr><call><name>fstw</name><argument_list>(<argument><expr><name>fr7</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	  <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
	  <expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PA_LINUX</name></cpp:ifdef>
	  <comment type="block">/* See previous comment for FFI_TYPE_FLOAT.  */</comment>
	  <switch>switch <condition>(<expr><name>slot</name> - <name>FIRST_ARG_SLOT</name></expr>)</condition>
	    <block>{
	    <case>case <expr>1</expr>: <expr_stmt><expr><call><name>fstd</name><argument_list>(<argument><expr><name>fr5</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case><case>case <expr>3</expr>: <expr_stmt><expr><call><name>fstd</name><argument_list>(<argument><expr><name>fr7</name></expr></argument>, <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
	    </case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	  <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
	  <comment type="block">/* Structs smaller or equal than 4 bytes are passed in one
	     register. Structs smaller or equal 8 bytes are passed in two
	     registers. Larger structures are passed by pointer.  */</comment>
	  <if>if<condition>(<expr><name>(*<name>p_arg</name>)-&gt;<name>size</name></name> &lt;= 4</expr>)</condition><then>
	    <block>{
	      <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + <sizeof>sizeof<argument_list>(<argument><expr><name>UINT32</name></expr></argument>)</argument_list></sizeof> -
		<name>(*<name>p_arg</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
	    }</block></then>
	  <else>else <if>if <condition>(<expr><name>(*<name>p_arg</name>)-&gt;<name>size</name></name> &lt;= 8</expr>)</condition><then>
	    <block>{
	      <expr_stmt><expr><name>slot</name> += (<name>slot</name> &amp; 1) ? 1 : 2</expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name>stack</name> - <name>slot</name></expr></argument>)</argument_list></call> + <sizeof>sizeof<argument_list>(<argument><expr><name>UINT64</name></expr></argument>)</argument_list></sizeof> -
		<name>(*<name>p_arg</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
	    }</block></then>
	  <else>else
	    <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>void</name> *) *(<name>stack</name> - <name>slot</name>)</expr>;</expr_stmt></else></if></else></if>
	  <break>break;</break>

	</case><default>default:
	  <expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</default>}</block></switch>

      <expr_stmt><expr><name>slot</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>p_arg</name>++</expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Invoke the closure.  */</comment>
  <expr_stmt><expr><call>(<name><name>closure</name>-&gt;<name>fun</name></name>) <argument_list>(<argument><expr><name>cif</name></expr></argument>, <argument><expr><name>rvalue</name></expr></argument>, <argument><expr><name>avalue</name></expr></argument>, <argument><expr><name><name>closure</name>-&gt;<name>user_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr>"after calling function, ret[0] = %08x, ret[1] = %08x\n"</expr></argument>, <argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name></expr></argument>,
	<argument><expr><name><name>ret</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Store the result using the lower 2 bytes of the flags.  */</comment>
  <switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>flags</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
      <expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <call>(<name>UINT8</name>)<argument_list>(<argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
      <expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <call>(<name>SINT8</name>)<argument_list>(<argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
      <expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <call>(<name>UINT16</name>)<argument_list>(<argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
      <expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <call>(<name>SINT16</name>)<argument_list>(<argument><expr><name><name>ret</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>FFI_TYPE_INT</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
      <expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <name><name>ret</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
      <expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <name><name>ret</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name> - 1) = <name><name>ret</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
      <expr_stmt><expr><call><name>fldd</name><argument_list>(<argument><expr><name>rvalue</name></expr></argument>, <argument><expr><name>fr4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
      <expr_stmt><expr><call><name>fldw</name><argument_list>(<argument><expr><name>rvalue</name></expr></argument>, <argument><expr><name>fr4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
      <comment type="block">/* Don't need a return value, done by caller.  */</comment>
      <break>break;</break>

    </case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT2</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT3</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT4</name></expr>:
      <expr_stmt><expr><name>tmp</name> = <call>(<name>void</name>*)<argument_list>(<argument><expr><name>stack</name> -  <name>FIRST_ARG_SLOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp</name> += 4 - <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>void</name>*)<name>tmp</name></expr></argument>, <argument><expr>&amp;<name><name>ret</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT5</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT6</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT7</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT8</name></expr>:
      <block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>ret2</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>

	<comment type="block">/* Right justify ret[0] and ret[1] */</comment>
	<switch>switch <condition>(<expr><name><name>cif</name>-&gt;<name>flags</name></name></expr>)</condition>
	  <block>{
	    <case>case <expr><name>FFI_TYPE_SMALL_STRUCT5</name></expr>: <expr_stmt><expr><name>off</name> = 3</expr>;</expr_stmt> <break>break;</break>
	    </case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT6</name></expr>: <expr_stmt><expr><name>off</name> = 2</expr>;</expr_stmt> <break>break;</break>
	    </case><case>case <expr><name>FFI_TYPE_SMALL_STRUCT7</name></expr>: <expr_stmt><expr><name>off</name> = 1</expr>;</expr_stmt> <break>break;</break>
	    </case><default>default: <expr_stmt><expr><name>off</name> = 0</expr>;</expr_stmt> <break>break;</break>
	  </default>}</block></switch>

	<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>ret2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ret2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr>(<name>char</name> *)<name>ret2</name> + <name>off</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr>8 - <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name>) = <name><name>ret2</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr>*(<name>stack</name> - <name>FIRST_ARG_SLOT</name> - 1) = <name><name>ret2</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
      }</block>
      <break>break;</break>

    </case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_VOID</name></expr>:
      <break>break;</break>

    </case><default>default:
      <expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"assert with cif-&gt;flags: %d\n"</expr></argument>,<argument><expr><name><name>cif</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </default>}</block></switch>
  <return>return <expr><name>FFI_OK</name></expr>;</return>
}</block>

<comment type="block">/* Fill in a closure to refer to the specified fun and user_data.
   cif specifies the argument and result types for fun.
   The cif must already be prep'ed.  */</comment>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ffi_closure_pa32</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<function><type><name>ffi_status</name></type>
<name>ffi_prep_closure_loc</name> <parameter_list>(<param><decl><type><name>ffi_closure</name>*</type> <name>closure</name></decl></param>,
		      <param><decl><type><name>ffi_cif</name>*</type> <name>cif</name></decl></param>,
		      <param><function_decl><type><name>void</name></type> (*<name>fun</name>)<parameter_list>(<param><decl><type><name>ffi_cif</name>*</type></decl></param>,<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>void</name>**</type></decl></param>,<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>,
		      <param><decl><type><name>void</name> *</type><name>user_data</name></decl></param>,
		      <param><decl><type><name>void</name> *</type><name>codeloc</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>UINT32</name> *</type><name>tramp</name> <init>= <expr><call>(<name>UINT32</name> *)<argument_list>(<argument><expr><name><name>closure</name>-&gt;<name>tramp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PA_HPUX</name></cpp:ifdef>
  <decl_stmt><decl><type><name>UINT32</name> *</type><name>tmp</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>FFI_ASSERT</name> <argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>abi</name></name> == <name>FFI_PA32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a small trampoline that will branch to our
     handler function. Use PC-relative addressing.  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PA_LINUX</name></cpp:ifdef>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>0</expr>]</index></name> = 0xeaa00000</expr>;</expr_stmt> <comment type="block">/* b,l .+8,%r21        ; %r21 &lt;- pc+8 */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>1</expr>]</index></name> = 0xd6a01c1e</expr>;</expr_stmt> <comment type="block">/* depi 0,31,2,%r21    ; mask priv bits */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>2</expr>]</index></name> = 0x4aa10028</expr>;</expr_stmt> <comment type="block">/* ldw 20(%r21),%r1    ; load plabel */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>3</expr>]</index></name> = 0x36b53ff1</expr>;</expr_stmt> <comment type="block">/* ldo -8(%r21),%r21   ; get closure addr */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>4</expr>]</index></name> = 0x0c201096</expr>;</expr_stmt> <comment type="block">/* ldw 0(%r1),%r22     ; address of handler */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>5</expr>]</index></name> = 0xeac0c000</expr>;</expr_stmt> <comment type="block">/* bv%r0(%r22)         ; branch to handler */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>6</expr>]</index></name> = 0x0c281093</expr>;</expr_stmt> <comment type="block">/* ldw 4(%r1),%r19     ; GP of handler */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>7</expr>]</index></name> = (<call>(<name>UINT32</name>)<argument_list>(<argument><expr><name>ffi_closure_pa32</name></expr></argument>)</argument_list></call> &amp; ~2)</expr>;</expr_stmt>

  <comment type="block">/* Flush d/icache -- have to flush up 2 two lines because of
     alignment.  */</comment>
  <asm>__asm__ <specifier>volatile</specifier>(
		   "fdc 0(%0)\n\t"
		   "fdc %1(%0)\n\t"
		   "fic 0(%%sr4, %0)\n\t"
		   "fic %1(%%sr4, %0)\n\t"
		   "sync\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n"
		   :
		   : "r"((unsigned long)tramp &amp; ~31),
		     "r"(32 <comment type="block">/* stride */</comment>)
		   : "memory");</asm>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PA_HPUX</name></cpp:ifdef>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>0</expr>]</index></name> = 0xeaa00000</expr>;</expr_stmt> <comment type="block">/* b,l .+8,%r21        ; %r21 &lt;- pc+8  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>1</expr>]</index></name> = 0xd6a01c1e</expr>;</expr_stmt> <comment type="block">/* depi 0,31,2,%r21    ; mask priv bits  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>2</expr>]</index></name> = 0x4aa10038</expr>;</expr_stmt> <comment type="block">/* ldw 28(%r21),%r1    ; load plabel  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>3</expr>]</index></name> = 0x36b53ff1</expr>;</expr_stmt> <comment type="block">/* ldo -8(%r21),%r21   ; get closure addr  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>4</expr>]</index></name> = 0x0c201096</expr>;</expr_stmt> <comment type="block">/* ldw 0(%r1),%r22     ; address of handler  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>5</expr>]</index></name> = 0x02c010b4</expr>;</expr_stmt> <comment type="block">/* ldsid (%r22),%r20   ; load space id  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>6</expr>]</index></name> = 0x00141820</expr>;</expr_stmt> <comment type="block">/* mtsp %r20,%sr0      ; into %sr0  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>7</expr>]</index></name> = 0xe2c00000</expr>;</expr_stmt> <comment type="block">/* be 0(%sr0,%r22)     ; branch to handler  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>8</expr>]</index></name> = 0x0c281093</expr>;</expr_stmt> <comment type="block">/* ldw 4(%r1),%r19     ; GP of handler  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>9</expr>]</index></name> = (<call>(<name>UINT32</name>)<argument_list>(<argument><expr><name>ffi_closure_pa32</name></expr></argument>)</argument_list></call> &amp; ~2)</expr>;</expr_stmt>

  <comment type="block">/* Flush d/icache -- have to flush three lines because of alignment.  */</comment>
  <asm>__asm__ <specifier>volatile</specifier>(
		   "copy %1,%0\n\t"
		   "fdc,m %2(%0)\n\t"
		   "fdc,m %2(%0)\n\t"
		   "fdc,m %2(%0)\n\t"
		   "ldsid (%1),%0\n\t"
		   "mtsp %0,%%sr0\n\t"
		   "copy %1,%0\n\t"
		   "fic,m %2(%%sr0,%0)\n\t"
		   "fic,m %2(%%sr0,%0)\n\t"
		   "fic,m %2(%%sr0,%0)\n\t"
		   "sync\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n\t"
		   "nop\n"
		   : "=&amp;r" ((unsigned long)tmp)
		   : "r" ((unsigned long)tramp &amp; ~31),
		     "r" (32<comment type="block">/* stride */</comment>)
		   : "memory");</asm>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>closure</name>-&gt;<name>cif</name></name>  = <name>cif</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>closure</name>-&gt;<name>user_data</name></name> = <name>user_data</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>closure</name>-&gt;<name>fun</name></name>  = <name>fun</name></expr>;</expr_stmt>

  <return>return <expr><name>FFI_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
