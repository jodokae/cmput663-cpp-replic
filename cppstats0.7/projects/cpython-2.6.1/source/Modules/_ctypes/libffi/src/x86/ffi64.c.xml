<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_ctypes/libffi/src/x86/ffi64.c"><comment type="block">/* -----------------------------------------------------------------------
   ffi.c - Copyright (c) 2002, 2007  Bo Thorsen &lt;bo@suse.de&gt;
           Copyright (c) 2008  Red Hat, Inc.
   
   x86-64 Foreign Function Interface 

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   ``Software''), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
   ----------------------------------------------------------------------- */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ffi_common.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__x86_64__</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_GPR_REGS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SSE_REGS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<struct>struct <name>register_args</name>
<block>{
  <comment type="block">/* Registers for argument passing.  */</comment>
  <decl_stmt><decl><type><name>UINT64</name></type> <name><name>gpr</name><index>[<expr><name>MAX_GPR_REGS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__int128_t</name></type> <name><name>sse</name><index>[<expr><name>MAX_SSE_REGS</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ffi_call_unix64</name> <parameter_list>(<param><decl><type><name>void</name> *</type><name>args</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>bytes</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>,
			     <param><decl><type><name>void</name> *</type><name>raddr</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>fnaddr</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>, <param><decl><type><name>unsigned</name></type> <name>ssecount</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* All reference to register classes here is identical to the code in
   gcc/config/i386/i386.c. Do *not* change one without the other.  */</comment>

<comment type="block">/* Register class used for passing given 64bit part of the argument.
   These represent classes as documented by the PS ABI, with the exception
   of SSESF, SSEDF classes, that are basically SSE class, just gcc will
   use SF or DFmode move instead of DImode to avoid reformating penalties.

   Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves
   whenever possible (upper half does contain padding).  */</comment>
<enum>enum <name>x86_64_reg_class</name>
  <block>{
    <decl><name>X86_64_NO_CLASS</name></decl>,
    <decl><name>X86_64_INTEGER_CLASS</name></decl>,
    <decl><name>X86_64_INTEGERSI_CLASS</name></decl>,
    <decl><name>X86_64_SSE_CLASS</name></decl>,
    <decl><name>X86_64_SSESF_CLASS</name></decl>,
    <decl><name>X86_64_SSEDF_CLASS</name></decl>,
    <decl><name>X86_64_SSEUP_CLASS</name></decl>,
    <decl><name>X86_64_X87_CLASS</name></decl>,
    <decl><name>X86_64_X87UP_CLASS</name></decl>,
    <decl><name>X86_64_COMPLEX_X87_CLASS</name></decl>,
    <decl><name>X86_64_MEMORY_CLASS</name></decl>
  }</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CLASSES</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SSE_CLASS_P</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((X) &gt;= X86_64_SSE_CLASS &amp;&amp; X &lt;= X86_64_SSEUP_CLASS)</cpp:value></cpp:define>

<comment type="block">/* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal
   of this code is to classify each 8bytes of incoming argument by the register
   class and assign registers accordingly.  */</comment>

<comment type="block">/* Return the union class of CLASS1 and CLASS2.
   See the x86-64 PS ABI for details.  */</comment>

<enum><specifier>static</specifier> enum <name>x86_64_reg_class</name>
<name>merge_classes</name> <expr_stmt><expr>(enum <name>x86_64_reg_class</name> <name>class1</name>, enum <name>x86_64_reg_class</name> <name>class2</name>)
<block>{
  <comment type="block">/* Rule #1: If both classes are equal, this is the resulting class.  */</comment>
  <if>if <condition>(<expr><name>class1</name> == <name>class2</name></expr>)</condition><then>
    <return>return <expr><name>class1</name></expr>;</return></then></if></block></expr></expr_stmt></enum>

  <comment type="block">/* Rule #2: If one of the classes is NO_CLASS, the resulting class is
     the other class.  */</comment>
  <if>if <condition>(<expr><name>class1</name> == <name>X86_64_NO_CLASS</name></expr>)</condition><then>
    <return>return <expr><name>class2</name></expr>;</return></then></if>
  <if>if <condition>(<expr><name>class2</name> == <name>X86_64_NO_CLASS</name></expr>)</condition><then>
    <return>return <expr><name>class1</name></expr>;</return></then></if>

  <comment type="block">/* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */</comment>
  <if>if <condition>(<expr><name>class1</name> == <name>X86_64_MEMORY_CLASS</name> || <name>class2</name> == <name>X86_64_MEMORY_CLASS</name></expr>)</condition><then>
    <return>return <expr><name>X86_64_MEMORY_CLASS</name></expr>;</return></then></if>

  <comment type="block">/* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */</comment>
  <if>if <condition>(<expr>(<name>class1</name> == <name>X86_64_INTEGERSI_CLASS</name> &amp;&amp; <name>class2</name> == <name>X86_64_SSESF_CLASS</name>)
      || (<name>class2</name> == <name>X86_64_INTEGERSI_CLASS</name> &amp;&amp; <name>class1</name> == <name>X86_64_SSESF_CLASS</name>)</expr>)</condition><then>
    <return>return <expr><name>X86_64_INTEGERSI_CLASS</name></expr>;</return></then></if>
  <if>if <condition>(<expr><name>class1</name> == <name>X86_64_INTEGER_CLASS</name> || <name>class1</name> == <name>X86_64_INTEGERSI_CLASS</name>
      || <name>class2</name> == <name>X86_64_INTEGER_CLASS</name> || <name>class2</name> == <name>X86_64_INTEGERSI_CLASS</name></expr>)</condition><then>
    <return>return <expr><name>X86_64_INTEGER_CLASS</name></expr>;</return></then></if>

  <comment type="block">/* Rule #5: If one of the classes is X87, X87UP, or COMPLEX_X87 class,
     MEMORY is used.  */</comment>
  <if>if <condition>(<expr><name>class1</name> == <name>X86_64_X87_CLASS</name>
      || <name>class1</name> == <name>X86_64_X87UP_CLASS</name>
      || <name>class1</name> == <name>X86_64_COMPLEX_X87_CLASS</name>
      || <name>class2</name> == <name>X86_64_X87_CLASS</name>
      || <name>class2</name> == <name>X86_64_X87UP_CLASS</name>
      || <name>class2</name> == <name>X86_64_COMPLEX_X87_CLASS</name></expr>)</condition><then>
    <return>return <expr><name>X86_64_MEMORY_CLASS</name></expr>;</return></then></if>

  <comment type="block">/* Rule #6: Otherwise class SSE is used.  */</comment>
  <return>return <expr><name>X86_64_SSE_CLASS</name></expr>;</return>
}

<comment type="block">/* Classify the argument of type TYPE and mode MODE.
   CLASSES will be filled by the register class used to pass each word
   of the operand.  The number of words is returned.  In case the parameter
   should be passed in memory, 0 is returned. As a special case for zero
   sized containers, classes[0] will be NO_CLASS and 1 is returned.

   See the x86-64 PS ABI for details.
*/</comment>
static <decl_stmt><decl><type><name>int</name></type>
<name>classify_argument</name> <argument_list>(<argument><expr><name>ffi_type</name> *<name>type</name></expr></argument>, <argument>enum <expr><name>x86_64_reg_class</name> <name><name>classes</name><index>[]</index></name></expr></argument>,
		   <argument><expr><name>size_t</name> <name>byte_offset</name></expr></argument>)</argument_list>
<block>{
  <switch>switch <condition>(<expr><name><name>type</name>-&gt;<name>type</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>FFI_TYPE_UINT8</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SINT8</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_UINT16</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SINT16</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_UINT32</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SINT32</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_UINT64</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_SINT64</name></expr>:
    </case><case>case <expr><name>FFI_TYPE_POINTER</name></expr>:
      <if>if <condition>(<expr><name>byte_offset</name> + <name><name>type</name>-&gt;<name>size</name></name> &lt;= 4</expr>)</condition><then>
	<expr_stmt><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name> = <name>X86_64_INTEGERSI_CLASS</name></expr>;</expr_stmt></then>
      <else>else
	<expr_stmt><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name> = <name>X86_64_INTEGER_CLASS</name></expr>;</expr_stmt></else></if>
      <return>return <expr>1</expr>;</return>
    </case><case>case <expr><name>FFI_TYPE_FLOAT</name></expr>:
      <if>if <condition>(<expr><name>byte_offset</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name> = <name>X86_64_SSESF_CLASS</name></expr>;</expr_stmt></then>
      <else>else
	<expr_stmt><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name> = <name>X86_64_SSE_CLASS</name></expr>;</expr_stmt></else></if>
      <return>return <expr>1</expr>;</return>
    </case><case>case <expr><name>FFI_TYPE_DOUBLE</name></expr>:
      <expr_stmt><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name> = <name>X86_64_SSEDF_CLASS</name></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    </case><case>case <expr><name>FFI_TYPE_LONGDOUBLE</name></expr>:
      <expr_stmt><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name> = <name>X86_64_X87_CLASS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>classes</name><index>[<expr>1</expr>]</index></name> = <name>X86_64_X87UP_CLASS</name></expr>;</expr_stmt>
      <return>return <expr>2</expr>;</return>
    </case><case>case <expr><name>FFI_TYPE_STRUCT</name></expr>:
      <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>UNITS_PER_WORD</name> <init>= <expr>8</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>words</name> <init>= <expr>(<name><name>type</name>-&gt;<name>size</name></name> + <name>UNITS_PER_WORD</name> - 1) / <name>UNITS_PER_WORD</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ffi_type</name> **</type><name>ptr</name></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<enum>enum <name>x86_64_reg_class</name> <name><name>subclasses</name><index>[<expr><name>MAX_CLASSES</name></expr>]</index></name>;</enum>

	<comment type="block">/* If the struct is larger than 16 bytes, pass it on the stack.  */</comment>
	<if>if <condition>(<expr><name><name>type</name>-&gt;<name>size</name></name> &gt; 16</expr>)</condition><then>
	  <return>return <expr>0</expr>;</return></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>words</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	  <expr_stmt><expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name> = <name>X86_64_NO_CLASS</name></expr>;</expr_stmt></for>

	<comment type="block">/* Merge the fields of structure.  */</comment>
	<for>for (<init><expr><name>ptr</name> = <name><name>type</name>-&gt;<name>elements</name></name></expr>;</init> <condition><expr>*<name>ptr</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>ptr</name>++</expr></incr>)
	  <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>byte_offset</name> = <call><name>ALIGN</name> <argument_list>(<argument><expr><name>byte_offset</name></expr></argument>, <argument><expr><name>(*<name>ptr</name>)-&gt;<name>alignment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><name>num</name> = <call><name>classify_argument</name> <argument_list>(<argument><expr>*<name>ptr</name></expr></argument>, <argument><expr><name>subclasses</name></expr></argument>, <argument><expr><name>byte_offset</name> % 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>num</name> == 0</expr>)</condition><then>
	      <return>return <expr>0</expr>;</return></then></if>
	    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	      <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name>byte_offset</name> / 8</expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>classes</name><index>[<expr><name>i</name> + <name>pos</name></expr>]</index></name> =
		  <call><name>merge_classes</name> <argument_list>(<argument><expr><name><name>subclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>classes</name><index>[<expr><name>i</name> + <name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      }</block></for>

	    <expr_stmt><expr><name>byte_offset</name> += <name>(*<name>ptr</name>)-&gt;<name>size</name></name></expr>;</expr_stmt>
	  }</block></for>

	<comment type="block">/* Final merger cleanup.  */</comment>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>words</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	  <block>{
	    <comment type="block">/* If one class is MEMORY, everything should be passed in
	       memory.  */</comment>
	    <if>if <condition>(<expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name> == <name>X86_64_MEMORY_CLASS</name></expr>)</condition><then>
	      <return>return <expr>0</expr>;</return></then></if>

	    <comment type="block">/* The X86_64_SSEUP_CLASS should be always preceded by
	       X86_64_SSE_CLASS.  */</comment>
	    <if>if <condition>(<expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name> == <name>X86_64_SSEUP_CLASS</name>
		&amp;&amp; (<name>i</name> == 0 || <name><name>classes</name><index>[<expr><name>i</name> - 1</expr>]</index></name> != <name>X86_64_SSE_CLASS</name>)</expr>)</condition><then>
	      <expr_stmt><expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name> = <name>X86_64_SSE_CLASS</name></expr>;</expr_stmt></then></if>

	    <comment type="block">/*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */</comment>
	    <if>if <condition>(<expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name> == <name>X86_64_X87UP_CLASS</name>
		&amp;&amp; (<name>i</name> == 0 || <name><name>classes</name><index>[<expr><name>i</name> - 1</expr>]</index></name> != <name>X86_64_X87_CLASS</name>)</expr>)</condition><then>
	      <expr_stmt><expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name> = <name>X86_64_SSE_CLASS</name></expr>;</expr_stmt></then></if>
	  }</block></for>
	<return>return <expr><name>words</name></expr>;</return>
      }</block>

    </case><default>default:
      <expr_stmt><expr><call><name>FFI_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>
  <return>return <expr>0</expr>;</return> <comment type="block">/* Never reached.  */</comment>
}</block></decl></decl_stmt>

<comment type="block">/* Examine the argument and return set number of register required in each
   class.  Return zero iff parameter should be passed in memory, otherwise
   the number of registers.  */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>
<name>examine_argument</name> <argument_list>(<argument><expr><name>ffi_type</name> *<name>type</name></expr></argument>, <argument>enum <expr><name>x86_64_reg_class</name> <name><name>classes</name><index>[<expr><name>MAX_CLASSES</name></expr>]</index></name></expr></argument>,
		  <argument><expr><name>_Bool</name> <name>in_return</name></expr></argument>, <argument><expr><name>int</name> *<name>pngpr</name></expr></argument>, <argument><expr><name>int</name> *<name>pnsse</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>ngpr</name></decl>, <decl><type ref="prev"/><name>nsse</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>n</name> = <call><name>classify_argument</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>classes</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <expr_stmt><expr><name>ngpr</name> = <name>nsse</name> = 0</expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <switch>switch <condition>(<expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
      <block>{
      <case>case <expr><name>X86_64_INTEGER_CLASS</name></expr>:
      </case><case>case <expr><name>X86_64_INTEGERSI_CLASS</name></expr>:
	<expr_stmt><expr><name>ngpr</name>++</expr>;</expr_stmt>
	<break>break;</break>
      </case><case>case <expr><name>X86_64_SSE_CLASS</name></expr>:
      </case><case>case <expr><name>X86_64_SSESF_CLASS</name></expr>:
      </case><case>case <expr><name>X86_64_SSEDF_CLASS</name></expr>:
	<expr_stmt><expr><name>nsse</name>++</expr>;</expr_stmt>
	<break>break;</break>
      </case><case>case <expr><name>X86_64_NO_CLASS</name></expr>:
      </case><case>case <expr><name>X86_64_SSEUP_CLASS</name></expr>:
	<break>break;</break>
      </case><case>case <expr><name>X86_64_X87_CLASS</name></expr>:
      </case><case>case <expr><name>X86_64_X87UP_CLASS</name></expr>:
      </case><case>case <expr><name>X86_64_COMPLEX_X87_CLASS</name></expr>:
	<return>return <expr><name>in_return</name> != 0</expr>;</return>
      </case><default>default:
	<expr_stmt><expr><call><name>abort</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
      </default>}</block></switch></for>

  <expr_stmt><expr>*<name>pngpr</name> = <name>ngpr</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pnsse</name> = <name>nsse</name></expr>;</expr_stmt>

  <return>return <expr><name>n</name></expr>;</return>
}</block></decl></decl_stmt>

<comment type="block">/* Perform machine dependent cif processing.  */</comment>

<function><type><name>ffi_status</name></type>
<name>ffi_prep_cif_machdep</name> <parameter_list>(<param><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>gprcount</name></decl>, <decl><type ref="prev"/><name>ssecount</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>avn</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>ngpr</name></decl>, <decl><type ref="prev"/><name>nsse</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>
  <enum>enum <name>x86_64_reg_class</name> <name><name>classes</name><index>[<expr><name>MAX_CLASSES</name></expr>]</index></name>;</enum>
  <decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>gprcount</name> = <name>ssecount</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><name>flags</name> = <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>flags</name> != <name>FFI_TYPE_VOID</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>n</name> = <call><name>examine_argument</name> <argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name></name></expr></argument>, <argument><expr><name>classes</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>ngpr</name></expr></argument>, <argument><expr>&amp;<name>nsse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
	<block>{
	  <comment type="block">/* The return value is passed in memory.  A pointer to that
	     memory is the first argument.  Allocate a register for it.  */</comment>
	  <expr_stmt><expr><name>gprcount</name>++</expr>;</expr_stmt>
	  <comment type="block">/* We don't have to do anything in asm for the return.  */</comment>
	  <expr_stmt><expr><name>flags</name> = <name>FFI_TYPE_VOID</name></expr>;</expr_stmt>
	}</block></then>
      <else>else <if>if <condition>(<expr><name>flags</name> == <name>FFI_TYPE_STRUCT</name></expr>)</condition><then>
	<block>{
	  <comment type="block">/* Mark which registers the result appears in.  */</comment>
	  <decl_stmt><decl><type><name>_Bool</name></type> <name>sse0</name> <init>= <expr><call><name>SSE_CLASS_P</name> <argument_list>(<argument><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>_Bool</name></type> <name>sse1</name> <init>= <expr><name>n</name> == 2 &amp;&amp; <call><name>SSE_CLASS_P</name> <argument_list>(<argument><expr><name><name>classes</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if>if <condition>(<expr><name>sse0</name> &amp;&amp; !<name>sse1</name></expr>)</condition><then>
	    <expr_stmt><expr><name>flags</name> |= 1 &lt;&lt; 8</expr>;</expr_stmt></then>
	  <else>else <if>if <condition>(<expr>!<name>sse0</name> &amp;&amp; <name>sse1</name></expr>)</condition><then>
	    <expr_stmt><expr><name>flags</name> |= 1 &lt;&lt; 9</expr>;</expr_stmt></then>
	  <else>else <if>if <condition>(<expr><name>sse0</name> &amp;&amp; <name>sse1</name></expr>)</condition><then>
	    <expr_stmt><expr><name>flags</name> |= 1 &lt;&lt; 10</expr>;</expr_stmt></then></if></else></if></else></if>
	  <comment type="block">/* Mark the true size of the structure.  */</comment>
	  <expr_stmt><expr><name>flags</name> |= <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>size</name></name> &lt;&lt; 12</expr>;</expr_stmt>
	}</block></then></if></else></if>
    }</block></then></if>

  <comment type="block">/* Go over all arguments and determine the way they should be passed.
     If it's in a register and there is space for it, let that be so. If
     not, add it's size to the stack byte count.  */</comment>
  <for>for (<init><expr><name>bytes</name> = 0</expr>, <expr><name>i</name> = 0</expr>, <expr><name>avn</name> = <name><name>cif</name>-&gt;<name>nargs</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name>avn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><call><name>examine_argument</name> <argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>classes</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>ngpr</name></expr></argument>, <argument><expr>&amp;<name>nsse</name></expr></argument>)</argument_list></call> == 0
	  || <name>gprcount</name> + <name>ngpr</name> &gt; <name>MAX_GPR_REGS</name>
	  || <name>ssecount</name> + <name>nsse</name> &gt; <name>MAX_SSE_REGS</name></expr>)</condition><then>
	<block>{
	  <decl_stmt><decl><type><name>long</name></type> <name>align</name> <init>= <expr><name><name>cif</name>-&gt;<name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>alignment</name></expr></init></decl>;</decl_stmt>

	  <if>if <condition>(<expr><name>align</name> &lt; 8</expr>)</condition><then>
	    <expr_stmt><expr><name>align</name> = 8</expr>;</expr_stmt></then></if>

	  <expr_stmt><expr><name>bytes</name> = <call><name>ALIGN</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>bytes</name> += <name><name>cif</name>-&gt;<name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>size</name></expr>;</expr_stmt>
	}</block></then>
      <else>else
	<block>{
	  <expr_stmt><expr><name>gprcount</name> += <name>ngpr</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>ssecount</name> += <name>nsse</name></expr>;</expr_stmt>
	}</block></else></if>
    }</block></for>
  <if>if <condition>(<expr><name>ssecount</name></expr>)</condition><then>
    <expr_stmt><expr><name>flags</name> |= 1 &lt;&lt; 11</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>cif</name>-&gt;<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cif</name>-&gt;<name>bytes</name></name> = <name>bytes</name></expr>;</expr_stmt>

  <return>return <expr><name>FFI_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>ffi_call</name> <parameter_list>(<param><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>fn</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>, <param><decl><type><name>void</name> *</type><name>rvalue</name></decl></param>, <param><decl><type><name>void</name> **</type><name>avalue</name></decl></param>)</parameter_list>
<block>{
  <enum>enum <name>x86_64_reg_class</name> <name><name>classes</name><index>[<expr><name>MAX_CLASSES</name></expr>]</index></name>;</enum>
  <decl_stmt><decl><type><name>char</name> *</type><name>stack</name></decl>, *<decl><type ref="prev"/><name>argp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ffi_type</name> **</type><name>arg_types</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>gprcount</name></decl>, <decl><type ref="prev"/><name>ssecount</name></decl>, <decl><type ref="prev"/><name>ngpr</name></decl>, <decl><type ref="prev"/><name>nsse</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>avn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_Bool</name></type> <name>ret_in_memory</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>register_args</name> *</type><name>reg_args</name></decl>;</decl_stmt>

  <comment type="block">/* Can't call 32-bit mode from 64-bit mode.  */</comment>
  <expr_stmt><expr><call><name>FFI_ASSERT</name> <argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>abi</name></name> == <name>FFI_UNIX64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the return value is a struct and we don't have a return value
     address then we need to make one.  Note the setting of flags to
     VOID above in ffi_prep_cif_machdep.  */</comment>
  <expr_stmt><expr><name>ret_in_memory</name> = (<name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name> == <name>FFI_TYPE_STRUCT</name>
		   &amp;&amp; (<name><name>cif</name>-&gt;<name>flags</name></name> &amp; 0xff) == <name>FFI_TYPE_VOID</name>)</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>rvalue</name> == <name>NULL</name> &amp;&amp; <name>ret_in_memory</name></expr>)</condition><then>
    <expr_stmt><expr><name>rvalue</name> = <call><name>alloca</name> <argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Allocate the space for the arguments, plus 4 words of temp space.  */</comment>
  <expr_stmt><expr><name>stack</name> = <call><name>alloca</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument>struct <expr><name>register_args</name></expr></argument>)</argument_list></sizeof> + <name><name>cif</name>-&gt;<name>bytes</name></name> + 4*8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>reg_args</name> = (struct <name>register_args</name> *) <name>stack</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>argp</name> = <name>stack</name> + <sizeof>sizeof <argument_list>(<argument>struct <expr><name>register_args</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

  <expr_stmt><expr><name>gprcount</name> = <name>ssecount</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* If the return value is passed in memory, add the pointer as the
     first integer argument.  */</comment>
  <if>if <condition>(<expr><name>ret_in_memory</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>reg_args</name>-&gt;<name>gpr</name><index>[<expr><name>gprcount</name>++</expr>]</index></name> = (<name>long</name>) <name>rvalue</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>avn</name> = <name><name>cif</name>-&gt;<name>nargs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>arg_types</name> = <name><name>cif</name>-&gt;<name>arg_types</name></name></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>avn</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>size</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>n</name> = <call><name>examine_argument</name> <argument_list>(<argument><expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>classes</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>ngpr</name></expr></argument>, <argument><expr>&amp;<name>nsse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>n</name> == 0
	  || <name>gprcount</name> + <name>ngpr</name> &gt; <name>MAX_GPR_REGS</name>
	  || <name>ssecount</name> + <name>nsse</name> &gt; <name>MAX_SSE_REGS</name></expr>)</condition><then>
	<block>{
	  <decl_stmt><decl><type><name>long</name></type> <name>align</name> <init>= <expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>alignment</name></expr></init></decl>;</decl_stmt>

	  <comment type="block">/* Stack arguments are *always* at least 8 byte aligned.  */</comment>
	  <if>if <condition>(<expr><name>align</name> &lt; 8</expr>)</condition><then>
	    <expr_stmt><expr><name>align</name> = 8</expr>;</expr_stmt></then></if>

	  <comment type="block">/* Pass this argument in memory.  */</comment>
	  <expr_stmt><expr><name>argp</name> = (<name>void</name> *) <call><name>ALIGN</name> <argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>argp</name> += <name>size</name></expr>;</expr_stmt>
	}</block></then>
      <else>else
	<block>{
	  <comment type="block">/* The argument is passed entirely in registers.  */</comment>
	  <decl_stmt><decl><type><name>char</name> *</type><name>a</name> <init>= <expr>(<name>char</name> *) <name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

	  <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>a</name> += 8</expr>, <expr><name>size</name> -= 8</expr></incr>)
	    <block>{
	      <switch>switch <condition>(<expr><name><name>classes</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
		<block>{
		<case>case <expr><name>X86_64_INTEGER_CLASS</name></expr>:
		</case><case>case <expr><name>X86_64_INTEGERSI_CLASS</name></expr>:
		  <expr_stmt><expr><name><name>reg_args</name>-&gt;<name>gpr</name><index>[<expr><name>gprcount</name></expr>]</index></name> = 0</expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr>&amp;<name><name>reg_args</name>-&gt;<name>gpr</name><index>[<expr><name>gprcount</name></expr>]</index></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>size</name> &lt; 8 ? <name>size</name> : 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name>gprcount</name>++</expr>;</expr_stmt>
		  <break>break;</break>
		</case><case>case <expr><name>X86_64_SSE_CLASS</name></expr>:
		</case><case>case <expr><name>X86_64_SSEDF_CLASS</name></expr>:
		  <expr_stmt><expr><name><name>reg_args</name>-&gt;<name>sse</name><index>[<expr><name>ssecount</name>++</expr>]</index></name> = *(<name>UINT64</name> *) <name>a</name></expr>;</expr_stmt>
		  <break>break;</break>
		</case><case>case <expr><name>X86_64_SSESF_CLASS</name></expr>:
		  <expr_stmt><expr><name><name>reg_args</name>-&gt;<name>sse</name><index>[<expr><name>ssecount</name>++</expr>]</index></name> = *(<name>UINT32</name> *) <name>a</name></expr>;</expr_stmt>
		  <break>break;</break>
		</case><default>default:
		  <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</default>}</block></switch>
	    }</block></for>
	}</block></else></if>
    }</block></for>

  <expr_stmt><expr><call><name>ffi_call_unix64</name> <argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>cif</name>-&gt;<name>bytes</name></name> + <sizeof>sizeof <argument_list>(<argument>struct <expr><name>register_args</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		   <argument><expr><name><name>cif</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name>rvalue</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>ssecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ffi_closure_unix64</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<function><type><name>ffi_status</name></type>
<name>ffi_prep_closure_loc</name> <parameter_list>(<param><decl><type><name>ffi_closure</name>*</type> <name>closure</name></decl></param>,
		      <param><decl><type><name>ffi_cif</name>*</type> <name>cif</name></decl></param>,
		      <param><function_decl><type><name>void</name></type> (*<name>fun</name>)<parameter_list>(<param><decl><type><name>ffi_cif</name>*</type></decl></param>, <param><decl><type><name>void</name>*</type></decl></param>, <param><decl><type><name>void</name>**</type></decl></param>, <param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>,
		      <param><decl><type><name>void</name> *</type><name>user_data</name></decl></param>,
		      <param><decl><type><name>void</name> *</type><name>codeloc</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>short</name> *</type><name>tramp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>tramp</name> = (volatile <name>unsigned</name> <name>short</name> *) &amp;<name><name>closure</name>-&gt;<name>tramp</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>tramp</name><index>[<expr>0</expr>]</index></name> = 0xbb49</expr>;</expr_stmt>		<comment type="block">/* mov &lt;code&gt;, %r11	*/</comment>
  <expr_stmt><expr>*(<name>void</name> * volatile *) &amp;<name><name>tramp</name><index>[<expr>1</expr>]</index></name> = <name>ffi_closure_unix64</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>5</expr>]</index></name> = 0xba49</expr>;</expr_stmt>		<comment type="block">/* mov &lt;data&gt;, %r10	*/</comment>
  <expr_stmt><expr>*(<name>void</name> * volatile *) &amp;<name><name>tramp</name><index>[<expr>6</expr>]</index></name> = <name>codeloc</name></expr>;</expr_stmt>

  <comment type="block">/* Set the carry bit iff the function uses any sse registers.
     This is clc or stc, together with the first byte of the jmp.  */</comment>
  <expr_stmt><expr><name><name>tramp</name><index>[<expr>10</expr>]</index></name> = <name><name>cif</name>-&gt;<name>flags</name></name> &amp; (1 &lt;&lt; 11) ? 0x49f9 : 0x49f8</expr>;</expr_stmt>

  <expr_stmt><expr><name><name>tramp</name><index>[<expr>11</expr>]</index></name> = 0xe3ff</expr>;</expr_stmt>			<comment type="block">/* jmp *%r11    */</comment>

  <expr_stmt><expr><name><name>closure</name>-&gt;<name>cif</name></name> = <name>cif</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>closure</name>-&gt;<name>fun</name></name> = <name>fun</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>closure</name>-&gt;<name>user_data</name></name> = <name>user_data</name></expr>;</expr_stmt>

  <return>return <expr><name>FFI_OK</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>ffi_closure_unix64_inner</name><parameter_list>(<param><decl><type><name>ffi_closure</name> *</type><name>closure</name></decl></param>, <param><decl><type><name>void</name> *</type><name>rvalue</name></decl></param>,
			 <param><decl><type>struct <name>register_args</name> *</type><name>reg_args</name></decl></param>, <param><decl><type><name>char</name> *</type><name>argp</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>ffi_cif</name> *</type><name>cif</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> **</type><name>avalue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ffi_type</name> **</type><name>arg_types</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>avn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>gprcount</name></decl>, <decl><type ref="prev"/><name>ssecount</name></decl>, <decl><type ref="prev"/><name>ngpr</name></decl>, <decl><type ref="prev"/><name>nsse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>cif</name> = <name><name>closure</name>-&gt;<name>cif</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>avalue</name> = <call><name>alloca</name><argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>nargs</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>gprcount</name> = <name>ssecount</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><name>ret</name> = <name><name>cif</name>-&gt;<name>rtype</name>-&gt;<name>type</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>ret</name> != <name>FFI_TYPE_VOID</name></expr>)</condition><then>
    <block>{
      <enum>enum <name>x86_64_reg_class</name> <name><name>classes</name><index>[<expr><name>MAX_CLASSES</name></expr>]</index></name>;</enum>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>examine_argument</name> <argument_list>(<argument><expr><name><name>cif</name>-&gt;<name>rtype</name></name></expr></argument>, <argument><expr><name>classes</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>ngpr</name></expr></argument>, <argument><expr>&amp;<name>nsse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
	<block>{
	  <comment type="block">/* The return value goes in memory.  Arrange for the closure
	     return value to go directly back to the original caller.  */</comment>
	  <expr_stmt><expr><name>rvalue</name> = (<name>void</name> *) <name><name>reg_args</name>-&gt;<name>gpr</name><index>[<expr><name>gprcount</name>++</expr>]</index></name></expr>;</expr_stmt>
	  <comment type="block">/* We don't have to do anything in asm for the return.  */</comment>
	  <expr_stmt><expr><name>ret</name> = <name>FFI_TYPE_VOID</name></expr>;</expr_stmt>
	}</block></then>
      <else>else <if>if <condition>(<expr><name>ret</name> == <name>FFI_TYPE_STRUCT</name> &amp;&amp; <name>n</name> == 2</expr>)</condition><then>
	<block>{
	  <comment type="block">/* Mark which register the second word of the structure goes in.  */</comment>
	  <decl_stmt><decl><type><name>_Bool</name></type> <name>sse0</name> <init>= <expr><call><name>SSE_CLASS_P</name> <argument_list>(<argument><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>_Bool</name></type> <name>sse1</name> <init>= <expr><call><name>SSE_CLASS_P</name> <argument_list>(<argument><expr><name><name>classes</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if>if <condition>(<expr>!<name>sse0</name> &amp;&amp; <name>sse1</name></expr>)</condition><then>
	    <expr_stmt><expr><name>ret</name> |= 1 &lt;&lt; 8</expr>;</expr_stmt></then>
	  <else>else <if>if <condition>(<expr><name>sse0</name> &amp;&amp; !<name>sse1</name></expr>)</condition><then>
	    <expr_stmt><expr><name>ret</name> |= 1 &lt;&lt; 9</expr>;</expr_stmt></then></if></else></if>
	}</block></then></if></else></if>
    }</block></then></if>

  <expr_stmt><expr><name>avn</name> = <name><name>cif</name>-&gt;<name>nargs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>arg_types</name> = <name><name>cif</name>-&gt;<name>arg_types</name></name></expr>;</expr_stmt>
  
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>avn</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <enum>enum <name>x86_64_reg_class</name> <name><name>classes</name><index>[<expr><name>MAX_CLASSES</name></expr>]</index></name>;</enum>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>n</name> = <call><name>examine_argument</name> <argument_list>(<argument><expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>classes</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>ngpr</name></expr></argument>, <argument><expr>&amp;<name>nsse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>n</name> == 0
	  || <name>gprcount</name> + <name>ngpr</name> &gt; <name>MAX_GPR_REGS</name>
	  || <name>ssecount</name> + <name>nsse</name> &gt; <name>MAX_SSE_REGS</name></expr>)</condition><then>
	<block>{
	  <decl_stmt><decl><type><name>long</name></type> <name>align</name> <init>= <expr><name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>alignment</name></expr></init></decl>;</decl_stmt>

	  <comment type="block">/* Stack arguments are *always* at least 8 byte aligned.  */</comment>
	  <if>if <condition>(<expr><name>align</name> &lt; 8</expr>)</condition><then>
	    <expr_stmt><expr><name>align</name> = 8</expr>;</expr_stmt></then></if>

	  <comment type="block">/* Pass this argument in memory.  */</comment>
	  <expr_stmt><expr><name>argp</name> = (<name>void</name> *) <call><name>ALIGN</name> <argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>argp</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>argp</name> += <name><name>arg_types</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>size</name></expr>;</expr_stmt>
	}</block></then>
      <comment type="block">/* If the argument is in a single register, or two consecutive
	 registers, then we can use that address directly.  */</comment>
      <else>else <if>if <condition>(<expr><name>n</name> == 1
	       || (<name>n</name> == 2
		   &amp;&amp; <call><name>SSE_CLASS_P</name> <argument_list>(<argument><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> == <call><name>SSE_CLASS_P</name> <argument_list>(<argument><expr><name><name>classes</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
	<block>{
	  <comment type="block">/* The argument is in a single register.  */</comment>
	  <if>if <condition>(<expr><call><name>SSE_CLASS_P</name> <argument_list>(<argument><expr><name><name>classes</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <block>{
	      <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = &amp;<name><name>reg_args</name>-&gt;<name>sse</name><index>[<expr><name>ssecount</name></expr>]</index></name></expr>;</expr_stmt>
	      <expr_stmt><expr><name>ssecount</name> += <name>n</name></expr>;</expr_stmt>
	    }</block></then>
	  <else>else
	    <block>{
	      <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = &amp;<name><name>reg_args</name>-&gt;<name>gpr</name><index>[<expr><name>gprcount</name></expr>]</index></name></expr>;</expr_stmt>
	      <expr_stmt><expr><name>gprcount</name> += <name>n</name></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then>
      <comment type="block">/* Otherwise, allocate space to make them consecutive.  */</comment>
      <else>else
	<block>{
	  <decl_stmt><decl><type><name>char</name> *</type><name>a</name> <init>= <expr><call><name>alloca</name> <argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

	  <expr_stmt><expr><name><name>avalue</name><index>[<expr><name>i</name></expr>]</index></name> = <name>a</name></expr>;</expr_stmt>
	  <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>a</name> += 8</expr></incr>)
	    <block>{
	      <if>if <condition>(<expr><call><name>SSE_CLASS_P</name> <argument_list>(<argument><expr><name><name>classes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>&amp;<name><name>reg_args</name>-&gt;<name>sse</name><index>[<expr><name>ssecount</name>++</expr>]</index></name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	      <else>else
		<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>&amp;<name><name>reg_args</name>-&gt;<name>gpr</name><index>[<expr><name>gprcount</name>++</expr>]</index></name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	    }</block></for>
	}</block></else></if></else></if>
    }</block></for>

  <comment type="block">/* Invoke the closure.  */</comment>
  <expr_stmt><expr><call><name><name>closure</name>-&gt;<name>fun</name></name> <argument_list>(<argument><expr><name>cif</name></expr></argument>, <argument><expr><name>rvalue</name></expr></argument>, <argument><expr><name>avalue</name></expr></argument>, <argument><expr><name><name>closure</name>-&gt;<name>user_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Tell assembly how to perform return type promotions.  */</comment>
  <return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __x86_64__ */</comment>
</unit>
