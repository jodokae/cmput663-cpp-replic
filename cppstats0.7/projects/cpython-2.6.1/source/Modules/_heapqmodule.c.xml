<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_heapqmodule.c"><comment type="block">/* Drop in replacement for heapq.py 

C implementation derived directly from heapq.py in Py2.3
which was written by Kevin O'Connor, augmented by Tim Peters,
annotated by Fran√ßois Pinard, and converted to C by Raymond Hettinger.

*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<comment type="block">/* Older implementations of heapq used Py_LE for comparisons.  Now, it uses
   Py_LT so it will match min(), sorted(), and bisect().  Unfortunately, some
   client code (Twisted for example) relied on Py_LE, so this little function
   restores compatability by trying both.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_lt</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>x</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>y</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>lt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>lt</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>lt</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"__lt__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>lt</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>PyObject_HasAttr</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>Py_LT</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>cmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>Py_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cmp</name> != -1</expr>)</condition><then>
		<expr_stmt><expr><name>cmp</name> = 1 - <name>cmp</name></expr>;</expr_stmt></then></if>
	<return>return <expr><name>cmp</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_siftdown</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>heap</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newitem</name></decl>, *<decl><type ref="prev"/><name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>parentpos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pos</name> &gt;= <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>newitem</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Follow the path to the root, moving parents down until finding
	   a place newitem fits. */</comment>
	<while>while <condition>(<expr><name>pos</name> &gt; <name>startpos</name></expr>)</condition><block>{
		<expr_stmt><expr><name>parentpos</name> = (<name>pos</name> - 1) &gt;&gt; 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>parent</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>parentpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> = <call><name>cmp_lt</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cmp</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> = <name>parentpos</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_siftup</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>heap</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl>, <decl><type ref="prev"/><name>endpos</name></decl>, <decl><type ref="prev"/><name>childpos</name></decl>, <decl><type ref="prev"/><name>rightpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newitem</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endpos</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>startpos</name> = <name>pos</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pos</name> &gt;= <name>endpos</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>newitem</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bubble up the smaller child until hitting a leaf. */</comment>
	<expr_stmt><expr><name>childpos</name> = 2*<name>pos</name> + 1</expr>;</expr_stmt>    <comment type="block">/* leftmost child position  */</comment>
	<while>while <condition>(<expr><name>childpos</name> &lt; <name>endpos</name></expr>)</condition> <block>{
		<comment type="block">/* Set childpos to index of smaller child.   */</comment>
		<expr_stmt><expr><name>rightpos</name> = <name>childpos</name> + 1</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rightpos</name> &lt; <name>endpos</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>cmp</name> = <call><name>cmp_lt</name><argument_list>(
				<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>childpos</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>rightpos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmp</name> == -1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>childpos</name> = <name>rightpos</name></expr>;</expr_stmt></then></if>
		}</block></then></if>
		<comment type="block">/* Move the smaller child up. */</comment>
		<expr_stmt><expr><name>tmp</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>childpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> = <name>childpos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>childpos</name> = 2*<name>pos</name> + 1</expr>;</expr_stmt>
	}</block></while>

	<comment type="block">/* The leaf at pos is empty now.  Put newitem there, and and bubble
	   it up to its final resting place (by sifting its parents down). */</comment>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>_siftdown</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>heappush</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>heap</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"heappush"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>heap</name></expr></argument>, <argument><expr>&amp;<name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"heap argument must be a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>_siftdown</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call>-1</expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>heappush_doc</name></expr></argument>,
<argument><expr>"Push item onto heap, maintaining the heap invariant."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>heappop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>heap</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>lastelt</name></decl>, *<decl><type ref="prev"/><name>returnitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"heap argument must be a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* # raises appropriate IndexError if heap is empty */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>lastelt</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>n</name>-1</expr></argument>)</argument_list></call></expr> ;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>lastelt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SetSlice</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>n</name>-1</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<name>n</name></expr>)</condition><then> 
		<return>return <expr><name>lastelt</name></expr>;</return></then></if>
	<expr_stmt><expr><name>returnitem</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>lastelt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>_siftup</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>returnitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>returnitem</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>heappop_doc</name></expr></argument>,
<argument><expr>"Pop the smallest item off the heap, maintaining the heap invariant."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>heapreplace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>heap</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>, *<decl><type ref="prev"/><name>returnitem</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"heapreplace"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>heap</name></expr></argument>, <argument><expr>&amp;<name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"heap argument must be a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call> &lt; 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>returnitem</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>_siftup</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>returnitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>returnitem</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>heapreplace_doc</name></expr></argument>,
<argument><expr>"Pop and return the current smallest value, and add the new item.\n\
\n\
This is more efficient than heappop() followed by heappush(), and can be\n\
more appropriate when using a fixed-size heap.  Note that the value\n\
returned may be larger than item!  That constrains reasonable uses of\n\
this routine unless written as part of a conditional replacement:\n\n\
        if item &gt; heap[0]:\n\
            item = heapreplace(heap, item)\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>heappushpop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>heap</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>, *<decl><type ref="prev"/><name>returnitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"heappushpop"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>heap</name></expr></argument>, <argument><expr>&amp;<name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"heap argument must be a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call> &lt; 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>item</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>cmp</name> = <call><name>cmp_lt</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cmp</name> == -1</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>item</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>returnitem</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>_siftup</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>returnitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>returnitem</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>heappushpop_doc</name></expr></argument>,
<argument><expr>"Push item on the heap, then pop and return the smallest item\n\
from the heap. The combined action runs more efficiently than\n\
heappush() followed by a separate call to heappop()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>heapify</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>heap</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyList_Check</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"heap argument must be a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Transform bottom-up.  The largest index there's any point to
	   looking at is the largest with a child index in-range, so must
	   have 2*i + 1 &lt; n, or i &lt; (n-1)/2.  If n is even = 2*j, this is
	   (2*j-1)/2 = j-1/2 so j-1 is the largest, which is n//2 - 1.  If
	   n is odd = 2*j+1, this is (2*j+1-1)/2 = j so j-1 is the largest,
	   and that's again n//2-1.
	*/</comment>
	<for>for (<init><expr><name>i</name>=<name>n</name>/2-1</expr> ;</init> <condition><expr><name>i</name>&gt;=0</expr> ;</condition> <incr><expr><name>i</name>--</expr></incr>)
		<if>if<condition>(<expr><call><name>_siftup</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>heap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if></for>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>heapify_doc</name></expr></argument>,
<argument><expr>"Transform list into a heap, in-place, in O(len(heap)) time."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nlargest</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>heap</name><init>=<expr><name>NULL</name></expr></init>, *<name>elem</name></decl>, *<decl><type ref="prev"/><name>iterable</name></decl>, *<decl><type ref="prev"/><name>sol</name></decl>, *<decl><type ref="prev"/><name>it</name></decl>, *<decl><type ref="prev"/><name>oldelem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"nO:nlargest"</expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>iterable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>heap</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>heap</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr> )<block>{
		<expr_stmt><expr><name>elem</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>elem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<goto>goto <name>fail</name>;</goto></then>
			<else>else
				<goto>goto <name>sortit</name>;</goto></else></if>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr><call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<goto>goto <name>sortit</name>;</goto></then></if>

	<for>for (<init><expr><name>i</name>=<name>n</name>/2-1</expr> ;</init> <condition><expr><name>i</name>&gt;=0</expr> ;</condition> <incr><expr><name>i</name>--</expr></incr>)
		<if>if<condition>(<expr><call><name>_siftup</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>heap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<goto>goto <name>fail</name>;</goto></then></if></for>

	<expr_stmt><expr><name>sol</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr>1</expr>)</condition> <block>{
		<expr_stmt><expr><name>elem</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>elem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<goto>goto <name>fail</name>;</goto></then>
			<else>else
				<goto>goto <name>sortit</name>;</goto></else></if>
		}</block></then></if>
		<expr_stmt><expr><name>cmp</name> = <call><name>cmp_lt</name><argument_list>(<argument><expr><name>sol</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cmp</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		}</block></then></if>
		<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>
		<expr_stmt><expr><name>oldelem</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>oldelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>_siftup</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<goto>goto <name>fail</name>;</goto></then></if>
		<expr_stmt><expr><name>sol</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
<label><name>sortit</name>:</label>
	<if>if <condition>(<expr><call><name>PyList_Sort</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>heap</name></expr>;</return>

<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>nlargest_doc</name></expr></argument>,
<argument><expr>"Find the n largest elements in a dataset.\n\
\n\
Equivalent to:  sorted(iterable, reverse=True)[:n]\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_siftdownmax</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>heap</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newitem</name></decl>, *<decl><type ref="prev"/><name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>parentpos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pos</name> &gt;= <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>newitem</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Follow the path to the root, moving parents down until finding
	   a place newitem fits. */</comment>
	<while>while <condition>(<expr><name>pos</name> &gt; <name>startpos</name></expr>)</condition><block>{
		<expr_stmt><expr><name>parentpos</name> = (<name>pos</name> - 1) &gt;&gt; 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>parent</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>parentpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> = <call><name>cmp_lt</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cmp</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> = <name>parentpos</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_siftupmax</name><parameter_list>(<param><decl><type><name>PyListObject</name> *</type><name>heap</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl>, <decl><type ref="prev"/><name>endpos</name></decl>, <decl><type ref="prev"/><name>childpos</name></decl>, <decl><type ref="prev"/><name>rightpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>newitem</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endpos</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>startpos</name> = <name>pos</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pos</name> &gt;= <name>endpos</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>newitem</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bubble up the smaller child until hitting a leaf. */</comment>
	<expr_stmt><expr><name>childpos</name> = 2*<name>pos</name> + 1</expr>;</expr_stmt>    <comment type="block">/* leftmost child position  */</comment>
	<while>while <condition>(<expr><name>childpos</name> &lt; <name>endpos</name></expr>)</condition> <block>{
		<comment type="block">/* Set childpos to index of smaller child.   */</comment>
		<expr_stmt><expr><name>rightpos</name> = <name>childpos</name> + 1</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rightpos</name> &lt; <name>endpos</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>cmp</name> = <call><name>cmp_lt</name><argument_list>(
				<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>rightpos</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>childpos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cmp</name> == -1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>-1</expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>childpos</name> = <name>rightpos</name></expr>;</expr_stmt></then></if>
		}</block></then></if>
		<comment type="block">/* Move the smaller child up. */</comment>
		<expr_stmt><expr><name>tmp</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>childpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> = <name>childpos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>childpos</name> = 2*<name>pos</name> + 1</expr>;</expr_stmt>
	}</block></while>

	<comment type="block">/* The leaf at pos is empty now.  Put newitem there, and and bubble
	   it up to its final resting place (by sifting its parents down). */</comment>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>_siftdownmax</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nsmallest</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>heap</name><init>=<expr><name>NULL</name></expr></init>, *<name>elem</name></decl>, *<decl><type ref="prev"/><name>iterable</name></decl>, *<decl><type ref="prev"/><name>los</name></decl>, *<decl><type ref="prev"/><name>it</name></decl>, *<decl><type ref="prev"/><name>oldelem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"nO:nsmallest"</expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>iterable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>heap</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>heap</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>

	<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr> )<block>{
		<expr_stmt><expr><name>elem</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>elem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<goto>goto <name>fail</name>;</goto></then>
			<else>else
				<goto>goto <name>sortit</name>;</goto></else></if>
		}</block></then></if>
		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		}</block></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name>n</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
		<goto>goto <name>sortit</name>;</goto></then></if>

	<for>for (<init><expr><name>i</name>=<name>n</name>/2-1</expr> ;</init> <condition><expr><name>i</name>&gt;=0</expr> ;</condition> <incr><expr><name>i</name>--</expr></incr>)
		<if>if<condition>(<expr><call><name>_siftupmax</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>heap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<goto>goto <name>fail</name>;</goto></then></if></for>

	<expr_stmt><expr><name>los</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr>1</expr>)</condition> <block>{
		<expr_stmt><expr><name>elem</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>elem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<goto>goto <name>fail</name>;</goto></then>
			<else>else
				<goto>goto <name>sortit</name>;</goto></else></if>
		}</block></then></if>
		<expr_stmt><expr><name>cmp</name> = <call><name>cmp_lt</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>los</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>cmp</name> == -1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		}</block></then></if>
		<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>

		<expr_stmt><expr><name>oldelem</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>oldelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>_siftupmax</name><argument_list>(<argument><expr>(<name>PyListObject</name> *)<name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
			<goto>goto <name>fail</name>;</goto></then></if>
		<expr_stmt><expr><name>los</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

<label><name>sortit</name>:</label>
	<if>if <condition>(<expr><call><name>PyList_Sort</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
		<goto>goto <name>fail</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>heap</name></expr>;</return>

<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>nsmallest_doc</name></expr></argument>,
<argument><expr>"Find the n smallest elements in a dataset.\n\
\n\
Equivalent to:  sorted(iterable)[:n]\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>heapq_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"heappush"</expr>,	<expr>(<name>PyCFunction</name>)<name>heappush</name></expr>,		
		<expr><name>METH_VARARGS</name></expr>,	<expr><name>heappush_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"heappushpop"</expr>,	<expr>(<name>PyCFunction</name>)<name>heappushpop</name></expr>,		
		<expr><name>METH_VARARGS</name></expr>,	<expr><name>heappushpop_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"heappop"</expr>,	<expr>(<name>PyCFunction</name>)<name>heappop</name></expr>,
		<expr><name>METH_O</name></expr>,		<expr><name>heappop_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"heapreplace"</expr>,	<expr>(<name>PyCFunction</name>)<name>heapreplace</name></expr>,
		<expr><name>METH_VARARGS</name></expr>,	<expr><name>heapreplace_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"heapify"</expr>,	<expr>(<name>PyCFunction</name>)<name>heapify</name></expr>,
		<expr><name>METH_O</name></expr>,		<expr><name>heapify_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"nlargest"</expr>,	<expr>(<name>PyCFunction</name>)<name>nlargest</name></expr>,
		<expr><name>METH_VARARGS</name></expr>,	<expr><name>nlargest_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"nsmallest"</expr>,	<expr>(<name>PyCFunction</name>)<name>nsmallest</name></expr>,
		<expr><name>METH_VARARGS</name></expr>,	<expr><name>nsmallest_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"Heap queue algorithm (a.k.a. priority queue).\n\
\n\
Heaps are arrays for which a[k] &lt;= a[2*k+1] and a[k] &lt;= a[2*k+2] for\n\
all k, counting elements from 0.  For the sake of comparison,\n\
non-existing elements are considered to be infinite.  The interesting\n\
property of a heap is that a[0] is always its smallest element.\n\
\n\
Usage:\n\
\n\
heap = []            # creates an empty heap\n\
heappush(heap, item) # pushes a new item on the heap\n\
item = heappop(heap) # pops the smallest item from the heap\n\
item = heap[0]       # smallest item on the heap without popping it\n\
heapify(x)           # transforms list into a heap, in-place, in linear time\n\
item = heapreplace(heap, item) # pops and returns smallest item, and adds\n\
                               # new item; the heap size is unchanged\n\
\n\
Our API differs from textbook heap algorithms as follows:\n\
\n\
- We use 0-based indexing.  This makes the relationship between the\n\
  index for a node and the indexes for its children slightly less\n\
  obvious, but is more suitable since Python uses 0-based indexing.\n\
\n\
- Our heappop() method returns the smallest item, not the largest.\n\
\n\
These two make it possible to view the heap as a regular Python list\n\
without surprises: heap[0] is the smallest item, and heap.sort()\n\
maintains the heap invariant!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>__about__</name></expr></argument>,
<argument><expr>"Heap queues\n\
\n\
[explanation by Fran√ßois Pinard]\n\
\n\
Heaps are arrays for which a[k] &lt;= a[2*k+1] and a[k] &lt;= a[2*k+2] for\n\
all k, counting elements from 0.  For the sake of comparison,\n\
non-existing elements are considered to be infinite.  The interesting\n\
property of a heap is that a[0] is always its smallest element.\n"
"\n\
The strange invariant above is meant to be an efficient memory\n\
representation for a tournament.  The numbers below are `k', not a[k]:\n\
\n\
                                   0\n\
\n\
                  1                                 2\n\
\n\
          3               4                5               6\n\
\n\
      7       8       9       10      11      12      13      14\n\
\n\
    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\
\n\
\n\
In the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\n\
an usual binary tournament we see in sports, each cell is the winner\n\
over the two cells it tops, and we can trace the winner down the tree\n\
to see all opponents s/he had.  However, in many computer applications\n\
of such tournaments, we do not need to trace the history of a winner.\n\
To be more memory efficient, when a winner is promoted, we try to\n\
replace it by something else at a lower level, and the rule becomes\n\
that a cell and the two cells it tops contain three different items,\n\
but the top cell \"wins\" over the two topped cells.\n"
"\n\
If this heap invariant is protected at all time, index 0 is clearly\n\
the overall winner.  The simplest algorithmic way to remove it and\n\
find the \"next\" winner is to move some loser (let's say cell 30 in the\n\
diagram above) into the 0 position, and then percolate this new 0 down\n\
the tree, exchanging values, until the invariant is re-established.\n\
This is clearly logarithmic on the total number of items in the tree.\n\
By iterating over all items, you get an O(n ln n) sort.\n"
"\n\
A nice feature of this sort is that you can efficiently insert new\n\
items while the sort is going on, provided that the inserted items are\n\
not \"better\" than the last 0'th element you extracted.  This is\n\
especially useful in simulation contexts, where the tree holds all\n\
incoming events, and the \"win\" condition means the smallest scheduled\n\
time.  When an event schedule other events for execution, they are\n\
scheduled into the future, so they can easily go into the heap.  So, a\n\
heap is a good structure for implementing schedulers (this is what I\n\
used for my MIDI sequencer :-).\n"
"\n\
Various structures for implementing schedulers have been extensively\n\
studied, and heaps are good for this, as they are reasonably speedy,\n\
the speed is almost constant, and the worst case is not much different\n\
than the average case.  However, there are other representations which\n\
are more efficient overall, yet the worst cases might be terrible.\n"
"\n\
Heaps are also very useful in big disk sorts.  You most probably all\n\
know that a big sort implies producing \"runs\" (which are pre-sorted\n\
sequences, which size is usually related to the amount of CPU memory),\n\
followed by a merging passes for these runs, which merging is often\n\
very cleverly organised[1].  It is very important that the initial\n\
sort produces the longest runs possible.  Tournaments are a good way\n\
to that.  If, using all the memory available to hold a tournament, you\n\
replace and percolate items that happen to fit the current run, you'll\n\
produce runs which are twice the size of the memory for random input,\n\
and much better for input fuzzily ordered.\n"
"\n\
Moreover, if you output the 0'th item on disk and get an input which\n\
may not fit in the current tournament (because the value \"wins\" over\n\
the last output value), it cannot fit in the heap, so the size of the\n\
heap decreases.  The freed memory could be cleverly reused immediately\n\
for progressively building a second heap, which grows at exactly the\n\
same rate the first heap is melting.  When the first heap completely\n\
vanishes, you switch heaps and start a new run.  Clever and quite\n\
effective!\n\
\n\
In a word, heaps are useful memory structures to know.  I use them in\n\
a few applications, and I think it is good to keep a `heap' module\n\
around. :-)\n"
"\n\
--------------------\n\
[1] The disk balancing algorithms which are current, nowadays, are\n\
more annoying than clever, and this is a consequence of the seeking\n\
capabilities of the disks.  On devices which cannot seek, like big\n\
tape drives, the story was quite different, and one had to be very\n\
clever to ensure (far in advance) that each tape movement will be the\n\
most effective possible (that is, will best participate at\n\
\"progressing\" the merge).  Some tapes were even able to read\n\
backwards, and this was also used to avoid the rewinding time.\n\
Believe me, real good tape sorts were quite spectacular to watch!\n\
From all times, sorting has always been a Great Art! :-)\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_heapq</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"_heapq"</expr></argument>, <argument><expr><name>heapq_methods</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
    		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"__about__"</expr></argument>, <argument><expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>__about__</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

</unit>
